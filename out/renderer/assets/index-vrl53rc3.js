const __vite__mapDeps=(i,m=__vite__mapDeps,d=(m.f||(m.f=["./subset-worker.chunk-CAElXgZ2.js","./subset-shared.chunk-OxIjZu0m.js","./pica-BBRUF1vY.js","./_commonjs-dynamic-modules-TGKdzP3c.js"])))=>i.map(i=>d[i]);
function _mergeNamespaces(n3, m3) {
  for (var i3 = 0; i3 < m3.length; i3++) {
    const e12 = m3[i3];
    if (typeof e12 !== "string" && !Array.isArray(e12)) {
      for (const k2 in e12) {
        if (k2 !== "default" && !(k2 in n3)) {
          const d3 = Object.getOwnPropertyDescriptor(e12, k2);
          if (d3) {
            Object.defineProperty(n3, k2, d3.get ? d3 : {
              enumerable: true,
              get: () => e12[k2]
            });
          }
        }
      }
    }
  }
  return Object.freeze(Object.defineProperty(n3, Symbol.toStringTag, { value: "Module" }));
}
var commonjsGlobal = typeof globalThis !== "undefined" ? globalThis : typeof window !== "undefined" ? window : typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : {};
function getDefaultExportFromCjs(x3) {
  return x3 && x3.__esModule && Object.prototype.hasOwnProperty.call(x3, "default") ? x3["default"] : x3;
}
var jsxRuntime = { exports: {} };
var reactJsxRuntime_production = {};
var hasRequiredReactJsxRuntime_production;
function requireReactJsxRuntime_production() {
  if (hasRequiredReactJsxRuntime_production) return reactJsxRuntime_production;
  hasRequiredReactJsxRuntime_production = 1;
  var REACT_ELEMENT_TYPE = Symbol.for("react.transitional.element"), REACT_FRAGMENT_TYPE = Symbol.for("react.fragment");
  function jsxProd(type, config, maybeKey) {
    var key = null;
    void 0 !== maybeKey && (key = "" + maybeKey);
    void 0 !== config.key && (key = "" + config.key);
    if ("key" in config) {
      maybeKey = {};
      for (var propName in config)
        "key" !== propName && (maybeKey[propName] = config[propName]);
    } else maybeKey = config;
    config = maybeKey.ref;
    return {
      $$typeof: REACT_ELEMENT_TYPE,
      type,
      key,
      ref: void 0 !== config ? config : null,
      props: maybeKey
    };
  }
  reactJsxRuntime_production.Fragment = REACT_FRAGMENT_TYPE;
  reactJsxRuntime_production.jsx = jsxProd;
  reactJsxRuntime_production.jsxs = jsxProd;
  return reactJsxRuntime_production;
}
var hasRequiredJsxRuntime;
function requireJsxRuntime() {
  if (hasRequiredJsxRuntime) return jsxRuntime.exports;
  hasRequiredJsxRuntime = 1;
  {
    jsxRuntime.exports = requireReactJsxRuntime_production();
  }
  return jsxRuntime.exports;
}
var jsxRuntimeExports = requireJsxRuntime();
var react = { exports: {} };
var react_production = {};
var hasRequiredReact_production;
function requireReact_production() {
  if (hasRequiredReact_production) return react_production;
  hasRequiredReact_production = 1;
  var REACT_ELEMENT_TYPE = Symbol.for("react.transitional.element"), REACT_PORTAL_TYPE = Symbol.for("react.portal"), REACT_FRAGMENT_TYPE = Symbol.for("react.fragment"), REACT_STRICT_MODE_TYPE = Symbol.for("react.strict_mode"), REACT_PROFILER_TYPE = Symbol.for("react.profiler"), REACT_CONSUMER_TYPE = Symbol.for("react.consumer"), REACT_CONTEXT_TYPE = Symbol.for("react.context"), REACT_FORWARD_REF_TYPE = Symbol.for("react.forward_ref"), REACT_SUSPENSE_TYPE = Symbol.for("react.suspense"), REACT_MEMO_TYPE = Symbol.for("react.memo"), REACT_LAZY_TYPE = Symbol.for("react.lazy"), REACT_ACTIVITY_TYPE = Symbol.for("react.activity"), MAYBE_ITERATOR_SYMBOL = Symbol.iterator;
  function getIteratorFn(maybeIterable) {
    if (null === maybeIterable || "object" !== typeof maybeIterable) return null;
    maybeIterable = MAYBE_ITERATOR_SYMBOL && maybeIterable[MAYBE_ITERATOR_SYMBOL] || maybeIterable["@@iterator"];
    return "function" === typeof maybeIterable ? maybeIterable : null;
  }
  var ReactNoopUpdateQueue = {
    isMounted: function() {
      return false;
    },
    enqueueForceUpdate: function() {
    },
    enqueueReplaceState: function() {
    },
    enqueueSetState: function() {
    }
  }, assign2 = Object.assign, emptyObject = {};
  function Component(props, context, updater) {
    this.props = props;
    this.context = context;
    this.refs = emptyObject;
    this.updater = updater || ReactNoopUpdateQueue;
  }
  Component.prototype.isReactComponent = {};
  Component.prototype.setState = function(partialState, callback) {
    if ("object" !== typeof partialState && "function" !== typeof partialState && null != partialState)
      throw Error(
        "takes an object of state variables to update or a function which returns an object of state variables."
      );
    this.updater.enqueueSetState(this, partialState, callback, "setState");
  };
  Component.prototype.forceUpdate = function(callback) {
    this.updater.enqueueForceUpdate(this, callback, "forceUpdate");
  };
  function ComponentDummy() {
  }
  ComponentDummy.prototype = Component.prototype;
  function PureComponent(props, context, updater) {
    this.props = props;
    this.context = context;
    this.refs = emptyObject;
    this.updater = updater || ReactNoopUpdateQueue;
  }
  var pureComponentPrototype = PureComponent.prototype = new ComponentDummy();
  pureComponentPrototype.constructor = PureComponent;
  assign2(pureComponentPrototype, Component.prototype);
  pureComponentPrototype.isPureReactComponent = true;
  var isArrayImpl = Array.isArray;
  function noop3() {
  }
  var ReactSharedInternals = { H: null, A: null, T: null, S: null }, hasOwnProperty = Object.prototype.hasOwnProperty;
  function ReactElement(type, key, props) {
    var refProp = props.ref;
    return {
      $$typeof: REACT_ELEMENT_TYPE,
      type,
      key,
      ref: void 0 !== refProp ? refProp : null,
      props
    };
  }
  function cloneAndReplaceKey(oldElement, newKey) {
    return ReactElement(oldElement.type, newKey, oldElement.props);
  }
  function isValidElement(object) {
    return "object" === typeof object && null !== object && object.$$typeof === REACT_ELEMENT_TYPE;
  }
  function escape(key) {
    var escaperLookup = { "=": "=0", ":": "=2" };
    return "$" + key.replace(/[=:]/g, function(match) {
      return escaperLookup[match];
    });
  }
  var userProvidedKeyEscapeRegex = /\/+/g;
  function getElementKey(element, index2) {
    return "object" === typeof element && null !== element && null != element.key ? escape("" + element.key) : index2.toString(36);
  }
  function resolveThenable(thenable) {
    switch (thenable.status) {
      case "fulfilled":
        return thenable.value;
      case "rejected":
        throw thenable.reason;
      default:
        switch ("string" === typeof thenable.status ? thenable.then(noop3, noop3) : (thenable.status = "pending", thenable.then(
          function(fulfilledValue) {
            "pending" === thenable.status && (thenable.status = "fulfilled", thenable.value = fulfilledValue);
          },
          function(error) {
            "pending" === thenable.status && (thenable.status = "rejected", thenable.reason = error);
          }
        )), thenable.status) {
          case "fulfilled":
            return thenable.value;
          case "rejected":
            throw thenable.reason;
        }
    }
    throw thenable;
  }
  function mapIntoArray(children, array, escapedPrefix, nameSoFar, callback) {
    var type = typeof children;
    if ("undefined" === type || "boolean" === type) children = null;
    var invokeCallback = false;
    if (null === children) invokeCallback = true;
    else
      switch (type) {
        case "bigint":
        case "string":
        case "number":
          invokeCallback = true;
          break;
        case "object":
          switch (children.$$typeof) {
            case REACT_ELEMENT_TYPE:
            case REACT_PORTAL_TYPE:
              invokeCallback = true;
              break;
            case REACT_LAZY_TYPE:
              return invokeCallback = children._init, mapIntoArray(
                invokeCallback(children._payload),
                array,
                escapedPrefix,
                nameSoFar,
                callback
              );
          }
      }
    if (invokeCallback)
      return callback = callback(children), invokeCallback = "" === nameSoFar ? "." + getElementKey(children, 0) : nameSoFar, isArrayImpl(callback) ? (escapedPrefix = "", null != invokeCallback && (escapedPrefix = invokeCallback.replace(userProvidedKeyEscapeRegex, "$&/") + "/"), mapIntoArray(callback, array, escapedPrefix, "", function(c3) {
        return c3;
      })) : null != callback && (isValidElement(callback) && (callback = cloneAndReplaceKey(
        callback,
        escapedPrefix + (null == callback.key || children && children.key === callback.key ? "" : ("" + callback.key).replace(
          userProvidedKeyEscapeRegex,
          "$&/"
        ) + "/") + invokeCallback
      )), array.push(callback)), 1;
    invokeCallback = 0;
    var nextNamePrefix = "" === nameSoFar ? "." : nameSoFar + ":";
    if (isArrayImpl(children))
      for (var i3 = 0; i3 < children.length; i3++)
        nameSoFar = children[i3], type = nextNamePrefix + getElementKey(nameSoFar, i3), invokeCallback += mapIntoArray(
          nameSoFar,
          array,
          escapedPrefix,
          type,
          callback
        );
    else if (i3 = getIteratorFn(children), "function" === typeof i3)
      for (children = i3.call(children), i3 = 0; !(nameSoFar = children.next()).done; )
        nameSoFar = nameSoFar.value, type = nextNamePrefix + getElementKey(nameSoFar, i3++), invokeCallback += mapIntoArray(
          nameSoFar,
          array,
          escapedPrefix,
          type,
          callback
        );
    else if ("object" === type) {
      if ("function" === typeof children.then)
        return mapIntoArray(
          resolveThenable(children),
          array,
          escapedPrefix,
          nameSoFar,
          callback
        );
      array = String(children);
      throw Error(
        "Objects are not valid as a React child (found: " + ("[object Object]" === array ? "object with keys {" + Object.keys(children).join(", ") + "}" : array) + "). If you meant to render a collection of children, use an array instead."
      );
    }
    return invokeCallback;
  }
  function mapChildren(children, func, context) {
    if (null == children) return children;
    var result = [], count2 = 0;
    mapIntoArray(children, result, "", "", function(child) {
      return func.call(context, child, count2++);
    });
    return result;
  }
  function lazyInitializer(payload) {
    if (-1 === payload._status) {
      var ctor = payload._result;
      ctor = ctor();
      ctor.then(
        function(moduleObject) {
          if (0 === payload._status || -1 === payload._status)
            payload._status = 1, payload._result = moduleObject;
        },
        function(error) {
          if (0 === payload._status || -1 === payload._status)
            payload._status = 2, payload._result = error;
        }
      );
      -1 === payload._status && (payload._status = 0, payload._result = ctor);
    }
    if (1 === payload._status) return payload._result.default;
    throw payload._result;
  }
  var reportGlobalError = "function" === typeof reportError ? reportError : function(error) {
    if ("object" === typeof window && "function" === typeof window.ErrorEvent) {
      var event = new window.ErrorEvent("error", {
        bubbles: true,
        cancelable: true,
        message: "object" === typeof error && null !== error && "string" === typeof error.message ? String(error.message) : String(error),
        error
      });
      if (!window.dispatchEvent(event)) return;
    } else if ("object" === typeof process && "function" === typeof process.emit) {
      process.emit("uncaughtException", error);
      return;
    }
    console.error(error);
  }, Children = {
    map: mapChildren,
    forEach: function(children, forEachFunc, forEachContext) {
      mapChildren(
        children,
        function() {
          forEachFunc.apply(this, arguments);
        },
        forEachContext
      );
    },
    count: function(children) {
      var n3 = 0;
      mapChildren(children, function() {
        n3++;
      });
      return n3;
    },
    toArray: function(children) {
      return mapChildren(children, function(child) {
        return child;
      }) || [];
    },
    only: function(children) {
      if (!isValidElement(children))
        throw Error(
          "React.Children.only expected to receive a single React element child."
        );
      return children;
    }
  };
  react_production.Activity = REACT_ACTIVITY_TYPE;
  react_production.Children = Children;
  react_production.Component = Component;
  react_production.Fragment = REACT_FRAGMENT_TYPE;
  react_production.Profiler = REACT_PROFILER_TYPE;
  react_production.PureComponent = PureComponent;
  react_production.StrictMode = REACT_STRICT_MODE_TYPE;
  react_production.Suspense = REACT_SUSPENSE_TYPE;
  react_production.__CLIENT_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE = ReactSharedInternals;
  react_production.__COMPILER_RUNTIME = {
    __proto__: null,
    c: function(size2) {
      return ReactSharedInternals.H.useMemoCache(size2);
    }
  };
  react_production.cache = function(fn2) {
    return function() {
      return fn2.apply(null, arguments);
    };
  };
  react_production.cacheSignal = function() {
    return null;
  };
  react_production.cloneElement = function(element, config, children) {
    if (null === element || void 0 === element)
      throw Error(
        "The argument must be a React element, but you passed " + element + "."
      );
    var props = assign2({}, element.props), key = element.key;
    if (null != config)
      for (propName in void 0 !== config.key && (key = "" + config.key), config)
        !hasOwnProperty.call(config, propName) || "key" === propName || "__self" === propName || "__source" === propName || "ref" === propName && void 0 === config.ref || (props[propName] = config[propName]);
    var propName = arguments.length - 2;
    if (1 === propName) props.children = children;
    else if (1 < propName) {
      for (var childArray = Array(propName), i3 = 0; i3 < propName; i3++)
        childArray[i3] = arguments[i3 + 2];
      props.children = childArray;
    }
    return ReactElement(element.type, key, props);
  };
  react_production.createContext = function(defaultValue) {
    defaultValue = {
      $$typeof: REACT_CONTEXT_TYPE,
      _currentValue: defaultValue,
      _currentValue2: defaultValue,
      _threadCount: 0,
      Provider: null,
      Consumer: null
    };
    defaultValue.Provider = defaultValue;
    defaultValue.Consumer = {
      $$typeof: REACT_CONSUMER_TYPE,
      _context: defaultValue
    };
    return defaultValue;
  };
  react_production.createElement = function(type, config, children) {
    var propName, props = {}, key = null;
    if (null != config)
      for (propName in void 0 !== config.key && (key = "" + config.key), config)
        hasOwnProperty.call(config, propName) && "key" !== propName && "__self" !== propName && "__source" !== propName && (props[propName] = config[propName]);
    var childrenLength = arguments.length - 2;
    if (1 === childrenLength) props.children = children;
    else if (1 < childrenLength) {
      for (var childArray = Array(childrenLength), i3 = 0; i3 < childrenLength; i3++)
        childArray[i3] = arguments[i3 + 2];
      props.children = childArray;
    }
    if (type && type.defaultProps)
      for (propName in childrenLength = type.defaultProps, childrenLength)
        void 0 === props[propName] && (props[propName] = childrenLength[propName]);
    return ReactElement(type, key, props);
  };
  react_production.createRef = function() {
    return { current: null };
  };
  react_production.forwardRef = function(render) {
    return { $$typeof: REACT_FORWARD_REF_TYPE, render };
  };
  react_production.isValidElement = isValidElement;
  react_production.lazy = function(ctor) {
    return {
      $$typeof: REACT_LAZY_TYPE,
      _payload: { _status: -1, _result: ctor },
      _init: lazyInitializer
    };
  };
  react_production.memo = function(type, compare) {
    return {
      $$typeof: REACT_MEMO_TYPE,
      type,
      compare: void 0 === compare ? null : compare
    };
  };
  react_production.startTransition = function(scope) {
    var prevTransition = ReactSharedInternals.T, currentTransition = {};
    ReactSharedInternals.T = currentTransition;
    try {
      var returnValue = scope(), onStartTransitionFinish = ReactSharedInternals.S;
      null !== onStartTransitionFinish && onStartTransitionFinish(currentTransition, returnValue);
      "object" === typeof returnValue && null !== returnValue && "function" === typeof returnValue.then && returnValue.then(noop3, reportGlobalError);
    } catch (error) {
      reportGlobalError(error);
    } finally {
      null !== prevTransition && null !== currentTransition.types && (prevTransition.types = currentTransition.types), ReactSharedInternals.T = prevTransition;
    }
  };
  react_production.unstable_useCacheRefresh = function() {
    return ReactSharedInternals.H.useCacheRefresh();
  };
  react_production.use = function(usable) {
    return ReactSharedInternals.H.use(usable);
  };
  react_production.useActionState = function(action, initialState, permalink) {
    return ReactSharedInternals.H.useActionState(action, initialState, permalink);
  };
  react_production.useCallback = function(callback, deps) {
    return ReactSharedInternals.H.useCallback(callback, deps);
  };
  react_production.useContext = function(Context) {
    return ReactSharedInternals.H.useContext(Context);
  };
  react_production.useDebugValue = function() {
  };
  react_production.useDeferredValue = function(value, initialValue) {
    return ReactSharedInternals.H.useDeferredValue(value, initialValue);
  };
  react_production.useEffect = function(create2, deps) {
    return ReactSharedInternals.H.useEffect(create2, deps);
  };
  react_production.useEffectEvent = function(callback) {
    return ReactSharedInternals.H.useEffectEvent(callback);
  };
  react_production.useId = function() {
    return ReactSharedInternals.H.useId();
  };
  react_production.useImperativeHandle = function(ref, create2, deps) {
    return ReactSharedInternals.H.useImperativeHandle(ref, create2, deps);
  };
  react_production.useInsertionEffect = function(create2, deps) {
    return ReactSharedInternals.H.useInsertionEffect(create2, deps);
  };
  react_production.useLayoutEffect = function(create2, deps) {
    return ReactSharedInternals.H.useLayoutEffect(create2, deps);
  };
  react_production.useMemo = function(create2, deps) {
    return ReactSharedInternals.H.useMemo(create2, deps);
  };
  react_production.useOptimistic = function(passthrough, reducer) {
    return ReactSharedInternals.H.useOptimistic(passthrough, reducer);
  };
  react_production.useReducer = function(reducer, initialArg, init) {
    return ReactSharedInternals.H.useReducer(reducer, initialArg, init);
  };
  react_production.useRef = function(initialValue) {
    return ReactSharedInternals.H.useRef(initialValue);
  };
  react_production.useState = function(initialState) {
    return ReactSharedInternals.H.useState(initialState);
  };
  react_production.useSyncExternalStore = function(subscribe, getSnapshot, getServerSnapshot) {
    return ReactSharedInternals.H.useSyncExternalStore(
      subscribe,
      getSnapshot,
      getServerSnapshot
    );
  };
  react_production.useTransition = function() {
    return ReactSharedInternals.H.useTransition();
  };
  react_production.version = "19.2.0";
  return react_production;
}
var hasRequiredReact;
function requireReact() {
  if (hasRequiredReact) return react.exports;
  hasRequiredReact = 1;
  {
    react.exports = requireReact_production();
  }
  return react.exports;
}
var reactExports = requireReact();
const React = /* @__PURE__ */ getDefaultExportFromCjs(reactExports);
const $2AODx$react = /* @__PURE__ */ _mergeNamespaces({
  __proto__: null,
  default: React
}, [reactExports]);
var client = { exports: {} };
var reactDomClient_production = {};
var scheduler = { exports: {} };
var scheduler_production = {};
var hasRequiredScheduler_production;
function requireScheduler_production() {
  if (hasRequiredScheduler_production) return scheduler_production;
  hasRequiredScheduler_production = 1;
  (function(exports$1) {
    function push(heap, node) {
      var index2 = heap.length;
      heap.push(node);
      a: for (; 0 < index2; ) {
        var parentIndex = index2 - 1 >>> 1, parent = heap[parentIndex];
        if (0 < compare(parent, node))
          heap[parentIndex] = node, heap[index2] = parent, index2 = parentIndex;
        else break a;
      }
    }
    function peek(heap) {
      return 0 === heap.length ? null : heap[0];
    }
    function pop(heap) {
      if (0 === heap.length) return null;
      var first = heap[0], last = heap.pop();
      if (last !== first) {
        heap[0] = last;
        a: for (var index2 = 0, length = heap.length, halfLength = length >>> 1; index2 < halfLength; ) {
          var leftIndex = 2 * (index2 + 1) - 1, left = heap[leftIndex], rightIndex = leftIndex + 1, right = heap[rightIndex];
          if (0 > compare(left, last))
            rightIndex < length && 0 > compare(right, left) ? (heap[index2] = right, heap[rightIndex] = last, index2 = rightIndex) : (heap[index2] = left, heap[leftIndex] = last, index2 = leftIndex);
          else if (rightIndex < length && 0 > compare(right, last))
            heap[index2] = right, heap[rightIndex] = last, index2 = rightIndex;
          else break a;
        }
      }
      return first;
    }
    function compare(a3, b3) {
      var diff = a3.sortIndex - b3.sortIndex;
      return 0 !== diff ? diff : a3.id - b3.id;
    }
    exports$1.unstable_now = void 0;
    if ("object" === typeof performance && "function" === typeof performance.now) {
      var localPerformance = performance;
      exports$1.unstable_now = function() {
        return localPerformance.now();
      };
    } else {
      var localDate = Date, initialTime = localDate.now();
      exports$1.unstable_now = function() {
        return localDate.now() - initialTime;
      };
    }
    var taskQueue = [], timerQueue = [], taskIdCounter = 1, currentTask = null, currentPriorityLevel = 3, isPerformingWork = false, isHostCallbackScheduled = false, isHostTimeoutScheduled = false, needsPaint = false, localSetTimeout = "function" === typeof setTimeout ? setTimeout : null, localClearTimeout = "function" === typeof clearTimeout ? clearTimeout : null, localSetImmediate = "undefined" !== typeof setImmediate ? setImmediate : null;
    function advanceTimers(currentTime) {
      for (var timer = peek(timerQueue); null !== timer; ) {
        if (null === timer.callback) pop(timerQueue);
        else if (timer.startTime <= currentTime)
          pop(timerQueue), timer.sortIndex = timer.expirationTime, push(taskQueue, timer);
        else break;
        timer = peek(timerQueue);
      }
    }
    function handleTimeout(currentTime) {
      isHostTimeoutScheduled = false;
      advanceTimers(currentTime);
      if (!isHostCallbackScheduled)
        if (null !== peek(taskQueue))
          isHostCallbackScheduled = true, isMessageLoopRunning || (isMessageLoopRunning = true, schedulePerformWorkUntilDeadline());
        else {
          var firstTimer = peek(timerQueue);
          null !== firstTimer && requestHostTimeout(handleTimeout, firstTimer.startTime - currentTime);
        }
    }
    var isMessageLoopRunning = false, taskTimeoutID = -1, frameInterval = 5, startTime = -1;
    function shouldYieldToHost() {
      return needsPaint ? true : exports$1.unstable_now() - startTime < frameInterval ? false : true;
    }
    function performWorkUntilDeadline() {
      needsPaint = false;
      if (isMessageLoopRunning) {
        var currentTime = exports$1.unstable_now();
        startTime = currentTime;
        var hasMoreWork = true;
        try {
          a: {
            isHostCallbackScheduled = false;
            isHostTimeoutScheduled && (isHostTimeoutScheduled = false, localClearTimeout(taskTimeoutID), taskTimeoutID = -1);
            isPerformingWork = true;
            var previousPriorityLevel = currentPriorityLevel;
            try {
              b: {
                advanceTimers(currentTime);
                for (currentTask = peek(taskQueue); null !== currentTask && !(currentTask.expirationTime > currentTime && shouldYieldToHost()); ) {
                  var callback = currentTask.callback;
                  if ("function" === typeof callback) {
                    currentTask.callback = null;
                    currentPriorityLevel = currentTask.priorityLevel;
                    var continuationCallback = callback(
                      currentTask.expirationTime <= currentTime
                    );
                    currentTime = exports$1.unstable_now();
                    if ("function" === typeof continuationCallback) {
                      currentTask.callback = continuationCallback;
                      advanceTimers(currentTime);
                      hasMoreWork = true;
                      break b;
                    }
                    currentTask === peek(taskQueue) && pop(taskQueue);
                    advanceTimers(currentTime);
                  } else pop(taskQueue);
                  currentTask = peek(taskQueue);
                }
                if (null !== currentTask) hasMoreWork = true;
                else {
                  var firstTimer = peek(timerQueue);
                  null !== firstTimer && requestHostTimeout(
                    handleTimeout,
                    firstTimer.startTime - currentTime
                  );
                  hasMoreWork = false;
                }
              }
              break a;
            } finally {
              currentTask = null, currentPriorityLevel = previousPriorityLevel, isPerformingWork = false;
            }
            hasMoreWork = void 0;
          }
        } finally {
          hasMoreWork ? schedulePerformWorkUntilDeadline() : isMessageLoopRunning = false;
        }
      }
    }
    var schedulePerformWorkUntilDeadline;
    if ("function" === typeof localSetImmediate)
      schedulePerformWorkUntilDeadline = function() {
        localSetImmediate(performWorkUntilDeadline);
      };
    else if ("undefined" !== typeof MessageChannel) {
      var channel = new MessageChannel(), port = channel.port2;
      channel.port1.onmessage = performWorkUntilDeadline;
      schedulePerformWorkUntilDeadline = function() {
        port.postMessage(null);
      };
    } else
      schedulePerformWorkUntilDeadline = function() {
        localSetTimeout(performWorkUntilDeadline, 0);
      };
    function requestHostTimeout(callback, ms2) {
      taskTimeoutID = localSetTimeout(function() {
        callback(exports$1.unstable_now());
      }, ms2);
    }
    exports$1.unstable_IdlePriority = 5;
    exports$1.unstable_ImmediatePriority = 1;
    exports$1.unstable_LowPriority = 4;
    exports$1.unstable_NormalPriority = 3;
    exports$1.unstable_Profiling = null;
    exports$1.unstable_UserBlockingPriority = 2;
    exports$1.unstable_cancelCallback = function(task) {
      task.callback = null;
    };
    exports$1.unstable_forceFrameRate = function(fps) {
      0 > fps || 125 < fps ? console.error(
        "forceFrameRate takes a positive int between 0 and 125, forcing frame rates higher than 125 fps is not supported"
      ) : frameInterval = 0 < fps ? Math.floor(1e3 / fps) : 5;
    };
    exports$1.unstable_getCurrentPriorityLevel = function() {
      return currentPriorityLevel;
    };
    exports$1.unstable_next = function(eventHandler) {
      switch (currentPriorityLevel) {
        case 1:
        case 2:
        case 3:
          var priorityLevel = 3;
          break;
        default:
          priorityLevel = currentPriorityLevel;
      }
      var previousPriorityLevel = currentPriorityLevel;
      currentPriorityLevel = priorityLevel;
      try {
        return eventHandler();
      } finally {
        currentPriorityLevel = previousPriorityLevel;
      }
    };
    exports$1.unstable_requestPaint = function() {
      needsPaint = true;
    };
    exports$1.unstable_runWithPriority = function(priorityLevel, eventHandler) {
      switch (priorityLevel) {
        case 1:
        case 2:
        case 3:
        case 4:
        case 5:
          break;
        default:
          priorityLevel = 3;
      }
      var previousPriorityLevel = currentPriorityLevel;
      currentPriorityLevel = priorityLevel;
      try {
        return eventHandler();
      } finally {
        currentPriorityLevel = previousPriorityLevel;
      }
    };
    exports$1.unstable_scheduleCallback = function(priorityLevel, callback, options) {
      var currentTime = exports$1.unstable_now();
      "object" === typeof options && null !== options ? (options = options.delay, options = "number" === typeof options && 0 < options ? currentTime + options : currentTime) : options = currentTime;
      switch (priorityLevel) {
        case 1:
          var timeout = -1;
          break;
        case 2:
          timeout = 250;
          break;
        case 5:
          timeout = 1073741823;
          break;
        case 4:
          timeout = 1e4;
          break;
        default:
          timeout = 5e3;
      }
      timeout = options + timeout;
      priorityLevel = {
        id: taskIdCounter++,
        callback,
        priorityLevel,
        startTime: options,
        expirationTime: timeout,
        sortIndex: -1
      };
      options > currentTime ? (priorityLevel.sortIndex = options, push(timerQueue, priorityLevel), null === peek(taskQueue) && priorityLevel === peek(timerQueue) && (isHostTimeoutScheduled ? (localClearTimeout(taskTimeoutID), taskTimeoutID = -1) : isHostTimeoutScheduled = true, requestHostTimeout(handleTimeout, options - currentTime))) : (priorityLevel.sortIndex = timeout, push(taskQueue, priorityLevel), isHostCallbackScheduled || isPerformingWork || (isHostCallbackScheduled = true, isMessageLoopRunning || (isMessageLoopRunning = true, schedulePerformWorkUntilDeadline())));
      return priorityLevel;
    };
    exports$1.unstable_shouldYield = shouldYieldToHost;
    exports$1.unstable_wrapCallback = function(callback) {
      var parentPriorityLevel = currentPriorityLevel;
      return function() {
        var previousPriorityLevel = currentPriorityLevel;
        currentPriorityLevel = parentPriorityLevel;
        try {
          return callback.apply(this, arguments);
        } finally {
          currentPriorityLevel = previousPriorityLevel;
        }
      };
    };
  })(scheduler_production);
  return scheduler_production;
}
var hasRequiredScheduler;
function requireScheduler() {
  if (hasRequiredScheduler) return scheduler.exports;
  hasRequiredScheduler = 1;
  {
    scheduler.exports = requireScheduler_production();
  }
  return scheduler.exports;
}
var reactDom = { exports: {} };
var reactDom_production = {};
var hasRequiredReactDom_production;
function requireReactDom_production() {
  if (hasRequiredReactDom_production) return reactDom_production;
  hasRequiredReactDom_production = 1;
  var React2 = requireReact();
  function formatProdErrorMessage(code) {
    var url = "https://react.dev/errors/" + code;
    if (1 < arguments.length) {
      url += "?args[]=" + encodeURIComponent(arguments[1]);
      for (var i3 = 2; i3 < arguments.length; i3++)
        url += "&args[]=" + encodeURIComponent(arguments[i3]);
    }
    return "Minified React error #" + code + "; visit " + url + " for the full message or use the non-minified dev environment for full errors and additional helpful warnings.";
  }
  function noop3() {
  }
  var Internals = {
    d: {
      f: noop3,
      r: function() {
        throw Error(formatProdErrorMessage(522));
      },
      D: noop3,
      C: noop3,
      L: noop3,
      m: noop3,
      X: noop3,
      S: noop3,
      M: noop3
    },
    p: 0,
    findDOMNode: null
  }, REACT_PORTAL_TYPE = Symbol.for("react.portal");
  function createPortal$1(children, containerInfo, implementation) {
    var key = 3 < arguments.length && void 0 !== arguments[3] ? arguments[3] : null;
    return {
      $$typeof: REACT_PORTAL_TYPE,
      key: null == key ? null : "" + key,
      children,
      containerInfo,
      implementation
    };
  }
  var ReactSharedInternals = React2.__CLIENT_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE;
  function getCrossOriginStringAs(as2, input) {
    if ("font" === as2) return "";
    if ("string" === typeof input)
      return "use-credentials" === input ? input : "";
  }
  reactDom_production.__DOM_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE = Internals;
  reactDom_production.createPortal = function(children, container) {
    var key = 2 < arguments.length && void 0 !== arguments[2] ? arguments[2] : null;
    if (!container || 1 !== container.nodeType && 9 !== container.nodeType && 11 !== container.nodeType)
      throw Error(formatProdErrorMessage(299));
    return createPortal$1(children, container, null, key);
  };
  reactDom_production.flushSync = function(fn2) {
    var previousTransition = ReactSharedInternals.T, previousUpdatePriority = Internals.p;
    try {
      if (ReactSharedInternals.T = null, Internals.p = 2, fn2) return fn2();
    } finally {
      ReactSharedInternals.T = previousTransition, Internals.p = previousUpdatePriority, Internals.d.f();
    }
  };
  reactDom_production.preconnect = function(href, options) {
    "string" === typeof href && (options ? (options = options.crossOrigin, options = "string" === typeof options ? "use-credentials" === options ? options : "" : void 0) : options = null, Internals.d.C(href, options));
  };
  reactDom_production.prefetchDNS = function(href) {
    "string" === typeof href && Internals.d.D(href);
  };
  reactDom_production.preinit = function(href, options) {
    if ("string" === typeof href && options && "string" === typeof options.as) {
      var as2 = options.as, crossOrigin = getCrossOriginStringAs(as2, options.crossOrigin), integrity = "string" === typeof options.integrity ? options.integrity : void 0, fetchPriority = "string" === typeof options.fetchPriority ? options.fetchPriority : void 0;
      "style" === as2 ? Internals.d.S(
        href,
        "string" === typeof options.precedence ? options.precedence : void 0,
        {
          crossOrigin,
          integrity,
          fetchPriority
        }
      ) : "script" === as2 && Internals.d.X(href, {
        crossOrigin,
        integrity,
        fetchPriority,
        nonce: "string" === typeof options.nonce ? options.nonce : void 0
      });
    }
  };
  reactDom_production.preinitModule = function(href, options) {
    if ("string" === typeof href)
      if ("object" === typeof options && null !== options) {
        if (null == options.as || "script" === options.as) {
          var crossOrigin = getCrossOriginStringAs(
            options.as,
            options.crossOrigin
          );
          Internals.d.M(href, {
            crossOrigin,
            integrity: "string" === typeof options.integrity ? options.integrity : void 0,
            nonce: "string" === typeof options.nonce ? options.nonce : void 0
          });
        }
      } else null == options && Internals.d.M(href);
  };
  reactDom_production.preload = function(href, options) {
    if ("string" === typeof href && "object" === typeof options && null !== options && "string" === typeof options.as) {
      var as2 = options.as, crossOrigin = getCrossOriginStringAs(as2, options.crossOrigin);
      Internals.d.L(href, as2, {
        crossOrigin,
        integrity: "string" === typeof options.integrity ? options.integrity : void 0,
        nonce: "string" === typeof options.nonce ? options.nonce : void 0,
        type: "string" === typeof options.type ? options.type : void 0,
        fetchPriority: "string" === typeof options.fetchPriority ? options.fetchPriority : void 0,
        referrerPolicy: "string" === typeof options.referrerPolicy ? options.referrerPolicy : void 0,
        imageSrcSet: "string" === typeof options.imageSrcSet ? options.imageSrcSet : void 0,
        imageSizes: "string" === typeof options.imageSizes ? options.imageSizes : void 0,
        media: "string" === typeof options.media ? options.media : void 0
      });
    }
  };
  reactDom_production.preloadModule = function(href, options) {
    if ("string" === typeof href)
      if (options) {
        var crossOrigin = getCrossOriginStringAs(options.as, options.crossOrigin);
        Internals.d.m(href, {
          as: "string" === typeof options.as && "script" !== options.as ? options.as : void 0,
          crossOrigin,
          integrity: "string" === typeof options.integrity ? options.integrity : void 0
        });
      } else Internals.d.m(href);
  };
  reactDom_production.requestFormReset = function(form) {
    Internals.d.r(form);
  };
  reactDom_production.unstable_batchedUpdates = function(fn2, a3) {
    return fn2(a3);
  };
  reactDom_production.useFormState = function(action, initialState, permalink) {
    return ReactSharedInternals.H.useFormState(action, initialState, permalink);
  };
  reactDom_production.useFormStatus = function() {
    return ReactSharedInternals.H.useHostTransitionStatus();
  };
  reactDom_production.version = "19.2.0";
  return reactDom_production;
}
var hasRequiredReactDom;
function requireReactDom() {
  if (hasRequiredReactDom) return reactDom.exports;
  hasRequiredReactDom = 1;
  function checkDCE() {
    if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ === "undefined" || typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE !== "function") {
      return;
    }
    try {
      __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE(checkDCE);
    } catch (err2) {
      console.error(err2);
    }
  }
  {
    checkDCE();
    reactDom.exports = requireReactDom_production();
  }
  return reactDom.exports;
}
var hasRequiredReactDomClient_production;
function requireReactDomClient_production() {
  if (hasRequiredReactDomClient_production) return reactDomClient_production;
  hasRequiredReactDomClient_production = 1;
  var Scheduler = requireScheduler(), React2 = requireReact(), ReactDOM2 = requireReactDom();
  function formatProdErrorMessage(code) {
    var url = "https://react.dev/errors/" + code;
    if (1 < arguments.length) {
      url += "?args[]=" + encodeURIComponent(arguments[1]);
      for (var i3 = 2; i3 < arguments.length; i3++)
        url += "&args[]=" + encodeURIComponent(arguments[i3]);
    }
    return "Minified React error #" + code + "; visit " + url + " for the full message or use the non-minified dev environment for full errors and additional helpful warnings.";
  }
  function isValidContainer(node) {
    return !(!node || 1 !== node.nodeType && 9 !== node.nodeType && 11 !== node.nodeType);
  }
  function getNearestMountedFiber(fiber) {
    var node = fiber, nearestMounted = fiber;
    if (fiber.alternate) for (; node.return; ) node = node.return;
    else {
      fiber = node;
      do
        node = fiber, 0 !== (node.flags & 4098) && (nearestMounted = node.return), fiber = node.return;
      while (fiber);
    }
    return 3 === node.tag ? nearestMounted : null;
  }
  function getSuspenseInstanceFromFiber(fiber) {
    if (13 === fiber.tag) {
      var suspenseState = fiber.memoizedState;
      null === suspenseState && (fiber = fiber.alternate, null !== fiber && (suspenseState = fiber.memoizedState));
      if (null !== suspenseState) return suspenseState.dehydrated;
    }
    return null;
  }
  function getActivityInstanceFromFiber(fiber) {
    if (31 === fiber.tag) {
      var activityState = fiber.memoizedState;
      null === activityState && (fiber = fiber.alternate, null !== fiber && (activityState = fiber.memoizedState));
      if (null !== activityState) return activityState.dehydrated;
    }
    return null;
  }
  function assertIsMounted(fiber) {
    if (getNearestMountedFiber(fiber) !== fiber)
      throw Error(formatProdErrorMessage(188));
  }
  function findCurrentFiberUsingSlowPath(fiber) {
    var alternate = fiber.alternate;
    if (!alternate) {
      alternate = getNearestMountedFiber(fiber);
      if (null === alternate) throw Error(formatProdErrorMessage(188));
      return alternate !== fiber ? null : fiber;
    }
    for (var a3 = fiber, b3 = alternate; ; ) {
      var parentA = a3.return;
      if (null === parentA) break;
      var parentB = parentA.alternate;
      if (null === parentB) {
        b3 = parentA.return;
        if (null !== b3) {
          a3 = b3;
          continue;
        }
        break;
      }
      if (parentA.child === parentB.child) {
        for (parentB = parentA.child; parentB; ) {
          if (parentB === a3) return assertIsMounted(parentA), fiber;
          if (parentB === b3) return assertIsMounted(parentA), alternate;
          parentB = parentB.sibling;
        }
        throw Error(formatProdErrorMessage(188));
      }
      if (a3.return !== b3.return) a3 = parentA, b3 = parentB;
      else {
        for (var didFindChild = false, child$0 = parentA.child; child$0; ) {
          if (child$0 === a3) {
            didFindChild = true;
            a3 = parentA;
            b3 = parentB;
            break;
          }
          if (child$0 === b3) {
            didFindChild = true;
            b3 = parentA;
            a3 = parentB;
            break;
          }
          child$0 = child$0.sibling;
        }
        if (!didFindChild) {
          for (child$0 = parentB.child; child$0; ) {
            if (child$0 === a3) {
              didFindChild = true;
              a3 = parentB;
              b3 = parentA;
              break;
            }
            if (child$0 === b3) {
              didFindChild = true;
              b3 = parentB;
              a3 = parentA;
              break;
            }
            child$0 = child$0.sibling;
          }
          if (!didFindChild) throw Error(formatProdErrorMessage(189));
        }
      }
      if (a3.alternate !== b3) throw Error(formatProdErrorMessage(190));
    }
    if (3 !== a3.tag) throw Error(formatProdErrorMessage(188));
    return a3.stateNode.current === a3 ? fiber : alternate;
  }
  function findCurrentHostFiberImpl(node) {
    var tag = node.tag;
    if (5 === tag || 26 === tag || 27 === tag || 6 === tag) return node;
    for (node = node.child; null !== node; ) {
      tag = findCurrentHostFiberImpl(node);
      if (null !== tag) return tag;
      node = node.sibling;
    }
    return null;
  }
  var assign2 = Object.assign, REACT_LEGACY_ELEMENT_TYPE = Symbol.for("react.element"), REACT_ELEMENT_TYPE = Symbol.for("react.transitional.element"), REACT_PORTAL_TYPE = Symbol.for("react.portal"), REACT_FRAGMENT_TYPE = Symbol.for("react.fragment"), REACT_STRICT_MODE_TYPE = Symbol.for("react.strict_mode"), REACT_PROFILER_TYPE = Symbol.for("react.profiler"), REACT_CONSUMER_TYPE = Symbol.for("react.consumer"), REACT_CONTEXT_TYPE = Symbol.for("react.context"), REACT_FORWARD_REF_TYPE = Symbol.for("react.forward_ref"), REACT_SUSPENSE_TYPE = Symbol.for("react.suspense"), REACT_SUSPENSE_LIST_TYPE = Symbol.for("react.suspense_list"), REACT_MEMO_TYPE = Symbol.for("react.memo"), REACT_LAZY_TYPE = Symbol.for("react.lazy");
  var REACT_ACTIVITY_TYPE = Symbol.for("react.activity");
  var REACT_MEMO_CACHE_SENTINEL = Symbol.for("react.memo_cache_sentinel");
  var MAYBE_ITERATOR_SYMBOL = Symbol.iterator;
  function getIteratorFn(maybeIterable) {
    if (null === maybeIterable || "object" !== typeof maybeIterable) return null;
    maybeIterable = MAYBE_ITERATOR_SYMBOL && maybeIterable[MAYBE_ITERATOR_SYMBOL] || maybeIterable["@@iterator"];
    return "function" === typeof maybeIterable ? maybeIterable : null;
  }
  var REACT_CLIENT_REFERENCE = Symbol.for("react.client.reference");
  function getComponentNameFromType(type) {
    if (null == type) return null;
    if ("function" === typeof type)
      return type.$$typeof === REACT_CLIENT_REFERENCE ? null : type.displayName || type.name || null;
    if ("string" === typeof type) return type;
    switch (type) {
      case REACT_FRAGMENT_TYPE:
        return "Fragment";
      case REACT_PROFILER_TYPE:
        return "Profiler";
      case REACT_STRICT_MODE_TYPE:
        return "StrictMode";
      case REACT_SUSPENSE_TYPE:
        return "Suspense";
      case REACT_SUSPENSE_LIST_TYPE:
        return "SuspenseList";
      case REACT_ACTIVITY_TYPE:
        return "Activity";
    }
    if ("object" === typeof type)
      switch (type.$$typeof) {
        case REACT_PORTAL_TYPE:
          return "Portal";
        case REACT_CONTEXT_TYPE:
          return type.displayName || "Context";
        case REACT_CONSUMER_TYPE:
          return (type._context.displayName || "Context") + ".Consumer";
        case REACT_FORWARD_REF_TYPE:
          var innerType = type.render;
          type = type.displayName;
          type || (type = innerType.displayName || innerType.name || "", type = "" !== type ? "ForwardRef(" + type + ")" : "ForwardRef");
          return type;
        case REACT_MEMO_TYPE:
          return innerType = type.displayName || null, null !== innerType ? innerType : getComponentNameFromType(type.type) || "Memo";
        case REACT_LAZY_TYPE:
          innerType = type._payload;
          type = type._init;
          try {
            return getComponentNameFromType(type(innerType));
          } catch (x3) {
          }
      }
    return null;
  }
  var isArrayImpl = Array.isArray, ReactSharedInternals = React2.__CLIENT_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE, ReactDOMSharedInternals = ReactDOM2.__DOM_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE, sharedNotPendingObject = {
    pending: false,
    data: null,
    method: null,
    action: null
  }, valueStack = [], index2 = -1;
  function createCursor(defaultValue) {
    return { current: defaultValue };
  }
  function pop(cursor) {
    0 > index2 || (cursor.current = valueStack[index2], valueStack[index2] = null, index2--);
  }
  function push(cursor, value) {
    index2++;
    valueStack[index2] = cursor.current;
    cursor.current = value;
  }
  var contextStackCursor = createCursor(null), contextFiberStackCursor = createCursor(null), rootInstanceStackCursor = createCursor(null), hostTransitionProviderCursor = createCursor(null);
  function pushHostContainer(fiber, nextRootInstance) {
    push(rootInstanceStackCursor, nextRootInstance);
    push(contextFiberStackCursor, fiber);
    push(contextStackCursor, null);
    switch (nextRootInstance.nodeType) {
      case 9:
      case 11:
        fiber = (fiber = nextRootInstance.documentElement) ? (fiber = fiber.namespaceURI) ? getOwnHostContext(fiber) : 0 : 0;
        break;
      default:
        if (fiber = nextRootInstance.tagName, nextRootInstance = nextRootInstance.namespaceURI)
          nextRootInstance = getOwnHostContext(nextRootInstance), fiber = getChildHostContextProd(nextRootInstance, fiber);
        else
          switch (fiber) {
            case "svg":
              fiber = 1;
              break;
            case "math":
              fiber = 2;
              break;
            default:
              fiber = 0;
          }
    }
    pop(contextStackCursor);
    push(contextStackCursor, fiber);
  }
  function popHostContainer() {
    pop(contextStackCursor);
    pop(contextFiberStackCursor);
    pop(rootInstanceStackCursor);
  }
  function pushHostContext(fiber) {
    null !== fiber.memoizedState && push(hostTransitionProviderCursor, fiber);
    var context = contextStackCursor.current;
    var JSCompiler_inline_result = getChildHostContextProd(context, fiber.type);
    context !== JSCompiler_inline_result && (push(contextFiberStackCursor, fiber), push(contextStackCursor, JSCompiler_inline_result));
  }
  function popHostContext(fiber) {
    contextFiberStackCursor.current === fiber && (pop(contextStackCursor), pop(contextFiberStackCursor));
    hostTransitionProviderCursor.current === fiber && (pop(hostTransitionProviderCursor), HostTransitionContext._currentValue = sharedNotPendingObject);
  }
  var prefix, suffix;
  function describeBuiltInComponentFrame(name) {
    if (void 0 === prefix)
      try {
        throw Error();
      } catch (x3) {
        var match = x3.stack.trim().match(/\n( *(at )?)/);
        prefix = match && match[1] || "";
        suffix = -1 < x3.stack.indexOf("\n    at") ? " (<anonymous>)" : -1 < x3.stack.indexOf("@") ? "@unknown:0:0" : "";
      }
    return "\n" + prefix + name + suffix;
  }
  var reentry = false;
  function describeNativeComponentFrame(fn2, construct) {
    if (!fn2 || reentry) return "";
    reentry = true;
    var previousPrepareStackTrace = Error.prepareStackTrace;
    Error.prepareStackTrace = void 0;
    try {
      var RunInRootFrame = {
        DetermineComponentFrameRoot: function() {
          try {
            if (construct) {
              var Fake = function() {
                throw Error();
              };
              Object.defineProperty(Fake.prototype, "props", {
                set: function() {
                  throw Error();
                }
              });
              if ("object" === typeof Reflect && Reflect.construct) {
                try {
                  Reflect.construct(Fake, []);
                } catch (x3) {
                  var control = x3;
                }
                Reflect.construct(fn2, [], Fake);
              } else {
                try {
                  Fake.call();
                } catch (x$1) {
                  control = x$1;
                }
                fn2.call(Fake.prototype);
              }
            } else {
              try {
                throw Error();
              } catch (x$2) {
                control = x$2;
              }
              (Fake = fn2()) && "function" === typeof Fake.catch && Fake.catch(function() {
              });
            }
          } catch (sample) {
            if (sample && control && "string" === typeof sample.stack)
              return [sample.stack, control.stack];
          }
          return [null, null];
        }
      };
      RunInRootFrame.DetermineComponentFrameRoot.displayName = "DetermineComponentFrameRoot";
      var namePropDescriptor = Object.getOwnPropertyDescriptor(
        RunInRootFrame.DetermineComponentFrameRoot,
        "name"
      );
      namePropDescriptor && namePropDescriptor.configurable && Object.defineProperty(
        RunInRootFrame.DetermineComponentFrameRoot,
        "name",
        { value: "DetermineComponentFrameRoot" }
      );
      var _RunInRootFrame$Deter = RunInRootFrame.DetermineComponentFrameRoot(), sampleStack = _RunInRootFrame$Deter[0], controlStack = _RunInRootFrame$Deter[1];
      if (sampleStack && controlStack) {
        var sampleLines = sampleStack.split("\n"), controlLines = controlStack.split("\n");
        for (namePropDescriptor = RunInRootFrame = 0; RunInRootFrame < sampleLines.length && !sampleLines[RunInRootFrame].includes("DetermineComponentFrameRoot"); )
          RunInRootFrame++;
        for (; namePropDescriptor < controlLines.length && !controlLines[namePropDescriptor].includes(
          "DetermineComponentFrameRoot"
        ); )
          namePropDescriptor++;
        if (RunInRootFrame === sampleLines.length || namePropDescriptor === controlLines.length)
          for (RunInRootFrame = sampleLines.length - 1, namePropDescriptor = controlLines.length - 1; 1 <= RunInRootFrame && 0 <= namePropDescriptor && sampleLines[RunInRootFrame] !== controlLines[namePropDescriptor]; )
            namePropDescriptor--;
        for (; 1 <= RunInRootFrame && 0 <= namePropDescriptor; RunInRootFrame--, namePropDescriptor--)
          if (sampleLines[RunInRootFrame] !== controlLines[namePropDescriptor]) {
            if (1 !== RunInRootFrame || 1 !== namePropDescriptor) {
              do
                if (RunInRootFrame--, namePropDescriptor--, 0 > namePropDescriptor || sampleLines[RunInRootFrame] !== controlLines[namePropDescriptor]) {
                  var frame = "\n" + sampleLines[RunInRootFrame].replace(" at new ", " at ");
                  fn2.displayName && frame.includes("<anonymous>") && (frame = frame.replace("<anonymous>", fn2.displayName));
                  return frame;
                }
              while (1 <= RunInRootFrame && 0 <= namePropDescriptor);
            }
            break;
          }
      }
    } finally {
      reentry = false, Error.prepareStackTrace = previousPrepareStackTrace;
    }
    return (previousPrepareStackTrace = fn2 ? fn2.displayName || fn2.name : "") ? describeBuiltInComponentFrame(previousPrepareStackTrace) : "";
  }
  function describeFiber(fiber, childFiber) {
    switch (fiber.tag) {
      case 26:
      case 27:
      case 5:
        return describeBuiltInComponentFrame(fiber.type);
      case 16:
        return describeBuiltInComponentFrame("Lazy");
      case 13:
        return fiber.child !== childFiber && null !== childFiber ? describeBuiltInComponentFrame("Suspense Fallback") : describeBuiltInComponentFrame("Suspense");
      case 19:
        return describeBuiltInComponentFrame("SuspenseList");
      case 0:
      case 15:
        return describeNativeComponentFrame(fiber.type, false);
      case 11:
        return describeNativeComponentFrame(fiber.type.render, false);
      case 1:
        return describeNativeComponentFrame(fiber.type, true);
      case 31:
        return describeBuiltInComponentFrame("Activity");
      default:
        return "";
    }
  }
  function getStackByFiberInDevAndProd(workInProgress2) {
    try {
      var info = "", previous = null;
      do
        info += describeFiber(workInProgress2, previous), previous = workInProgress2, workInProgress2 = workInProgress2.return;
      while (workInProgress2);
      return info;
    } catch (x3) {
      return "\nError generating stack: " + x3.message + "\n" + x3.stack;
    }
  }
  var hasOwnProperty = Object.prototype.hasOwnProperty, scheduleCallback$3 = Scheduler.unstable_scheduleCallback, cancelCallback$1 = Scheduler.unstable_cancelCallback, shouldYield = Scheduler.unstable_shouldYield, requestPaint = Scheduler.unstable_requestPaint, now = Scheduler.unstable_now, getCurrentPriorityLevel = Scheduler.unstable_getCurrentPriorityLevel, ImmediatePriority = Scheduler.unstable_ImmediatePriority, UserBlockingPriority = Scheduler.unstable_UserBlockingPriority, NormalPriority$1 = Scheduler.unstable_NormalPriority, LowPriority = Scheduler.unstable_LowPriority, IdlePriority = Scheduler.unstable_IdlePriority, log$1 = Scheduler.log, unstable_setDisableYieldValue = Scheduler.unstable_setDisableYieldValue, rendererID = null, injectedHook = null;
  function setIsStrictModeForDevtools(newIsStrictMode) {
    "function" === typeof log$1 && unstable_setDisableYieldValue(newIsStrictMode);
    if (injectedHook && "function" === typeof injectedHook.setStrictMode)
      try {
        injectedHook.setStrictMode(rendererID, newIsStrictMode);
      } catch (err2) {
      }
  }
  var clz32 = Math.clz32 ? Math.clz32 : clz32Fallback, log = Math.log, LN2 = Math.LN2;
  function clz32Fallback(x3) {
    x3 >>>= 0;
    return 0 === x3 ? 32 : 31 - (log(x3) / LN2 | 0) | 0;
  }
  var nextTransitionUpdateLane = 256, nextTransitionDeferredLane = 262144, nextRetryLane = 4194304;
  function getHighestPriorityLanes(lanes) {
    var pendingSyncLanes = lanes & 42;
    if (0 !== pendingSyncLanes) return pendingSyncLanes;
    switch (lanes & -lanes) {
      case 1:
        return 1;
      case 2:
        return 2;
      case 4:
        return 4;
      case 8:
        return 8;
      case 16:
        return 16;
      case 32:
        return 32;
      case 64:
        return 64;
      case 128:
        return 128;
      case 256:
      case 512:
      case 1024:
      case 2048:
      case 4096:
      case 8192:
      case 16384:
      case 32768:
      case 65536:
      case 131072:
        return lanes & 261888;
      case 262144:
      case 524288:
      case 1048576:
      case 2097152:
        return lanes & 3932160;
      case 4194304:
      case 8388608:
      case 16777216:
      case 33554432:
        return lanes & 62914560;
      case 67108864:
        return 67108864;
      case 134217728:
        return 134217728;
      case 268435456:
        return 268435456;
      case 536870912:
        return 536870912;
      case 1073741824:
        return 0;
      default:
        return lanes;
    }
  }
  function getNextLanes(root2, wipLanes, rootHasPendingCommit) {
    var pendingLanes = root2.pendingLanes;
    if (0 === pendingLanes) return 0;
    var nextLanes = 0, suspendedLanes = root2.suspendedLanes, pingedLanes = root2.pingedLanes;
    root2 = root2.warmLanes;
    var nonIdlePendingLanes = pendingLanes & 134217727;
    0 !== nonIdlePendingLanes ? (pendingLanes = nonIdlePendingLanes & ~suspendedLanes, 0 !== pendingLanes ? nextLanes = getHighestPriorityLanes(pendingLanes) : (pingedLanes &= nonIdlePendingLanes, 0 !== pingedLanes ? nextLanes = getHighestPriorityLanes(pingedLanes) : rootHasPendingCommit || (rootHasPendingCommit = nonIdlePendingLanes & ~root2, 0 !== rootHasPendingCommit && (nextLanes = getHighestPriorityLanes(rootHasPendingCommit))))) : (nonIdlePendingLanes = pendingLanes & ~suspendedLanes, 0 !== nonIdlePendingLanes ? nextLanes = getHighestPriorityLanes(nonIdlePendingLanes) : 0 !== pingedLanes ? nextLanes = getHighestPriorityLanes(pingedLanes) : rootHasPendingCommit || (rootHasPendingCommit = pendingLanes & ~root2, 0 !== rootHasPendingCommit && (nextLanes = getHighestPriorityLanes(rootHasPendingCommit))));
    return 0 === nextLanes ? 0 : 0 !== wipLanes && wipLanes !== nextLanes && 0 === (wipLanes & suspendedLanes) && (suspendedLanes = nextLanes & -nextLanes, rootHasPendingCommit = wipLanes & -wipLanes, suspendedLanes >= rootHasPendingCommit || 32 === suspendedLanes && 0 !== (rootHasPendingCommit & 4194048)) ? wipLanes : nextLanes;
  }
  function checkIfRootIsPrerendering(root2, renderLanes2) {
    return 0 === (root2.pendingLanes & ~(root2.suspendedLanes & ~root2.pingedLanes) & renderLanes2);
  }
  function computeExpirationTime(lane, currentTime) {
    switch (lane) {
      case 1:
      case 2:
      case 4:
      case 8:
      case 64:
        return currentTime + 250;
      case 16:
      case 32:
      case 128:
      case 256:
      case 512:
      case 1024:
      case 2048:
      case 4096:
      case 8192:
      case 16384:
      case 32768:
      case 65536:
      case 131072:
      case 262144:
      case 524288:
      case 1048576:
      case 2097152:
        return currentTime + 5e3;
      case 4194304:
      case 8388608:
      case 16777216:
      case 33554432:
        return -1;
      case 67108864:
      case 134217728:
      case 268435456:
      case 536870912:
      case 1073741824:
        return -1;
      default:
        return -1;
    }
  }
  function claimNextRetryLane() {
    var lane = nextRetryLane;
    nextRetryLane <<= 1;
    0 === (nextRetryLane & 62914560) && (nextRetryLane = 4194304);
    return lane;
  }
  function createLaneMap(initial) {
    for (var laneMap = [], i3 = 0; 31 > i3; i3++) laneMap.push(initial);
    return laneMap;
  }
  function markRootUpdated$1(root2, updateLane) {
    root2.pendingLanes |= updateLane;
    268435456 !== updateLane && (root2.suspendedLanes = 0, root2.pingedLanes = 0, root2.warmLanes = 0);
  }
  function markRootFinished(root2, finishedLanes, remainingLanes, spawnedLane, updatedLanes, suspendedRetryLanes) {
    var previouslyPendingLanes = root2.pendingLanes;
    root2.pendingLanes = remainingLanes;
    root2.suspendedLanes = 0;
    root2.pingedLanes = 0;
    root2.warmLanes = 0;
    root2.expiredLanes &= remainingLanes;
    root2.entangledLanes &= remainingLanes;
    root2.errorRecoveryDisabledLanes &= remainingLanes;
    root2.shellSuspendCounter = 0;
    var entanglements = root2.entanglements, expirationTimes = root2.expirationTimes, hiddenUpdates = root2.hiddenUpdates;
    for (remainingLanes = previouslyPendingLanes & ~remainingLanes; 0 < remainingLanes; ) {
      var index$7 = 31 - clz32(remainingLanes), lane = 1 << index$7;
      entanglements[index$7] = 0;
      expirationTimes[index$7] = -1;
      var hiddenUpdatesForLane = hiddenUpdates[index$7];
      if (null !== hiddenUpdatesForLane)
        for (hiddenUpdates[index$7] = null, index$7 = 0; index$7 < hiddenUpdatesForLane.length; index$7++) {
          var update = hiddenUpdatesForLane[index$7];
          null !== update && (update.lane &= -536870913);
        }
      remainingLanes &= ~lane;
    }
    0 !== spawnedLane && markSpawnedDeferredLane(root2, spawnedLane, 0);
    0 !== suspendedRetryLanes && 0 === updatedLanes && 0 !== root2.tag && (root2.suspendedLanes |= suspendedRetryLanes & ~(previouslyPendingLanes & ~finishedLanes));
  }
  function markSpawnedDeferredLane(root2, spawnedLane, entangledLanes) {
    root2.pendingLanes |= spawnedLane;
    root2.suspendedLanes &= ~spawnedLane;
    var spawnedLaneIndex = 31 - clz32(spawnedLane);
    root2.entangledLanes |= spawnedLane;
    root2.entanglements[spawnedLaneIndex] = root2.entanglements[spawnedLaneIndex] | 1073741824 | entangledLanes & 261930;
  }
  function markRootEntangled(root2, entangledLanes) {
    var rootEntangledLanes = root2.entangledLanes |= entangledLanes;
    for (root2 = root2.entanglements; rootEntangledLanes; ) {
      var index$8 = 31 - clz32(rootEntangledLanes), lane = 1 << index$8;
      lane & entangledLanes | root2[index$8] & entangledLanes && (root2[index$8] |= entangledLanes);
      rootEntangledLanes &= ~lane;
    }
  }
  function getBumpedLaneForHydration(root2, renderLanes2) {
    var renderLane = renderLanes2 & -renderLanes2;
    renderLane = 0 !== (renderLane & 42) ? 1 : getBumpedLaneForHydrationByLane(renderLane);
    return 0 !== (renderLane & (root2.suspendedLanes | renderLanes2)) ? 0 : renderLane;
  }
  function getBumpedLaneForHydrationByLane(lane) {
    switch (lane) {
      case 2:
        lane = 1;
        break;
      case 8:
        lane = 4;
        break;
      case 32:
        lane = 16;
        break;
      case 256:
      case 512:
      case 1024:
      case 2048:
      case 4096:
      case 8192:
      case 16384:
      case 32768:
      case 65536:
      case 131072:
      case 262144:
      case 524288:
      case 1048576:
      case 2097152:
      case 4194304:
      case 8388608:
      case 16777216:
      case 33554432:
        lane = 128;
        break;
      case 268435456:
        lane = 134217728;
        break;
      default:
        lane = 0;
    }
    return lane;
  }
  function lanesToEventPriority(lanes) {
    lanes &= -lanes;
    return 2 < lanes ? 8 < lanes ? 0 !== (lanes & 134217727) ? 32 : 268435456 : 8 : 2;
  }
  function resolveUpdatePriority() {
    var updatePriority = ReactDOMSharedInternals.p;
    if (0 !== updatePriority) return updatePriority;
    updatePriority = window.event;
    return void 0 === updatePriority ? 32 : getEventPriority(updatePriority.type);
  }
  function runWithPriority(priority, fn2) {
    var previousPriority = ReactDOMSharedInternals.p;
    try {
      return ReactDOMSharedInternals.p = priority, fn2();
    } finally {
      ReactDOMSharedInternals.p = previousPriority;
    }
  }
  var randomKey = Math.random().toString(36).slice(2), internalInstanceKey = "__reactFiber$" + randomKey, internalPropsKey = "__reactProps$" + randomKey, internalContainerInstanceKey = "__reactContainer$" + randomKey, internalEventHandlersKey = "__reactEvents$" + randomKey, internalEventHandlerListenersKey = "__reactListeners$" + randomKey, internalEventHandlesSetKey = "__reactHandles$" + randomKey, internalRootNodeResourcesKey = "__reactResources$" + randomKey, internalHoistableMarker = "__reactMarker$" + randomKey;
  function detachDeletedInstance(node) {
    delete node[internalInstanceKey];
    delete node[internalPropsKey];
    delete node[internalEventHandlersKey];
    delete node[internalEventHandlerListenersKey];
    delete node[internalEventHandlesSetKey];
  }
  function getClosestInstanceFromNode(targetNode) {
    var targetInst = targetNode[internalInstanceKey];
    if (targetInst) return targetInst;
    for (var parentNode = targetNode.parentNode; parentNode; ) {
      if (targetInst = parentNode[internalContainerInstanceKey] || parentNode[internalInstanceKey]) {
        parentNode = targetInst.alternate;
        if (null !== targetInst.child || null !== parentNode && null !== parentNode.child)
          for (targetNode = getParentHydrationBoundary(targetNode); null !== targetNode; ) {
            if (parentNode = targetNode[internalInstanceKey]) return parentNode;
            targetNode = getParentHydrationBoundary(targetNode);
          }
        return targetInst;
      }
      targetNode = parentNode;
      parentNode = targetNode.parentNode;
    }
    return null;
  }
  function getInstanceFromNode(node) {
    if (node = node[internalInstanceKey] || node[internalContainerInstanceKey]) {
      var tag = node.tag;
      if (5 === tag || 6 === tag || 13 === tag || 31 === tag || 26 === tag || 27 === tag || 3 === tag)
        return node;
    }
    return null;
  }
  function getNodeFromInstance(inst) {
    var tag = inst.tag;
    if (5 === tag || 26 === tag || 27 === tag || 6 === tag) return inst.stateNode;
    throw Error(formatProdErrorMessage(33));
  }
  function getResourcesFromRoot(root2) {
    var resources = root2[internalRootNodeResourcesKey];
    resources || (resources = root2[internalRootNodeResourcesKey] = { hoistableStyles: /* @__PURE__ */ new Map(), hoistableScripts: /* @__PURE__ */ new Map() });
    return resources;
  }
  function markNodeAsHoistable(node) {
    node[internalHoistableMarker] = true;
  }
  var allNativeEvents = /* @__PURE__ */ new Set(), registrationNameDependencies = {};
  function registerTwoPhaseEvent(registrationName, dependencies) {
    registerDirectEvent(registrationName, dependencies);
    registerDirectEvent(registrationName + "Capture", dependencies);
  }
  function registerDirectEvent(registrationName, dependencies) {
    registrationNameDependencies[registrationName] = dependencies;
    for (registrationName = 0; registrationName < dependencies.length; registrationName++)
      allNativeEvents.add(dependencies[registrationName]);
  }
  var VALID_ATTRIBUTE_NAME_REGEX = RegExp(
    "^[:A-Z_a-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD][:A-Z_a-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD\\-.0-9\\u00B7\\u0300-\\u036F\\u203F-\\u2040]*$"
  ), illegalAttributeNameCache = {}, validatedAttributeNameCache = {};
  function isAttributeNameSafe(attributeName) {
    if (hasOwnProperty.call(validatedAttributeNameCache, attributeName))
      return true;
    if (hasOwnProperty.call(illegalAttributeNameCache, attributeName)) return false;
    if (VALID_ATTRIBUTE_NAME_REGEX.test(attributeName))
      return validatedAttributeNameCache[attributeName] = true;
    illegalAttributeNameCache[attributeName] = true;
    return false;
  }
  function setValueForAttribute(node, name, value) {
    if (isAttributeNameSafe(name))
      if (null === value) node.removeAttribute(name);
      else {
        switch (typeof value) {
          case "undefined":
          case "function":
          case "symbol":
            node.removeAttribute(name);
            return;
          case "boolean":
            var prefix$10 = name.toLowerCase().slice(0, 5);
            if ("data-" !== prefix$10 && "aria-" !== prefix$10) {
              node.removeAttribute(name);
              return;
            }
        }
        node.setAttribute(name, "" + value);
      }
  }
  function setValueForKnownAttribute(node, name, value) {
    if (null === value) node.removeAttribute(name);
    else {
      switch (typeof value) {
        case "undefined":
        case "function":
        case "symbol":
        case "boolean":
          node.removeAttribute(name);
          return;
      }
      node.setAttribute(name, "" + value);
    }
  }
  function setValueForNamespacedAttribute(node, namespace, name, value) {
    if (null === value) node.removeAttribute(name);
    else {
      switch (typeof value) {
        case "undefined":
        case "function":
        case "symbol":
        case "boolean":
          node.removeAttribute(name);
          return;
      }
      node.setAttributeNS(namespace, name, "" + value);
    }
  }
  function getToStringValue(value) {
    switch (typeof value) {
      case "bigint":
      case "boolean":
      case "number":
      case "string":
      case "undefined":
        return value;
      case "object":
        return value;
      default:
        return "";
    }
  }
  function isCheckable(elem) {
    var type = elem.type;
    return (elem = elem.nodeName) && "input" === elem.toLowerCase() && ("checkbox" === type || "radio" === type);
  }
  function trackValueOnNode(node, valueField, currentValue) {
    var descriptor = Object.getOwnPropertyDescriptor(
      node.constructor.prototype,
      valueField
    );
    if (!node.hasOwnProperty(valueField) && "undefined" !== typeof descriptor && "function" === typeof descriptor.get && "function" === typeof descriptor.set) {
      var get = descriptor.get, set = descriptor.set;
      Object.defineProperty(node, valueField, {
        configurable: true,
        get: function() {
          return get.call(this);
        },
        set: function(value) {
          currentValue = "" + value;
          set.call(this, value);
        }
      });
      Object.defineProperty(node, valueField, {
        enumerable: descriptor.enumerable
      });
      return {
        getValue: function() {
          return currentValue;
        },
        setValue: function(value) {
          currentValue = "" + value;
        },
        stopTracking: function() {
          node._valueTracker = null;
          delete node[valueField];
        }
      };
    }
  }
  function track(node) {
    if (!node._valueTracker) {
      var valueField = isCheckable(node) ? "checked" : "value";
      node._valueTracker = trackValueOnNode(
        node,
        valueField,
        "" + node[valueField]
      );
    }
  }
  function updateValueIfChanged(node) {
    if (!node) return false;
    var tracker = node._valueTracker;
    if (!tracker) return true;
    var lastValue = tracker.getValue();
    var value = "";
    node && (value = isCheckable(node) ? node.checked ? "true" : "false" : node.value);
    node = value;
    return node !== lastValue ? (tracker.setValue(node), true) : false;
  }
  function getActiveElement(doc) {
    doc = doc || ("undefined" !== typeof document ? document : void 0);
    if ("undefined" === typeof doc) return null;
    try {
      return doc.activeElement || doc.body;
    } catch (e12) {
      return doc.body;
    }
  }
  var escapeSelectorAttributeValueInsideDoubleQuotesRegex = /[\n"\\]/g;
  function escapeSelectorAttributeValueInsideDoubleQuotes(value) {
    return value.replace(
      escapeSelectorAttributeValueInsideDoubleQuotesRegex,
      function(ch2) {
        return "\\" + ch2.charCodeAt(0).toString(16) + " ";
      }
    );
  }
  function updateInput(element, value, defaultValue, lastDefaultValue, checked, defaultChecked, type, name) {
    element.name = "";
    null != type && "function" !== typeof type && "symbol" !== typeof type && "boolean" !== typeof type ? element.type = type : element.removeAttribute("type");
    if (null != value)
      if ("number" === type) {
        if (0 === value && "" === element.value || element.value != value)
          element.value = "" + getToStringValue(value);
      } else
        element.value !== "" + getToStringValue(value) && (element.value = "" + getToStringValue(value));
    else
      "submit" !== type && "reset" !== type || element.removeAttribute("value");
    null != value ? setDefaultValue(element, type, getToStringValue(value)) : null != defaultValue ? setDefaultValue(element, type, getToStringValue(defaultValue)) : null != lastDefaultValue && element.removeAttribute("value");
    null == checked && null != defaultChecked && (element.defaultChecked = !!defaultChecked);
    null != checked && (element.checked = checked && "function" !== typeof checked && "symbol" !== typeof checked);
    null != name && "function" !== typeof name && "symbol" !== typeof name && "boolean" !== typeof name ? element.name = "" + getToStringValue(name) : element.removeAttribute("name");
  }
  function initInput(element, value, defaultValue, checked, defaultChecked, type, name, isHydrating2) {
    null != type && "function" !== typeof type && "symbol" !== typeof type && "boolean" !== typeof type && (element.type = type);
    if (null != value || null != defaultValue) {
      if (!("submit" !== type && "reset" !== type || void 0 !== value && null !== value)) {
        track(element);
        return;
      }
      defaultValue = null != defaultValue ? "" + getToStringValue(defaultValue) : "";
      value = null != value ? "" + getToStringValue(value) : defaultValue;
      isHydrating2 || value === element.value || (element.value = value);
      element.defaultValue = value;
    }
    checked = null != checked ? checked : defaultChecked;
    checked = "function" !== typeof checked && "symbol" !== typeof checked && !!checked;
    element.checked = isHydrating2 ? element.checked : !!checked;
    element.defaultChecked = !!checked;
    null != name && "function" !== typeof name && "symbol" !== typeof name && "boolean" !== typeof name && (element.name = name);
    track(element);
  }
  function setDefaultValue(node, type, value) {
    "number" === type && getActiveElement(node.ownerDocument) === node || node.defaultValue === "" + value || (node.defaultValue = "" + value);
  }
  function updateOptions(node, multiple, propValue, setDefaultSelected) {
    node = node.options;
    if (multiple) {
      multiple = {};
      for (var i3 = 0; i3 < propValue.length; i3++)
        multiple["$" + propValue[i3]] = true;
      for (propValue = 0; propValue < node.length; propValue++)
        i3 = multiple.hasOwnProperty("$" + node[propValue].value), node[propValue].selected !== i3 && (node[propValue].selected = i3), i3 && setDefaultSelected && (node[propValue].defaultSelected = true);
    } else {
      propValue = "" + getToStringValue(propValue);
      multiple = null;
      for (i3 = 0; i3 < node.length; i3++) {
        if (node[i3].value === propValue) {
          node[i3].selected = true;
          setDefaultSelected && (node[i3].defaultSelected = true);
          return;
        }
        null !== multiple || node[i3].disabled || (multiple = node[i3]);
      }
      null !== multiple && (multiple.selected = true);
    }
  }
  function updateTextarea(element, value, defaultValue) {
    if (null != value && (value = "" + getToStringValue(value), value !== element.value && (element.value = value), null == defaultValue)) {
      element.defaultValue !== value && (element.defaultValue = value);
      return;
    }
    element.defaultValue = null != defaultValue ? "" + getToStringValue(defaultValue) : "";
  }
  function initTextarea(element, value, defaultValue, children) {
    if (null == value) {
      if (null != children) {
        if (null != defaultValue) throw Error(formatProdErrorMessage(92));
        if (isArrayImpl(children)) {
          if (1 < children.length) throw Error(formatProdErrorMessage(93));
          children = children[0];
        }
        defaultValue = children;
      }
      null == defaultValue && (defaultValue = "");
      value = defaultValue;
    }
    defaultValue = getToStringValue(value);
    element.defaultValue = defaultValue;
    children = element.textContent;
    children === defaultValue && "" !== children && null !== children && (element.value = children);
    track(element);
  }
  function setTextContent(node, text) {
    if (text) {
      var firstChild = node.firstChild;
      if (firstChild && firstChild === node.lastChild && 3 === firstChild.nodeType) {
        firstChild.nodeValue = text;
        return;
      }
    }
    node.textContent = text;
  }
  var unitlessNumbers = new Set(
    "animationIterationCount aspectRatio borderImageOutset borderImageSlice borderImageWidth boxFlex boxFlexGroup boxOrdinalGroup columnCount columns flex flexGrow flexPositive flexShrink flexNegative flexOrder gridArea gridRow gridRowEnd gridRowSpan gridRowStart gridColumn gridColumnEnd gridColumnSpan gridColumnStart fontWeight lineClamp lineHeight opacity order orphans scale tabSize widows zIndex zoom fillOpacity floodOpacity stopOpacity strokeDasharray strokeDashoffset strokeMiterlimit strokeOpacity strokeWidth MozAnimationIterationCount MozBoxFlex MozBoxFlexGroup MozLineClamp msAnimationIterationCount msFlex msZoom msFlexGrow msFlexNegative msFlexOrder msFlexPositive msFlexShrink msGridColumn msGridColumnSpan msGridRow msGridRowSpan WebkitAnimationIterationCount WebkitBoxFlex WebKitBoxFlexGroup WebkitBoxOrdinalGroup WebkitColumnCount WebkitColumns WebkitFlex WebkitFlexGrow WebkitFlexPositive WebkitFlexShrink WebkitLineClamp".split(
      " "
    )
  );
  function setValueForStyle(style2, styleName, value) {
    var isCustomProperty = 0 === styleName.indexOf("--");
    null == value || "boolean" === typeof value || "" === value ? isCustomProperty ? style2.setProperty(styleName, "") : "float" === styleName ? style2.cssFloat = "" : style2[styleName] = "" : isCustomProperty ? style2.setProperty(styleName, value) : "number" !== typeof value || 0 === value || unitlessNumbers.has(styleName) ? "float" === styleName ? style2.cssFloat = value : style2[styleName] = ("" + value).trim() : style2[styleName] = value + "px";
  }
  function setValueForStyles(node, styles, prevStyles) {
    if (null != styles && "object" !== typeof styles)
      throw Error(formatProdErrorMessage(62));
    node = node.style;
    if (null != prevStyles) {
      for (var styleName in prevStyles)
        !prevStyles.hasOwnProperty(styleName) || null != styles && styles.hasOwnProperty(styleName) || (0 === styleName.indexOf("--") ? node.setProperty(styleName, "") : "float" === styleName ? node.cssFloat = "" : node[styleName] = "");
      for (var styleName$16 in styles)
        styleName = styles[styleName$16], styles.hasOwnProperty(styleName$16) && prevStyles[styleName$16] !== styleName && setValueForStyle(node, styleName$16, styleName);
    } else
      for (var styleName$17 in styles)
        styles.hasOwnProperty(styleName$17) && setValueForStyle(node, styleName$17, styles[styleName$17]);
  }
  function isCustomElement(tagName) {
    if (-1 === tagName.indexOf("-")) return false;
    switch (tagName) {
      case "annotation-xml":
      case "color-profile":
      case "font-face":
      case "font-face-src":
      case "font-face-uri":
      case "font-face-format":
      case "font-face-name":
      case "missing-glyph":
        return false;
      default:
        return true;
    }
  }
  var aliases = /* @__PURE__ */ new Map([
    ["acceptCharset", "accept-charset"],
    ["htmlFor", "for"],
    ["httpEquiv", "http-equiv"],
    ["crossOrigin", "crossorigin"],
    ["accentHeight", "accent-height"],
    ["alignmentBaseline", "alignment-baseline"],
    ["arabicForm", "arabic-form"],
    ["baselineShift", "baseline-shift"],
    ["capHeight", "cap-height"],
    ["clipPath", "clip-path"],
    ["clipRule", "clip-rule"],
    ["colorInterpolation", "color-interpolation"],
    ["colorInterpolationFilters", "color-interpolation-filters"],
    ["colorProfile", "color-profile"],
    ["colorRendering", "color-rendering"],
    ["dominantBaseline", "dominant-baseline"],
    ["enableBackground", "enable-background"],
    ["fillOpacity", "fill-opacity"],
    ["fillRule", "fill-rule"],
    ["floodColor", "flood-color"],
    ["floodOpacity", "flood-opacity"],
    ["fontFamily", "font-family"],
    ["fontSize", "font-size"],
    ["fontSizeAdjust", "font-size-adjust"],
    ["fontStretch", "font-stretch"],
    ["fontStyle", "font-style"],
    ["fontVariant", "font-variant"],
    ["fontWeight", "font-weight"],
    ["glyphName", "glyph-name"],
    ["glyphOrientationHorizontal", "glyph-orientation-horizontal"],
    ["glyphOrientationVertical", "glyph-orientation-vertical"],
    ["horizAdvX", "horiz-adv-x"],
    ["horizOriginX", "horiz-origin-x"],
    ["imageRendering", "image-rendering"],
    ["letterSpacing", "letter-spacing"],
    ["lightingColor", "lighting-color"],
    ["markerEnd", "marker-end"],
    ["markerMid", "marker-mid"],
    ["markerStart", "marker-start"],
    ["overlinePosition", "overline-position"],
    ["overlineThickness", "overline-thickness"],
    ["paintOrder", "paint-order"],
    ["panose-1", "panose-1"],
    ["pointerEvents", "pointer-events"],
    ["renderingIntent", "rendering-intent"],
    ["shapeRendering", "shape-rendering"],
    ["stopColor", "stop-color"],
    ["stopOpacity", "stop-opacity"],
    ["strikethroughPosition", "strikethrough-position"],
    ["strikethroughThickness", "strikethrough-thickness"],
    ["strokeDasharray", "stroke-dasharray"],
    ["strokeDashoffset", "stroke-dashoffset"],
    ["strokeLinecap", "stroke-linecap"],
    ["strokeLinejoin", "stroke-linejoin"],
    ["strokeMiterlimit", "stroke-miterlimit"],
    ["strokeOpacity", "stroke-opacity"],
    ["strokeWidth", "stroke-width"],
    ["textAnchor", "text-anchor"],
    ["textDecoration", "text-decoration"],
    ["textRendering", "text-rendering"],
    ["transformOrigin", "transform-origin"],
    ["underlinePosition", "underline-position"],
    ["underlineThickness", "underline-thickness"],
    ["unicodeBidi", "unicode-bidi"],
    ["unicodeRange", "unicode-range"],
    ["unitsPerEm", "units-per-em"],
    ["vAlphabetic", "v-alphabetic"],
    ["vHanging", "v-hanging"],
    ["vIdeographic", "v-ideographic"],
    ["vMathematical", "v-mathematical"],
    ["vectorEffect", "vector-effect"],
    ["vertAdvY", "vert-adv-y"],
    ["vertOriginX", "vert-origin-x"],
    ["vertOriginY", "vert-origin-y"],
    ["wordSpacing", "word-spacing"],
    ["writingMode", "writing-mode"],
    ["xmlnsXlink", "xmlns:xlink"],
    ["xHeight", "x-height"]
  ]), isJavaScriptProtocol = /^[\u0000-\u001F ]*j[\r\n\t]*a[\r\n\t]*v[\r\n\t]*a[\r\n\t]*s[\r\n\t]*c[\r\n\t]*r[\r\n\t]*i[\r\n\t]*p[\r\n\t]*t[\r\n\t]*:/i;
  function sanitizeURL(url) {
    return isJavaScriptProtocol.test("" + url) ? "javascript:throw new Error('React has blocked a javascript: URL as a security precaution.')" : url;
  }
  function noop$12() {
  }
  var currentReplayingEvent = null;
  function getEventTarget(nativeEvent) {
    nativeEvent = nativeEvent.target || nativeEvent.srcElement || window;
    nativeEvent.correspondingUseElement && (nativeEvent = nativeEvent.correspondingUseElement);
    return 3 === nativeEvent.nodeType ? nativeEvent.parentNode : nativeEvent;
  }
  var restoreTarget = null, restoreQueue = null;
  function restoreStateOfTarget(target) {
    var internalInstance = getInstanceFromNode(target);
    if (internalInstance && (target = internalInstance.stateNode)) {
      var props = target[internalPropsKey] || null;
      a: switch (target = internalInstance.stateNode, internalInstance.type) {
        case "input":
          updateInput(
            target,
            props.value,
            props.defaultValue,
            props.defaultValue,
            props.checked,
            props.defaultChecked,
            props.type,
            props.name
          );
          internalInstance = props.name;
          if ("radio" === props.type && null != internalInstance) {
            for (props = target; props.parentNode; ) props = props.parentNode;
            props = props.querySelectorAll(
              'input[name="' + escapeSelectorAttributeValueInsideDoubleQuotes(
                "" + internalInstance
              ) + '"][type="radio"]'
            );
            for (internalInstance = 0; internalInstance < props.length; internalInstance++) {
              var otherNode = props[internalInstance];
              if (otherNode !== target && otherNode.form === target.form) {
                var otherProps = otherNode[internalPropsKey] || null;
                if (!otherProps) throw Error(formatProdErrorMessage(90));
                updateInput(
                  otherNode,
                  otherProps.value,
                  otherProps.defaultValue,
                  otherProps.defaultValue,
                  otherProps.checked,
                  otherProps.defaultChecked,
                  otherProps.type,
                  otherProps.name
                );
              }
            }
            for (internalInstance = 0; internalInstance < props.length; internalInstance++)
              otherNode = props[internalInstance], otherNode.form === target.form && updateValueIfChanged(otherNode);
          }
          break a;
        case "textarea":
          updateTextarea(target, props.value, props.defaultValue);
          break a;
        case "select":
          internalInstance = props.value, null != internalInstance && updateOptions(target, !!props.multiple, internalInstance, false);
      }
    }
  }
  var isInsideEventHandler = false;
  function batchedUpdates$1(fn2, a3, b3) {
    if (isInsideEventHandler) return fn2(a3, b3);
    isInsideEventHandler = true;
    try {
      var JSCompiler_inline_result = fn2(a3);
      return JSCompiler_inline_result;
    } finally {
      if (isInsideEventHandler = false, null !== restoreTarget || null !== restoreQueue) {
        if (flushSyncWork$1(), restoreTarget && (a3 = restoreTarget, fn2 = restoreQueue, restoreQueue = restoreTarget = null, restoreStateOfTarget(a3), fn2))
          for (a3 = 0; a3 < fn2.length; a3++) restoreStateOfTarget(fn2[a3]);
      }
    }
  }
  function getListener(inst, registrationName) {
    var stateNode = inst.stateNode;
    if (null === stateNode) return null;
    var props = stateNode[internalPropsKey] || null;
    if (null === props) return null;
    stateNode = props[registrationName];
    a: switch (registrationName) {
      case "onClick":
      case "onClickCapture":
      case "onDoubleClick":
      case "onDoubleClickCapture":
      case "onMouseDown":
      case "onMouseDownCapture":
      case "onMouseMove":
      case "onMouseMoveCapture":
      case "onMouseUp":
      case "onMouseUpCapture":
      case "onMouseEnter":
        (props = !props.disabled) || (inst = inst.type, props = !("button" === inst || "input" === inst || "select" === inst || "textarea" === inst));
        inst = !props;
        break a;
      default:
        inst = false;
    }
    if (inst) return null;
    if (stateNode && "function" !== typeof stateNode)
      throw Error(
        formatProdErrorMessage(231, registrationName, typeof stateNode)
      );
    return stateNode;
  }
  var canUseDOM = !("undefined" === typeof window || "undefined" === typeof window.document || "undefined" === typeof window.document.createElement), passiveBrowserEventsSupported = false;
  if (canUseDOM)
    try {
      var options = {};
      Object.defineProperty(options, "passive", {
        get: function() {
          passiveBrowserEventsSupported = true;
        }
      });
      window.addEventListener("test", options, options);
      window.removeEventListener("test", options, options);
    } catch (e12) {
      passiveBrowserEventsSupported = false;
    }
  var root = null, startText = null, fallbackText = null;
  function getData() {
    if (fallbackText) return fallbackText;
    var start, startValue = startText, startLength = startValue.length, end, endValue = "value" in root ? root.value : root.textContent, endLength = endValue.length;
    for (start = 0; start < startLength && startValue[start] === endValue[start]; start++) ;
    var minEnd = startLength - start;
    for (end = 1; end <= minEnd && startValue[startLength - end] === endValue[endLength - end]; end++) ;
    return fallbackText = endValue.slice(start, 1 < end ? 1 - end : void 0);
  }
  function getEventCharCode(nativeEvent) {
    var keyCode = nativeEvent.keyCode;
    "charCode" in nativeEvent ? (nativeEvent = nativeEvent.charCode, 0 === nativeEvent && 13 === keyCode && (nativeEvent = 13)) : nativeEvent = keyCode;
    10 === nativeEvent && (nativeEvent = 13);
    return 32 <= nativeEvent || 13 === nativeEvent ? nativeEvent : 0;
  }
  function functionThatReturnsTrue() {
    return true;
  }
  function functionThatReturnsFalse() {
    return false;
  }
  function createSyntheticEvent(Interface) {
    function SyntheticBaseEvent(reactName, reactEventType, targetInst, nativeEvent, nativeEventTarget) {
      this._reactName = reactName;
      this._targetInst = targetInst;
      this.type = reactEventType;
      this.nativeEvent = nativeEvent;
      this.target = nativeEventTarget;
      this.currentTarget = null;
      for (var propName in Interface)
        Interface.hasOwnProperty(propName) && (reactName = Interface[propName], this[propName] = reactName ? reactName(nativeEvent) : nativeEvent[propName]);
      this.isDefaultPrevented = (null != nativeEvent.defaultPrevented ? nativeEvent.defaultPrevented : false === nativeEvent.returnValue) ? functionThatReturnsTrue : functionThatReturnsFalse;
      this.isPropagationStopped = functionThatReturnsFalse;
      return this;
    }
    assign2(SyntheticBaseEvent.prototype, {
      preventDefault: function() {
        this.defaultPrevented = true;
        var event = this.nativeEvent;
        event && (event.preventDefault ? event.preventDefault() : "unknown" !== typeof event.returnValue && (event.returnValue = false), this.isDefaultPrevented = functionThatReturnsTrue);
      },
      stopPropagation: function() {
        var event = this.nativeEvent;
        event && (event.stopPropagation ? event.stopPropagation() : "unknown" !== typeof event.cancelBubble && (event.cancelBubble = true), this.isPropagationStopped = functionThatReturnsTrue);
      },
      persist: function() {
      },
      isPersistent: functionThatReturnsTrue
    });
    return SyntheticBaseEvent;
  }
  var EventInterface = {
    eventPhase: 0,
    bubbles: 0,
    cancelable: 0,
    timeStamp: function(event) {
      return event.timeStamp || Date.now();
    },
    defaultPrevented: 0,
    isTrusted: 0
  }, SyntheticEvent = createSyntheticEvent(EventInterface), UIEventInterface = assign2({}, EventInterface, { view: 0, detail: 0 }), SyntheticUIEvent = createSyntheticEvent(UIEventInterface), lastMovementX, lastMovementY, lastMouseEvent, MouseEventInterface = assign2({}, UIEventInterface, {
    screenX: 0,
    screenY: 0,
    clientX: 0,
    clientY: 0,
    pageX: 0,
    pageY: 0,
    ctrlKey: 0,
    shiftKey: 0,
    altKey: 0,
    metaKey: 0,
    getModifierState: getEventModifierState,
    button: 0,
    buttons: 0,
    relatedTarget: function(event) {
      return void 0 === event.relatedTarget ? event.fromElement === event.srcElement ? event.toElement : event.fromElement : event.relatedTarget;
    },
    movementX: function(event) {
      if ("movementX" in event) return event.movementX;
      event !== lastMouseEvent && (lastMouseEvent && "mousemove" === event.type ? (lastMovementX = event.screenX - lastMouseEvent.screenX, lastMovementY = event.screenY - lastMouseEvent.screenY) : lastMovementY = lastMovementX = 0, lastMouseEvent = event);
      return lastMovementX;
    },
    movementY: function(event) {
      return "movementY" in event ? event.movementY : lastMovementY;
    }
  }), SyntheticMouseEvent = createSyntheticEvent(MouseEventInterface), DragEventInterface = assign2({}, MouseEventInterface, { dataTransfer: 0 }), SyntheticDragEvent = createSyntheticEvent(DragEventInterface), FocusEventInterface = assign2({}, UIEventInterface, { relatedTarget: 0 }), SyntheticFocusEvent = createSyntheticEvent(FocusEventInterface), AnimationEventInterface = assign2({}, EventInterface, {
    animationName: 0,
    elapsedTime: 0,
    pseudoElement: 0
  }), SyntheticAnimationEvent = createSyntheticEvent(AnimationEventInterface), ClipboardEventInterface = assign2({}, EventInterface, {
    clipboardData: function(event) {
      return "clipboardData" in event ? event.clipboardData : window.clipboardData;
    }
  }), SyntheticClipboardEvent = createSyntheticEvent(ClipboardEventInterface), CompositionEventInterface = assign2({}, EventInterface, { data: 0 }), SyntheticCompositionEvent = createSyntheticEvent(CompositionEventInterface), normalizeKey = {
    Esc: "Escape",
    Spacebar: " ",
    Left: "ArrowLeft",
    Up: "ArrowUp",
    Right: "ArrowRight",
    Down: "ArrowDown",
    Del: "Delete",
    Win: "OS",
    Menu: "ContextMenu",
    Apps: "ContextMenu",
    Scroll: "ScrollLock",
    MozPrintableKey: "Unidentified"
  }, translateToKey = {
    8: "Backspace",
    9: "Tab",
    12: "Clear",
    13: "Enter",
    16: "Shift",
    17: "Control",
    18: "Alt",
    19: "Pause",
    20: "CapsLock",
    27: "Escape",
    32: " ",
    33: "PageUp",
    34: "PageDown",
    35: "End",
    36: "Home",
    37: "ArrowLeft",
    38: "ArrowUp",
    39: "ArrowRight",
    40: "ArrowDown",
    45: "Insert",
    46: "Delete",
    112: "F1",
    113: "F2",
    114: "F3",
    115: "F4",
    116: "F5",
    117: "F6",
    118: "F7",
    119: "F8",
    120: "F9",
    121: "F10",
    122: "F11",
    123: "F12",
    144: "NumLock",
    145: "ScrollLock",
    224: "Meta"
  }, modifierKeyToProp = {
    Alt: "altKey",
    Control: "ctrlKey",
    Meta: "metaKey",
    Shift: "shiftKey"
  };
  function modifierStateGetter(keyArg) {
    var nativeEvent = this.nativeEvent;
    return nativeEvent.getModifierState ? nativeEvent.getModifierState(keyArg) : (keyArg = modifierKeyToProp[keyArg]) ? !!nativeEvent[keyArg] : false;
  }
  function getEventModifierState() {
    return modifierStateGetter;
  }
  var KeyboardEventInterface = assign2({}, UIEventInterface, {
    key: function(nativeEvent) {
      if (nativeEvent.key) {
        var key = normalizeKey[nativeEvent.key] || nativeEvent.key;
        if ("Unidentified" !== key) return key;
      }
      return "keypress" === nativeEvent.type ? (nativeEvent = getEventCharCode(nativeEvent), 13 === nativeEvent ? "Enter" : String.fromCharCode(nativeEvent)) : "keydown" === nativeEvent.type || "keyup" === nativeEvent.type ? translateToKey[nativeEvent.keyCode] || "Unidentified" : "";
    },
    code: 0,
    location: 0,
    ctrlKey: 0,
    shiftKey: 0,
    altKey: 0,
    metaKey: 0,
    repeat: 0,
    locale: 0,
    getModifierState: getEventModifierState,
    charCode: function(event) {
      return "keypress" === event.type ? getEventCharCode(event) : 0;
    },
    keyCode: function(event) {
      return "keydown" === event.type || "keyup" === event.type ? event.keyCode : 0;
    },
    which: function(event) {
      return "keypress" === event.type ? getEventCharCode(event) : "keydown" === event.type || "keyup" === event.type ? event.keyCode : 0;
    }
  }), SyntheticKeyboardEvent = createSyntheticEvent(KeyboardEventInterface), PointerEventInterface = assign2({}, MouseEventInterface, {
    pointerId: 0,
    width: 0,
    height: 0,
    pressure: 0,
    tangentialPressure: 0,
    tiltX: 0,
    tiltY: 0,
    twist: 0,
    pointerType: 0,
    isPrimary: 0
  }), SyntheticPointerEvent = createSyntheticEvent(PointerEventInterface), TouchEventInterface = assign2({}, UIEventInterface, {
    touches: 0,
    targetTouches: 0,
    changedTouches: 0,
    altKey: 0,
    metaKey: 0,
    ctrlKey: 0,
    shiftKey: 0,
    getModifierState: getEventModifierState
  }), SyntheticTouchEvent = createSyntheticEvent(TouchEventInterface), TransitionEventInterface = assign2({}, EventInterface, {
    propertyName: 0,
    elapsedTime: 0,
    pseudoElement: 0
  }), SyntheticTransitionEvent = createSyntheticEvent(TransitionEventInterface), WheelEventInterface = assign2({}, MouseEventInterface, {
    deltaX: function(event) {
      return "deltaX" in event ? event.deltaX : "wheelDeltaX" in event ? -event.wheelDeltaX : 0;
    },
    deltaY: function(event) {
      return "deltaY" in event ? event.deltaY : "wheelDeltaY" in event ? -event.wheelDeltaY : "wheelDelta" in event ? -event.wheelDelta : 0;
    },
    deltaZ: 0,
    deltaMode: 0
  }), SyntheticWheelEvent = createSyntheticEvent(WheelEventInterface), ToggleEventInterface = assign2({}, EventInterface, {
    newState: 0,
    oldState: 0
  }), SyntheticToggleEvent = createSyntheticEvent(ToggleEventInterface), END_KEYCODES = [9, 13, 27, 32], canUseCompositionEvent = canUseDOM && "CompositionEvent" in window, documentMode = null;
  canUseDOM && "documentMode" in document && (documentMode = document.documentMode);
  var canUseTextInputEvent = canUseDOM && "TextEvent" in window && !documentMode, useFallbackCompositionData = canUseDOM && (!canUseCompositionEvent || documentMode && 8 < documentMode && 11 >= documentMode), SPACEBAR_CHAR = String.fromCharCode(32), hasSpaceKeypress = false;
  function isFallbackCompositionEnd(domEventName, nativeEvent) {
    switch (domEventName) {
      case "keyup":
        return -1 !== END_KEYCODES.indexOf(nativeEvent.keyCode);
      case "keydown":
        return 229 !== nativeEvent.keyCode;
      case "keypress":
      case "mousedown":
      case "focusout":
        return true;
      default:
        return false;
    }
  }
  function getDataFromCustomEvent(nativeEvent) {
    nativeEvent = nativeEvent.detail;
    return "object" === typeof nativeEvent && "data" in nativeEvent ? nativeEvent.data : null;
  }
  var isComposing = false;
  function getNativeBeforeInputChars(domEventName, nativeEvent) {
    switch (domEventName) {
      case "compositionend":
        return getDataFromCustomEvent(nativeEvent);
      case "keypress":
        if (32 !== nativeEvent.which) return null;
        hasSpaceKeypress = true;
        return SPACEBAR_CHAR;
      case "textInput":
        return domEventName = nativeEvent.data, domEventName === SPACEBAR_CHAR && hasSpaceKeypress ? null : domEventName;
      default:
        return null;
    }
  }
  function getFallbackBeforeInputChars(domEventName, nativeEvent) {
    if (isComposing)
      return "compositionend" === domEventName || !canUseCompositionEvent && isFallbackCompositionEnd(domEventName, nativeEvent) ? (domEventName = getData(), fallbackText = startText = root = null, isComposing = false, domEventName) : null;
    switch (domEventName) {
      case "paste":
        return null;
      case "keypress":
        if (!(nativeEvent.ctrlKey || nativeEvent.altKey || nativeEvent.metaKey) || nativeEvent.ctrlKey && nativeEvent.altKey) {
          if (nativeEvent.char && 1 < nativeEvent.char.length)
            return nativeEvent.char;
          if (nativeEvent.which) return String.fromCharCode(nativeEvent.which);
        }
        return null;
      case "compositionend":
        return useFallbackCompositionData && "ko" !== nativeEvent.locale ? null : nativeEvent.data;
      default:
        return null;
    }
  }
  var supportedInputTypes = {
    color: true,
    date: true,
    datetime: true,
    "datetime-local": true,
    email: true,
    month: true,
    number: true,
    password: true,
    range: true,
    search: true,
    tel: true,
    text: true,
    time: true,
    url: true,
    week: true
  };
  function isTextInputElement(elem) {
    var nodeName = elem && elem.nodeName && elem.nodeName.toLowerCase();
    return "input" === nodeName ? !!supportedInputTypes[elem.type] : "textarea" === nodeName ? true : false;
  }
  function createAndAccumulateChangeEvent(dispatchQueue, inst, nativeEvent, target) {
    restoreTarget ? restoreQueue ? restoreQueue.push(target) : restoreQueue = [target] : restoreTarget = target;
    inst = accumulateTwoPhaseListeners(inst, "onChange");
    0 < inst.length && (nativeEvent = new SyntheticEvent(
      "onChange",
      "change",
      null,
      nativeEvent,
      target
    ), dispatchQueue.push({ event: nativeEvent, listeners: inst }));
  }
  var activeElement$1 = null, activeElementInst$1 = null;
  function runEventInBatch(dispatchQueue) {
    processDispatchQueue(dispatchQueue, 0);
  }
  function getInstIfValueChanged(targetInst) {
    var targetNode = getNodeFromInstance(targetInst);
    if (updateValueIfChanged(targetNode)) return targetInst;
  }
  function getTargetInstForChangeEvent(domEventName, targetInst) {
    if ("change" === domEventName) return targetInst;
  }
  var isInputEventSupported = false;
  if (canUseDOM) {
    var JSCompiler_inline_result$jscomp$286;
    if (canUseDOM) {
      var isSupported$jscomp$inline_427 = "oninput" in document;
      if (!isSupported$jscomp$inline_427) {
        var element$jscomp$inline_428 = document.createElement("div");
        element$jscomp$inline_428.setAttribute("oninput", "return;");
        isSupported$jscomp$inline_427 = "function" === typeof element$jscomp$inline_428.oninput;
      }
      JSCompiler_inline_result$jscomp$286 = isSupported$jscomp$inline_427;
    } else JSCompiler_inline_result$jscomp$286 = false;
    isInputEventSupported = JSCompiler_inline_result$jscomp$286 && (!document.documentMode || 9 < document.documentMode);
  }
  function stopWatchingForValueChange() {
    activeElement$1 && (activeElement$1.detachEvent("onpropertychange", handlePropertyChange), activeElementInst$1 = activeElement$1 = null);
  }
  function handlePropertyChange(nativeEvent) {
    if ("value" === nativeEvent.propertyName && getInstIfValueChanged(activeElementInst$1)) {
      var dispatchQueue = [];
      createAndAccumulateChangeEvent(
        dispatchQueue,
        activeElementInst$1,
        nativeEvent,
        getEventTarget(nativeEvent)
      );
      batchedUpdates$1(runEventInBatch, dispatchQueue);
    }
  }
  function handleEventsForInputEventPolyfill(domEventName, target, targetInst) {
    "focusin" === domEventName ? (stopWatchingForValueChange(), activeElement$1 = target, activeElementInst$1 = targetInst, activeElement$1.attachEvent("onpropertychange", handlePropertyChange)) : "focusout" === domEventName && stopWatchingForValueChange();
  }
  function getTargetInstForInputEventPolyfill(domEventName) {
    if ("selectionchange" === domEventName || "keyup" === domEventName || "keydown" === domEventName)
      return getInstIfValueChanged(activeElementInst$1);
  }
  function getTargetInstForClickEvent(domEventName, targetInst) {
    if ("click" === domEventName) return getInstIfValueChanged(targetInst);
  }
  function getTargetInstForInputOrChangeEvent(domEventName, targetInst) {
    if ("input" === domEventName || "change" === domEventName)
      return getInstIfValueChanged(targetInst);
  }
  function is2(x3, y3) {
    return x3 === y3 && (0 !== x3 || 1 / x3 === 1 / y3) || x3 !== x3 && y3 !== y3;
  }
  var objectIs = "function" === typeof Object.is ? Object.is : is2;
  function shallowEqual(objA, objB) {
    if (objectIs(objA, objB)) return true;
    if ("object" !== typeof objA || null === objA || "object" !== typeof objB || null === objB)
      return false;
    var keysA = Object.keys(objA), keysB = Object.keys(objB);
    if (keysA.length !== keysB.length) return false;
    for (keysB = 0; keysB < keysA.length; keysB++) {
      var currentKey = keysA[keysB];
      if (!hasOwnProperty.call(objB, currentKey) || !objectIs(objA[currentKey], objB[currentKey]))
        return false;
    }
    return true;
  }
  function getLeafNode(node) {
    for (; node && node.firstChild; ) node = node.firstChild;
    return node;
  }
  function getNodeForCharacterOffset(root2, offset2) {
    var node = getLeafNode(root2);
    root2 = 0;
    for (var nodeEnd; node; ) {
      if (3 === node.nodeType) {
        nodeEnd = root2 + node.textContent.length;
        if (root2 <= offset2 && nodeEnd >= offset2)
          return { node, offset: offset2 - root2 };
        root2 = nodeEnd;
      }
      a: {
        for (; node; ) {
          if (node.nextSibling) {
            node = node.nextSibling;
            break a;
          }
          node = node.parentNode;
        }
        node = void 0;
      }
      node = getLeafNode(node);
    }
  }
  function containsNode(outerNode, innerNode) {
    return outerNode && innerNode ? outerNode === innerNode ? true : outerNode && 3 === outerNode.nodeType ? false : innerNode && 3 === innerNode.nodeType ? containsNode(outerNode, innerNode.parentNode) : "contains" in outerNode ? outerNode.contains(innerNode) : outerNode.compareDocumentPosition ? !!(outerNode.compareDocumentPosition(innerNode) & 16) : false : false;
  }
  function getActiveElementDeep(containerInfo) {
    containerInfo = null != containerInfo && null != containerInfo.ownerDocument && null != containerInfo.ownerDocument.defaultView ? containerInfo.ownerDocument.defaultView : window;
    for (var element = getActiveElement(containerInfo.document); element instanceof containerInfo.HTMLIFrameElement; ) {
      try {
        var JSCompiler_inline_result = "string" === typeof element.contentWindow.location.href;
      } catch (err2) {
        JSCompiler_inline_result = false;
      }
      if (JSCompiler_inline_result) containerInfo = element.contentWindow;
      else break;
      element = getActiveElement(containerInfo.document);
    }
    return element;
  }
  function hasSelectionCapabilities(elem) {
    var nodeName = elem && elem.nodeName && elem.nodeName.toLowerCase();
    return nodeName && ("input" === nodeName && ("text" === elem.type || "search" === elem.type || "tel" === elem.type || "url" === elem.type || "password" === elem.type) || "textarea" === nodeName || "true" === elem.contentEditable);
  }
  var skipSelectionChangeEvent = canUseDOM && "documentMode" in document && 11 >= document.documentMode, activeElement = null, activeElementInst = null, lastSelection = null, mouseDown = false;
  function constructSelectEvent(dispatchQueue, nativeEvent, nativeEventTarget) {
    var doc = nativeEventTarget.window === nativeEventTarget ? nativeEventTarget.document : 9 === nativeEventTarget.nodeType ? nativeEventTarget : nativeEventTarget.ownerDocument;
    mouseDown || null == activeElement || activeElement !== getActiveElement(doc) || (doc = activeElement, "selectionStart" in doc && hasSelectionCapabilities(doc) ? doc = { start: doc.selectionStart, end: doc.selectionEnd } : (doc = (doc.ownerDocument && doc.ownerDocument.defaultView || window).getSelection(), doc = {
      anchorNode: doc.anchorNode,
      anchorOffset: doc.anchorOffset,
      focusNode: doc.focusNode,
      focusOffset: doc.focusOffset
    }), lastSelection && shallowEqual(lastSelection, doc) || (lastSelection = doc, doc = accumulateTwoPhaseListeners(activeElementInst, "onSelect"), 0 < doc.length && (nativeEvent = new SyntheticEvent(
      "onSelect",
      "select",
      null,
      nativeEvent,
      nativeEventTarget
    ), dispatchQueue.push({ event: nativeEvent, listeners: doc }), nativeEvent.target = activeElement)));
  }
  function makePrefixMap(styleProp, eventName) {
    var prefixes = {};
    prefixes[styleProp.toLowerCase()] = eventName.toLowerCase();
    prefixes["Webkit" + styleProp] = "webkit" + eventName;
    prefixes["Moz" + styleProp] = "moz" + eventName;
    return prefixes;
  }
  var vendorPrefixes = {
    animationend: makePrefixMap("Animation", "AnimationEnd"),
    animationiteration: makePrefixMap("Animation", "AnimationIteration"),
    animationstart: makePrefixMap("Animation", "AnimationStart"),
    transitionrun: makePrefixMap("Transition", "TransitionRun"),
    transitionstart: makePrefixMap("Transition", "TransitionStart"),
    transitioncancel: makePrefixMap("Transition", "TransitionCancel"),
    transitionend: makePrefixMap("Transition", "TransitionEnd")
  }, prefixedEventNames = {}, style = {};
  canUseDOM && (style = document.createElement("div").style, "AnimationEvent" in window || (delete vendorPrefixes.animationend.animation, delete vendorPrefixes.animationiteration.animation, delete vendorPrefixes.animationstart.animation), "TransitionEvent" in window || delete vendorPrefixes.transitionend.transition);
  function getVendorPrefixedEventName(eventName) {
    if (prefixedEventNames[eventName]) return prefixedEventNames[eventName];
    if (!vendorPrefixes[eventName]) return eventName;
    var prefixMap = vendorPrefixes[eventName], styleProp;
    for (styleProp in prefixMap)
      if (prefixMap.hasOwnProperty(styleProp) && styleProp in style)
        return prefixedEventNames[eventName] = prefixMap[styleProp];
    return eventName;
  }
  var ANIMATION_END = getVendorPrefixedEventName("animationend"), ANIMATION_ITERATION = getVendorPrefixedEventName("animationiteration"), ANIMATION_START = getVendorPrefixedEventName("animationstart"), TRANSITION_RUN = getVendorPrefixedEventName("transitionrun"), TRANSITION_START = getVendorPrefixedEventName("transitionstart"), TRANSITION_CANCEL = getVendorPrefixedEventName("transitioncancel"), TRANSITION_END = getVendorPrefixedEventName("transitionend"), topLevelEventsToReactNames = /* @__PURE__ */ new Map(), simpleEventPluginEvents = "abort auxClick beforeToggle cancel canPlay canPlayThrough click close contextMenu copy cut drag dragEnd dragEnter dragExit dragLeave dragOver dragStart drop durationChange emptied encrypted ended error gotPointerCapture input invalid keyDown keyPress keyUp load loadedData loadedMetadata loadStart lostPointerCapture mouseDown mouseMove mouseOut mouseOver mouseUp paste pause play playing pointerCancel pointerDown pointerMove pointerOut pointerOver pointerUp progress rateChange reset resize seeked seeking stalled submit suspend timeUpdate touchCancel touchEnd touchStart volumeChange scroll toggle touchMove waiting wheel".split(
    " "
  );
  simpleEventPluginEvents.push("scrollEnd");
  function registerSimpleEvent(domEventName, reactName) {
    topLevelEventsToReactNames.set(domEventName, reactName);
    registerTwoPhaseEvent(reactName, [domEventName]);
  }
  var reportGlobalError = "function" === typeof reportError ? reportError : function(error) {
    if ("object" === typeof window && "function" === typeof window.ErrorEvent) {
      var event = new window.ErrorEvent("error", {
        bubbles: true,
        cancelable: true,
        message: "object" === typeof error && null !== error && "string" === typeof error.message ? String(error.message) : String(error),
        error
      });
      if (!window.dispatchEvent(event)) return;
    } else if ("object" === typeof process && "function" === typeof process.emit) {
      process.emit("uncaughtException", error);
      return;
    }
    console.error(error);
  }, concurrentQueues = [], concurrentQueuesIndex = 0, concurrentlyUpdatedLanes = 0;
  function finishQueueingConcurrentUpdates() {
    for (var endIndex = concurrentQueuesIndex, i3 = concurrentlyUpdatedLanes = concurrentQueuesIndex = 0; i3 < endIndex; ) {
      var fiber = concurrentQueues[i3];
      concurrentQueues[i3++] = null;
      var queue = concurrentQueues[i3];
      concurrentQueues[i3++] = null;
      var update = concurrentQueues[i3];
      concurrentQueues[i3++] = null;
      var lane = concurrentQueues[i3];
      concurrentQueues[i3++] = null;
      if (null !== queue && null !== update) {
        var pending = queue.pending;
        null === pending ? update.next = update : (update.next = pending.next, pending.next = update);
        queue.pending = update;
      }
      0 !== lane && markUpdateLaneFromFiberToRoot(fiber, update, lane);
    }
  }
  function enqueueUpdate$1(fiber, queue, update, lane) {
    concurrentQueues[concurrentQueuesIndex++] = fiber;
    concurrentQueues[concurrentQueuesIndex++] = queue;
    concurrentQueues[concurrentQueuesIndex++] = update;
    concurrentQueues[concurrentQueuesIndex++] = lane;
    concurrentlyUpdatedLanes |= lane;
    fiber.lanes |= lane;
    fiber = fiber.alternate;
    null !== fiber && (fiber.lanes |= lane);
  }
  function enqueueConcurrentHookUpdate(fiber, queue, update, lane) {
    enqueueUpdate$1(fiber, queue, update, lane);
    return getRootForUpdatedFiber(fiber);
  }
  function enqueueConcurrentRenderForLane(fiber, lane) {
    enqueueUpdate$1(fiber, null, null, lane);
    return getRootForUpdatedFiber(fiber);
  }
  function markUpdateLaneFromFiberToRoot(sourceFiber, update, lane) {
    sourceFiber.lanes |= lane;
    var alternate = sourceFiber.alternate;
    null !== alternate && (alternate.lanes |= lane);
    for (var isHidden2 = false, parent = sourceFiber.return; null !== parent; )
      parent.childLanes |= lane, alternate = parent.alternate, null !== alternate && (alternate.childLanes |= lane), 22 === parent.tag && (sourceFiber = parent.stateNode, null === sourceFiber || sourceFiber._visibility & 1 || (isHidden2 = true)), sourceFiber = parent, parent = parent.return;
    return 3 === sourceFiber.tag ? (parent = sourceFiber.stateNode, isHidden2 && null !== update && (isHidden2 = 31 - clz32(lane), sourceFiber = parent.hiddenUpdates, alternate = sourceFiber[isHidden2], null === alternate ? sourceFiber[isHidden2] = [update] : alternate.push(update), update.lane = lane | 536870912), parent) : null;
  }
  function getRootForUpdatedFiber(sourceFiber) {
    if (50 < nestedUpdateCount)
      throw nestedUpdateCount = 0, rootWithNestedUpdates = null, Error(formatProdErrorMessage(185));
    for (var parent = sourceFiber.return; null !== parent; )
      sourceFiber = parent, parent = sourceFiber.return;
    return 3 === sourceFiber.tag ? sourceFiber.stateNode : null;
  }
  var emptyContextObject = {};
  function FiberNode(tag, pendingProps, key, mode) {
    this.tag = tag;
    this.key = key;
    this.sibling = this.child = this.return = this.stateNode = this.type = this.elementType = null;
    this.index = 0;
    this.refCleanup = this.ref = null;
    this.pendingProps = pendingProps;
    this.dependencies = this.memoizedState = this.updateQueue = this.memoizedProps = null;
    this.mode = mode;
    this.subtreeFlags = this.flags = 0;
    this.deletions = null;
    this.childLanes = this.lanes = 0;
    this.alternate = null;
  }
  function createFiberImplClass(tag, pendingProps, key, mode) {
    return new FiberNode(tag, pendingProps, key, mode);
  }
  function shouldConstruct(Component) {
    Component = Component.prototype;
    return !(!Component || !Component.isReactComponent);
  }
  function createWorkInProgress(current, pendingProps) {
    var workInProgress2 = current.alternate;
    null === workInProgress2 ? (workInProgress2 = createFiberImplClass(
      current.tag,
      pendingProps,
      current.key,
      current.mode
    ), workInProgress2.elementType = current.elementType, workInProgress2.type = current.type, workInProgress2.stateNode = current.stateNode, workInProgress2.alternate = current, current.alternate = workInProgress2) : (workInProgress2.pendingProps = pendingProps, workInProgress2.type = current.type, workInProgress2.flags = 0, workInProgress2.subtreeFlags = 0, workInProgress2.deletions = null);
    workInProgress2.flags = current.flags & 65011712;
    workInProgress2.childLanes = current.childLanes;
    workInProgress2.lanes = current.lanes;
    workInProgress2.child = current.child;
    workInProgress2.memoizedProps = current.memoizedProps;
    workInProgress2.memoizedState = current.memoizedState;
    workInProgress2.updateQueue = current.updateQueue;
    pendingProps = current.dependencies;
    workInProgress2.dependencies = null === pendingProps ? null : { lanes: pendingProps.lanes, firstContext: pendingProps.firstContext };
    workInProgress2.sibling = current.sibling;
    workInProgress2.index = current.index;
    workInProgress2.ref = current.ref;
    workInProgress2.refCleanup = current.refCleanup;
    return workInProgress2;
  }
  function resetWorkInProgress(workInProgress2, renderLanes2) {
    workInProgress2.flags &= 65011714;
    var current = workInProgress2.alternate;
    null === current ? (workInProgress2.childLanes = 0, workInProgress2.lanes = renderLanes2, workInProgress2.child = null, workInProgress2.subtreeFlags = 0, workInProgress2.memoizedProps = null, workInProgress2.memoizedState = null, workInProgress2.updateQueue = null, workInProgress2.dependencies = null, workInProgress2.stateNode = null) : (workInProgress2.childLanes = current.childLanes, workInProgress2.lanes = current.lanes, workInProgress2.child = current.child, workInProgress2.subtreeFlags = 0, workInProgress2.deletions = null, workInProgress2.memoizedProps = current.memoizedProps, workInProgress2.memoizedState = current.memoizedState, workInProgress2.updateQueue = current.updateQueue, workInProgress2.type = current.type, renderLanes2 = current.dependencies, workInProgress2.dependencies = null === renderLanes2 ? null : {
      lanes: renderLanes2.lanes,
      firstContext: renderLanes2.firstContext
    });
    return workInProgress2;
  }
  function createFiberFromTypeAndProps(type, key, pendingProps, owner, mode, lanes) {
    var fiberTag = 0;
    owner = type;
    if ("function" === typeof type) shouldConstruct(type) && (fiberTag = 1);
    else if ("string" === typeof type)
      fiberTag = isHostHoistableType(
        type,
        pendingProps,
        contextStackCursor.current
      ) ? 26 : "html" === type || "head" === type || "body" === type ? 27 : 5;
    else
      a: switch (type) {
        case REACT_ACTIVITY_TYPE:
          return type = createFiberImplClass(31, pendingProps, key, mode), type.elementType = REACT_ACTIVITY_TYPE, type.lanes = lanes, type;
        case REACT_FRAGMENT_TYPE:
          return createFiberFromFragment(pendingProps.children, mode, lanes, key);
        case REACT_STRICT_MODE_TYPE:
          fiberTag = 8;
          mode |= 24;
          break;
        case REACT_PROFILER_TYPE:
          return type = createFiberImplClass(12, pendingProps, key, mode | 2), type.elementType = REACT_PROFILER_TYPE, type.lanes = lanes, type;
        case REACT_SUSPENSE_TYPE:
          return type = createFiberImplClass(13, pendingProps, key, mode), type.elementType = REACT_SUSPENSE_TYPE, type.lanes = lanes, type;
        case REACT_SUSPENSE_LIST_TYPE:
          return type = createFiberImplClass(19, pendingProps, key, mode), type.elementType = REACT_SUSPENSE_LIST_TYPE, type.lanes = lanes, type;
        default:
          if ("object" === typeof type && null !== type)
            switch (type.$$typeof) {
              case REACT_CONTEXT_TYPE:
                fiberTag = 10;
                break a;
              case REACT_CONSUMER_TYPE:
                fiberTag = 9;
                break a;
              case REACT_FORWARD_REF_TYPE:
                fiberTag = 11;
                break a;
              case REACT_MEMO_TYPE:
                fiberTag = 14;
                break a;
              case REACT_LAZY_TYPE:
                fiberTag = 16;
                owner = null;
                break a;
            }
          fiberTag = 29;
          pendingProps = Error(
            formatProdErrorMessage(130, null === type ? "null" : typeof type, "")
          );
          owner = null;
      }
    key = createFiberImplClass(fiberTag, pendingProps, key, mode);
    key.elementType = type;
    key.type = owner;
    key.lanes = lanes;
    return key;
  }
  function createFiberFromFragment(elements, mode, lanes, key) {
    elements = createFiberImplClass(7, elements, key, mode);
    elements.lanes = lanes;
    return elements;
  }
  function createFiberFromText(content, mode, lanes) {
    content = createFiberImplClass(6, content, null, mode);
    content.lanes = lanes;
    return content;
  }
  function createFiberFromDehydratedFragment(dehydratedNode) {
    var fiber = createFiberImplClass(18, null, null, 0);
    fiber.stateNode = dehydratedNode;
    return fiber;
  }
  function createFiberFromPortal(portal, mode, lanes) {
    mode = createFiberImplClass(
      4,
      null !== portal.children ? portal.children : [],
      portal.key,
      mode
    );
    mode.lanes = lanes;
    mode.stateNode = {
      containerInfo: portal.containerInfo,
      pendingChildren: null,
      implementation: portal.implementation
    };
    return mode;
  }
  var CapturedStacks = /* @__PURE__ */ new WeakMap();
  function createCapturedValueAtFiber(value, source) {
    if ("object" === typeof value && null !== value) {
      var existing = CapturedStacks.get(value);
      if (void 0 !== existing) return existing;
      source = {
        value,
        source,
        stack: getStackByFiberInDevAndProd(source)
      };
      CapturedStacks.set(value, source);
      return source;
    }
    return {
      value,
      source,
      stack: getStackByFiberInDevAndProd(source)
    };
  }
  var forkStack = [], forkStackIndex = 0, treeForkProvider = null, treeForkCount = 0, idStack = [], idStackIndex = 0, treeContextProvider = null, treeContextId = 1, treeContextOverflow = "";
  function pushTreeFork(workInProgress2, totalChildren) {
    forkStack[forkStackIndex++] = treeForkCount;
    forkStack[forkStackIndex++] = treeForkProvider;
    treeForkProvider = workInProgress2;
    treeForkCount = totalChildren;
  }
  function pushTreeId(workInProgress2, totalChildren, index3) {
    idStack[idStackIndex++] = treeContextId;
    idStack[idStackIndex++] = treeContextOverflow;
    idStack[idStackIndex++] = treeContextProvider;
    treeContextProvider = workInProgress2;
    var baseIdWithLeadingBit = treeContextId;
    workInProgress2 = treeContextOverflow;
    var baseLength = 32 - clz32(baseIdWithLeadingBit) - 1;
    baseIdWithLeadingBit &= ~(1 << baseLength);
    index3 += 1;
    var length = 32 - clz32(totalChildren) + baseLength;
    if (30 < length) {
      var numberOfOverflowBits = baseLength - baseLength % 5;
      length = (baseIdWithLeadingBit & (1 << numberOfOverflowBits) - 1).toString(32);
      baseIdWithLeadingBit >>= numberOfOverflowBits;
      baseLength -= numberOfOverflowBits;
      treeContextId = 1 << 32 - clz32(totalChildren) + baseLength | index3 << baseLength | baseIdWithLeadingBit;
      treeContextOverflow = length + workInProgress2;
    } else
      treeContextId = 1 << length | index3 << baseLength | baseIdWithLeadingBit, treeContextOverflow = workInProgress2;
  }
  function pushMaterializedTreeId(workInProgress2) {
    null !== workInProgress2.return && (pushTreeFork(workInProgress2, 1), pushTreeId(workInProgress2, 1, 0));
  }
  function popTreeContext(workInProgress2) {
    for (; workInProgress2 === treeForkProvider; )
      treeForkProvider = forkStack[--forkStackIndex], forkStack[forkStackIndex] = null, treeForkCount = forkStack[--forkStackIndex], forkStack[forkStackIndex] = null;
    for (; workInProgress2 === treeContextProvider; )
      treeContextProvider = idStack[--idStackIndex], idStack[idStackIndex] = null, treeContextOverflow = idStack[--idStackIndex], idStack[idStackIndex] = null, treeContextId = idStack[--idStackIndex], idStack[idStackIndex] = null;
  }
  function restoreSuspendedTreeContext(workInProgress2, suspendedContext) {
    idStack[idStackIndex++] = treeContextId;
    idStack[idStackIndex++] = treeContextOverflow;
    idStack[idStackIndex++] = treeContextProvider;
    treeContextId = suspendedContext.id;
    treeContextOverflow = suspendedContext.overflow;
    treeContextProvider = workInProgress2;
  }
  var hydrationParentFiber = null, nextHydratableInstance = null, isHydrating = false, hydrationErrors = null, rootOrSingletonContext = false, HydrationMismatchException = Error(formatProdErrorMessage(519));
  function throwOnHydrationMismatch(fiber) {
    var error = Error(
      formatProdErrorMessage(
        418,
        1 < arguments.length && void 0 !== arguments[1] && arguments[1] ? "text" : "HTML",
        ""
      )
    );
    queueHydrationError(createCapturedValueAtFiber(error, fiber));
    throw HydrationMismatchException;
  }
  function prepareToHydrateHostInstance(fiber) {
    var instance = fiber.stateNode, type = fiber.type, props = fiber.memoizedProps;
    instance[internalInstanceKey] = fiber;
    instance[internalPropsKey] = props;
    switch (type) {
      case "dialog":
        listenToNonDelegatedEvent("cancel", instance);
        listenToNonDelegatedEvent("close", instance);
        break;
      case "iframe":
      case "object":
      case "embed":
        listenToNonDelegatedEvent("load", instance);
        break;
      case "video":
      case "audio":
        for (type = 0; type < mediaEventTypes.length; type++)
          listenToNonDelegatedEvent(mediaEventTypes[type], instance);
        break;
      case "source":
        listenToNonDelegatedEvent("error", instance);
        break;
      case "img":
      case "image":
      case "link":
        listenToNonDelegatedEvent("error", instance);
        listenToNonDelegatedEvent("load", instance);
        break;
      case "details":
        listenToNonDelegatedEvent("toggle", instance);
        break;
      case "input":
        listenToNonDelegatedEvent("invalid", instance);
        initInput(
          instance,
          props.value,
          props.defaultValue,
          props.checked,
          props.defaultChecked,
          props.type,
          props.name,
          true
        );
        break;
      case "select":
        listenToNonDelegatedEvent("invalid", instance);
        break;
      case "textarea":
        listenToNonDelegatedEvent("invalid", instance), initTextarea(instance, props.value, props.defaultValue, props.children);
    }
    type = props.children;
    "string" !== typeof type && "number" !== typeof type && "bigint" !== typeof type || instance.textContent === "" + type || true === props.suppressHydrationWarning || checkForUnmatchedText(instance.textContent, type) ? (null != props.popover && (listenToNonDelegatedEvent("beforetoggle", instance), listenToNonDelegatedEvent("toggle", instance)), null != props.onScroll && listenToNonDelegatedEvent("scroll", instance), null != props.onScrollEnd && listenToNonDelegatedEvent("scrollend", instance), null != props.onClick && (instance.onclick = noop$12), instance = true) : instance = false;
    instance || throwOnHydrationMismatch(fiber, true);
  }
  function popToNextHostParent(fiber) {
    for (hydrationParentFiber = fiber.return; hydrationParentFiber; )
      switch (hydrationParentFiber.tag) {
        case 5:
        case 31:
        case 13:
          rootOrSingletonContext = false;
          return;
        case 27:
        case 3:
          rootOrSingletonContext = true;
          return;
        default:
          hydrationParentFiber = hydrationParentFiber.return;
      }
  }
  function popHydrationState(fiber) {
    if (fiber !== hydrationParentFiber) return false;
    if (!isHydrating) return popToNextHostParent(fiber), isHydrating = true, false;
    var tag = fiber.tag, JSCompiler_temp;
    if (JSCompiler_temp = 3 !== tag && 27 !== tag) {
      if (JSCompiler_temp = 5 === tag)
        JSCompiler_temp = fiber.type, JSCompiler_temp = !("form" !== JSCompiler_temp && "button" !== JSCompiler_temp) || shouldSetTextContent(fiber.type, fiber.memoizedProps);
      JSCompiler_temp = !JSCompiler_temp;
    }
    JSCompiler_temp && nextHydratableInstance && throwOnHydrationMismatch(fiber);
    popToNextHostParent(fiber);
    if (13 === tag) {
      fiber = fiber.memoizedState;
      fiber = null !== fiber ? fiber.dehydrated : null;
      if (!fiber) throw Error(formatProdErrorMessage(317));
      nextHydratableInstance = getNextHydratableInstanceAfterHydrationBoundary(fiber);
    } else if (31 === tag) {
      fiber = fiber.memoizedState;
      fiber = null !== fiber ? fiber.dehydrated : null;
      if (!fiber) throw Error(formatProdErrorMessage(317));
      nextHydratableInstance = getNextHydratableInstanceAfterHydrationBoundary(fiber);
    } else
      27 === tag ? (tag = nextHydratableInstance, isSingletonScope(fiber.type) ? (fiber = previousHydratableOnEnteringScopedSingleton, previousHydratableOnEnteringScopedSingleton = null, nextHydratableInstance = fiber) : nextHydratableInstance = tag) : nextHydratableInstance = hydrationParentFiber ? getNextHydratable(fiber.stateNode.nextSibling) : null;
    return true;
  }
  function resetHydrationState() {
    nextHydratableInstance = hydrationParentFiber = null;
    isHydrating = false;
  }
  function upgradeHydrationErrorsToRecoverable() {
    var queuedErrors = hydrationErrors;
    null !== queuedErrors && (null === workInProgressRootRecoverableErrors ? workInProgressRootRecoverableErrors = queuedErrors : workInProgressRootRecoverableErrors.push.apply(
      workInProgressRootRecoverableErrors,
      queuedErrors
    ), hydrationErrors = null);
    return queuedErrors;
  }
  function queueHydrationError(error) {
    null === hydrationErrors ? hydrationErrors = [error] : hydrationErrors.push(error);
  }
  var valueCursor = createCursor(null), currentlyRenderingFiber$1 = null, lastContextDependency = null;
  function pushProvider(providerFiber, context, nextValue) {
    push(valueCursor, context._currentValue);
    context._currentValue = nextValue;
  }
  function popProvider(context) {
    context._currentValue = valueCursor.current;
    pop(valueCursor);
  }
  function scheduleContextWorkOnParentPath(parent, renderLanes2, propagationRoot) {
    for (; null !== parent; ) {
      var alternate = parent.alternate;
      (parent.childLanes & renderLanes2) !== renderLanes2 ? (parent.childLanes |= renderLanes2, null !== alternate && (alternate.childLanes |= renderLanes2)) : null !== alternate && (alternate.childLanes & renderLanes2) !== renderLanes2 && (alternate.childLanes |= renderLanes2);
      if (parent === propagationRoot) break;
      parent = parent.return;
    }
  }
  function propagateContextChanges(workInProgress2, contexts, renderLanes2, forcePropagateEntireTree) {
    var fiber = workInProgress2.child;
    null !== fiber && (fiber.return = workInProgress2);
    for (; null !== fiber; ) {
      var list = fiber.dependencies;
      if (null !== list) {
        var nextFiber = fiber.child;
        list = list.firstContext;
        a: for (; null !== list; ) {
          var dependency = list;
          list = fiber;
          for (var i3 = 0; i3 < contexts.length; i3++)
            if (dependency.context === contexts[i3]) {
              list.lanes |= renderLanes2;
              dependency = list.alternate;
              null !== dependency && (dependency.lanes |= renderLanes2);
              scheduleContextWorkOnParentPath(
                list.return,
                renderLanes2,
                workInProgress2
              );
              forcePropagateEntireTree || (nextFiber = null);
              break a;
            }
          list = dependency.next;
        }
      } else if (18 === fiber.tag) {
        nextFiber = fiber.return;
        if (null === nextFiber) throw Error(formatProdErrorMessage(341));
        nextFiber.lanes |= renderLanes2;
        list = nextFiber.alternate;
        null !== list && (list.lanes |= renderLanes2);
        scheduleContextWorkOnParentPath(nextFiber, renderLanes2, workInProgress2);
        nextFiber = null;
      } else nextFiber = fiber.child;
      if (null !== nextFiber) nextFiber.return = fiber;
      else
        for (nextFiber = fiber; null !== nextFiber; ) {
          if (nextFiber === workInProgress2) {
            nextFiber = null;
            break;
          }
          fiber = nextFiber.sibling;
          if (null !== fiber) {
            fiber.return = nextFiber.return;
            nextFiber = fiber;
            break;
          }
          nextFiber = nextFiber.return;
        }
      fiber = nextFiber;
    }
  }
  function propagateParentContextChanges(current, workInProgress2, renderLanes2, forcePropagateEntireTree) {
    current = null;
    for (var parent = workInProgress2, isInsidePropagationBailout = false; null !== parent; ) {
      if (!isInsidePropagationBailout) {
        if (0 !== (parent.flags & 524288)) isInsidePropagationBailout = true;
        else if (0 !== (parent.flags & 262144)) break;
      }
      if (10 === parent.tag) {
        var currentParent = parent.alternate;
        if (null === currentParent) throw Error(formatProdErrorMessage(387));
        currentParent = currentParent.memoizedProps;
        if (null !== currentParent) {
          var context = parent.type;
          objectIs(parent.pendingProps.value, currentParent.value) || (null !== current ? current.push(context) : current = [context]);
        }
      } else if (parent === hostTransitionProviderCursor.current) {
        currentParent = parent.alternate;
        if (null === currentParent) throw Error(formatProdErrorMessage(387));
        currentParent.memoizedState.memoizedState !== parent.memoizedState.memoizedState && (null !== current ? current.push(HostTransitionContext) : current = [HostTransitionContext]);
      }
      parent = parent.return;
    }
    null !== current && propagateContextChanges(
      workInProgress2,
      current,
      renderLanes2,
      forcePropagateEntireTree
    );
    workInProgress2.flags |= 262144;
  }
  function checkIfContextChanged(currentDependencies) {
    for (currentDependencies = currentDependencies.firstContext; null !== currentDependencies; ) {
      if (!objectIs(
        currentDependencies.context._currentValue,
        currentDependencies.memoizedValue
      ))
        return true;
      currentDependencies = currentDependencies.next;
    }
    return false;
  }
  function prepareToReadContext(workInProgress2) {
    currentlyRenderingFiber$1 = workInProgress2;
    lastContextDependency = null;
    workInProgress2 = workInProgress2.dependencies;
    null !== workInProgress2 && (workInProgress2.firstContext = null);
  }
  function readContext(context) {
    return readContextForConsumer(currentlyRenderingFiber$1, context);
  }
  function readContextDuringReconciliation(consumer, context) {
    null === currentlyRenderingFiber$1 && prepareToReadContext(consumer);
    return readContextForConsumer(consumer, context);
  }
  function readContextForConsumer(consumer, context) {
    var value = context._currentValue;
    context = { context, memoizedValue: value, next: null };
    if (null === lastContextDependency) {
      if (null === consumer) throw Error(formatProdErrorMessage(308));
      lastContextDependency = context;
      consumer.dependencies = { lanes: 0, firstContext: context };
      consumer.flags |= 524288;
    } else lastContextDependency = lastContextDependency.next = context;
    return value;
  }
  var AbortControllerLocal = "undefined" !== typeof AbortController ? AbortController : function() {
    var listeners = [], signal = this.signal = {
      aborted: false,
      addEventListener: function(type, listener) {
        listeners.push(listener);
      }
    };
    this.abort = function() {
      signal.aborted = true;
      listeners.forEach(function(listener) {
        return listener();
      });
    };
  }, scheduleCallback$2 = Scheduler.unstable_scheduleCallback, NormalPriority = Scheduler.unstable_NormalPriority, CacheContext = {
    $$typeof: REACT_CONTEXT_TYPE,
    Consumer: null,
    Provider: null,
    _currentValue: null,
    _currentValue2: null,
    _threadCount: 0
  };
  function createCache() {
    return {
      controller: new AbortControllerLocal(),
      data: /* @__PURE__ */ new Map(),
      refCount: 0
    };
  }
  function releaseCache(cache) {
    cache.refCount--;
    0 === cache.refCount && scheduleCallback$2(NormalPriority, function() {
      cache.controller.abort();
    });
  }
  var currentEntangledListeners = null, currentEntangledPendingCount = 0, currentEntangledLane = 0, currentEntangledActionThenable = null;
  function entangleAsyncAction(transition, thenable) {
    if (null === currentEntangledListeners) {
      var entangledListeners = currentEntangledListeners = [];
      currentEntangledPendingCount = 0;
      currentEntangledLane = requestTransitionLane();
      currentEntangledActionThenable = {
        status: "pending",
        value: void 0,
        then: function(resolve) {
          entangledListeners.push(resolve);
        }
      };
    }
    currentEntangledPendingCount++;
    thenable.then(pingEngtangledActionScope, pingEngtangledActionScope);
    return thenable;
  }
  function pingEngtangledActionScope() {
    if (0 === --currentEntangledPendingCount && null !== currentEntangledListeners) {
      null !== currentEntangledActionThenable && (currentEntangledActionThenable.status = "fulfilled");
      var listeners = currentEntangledListeners;
      currentEntangledListeners = null;
      currentEntangledLane = 0;
      currentEntangledActionThenable = null;
      for (var i3 = 0; i3 < listeners.length; i3++) (0, listeners[i3])();
    }
  }
  function chainThenableValue(thenable, result) {
    var listeners = [], thenableWithOverride = {
      status: "pending",
      value: null,
      reason: null,
      then: function(resolve) {
        listeners.push(resolve);
      }
    };
    thenable.then(
      function() {
        thenableWithOverride.status = "fulfilled";
        thenableWithOverride.value = result;
        for (var i3 = 0; i3 < listeners.length; i3++) (0, listeners[i3])(result);
      },
      function(error) {
        thenableWithOverride.status = "rejected";
        thenableWithOverride.reason = error;
        for (error = 0; error < listeners.length; error++)
          (0, listeners[error])(void 0);
      }
    );
    return thenableWithOverride;
  }
  var prevOnStartTransitionFinish = ReactSharedInternals.S;
  ReactSharedInternals.S = function(transition, returnValue) {
    globalMostRecentTransitionTime = now();
    "object" === typeof returnValue && null !== returnValue && "function" === typeof returnValue.then && entangleAsyncAction(transition, returnValue);
    null !== prevOnStartTransitionFinish && prevOnStartTransitionFinish(transition, returnValue);
  };
  var resumedCache = createCursor(null);
  function peekCacheFromPool() {
    var cacheResumedFromPreviousRender = resumedCache.current;
    return null !== cacheResumedFromPreviousRender ? cacheResumedFromPreviousRender : workInProgressRoot.pooledCache;
  }
  function pushTransition(offscreenWorkInProgress, prevCachePool) {
    null === prevCachePool ? push(resumedCache, resumedCache.current) : push(resumedCache, prevCachePool.pool);
  }
  function getSuspendedCache() {
    var cacheFromPool = peekCacheFromPool();
    return null === cacheFromPool ? null : { parent: CacheContext._currentValue, pool: cacheFromPool };
  }
  var SuspenseException = Error(formatProdErrorMessage(460)), SuspenseyCommitException = Error(formatProdErrorMessage(474)), SuspenseActionException = Error(formatProdErrorMessage(542)), noopSuspenseyCommitThenable = { then: function() {
  } };
  function isThenableResolved(thenable) {
    thenable = thenable.status;
    return "fulfilled" === thenable || "rejected" === thenable;
  }
  function trackUsedThenable(thenableState2, thenable, index3) {
    index3 = thenableState2[index3];
    void 0 === index3 ? thenableState2.push(thenable) : index3 !== thenable && (thenable.then(noop$12, noop$12), thenable = index3);
    switch (thenable.status) {
      case "fulfilled":
        return thenable.value;
      case "rejected":
        throw thenableState2 = thenable.reason, checkIfUseWrappedInAsyncCatch(thenableState2), thenableState2;
      default:
        if ("string" === typeof thenable.status) thenable.then(noop$12, noop$12);
        else {
          thenableState2 = workInProgressRoot;
          if (null !== thenableState2 && 100 < thenableState2.shellSuspendCounter)
            throw Error(formatProdErrorMessage(482));
          thenableState2 = thenable;
          thenableState2.status = "pending";
          thenableState2.then(
            function(fulfilledValue) {
              if ("pending" === thenable.status) {
                var fulfilledThenable = thenable;
                fulfilledThenable.status = "fulfilled";
                fulfilledThenable.value = fulfilledValue;
              }
            },
            function(error) {
              if ("pending" === thenable.status) {
                var rejectedThenable = thenable;
                rejectedThenable.status = "rejected";
                rejectedThenable.reason = error;
              }
            }
          );
        }
        switch (thenable.status) {
          case "fulfilled":
            return thenable.value;
          case "rejected":
            throw thenableState2 = thenable.reason, checkIfUseWrappedInAsyncCatch(thenableState2), thenableState2;
        }
        suspendedThenable = thenable;
        throw SuspenseException;
    }
  }
  function resolveLazy(lazyType) {
    try {
      var init = lazyType._init;
      return init(lazyType._payload);
    } catch (x3) {
      if (null !== x3 && "object" === typeof x3 && "function" === typeof x3.then)
        throw suspendedThenable = x3, SuspenseException;
      throw x3;
    }
  }
  var suspendedThenable = null;
  function getSuspendedThenable() {
    if (null === suspendedThenable) throw Error(formatProdErrorMessage(459));
    var thenable = suspendedThenable;
    suspendedThenable = null;
    return thenable;
  }
  function checkIfUseWrappedInAsyncCatch(rejectedReason) {
    if (rejectedReason === SuspenseException || rejectedReason === SuspenseActionException)
      throw Error(formatProdErrorMessage(483));
  }
  var thenableState$1 = null, thenableIndexCounter$1 = 0;
  function unwrapThenable(thenable) {
    var index3 = thenableIndexCounter$1;
    thenableIndexCounter$1 += 1;
    null === thenableState$1 && (thenableState$1 = []);
    return trackUsedThenable(thenableState$1, thenable, index3);
  }
  function coerceRef(workInProgress2, element) {
    element = element.props.ref;
    workInProgress2.ref = void 0 !== element ? element : null;
  }
  function throwOnInvalidObjectTypeImpl(returnFiber, newChild) {
    if (newChild.$$typeof === REACT_LEGACY_ELEMENT_TYPE)
      throw Error(formatProdErrorMessage(525));
    returnFiber = Object.prototype.toString.call(newChild);
    throw Error(
      formatProdErrorMessage(
        31,
        "[object Object]" === returnFiber ? "object with keys {" + Object.keys(newChild).join(", ") + "}" : returnFiber
      )
    );
  }
  function createChildReconciler(shouldTrackSideEffects) {
    function deleteChild(returnFiber, childToDelete) {
      if (shouldTrackSideEffects) {
        var deletions = returnFiber.deletions;
        null === deletions ? (returnFiber.deletions = [childToDelete], returnFiber.flags |= 16) : deletions.push(childToDelete);
      }
    }
    function deleteRemainingChildren(returnFiber, currentFirstChild) {
      if (!shouldTrackSideEffects) return null;
      for (; null !== currentFirstChild; )
        deleteChild(returnFiber, currentFirstChild), currentFirstChild = currentFirstChild.sibling;
      return null;
    }
    function mapRemainingChildren(currentFirstChild) {
      for (var existingChildren = /* @__PURE__ */ new Map(); null !== currentFirstChild; )
        null !== currentFirstChild.key ? existingChildren.set(currentFirstChild.key, currentFirstChild) : existingChildren.set(currentFirstChild.index, currentFirstChild), currentFirstChild = currentFirstChild.sibling;
      return existingChildren;
    }
    function useFiber(fiber, pendingProps) {
      fiber = createWorkInProgress(fiber, pendingProps);
      fiber.index = 0;
      fiber.sibling = null;
      return fiber;
    }
    function placeChild(newFiber, lastPlacedIndex, newIndex) {
      newFiber.index = newIndex;
      if (!shouldTrackSideEffects)
        return newFiber.flags |= 1048576, lastPlacedIndex;
      newIndex = newFiber.alternate;
      if (null !== newIndex)
        return newIndex = newIndex.index, newIndex < lastPlacedIndex ? (newFiber.flags |= 67108866, lastPlacedIndex) : newIndex;
      newFiber.flags |= 67108866;
      return lastPlacedIndex;
    }
    function placeSingleChild(newFiber) {
      shouldTrackSideEffects && null === newFiber.alternate && (newFiber.flags |= 67108866);
      return newFiber;
    }
    function updateTextNode(returnFiber, current, textContent, lanes) {
      if (null === current || 6 !== current.tag)
        return current = createFiberFromText(textContent, returnFiber.mode, lanes), current.return = returnFiber, current;
      current = useFiber(current, textContent);
      current.return = returnFiber;
      return current;
    }
    function updateElement(returnFiber, current, element, lanes) {
      var elementType = element.type;
      if (elementType === REACT_FRAGMENT_TYPE)
        return updateFragment(
          returnFiber,
          current,
          element.props.children,
          lanes,
          element.key
        );
      if (null !== current && (current.elementType === elementType || "object" === typeof elementType && null !== elementType && elementType.$$typeof === REACT_LAZY_TYPE && resolveLazy(elementType) === current.type))
        return current = useFiber(current, element.props), coerceRef(current, element), current.return = returnFiber, current;
      current = createFiberFromTypeAndProps(
        element.type,
        element.key,
        element.props,
        null,
        returnFiber.mode,
        lanes
      );
      coerceRef(current, element);
      current.return = returnFiber;
      return current;
    }
    function updatePortal(returnFiber, current, portal, lanes) {
      if (null === current || 4 !== current.tag || current.stateNode.containerInfo !== portal.containerInfo || current.stateNode.implementation !== portal.implementation)
        return current = createFiberFromPortal(portal, returnFiber.mode, lanes), current.return = returnFiber, current;
      current = useFiber(current, portal.children || []);
      current.return = returnFiber;
      return current;
    }
    function updateFragment(returnFiber, current, fragment, lanes, key) {
      if (null === current || 7 !== current.tag)
        return current = createFiberFromFragment(
          fragment,
          returnFiber.mode,
          lanes,
          key
        ), current.return = returnFiber, current;
      current = useFiber(current, fragment);
      current.return = returnFiber;
      return current;
    }
    function createChild(returnFiber, newChild, lanes) {
      if ("string" === typeof newChild && "" !== newChild || "number" === typeof newChild || "bigint" === typeof newChild)
        return newChild = createFiberFromText(
          "" + newChild,
          returnFiber.mode,
          lanes
        ), newChild.return = returnFiber, newChild;
      if ("object" === typeof newChild && null !== newChild) {
        switch (newChild.$$typeof) {
          case REACT_ELEMENT_TYPE:
            return lanes = createFiberFromTypeAndProps(
              newChild.type,
              newChild.key,
              newChild.props,
              null,
              returnFiber.mode,
              lanes
            ), coerceRef(lanes, newChild), lanes.return = returnFiber, lanes;
          case REACT_PORTAL_TYPE:
            return newChild = createFiberFromPortal(
              newChild,
              returnFiber.mode,
              lanes
            ), newChild.return = returnFiber, newChild;
          case REACT_LAZY_TYPE:
            return newChild = resolveLazy(newChild), createChild(returnFiber, newChild, lanes);
        }
        if (isArrayImpl(newChild) || getIteratorFn(newChild))
          return newChild = createFiberFromFragment(
            newChild,
            returnFiber.mode,
            lanes,
            null
          ), newChild.return = returnFiber, newChild;
        if ("function" === typeof newChild.then)
          return createChild(returnFiber, unwrapThenable(newChild), lanes);
        if (newChild.$$typeof === REACT_CONTEXT_TYPE)
          return createChild(
            returnFiber,
            readContextDuringReconciliation(returnFiber, newChild),
            lanes
          );
        throwOnInvalidObjectTypeImpl(returnFiber, newChild);
      }
      return null;
    }
    function updateSlot(returnFiber, oldFiber, newChild, lanes) {
      var key = null !== oldFiber ? oldFiber.key : null;
      if ("string" === typeof newChild && "" !== newChild || "number" === typeof newChild || "bigint" === typeof newChild)
        return null !== key ? null : updateTextNode(returnFiber, oldFiber, "" + newChild, lanes);
      if ("object" === typeof newChild && null !== newChild) {
        switch (newChild.$$typeof) {
          case REACT_ELEMENT_TYPE:
            return newChild.key === key ? updateElement(returnFiber, oldFiber, newChild, lanes) : null;
          case REACT_PORTAL_TYPE:
            return newChild.key === key ? updatePortal(returnFiber, oldFiber, newChild, lanes) : null;
          case REACT_LAZY_TYPE:
            return newChild = resolveLazy(newChild), updateSlot(returnFiber, oldFiber, newChild, lanes);
        }
        if (isArrayImpl(newChild) || getIteratorFn(newChild))
          return null !== key ? null : updateFragment(returnFiber, oldFiber, newChild, lanes, null);
        if ("function" === typeof newChild.then)
          return updateSlot(
            returnFiber,
            oldFiber,
            unwrapThenable(newChild),
            lanes
          );
        if (newChild.$$typeof === REACT_CONTEXT_TYPE)
          return updateSlot(
            returnFiber,
            oldFiber,
            readContextDuringReconciliation(returnFiber, newChild),
            lanes
          );
        throwOnInvalidObjectTypeImpl(returnFiber, newChild);
      }
      return null;
    }
    function updateFromMap(existingChildren, returnFiber, newIdx, newChild, lanes) {
      if ("string" === typeof newChild && "" !== newChild || "number" === typeof newChild || "bigint" === typeof newChild)
        return existingChildren = existingChildren.get(newIdx) || null, updateTextNode(returnFiber, existingChildren, "" + newChild, lanes);
      if ("object" === typeof newChild && null !== newChild) {
        switch (newChild.$$typeof) {
          case REACT_ELEMENT_TYPE:
            return existingChildren = existingChildren.get(
              null === newChild.key ? newIdx : newChild.key
            ) || null, updateElement(returnFiber, existingChildren, newChild, lanes);
          case REACT_PORTAL_TYPE:
            return existingChildren = existingChildren.get(
              null === newChild.key ? newIdx : newChild.key
            ) || null, updatePortal(returnFiber, existingChildren, newChild, lanes);
          case REACT_LAZY_TYPE:
            return newChild = resolveLazy(newChild), updateFromMap(
              existingChildren,
              returnFiber,
              newIdx,
              newChild,
              lanes
            );
        }
        if (isArrayImpl(newChild) || getIteratorFn(newChild))
          return existingChildren = existingChildren.get(newIdx) || null, updateFragment(returnFiber, existingChildren, newChild, lanes, null);
        if ("function" === typeof newChild.then)
          return updateFromMap(
            existingChildren,
            returnFiber,
            newIdx,
            unwrapThenable(newChild),
            lanes
          );
        if (newChild.$$typeof === REACT_CONTEXT_TYPE)
          return updateFromMap(
            existingChildren,
            returnFiber,
            newIdx,
            readContextDuringReconciliation(returnFiber, newChild),
            lanes
          );
        throwOnInvalidObjectTypeImpl(returnFiber, newChild);
      }
      return null;
    }
    function reconcileChildrenArray(returnFiber, currentFirstChild, newChildren, lanes) {
      for (var resultingFirstChild = null, previousNewFiber = null, oldFiber = currentFirstChild, newIdx = currentFirstChild = 0, nextOldFiber = null; null !== oldFiber && newIdx < newChildren.length; newIdx++) {
        oldFiber.index > newIdx ? (nextOldFiber = oldFiber, oldFiber = null) : nextOldFiber = oldFiber.sibling;
        var newFiber = updateSlot(
          returnFiber,
          oldFiber,
          newChildren[newIdx],
          lanes
        );
        if (null === newFiber) {
          null === oldFiber && (oldFiber = nextOldFiber);
          break;
        }
        shouldTrackSideEffects && oldFiber && null === newFiber.alternate && deleteChild(returnFiber, oldFiber);
        currentFirstChild = placeChild(newFiber, currentFirstChild, newIdx);
        null === previousNewFiber ? resultingFirstChild = newFiber : previousNewFiber.sibling = newFiber;
        previousNewFiber = newFiber;
        oldFiber = nextOldFiber;
      }
      if (newIdx === newChildren.length)
        return deleteRemainingChildren(returnFiber, oldFiber), isHydrating && pushTreeFork(returnFiber, newIdx), resultingFirstChild;
      if (null === oldFiber) {
        for (; newIdx < newChildren.length; newIdx++)
          oldFiber = createChild(returnFiber, newChildren[newIdx], lanes), null !== oldFiber && (currentFirstChild = placeChild(
            oldFiber,
            currentFirstChild,
            newIdx
          ), null === previousNewFiber ? resultingFirstChild = oldFiber : previousNewFiber.sibling = oldFiber, previousNewFiber = oldFiber);
        isHydrating && pushTreeFork(returnFiber, newIdx);
        return resultingFirstChild;
      }
      for (oldFiber = mapRemainingChildren(oldFiber); newIdx < newChildren.length; newIdx++)
        nextOldFiber = updateFromMap(
          oldFiber,
          returnFiber,
          newIdx,
          newChildren[newIdx],
          lanes
        ), null !== nextOldFiber && (shouldTrackSideEffects && null !== nextOldFiber.alternate && oldFiber.delete(
          null === nextOldFiber.key ? newIdx : nextOldFiber.key
        ), currentFirstChild = placeChild(
          nextOldFiber,
          currentFirstChild,
          newIdx
        ), null === previousNewFiber ? resultingFirstChild = nextOldFiber : previousNewFiber.sibling = nextOldFiber, previousNewFiber = nextOldFiber);
      shouldTrackSideEffects && oldFiber.forEach(function(child) {
        return deleteChild(returnFiber, child);
      });
      isHydrating && pushTreeFork(returnFiber, newIdx);
      return resultingFirstChild;
    }
    function reconcileChildrenIterator(returnFiber, currentFirstChild, newChildren, lanes) {
      if (null == newChildren) throw Error(formatProdErrorMessage(151));
      for (var resultingFirstChild = null, previousNewFiber = null, oldFiber = currentFirstChild, newIdx = currentFirstChild = 0, nextOldFiber = null, step = newChildren.next(); null !== oldFiber && !step.done; newIdx++, step = newChildren.next()) {
        oldFiber.index > newIdx ? (nextOldFiber = oldFiber, oldFiber = null) : nextOldFiber = oldFiber.sibling;
        var newFiber = updateSlot(returnFiber, oldFiber, step.value, lanes);
        if (null === newFiber) {
          null === oldFiber && (oldFiber = nextOldFiber);
          break;
        }
        shouldTrackSideEffects && oldFiber && null === newFiber.alternate && deleteChild(returnFiber, oldFiber);
        currentFirstChild = placeChild(newFiber, currentFirstChild, newIdx);
        null === previousNewFiber ? resultingFirstChild = newFiber : previousNewFiber.sibling = newFiber;
        previousNewFiber = newFiber;
        oldFiber = nextOldFiber;
      }
      if (step.done)
        return deleteRemainingChildren(returnFiber, oldFiber), isHydrating && pushTreeFork(returnFiber, newIdx), resultingFirstChild;
      if (null === oldFiber) {
        for (; !step.done; newIdx++, step = newChildren.next())
          step = createChild(returnFiber, step.value, lanes), null !== step && (currentFirstChild = placeChild(step, currentFirstChild, newIdx), null === previousNewFiber ? resultingFirstChild = step : previousNewFiber.sibling = step, previousNewFiber = step);
        isHydrating && pushTreeFork(returnFiber, newIdx);
        return resultingFirstChild;
      }
      for (oldFiber = mapRemainingChildren(oldFiber); !step.done; newIdx++, step = newChildren.next())
        step = updateFromMap(oldFiber, returnFiber, newIdx, step.value, lanes), null !== step && (shouldTrackSideEffects && null !== step.alternate && oldFiber.delete(null === step.key ? newIdx : step.key), currentFirstChild = placeChild(step, currentFirstChild, newIdx), null === previousNewFiber ? resultingFirstChild = step : previousNewFiber.sibling = step, previousNewFiber = step);
      shouldTrackSideEffects && oldFiber.forEach(function(child) {
        return deleteChild(returnFiber, child);
      });
      isHydrating && pushTreeFork(returnFiber, newIdx);
      return resultingFirstChild;
    }
    function reconcileChildFibersImpl(returnFiber, currentFirstChild, newChild, lanes) {
      "object" === typeof newChild && null !== newChild && newChild.type === REACT_FRAGMENT_TYPE && null === newChild.key && (newChild = newChild.props.children);
      if ("object" === typeof newChild && null !== newChild) {
        switch (newChild.$$typeof) {
          case REACT_ELEMENT_TYPE:
            a: {
              for (var key = newChild.key; null !== currentFirstChild; ) {
                if (currentFirstChild.key === key) {
                  key = newChild.type;
                  if (key === REACT_FRAGMENT_TYPE) {
                    if (7 === currentFirstChild.tag) {
                      deleteRemainingChildren(
                        returnFiber,
                        currentFirstChild.sibling
                      );
                      lanes = useFiber(
                        currentFirstChild,
                        newChild.props.children
                      );
                      lanes.return = returnFiber;
                      returnFiber = lanes;
                      break a;
                    }
                  } else if (currentFirstChild.elementType === key || "object" === typeof key && null !== key && key.$$typeof === REACT_LAZY_TYPE && resolveLazy(key) === currentFirstChild.type) {
                    deleteRemainingChildren(
                      returnFiber,
                      currentFirstChild.sibling
                    );
                    lanes = useFiber(currentFirstChild, newChild.props);
                    coerceRef(lanes, newChild);
                    lanes.return = returnFiber;
                    returnFiber = lanes;
                    break a;
                  }
                  deleteRemainingChildren(returnFiber, currentFirstChild);
                  break;
                } else deleteChild(returnFiber, currentFirstChild);
                currentFirstChild = currentFirstChild.sibling;
              }
              newChild.type === REACT_FRAGMENT_TYPE ? (lanes = createFiberFromFragment(
                newChild.props.children,
                returnFiber.mode,
                lanes,
                newChild.key
              ), lanes.return = returnFiber, returnFiber = lanes) : (lanes = createFiberFromTypeAndProps(
                newChild.type,
                newChild.key,
                newChild.props,
                null,
                returnFiber.mode,
                lanes
              ), coerceRef(lanes, newChild), lanes.return = returnFiber, returnFiber = lanes);
            }
            return placeSingleChild(returnFiber);
          case REACT_PORTAL_TYPE:
            a: {
              for (key = newChild.key; null !== currentFirstChild; ) {
                if (currentFirstChild.key === key)
                  if (4 === currentFirstChild.tag && currentFirstChild.stateNode.containerInfo === newChild.containerInfo && currentFirstChild.stateNode.implementation === newChild.implementation) {
                    deleteRemainingChildren(
                      returnFiber,
                      currentFirstChild.sibling
                    );
                    lanes = useFiber(currentFirstChild, newChild.children || []);
                    lanes.return = returnFiber;
                    returnFiber = lanes;
                    break a;
                  } else {
                    deleteRemainingChildren(returnFiber, currentFirstChild);
                    break;
                  }
                else deleteChild(returnFiber, currentFirstChild);
                currentFirstChild = currentFirstChild.sibling;
              }
              lanes = createFiberFromPortal(newChild, returnFiber.mode, lanes);
              lanes.return = returnFiber;
              returnFiber = lanes;
            }
            return placeSingleChild(returnFiber);
          case REACT_LAZY_TYPE:
            return newChild = resolveLazy(newChild), reconcileChildFibersImpl(
              returnFiber,
              currentFirstChild,
              newChild,
              lanes
            );
        }
        if (isArrayImpl(newChild))
          return reconcileChildrenArray(
            returnFiber,
            currentFirstChild,
            newChild,
            lanes
          );
        if (getIteratorFn(newChild)) {
          key = getIteratorFn(newChild);
          if ("function" !== typeof key) throw Error(formatProdErrorMessage(150));
          newChild = key.call(newChild);
          return reconcileChildrenIterator(
            returnFiber,
            currentFirstChild,
            newChild,
            lanes
          );
        }
        if ("function" === typeof newChild.then)
          return reconcileChildFibersImpl(
            returnFiber,
            currentFirstChild,
            unwrapThenable(newChild),
            lanes
          );
        if (newChild.$$typeof === REACT_CONTEXT_TYPE)
          return reconcileChildFibersImpl(
            returnFiber,
            currentFirstChild,
            readContextDuringReconciliation(returnFiber, newChild),
            lanes
          );
        throwOnInvalidObjectTypeImpl(returnFiber, newChild);
      }
      return "string" === typeof newChild && "" !== newChild || "number" === typeof newChild || "bigint" === typeof newChild ? (newChild = "" + newChild, null !== currentFirstChild && 6 === currentFirstChild.tag ? (deleteRemainingChildren(returnFiber, currentFirstChild.sibling), lanes = useFiber(currentFirstChild, newChild), lanes.return = returnFiber, returnFiber = lanes) : (deleteRemainingChildren(returnFiber, currentFirstChild), lanes = createFiberFromText(newChild, returnFiber.mode, lanes), lanes.return = returnFiber, returnFiber = lanes), placeSingleChild(returnFiber)) : deleteRemainingChildren(returnFiber, currentFirstChild);
    }
    return function(returnFiber, currentFirstChild, newChild, lanes) {
      try {
        thenableIndexCounter$1 = 0;
        var firstChildFiber = reconcileChildFibersImpl(
          returnFiber,
          currentFirstChild,
          newChild,
          lanes
        );
        thenableState$1 = null;
        return firstChildFiber;
      } catch (x3) {
        if (x3 === SuspenseException || x3 === SuspenseActionException) throw x3;
        var fiber = createFiberImplClass(29, x3, null, returnFiber.mode);
        fiber.lanes = lanes;
        fiber.return = returnFiber;
        return fiber;
      } finally {
      }
    };
  }
  var reconcileChildFibers = createChildReconciler(true), mountChildFibers = createChildReconciler(false), hasForceUpdate = false;
  function initializeUpdateQueue(fiber) {
    fiber.updateQueue = {
      baseState: fiber.memoizedState,
      firstBaseUpdate: null,
      lastBaseUpdate: null,
      shared: { pending: null, lanes: 0, hiddenCallbacks: null },
      callbacks: null
    };
  }
  function cloneUpdateQueue(current, workInProgress2) {
    current = current.updateQueue;
    workInProgress2.updateQueue === current && (workInProgress2.updateQueue = {
      baseState: current.baseState,
      firstBaseUpdate: current.firstBaseUpdate,
      lastBaseUpdate: current.lastBaseUpdate,
      shared: current.shared,
      callbacks: null
    });
  }
  function createUpdate(lane) {
    return { lane, tag: 0, payload: null, callback: null, next: null };
  }
  function enqueueUpdate(fiber, update, lane) {
    var updateQueue = fiber.updateQueue;
    if (null === updateQueue) return null;
    updateQueue = updateQueue.shared;
    if (0 !== (executionContext & 2)) {
      var pending = updateQueue.pending;
      null === pending ? update.next = update : (update.next = pending.next, pending.next = update);
      updateQueue.pending = update;
      update = getRootForUpdatedFiber(fiber);
      markUpdateLaneFromFiberToRoot(fiber, null, lane);
      return update;
    }
    enqueueUpdate$1(fiber, updateQueue, update, lane);
    return getRootForUpdatedFiber(fiber);
  }
  function entangleTransitions(root2, fiber, lane) {
    fiber = fiber.updateQueue;
    if (null !== fiber && (fiber = fiber.shared, 0 !== (lane & 4194048))) {
      var queueLanes = fiber.lanes;
      queueLanes &= root2.pendingLanes;
      lane |= queueLanes;
      fiber.lanes = lane;
      markRootEntangled(root2, lane);
    }
  }
  function enqueueCapturedUpdate(workInProgress2, capturedUpdate) {
    var queue = workInProgress2.updateQueue, current = workInProgress2.alternate;
    if (null !== current && (current = current.updateQueue, queue === current)) {
      var newFirst = null, newLast = null;
      queue = queue.firstBaseUpdate;
      if (null !== queue) {
        do {
          var clone2 = {
            lane: queue.lane,
            tag: queue.tag,
            payload: queue.payload,
            callback: null,
            next: null
          };
          null === newLast ? newFirst = newLast = clone2 : newLast = newLast.next = clone2;
          queue = queue.next;
        } while (null !== queue);
        null === newLast ? newFirst = newLast = capturedUpdate : newLast = newLast.next = capturedUpdate;
      } else newFirst = newLast = capturedUpdate;
      queue = {
        baseState: current.baseState,
        firstBaseUpdate: newFirst,
        lastBaseUpdate: newLast,
        shared: current.shared,
        callbacks: current.callbacks
      };
      workInProgress2.updateQueue = queue;
      return;
    }
    workInProgress2 = queue.lastBaseUpdate;
    null === workInProgress2 ? queue.firstBaseUpdate = capturedUpdate : workInProgress2.next = capturedUpdate;
    queue.lastBaseUpdate = capturedUpdate;
  }
  var didReadFromEntangledAsyncAction = false;
  function suspendIfUpdateReadFromEntangledAsyncAction() {
    if (didReadFromEntangledAsyncAction) {
      var entangledActionThenable = currentEntangledActionThenable;
      if (null !== entangledActionThenable) throw entangledActionThenable;
    }
  }
  function processUpdateQueue(workInProgress$jscomp$0, props, instance$jscomp$0, renderLanes2) {
    didReadFromEntangledAsyncAction = false;
    var queue = workInProgress$jscomp$0.updateQueue;
    hasForceUpdate = false;
    var firstBaseUpdate = queue.firstBaseUpdate, lastBaseUpdate = queue.lastBaseUpdate, pendingQueue = queue.shared.pending;
    if (null !== pendingQueue) {
      queue.shared.pending = null;
      var lastPendingUpdate = pendingQueue, firstPendingUpdate = lastPendingUpdate.next;
      lastPendingUpdate.next = null;
      null === lastBaseUpdate ? firstBaseUpdate = firstPendingUpdate : lastBaseUpdate.next = firstPendingUpdate;
      lastBaseUpdate = lastPendingUpdate;
      var current = workInProgress$jscomp$0.alternate;
      null !== current && (current = current.updateQueue, pendingQueue = current.lastBaseUpdate, pendingQueue !== lastBaseUpdate && (null === pendingQueue ? current.firstBaseUpdate = firstPendingUpdate : pendingQueue.next = firstPendingUpdate, current.lastBaseUpdate = lastPendingUpdate));
    }
    if (null !== firstBaseUpdate) {
      var newState = queue.baseState;
      lastBaseUpdate = 0;
      current = firstPendingUpdate = lastPendingUpdate = null;
      pendingQueue = firstBaseUpdate;
      do {
        var updateLane = pendingQueue.lane & -536870913, isHiddenUpdate = updateLane !== pendingQueue.lane;
        if (isHiddenUpdate ? (workInProgressRootRenderLanes & updateLane) === updateLane : (renderLanes2 & updateLane) === updateLane) {
          0 !== updateLane && updateLane === currentEntangledLane && (didReadFromEntangledAsyncAction = true);
          null !== current && (current = current.next = {
            lane: 0,
            tag: pendingQueue.tag,
            payload: pendingQueue.payload,
            callback: null,
            next: null
          });
          a: {
            var workInProgress2 = workInProgress$jscomp$0, update = pendingQueue;
            updateLane = props;
            var instance = instance$jscomp$0;
            switch (update.tag) {
              case 1:
                workInProgress2 = update.payload;
                if ("function" === typeof workInProgress2) {
                  newState = workInProgress2.call(instance, newState, updateLane);
                  break a;
                }
                newState = workInProgress2;
                break a;
              case 3:
                workInProgress2.flags = workInProgress2.flags & -65537 | 128;
              case 0:
                workInProgress2 = update.payload;
                updateLane = "function" === typeof workInProgress2 ? workInProgress2.call(instance, newState, updateLane) : workInProgress2;
                if (null === updateLane || void 0 === updateLane) break a;
                newState = assign2({}, newState, updateLane);
                break a;
              case 2:
                hasForceUpdate = true;
            }
          }
          updateLane = pendingQueue.callback;
          null !== updateLane && (workInProgress$jscomp$0.flags |= 64, isHiddenUpdate && (workInProgress$jscomp$0.flags |= 8192), isHiddenUpdate = queue.callbacks, null === isHiddenUpdate ? queue.callbacks = [updateLane] : isHiddenUpdate.push(updateLane));
        } else
          isHiddenUpdate = {
            lane: updateLane,
            tag: pendingQueue.tag,
            payload: pendingQueue.payload,
            callback: pendingQueue.callback,
            next: null
          }, null === current ? (firstPendingUpdate = current = isHiddenUpdate, lastPendingUpdate = newState) : current = current.next = isHiddenUpdate, lastBaseUpdate |= updateLane;
        pendingQueue = pendingQueue.next;
        if (null === pendingQueue)
          if (pendingQueue = queue.shared.pending, null === pendingQueue)
            break;
          else
            isHiddenUpdate = pendingQueue, pendingQueue = isHiddenUpdate.next, isHiddenUpdate.next = null, queue.lastBaseUpdate = isHiddenUpdate, queue.shared.pending = null;
      } while (1);
      null === current && (lastPendingUpdate = newState);
      queue.baseState = lastPendingUpdate;
      queue.firstBaseUpdate = firstPendingUpdate;
      queue.lastBaseUpdate = current;
      null === firstBaseUpdate && (queue.shared.lanes = 0);
      workInProgressRootSkippedLanes |= lastBaseUpdate;
      workInProgress$jscomp$0.lanes = lastBaseUpdate;
      workInProgress$jscomp$0.memoizedState = newState;
    }
  }
  function callCallback(callback, context) {
    if ("function" !== typeof callback)
      throw Error(formatProdErrorMessage(191, callback));
    callback.call(context);
  }
  function commitCallbacks(updateQueue, context) {
    var callbacks = updateQueue.callbacks;
    if (null !== callbacks)
      for (updateQueue.callbacks = null, updateQueue = 0; updateQueue < callbacks.length; updateQueue++)
        callCallback(callbacks[updateQueue], context);
  }
  var currentTreeHiddenStackCursor = createCursor(null), prevEntangledRenderLanesCursor = createCursor(0);
  function pushHiddenContext(fiber, context) {
    fiber = entangledRenderLanes;
    push(prevEntangledRenderLanesCursor, fiber);
    push(currentTreeHiddenStackCursor, context);
    entangledRenderLanes = fiber | context.baseLanes;
  }
  function reuseHiddenContextOnStack() {
    push(prevEntangledRenderLanesCursor, entangledRenderLanes);
    push(currentTreeHiddenStackCursor, currentTreeHiddenStackCursor.current);
  }
  function popHiddenContext() {
    entangledRenderLanes = prevEntangledRenderLanesCursor.current;
    pop(currentTreeHiddenStackCursor);
    pop(prevEntangledRenderLanesCursor);
  }
  var suspenseHandlerStackCursor = createCursor(null), shellBoundary = null;
  function pushPrimaryTreeSuspenseHandler(handler) {
    var current = handler.alternate;
    push(suspenseStackCursor, suspenseStackCursor.current & 1);
    push(suspenseHandlerStackCursor, handler);
    null === shellBoundary && (null === current || null !== currentTreeHiddenStackCursor.current ? shellBoundary = handler : null !== current.memoizedState && (shellBoundary = handler));
  }
  function pushDehydratedActivitySuspenseHandler(fiber) {
    push(suspenseStackCursor, suspenseStackCursor.current);
    push(suspenseHandlerStackCursor, fiber);
    null === shellBoundary && (shellBoundary = fiber);
  }
  function pushOffscreenSuspenseHandler(fiber) {
    22 === fiber.tag ? (push(suspenseStackCursor, suspenseStackCursor.current), push(suspenseHandlerStackCursor, fiber), null === shellBoundary && (shellBoundary = fiber)) : reuseSuspenseHandlerOnStack();
  }
  function reuseSuspenseHandlerOnStack() {
    push(suspenseStackCursor, suspenseStackCursor.current);
    push(suspenseHandlerStackCursor, suspenseHandlerStackCursor.current);
  }
  function popSuspenseHandler(fiber) {
    pop(suspenseHandlerStackCursor);
    shellBoundary === fiber && (shellBoundary = null);
    pop(suspenseStackCursor);
  }
  var suspenseStackCursor = createCursor(0);
  function findFirstSuspended(row) {
    for (var node = row; null !== node; ) {
      if (13 === node.tag) {
        var state = node.memoizedState;
        if (null !== state && (state = state.dehydrated, null === state || isSuspenseInstancePending(state) || isSuspenseInstanceFallback(state)))
          return node;
      } else if (19 === node.tag && ("forwards" === node.memoizedProps.revealOrder || "backwards" === node.memoizedProps.revealOrder || "unstable_legacy-backwards" === node.memoizedProps.revealOrder || "together" === node.memoizedProps.revealOrder)) {
        if (0 !== (node.flags & 128)) return node;
      } else if (null !== node.child) {
        node.child.return = node;
        node = node.child;
        continue;
      }
      if (node === row) break;
      for (; null === node.sibling; ) {
        if (null === node.return || node.return === row) return null;
        node = node.return;
      }
      node.sibling.return = node.return;
      node = node.sibling;
    }
    return null;
  }
  var renderLanes = 0, currentlyRenderingFiber = null, currentHook = null, workInProgressHook = null, didScheduleRenderPhaseUpdate = false, didScheduleRenderPhaseUpdateDuringThisPass = false, shouldDoubleInvokeUserFnsInHooksDEV = false, localIdCounter = 0, thenableIndexCounter = 0, thenableState = null, globalClientIdCounter = 0;
  function throwInvalidHookError() {
    throw Error(formatProdErrorMessage(321));
  }
  function areHookInputsEqual(nextDeps, prevDeps) {
    if (null === prevDeps) return false;
    for (var i3 = 0; i3 < prevDeps.length && i3 < nextDeps.length; i3++)
      if (!objectIs(nextDeps[i3], prevDeps[i3])) return false;
    return true;
  }
  function renderWithHooks(current, workInProgress2, Component, props, secondArg, nextRenderLanes) {
    renderLanes = nextRenderLanes;
    currentlyRenderingFiber = workInProgress2;
    workInProgress2.memoizedState = null;
    workInProgress2.updateQueue = null;
    workInProgress2.lanes = 0;
    ReactSharedInternals.H = null === current || null === current.memoizedState ? HooksDispatcherOnMount : HooksDispatcherOnUpdate;
    shouldDoubleInvokeUserFnsInHooksDEV = false;
    nextRenderLanes = Component(props, secondArg);
    shouldDoubleInvokeUserFnsInHooksDEV = false;
    didScheduleRenderPhaseUpdateDuringThisPass && (nextRenderLanes = renderWithHooksAgain(
      workInProgress2,
      Component,
      props,
      secondArg
    ));
    finishRenderingHooks(current);
    return nextRenderLanes;
  }
  function finishRenderingHooks(current) {
    ReactSharedInternals.H = ContextOnlyDispatcher;
    var didRenderTooFewHooks = null !== currentHook && null !== currentHook.next;
    renderLanes = 0;
    workInProgressHook = currentHook = currentlyRenderingFiber = null;
    didScheduleRenderPhaseUpdate = false;
    thenableIndexCounter = 0;
    thenableState = null;
    if (didRenderTooFewHooks) throw Error(formatProdErrorMessage(300));
    null === current || didReceiveUpdate || (current = current.dependencies, null !== current && checkIfContextChanged(current) && (didReceiveUpdate = true));
  }
  function renderWithHooksAgain(workInProgress2, Component, props, secondArg) {
    currentlyRenderingFiber = workInProgress2;
    var numberOfReRenders = 0;
    do {
      didScheduleRenderPhaseUpdateDuringThisPass && (thenableState = null);
      thenableIndexCounter = 0;
      didScheduleRenderPhaseUpdateDuringThisPass = false;
      if (25 <= numberOfReRenders) throw Error(formatProdErrorMessage(301));
      numberOfReRenders += 1;
      workInProgressHook = currentHook = null;
      if (null != workInProgress2.updateQueue) {
        var children = workInProgress2.updateQueue;
        children.lastEffect = null;
        children.events = null;
        children.stores = null;
        null != children.memoCache && (children.memoCache.index = 0);
      }
      ReactSharedInternals.H = HooksDispatcherOnRerender;
      children = Component(props, secondArg);
    } while (didScheduleRenderPhaseUpdateDuringThisPass);
    return children;
  }
  function TransitionAwareHostComponent() {
    var dispatcher = ReactSharedInternals.H, maybeThenable = dispatcher.useState()[0];
    maybeThenable = "function" === typeof maybeThenable.then ? useThenable(maybeThenable) : maybeThenable;
    dispatcher = dispatcher.useState()[0];
    (null !== currentHook ? currentHook.memoizedState : null) !== dispatcher && (currentlyRenderingFiber.flags |= 1024);
    return maybeThenable;
  }
  function checkDidRenderIdHook() {
    var didRenderIdHook = 0 !== localIdCounter;
    localIdCounter = 0;
    return didRenderIdHook;
  }
  function bailoutHooks(current, workInProgress2, lanes) {
    workInProgress2.updateQueue = current.updateQueue;
    workInProgress2.flags &= -2053;
    current.lanes &= ~lanes;
  }
  function resetHooksOnUnwind(workInProgress2) {
    if (didScheduleRenderPhaseUpdate) {
      for (workInProgress2 = workInProgress2.memoizedState; null !== workInProgress2; ) {
        var queue = workInProgress2.queue;
        null !== queue && (queue.pending = null);
        workInProgress2 = workInProgress2.next;
      }
      didScheduleRenderPhaseUpdate = false;
    }
    renderLanes = 0;
    workInProgressHook = currentHook = currentlyRenderingFiber = null;
    didScheduleRenderPhaseUpdateDuringThisPass = false;
    thenableIndexCounter = localIdCounter = 0;
    thenableState = null;
  }
  function mountWorkInProgressHook() {
    var hook = {
      memoizedState: null,
      baseState: null,
      baseQueue: null,
      queue: null,
      next: null
    };
    null === workInProgressHook ? currentlyRenderingFiber.memoizedState = workInProgressHook = hook : workInProgressHook = workInProgressHook.next = hook;
    return workInProgressHook;
  }
  function updateWorkInProgressHook() {
    if (null === currentHook) {
      var nextCurrentHook = currentlyRenderingFiber.alternate;
      nextCurrentHook = null !== nextCurrentHook ? nextCurrentHook.memoizedState : null;
    } else nextCurrentHook = currentHook.next;
    var nextWorkInProgressHook = null === workInProgressHook ? currentlyRenderingFiber.memoizedState : workInProgressHook.next;
    if (null !== nextWorkInProgressHook)
      workInProgressHook = nextWorkInProgressHook, currentHook = nextCurrentHook;
    else {
      if (null === nextCurrentHook) {
        if (null === currentlyRenderingFiber.alternate)
          throw Error(formatProdErrorMessage(467));
        throw Error(formatProdErrorMessage(310));
      }
      currentHook = nextCurrentHook;
      nextCurrentHook = {
        memoizedState: currentHook.memoizedState,
        baseState: currentHook.baseState,
        baseQueue: currentHook.baseQueue,
        queue: currentHook.queue,
        next: null
      };
      null === workInProgressHook ? currentlyRenderingFiber.memoizedState = workInProgressHook = nextCurrentHook : workInProgressHook = workInProgressHook.next = nextCurrentHook;
    }
    return workInProgressHook;
  }
  function createFunctionComponentUpdateQueue() {
    return { lastEffect: null, events: null, stores: null, memoCache: null };
  }
  function useThenable(thenable) {
    var index3 = thenableIndexCounter;
    thenableIndexCounter += 1;
    null === thenableState && (thenableState = []);
    thenable = trackUsedThenable(thenableState, thenable, index3);
    index3 = currentlyRenderingFiber;
    null === (null === workInProgressHook ? index3.memoizedState : workInProgressHook.next) && (index3 = index3.alternate, ReactSharedInternals.H = null === index3 || null === index3.memoizedState ? HooksDispatcherOnMount : HooksDispatcherOnUpdate);
    return thenable;
  }
  function use2(usable) {
    if (null !== usable && "object" === typeof usable) {
      if ("function" === typeof usable.then) return useThenable(usable);
      if (usable.$$typeof === REACT_CONTEXT_TYPE) return readContext(usable);
    }
    throw Error(formatProdErrorMessage(438, String(usable)));
  }
  function useMemoCache(size2) {
    var memoCache = null, updateQueue = currentlyRenderingFiber.updateQueue;
    null !== updateQueue && (memoCache = updateQueue.memoCache);
    if (null == memoCache) {
      var current = currentlyRenderingFiber.alternate;
      null !== current && (current = current.updateQueue, null !== current && (current = current.memoCache, null != current && (memoCache = {
        data: current.data.map(function(array) {
          return array.slice();
        }),
        index: 0
      })));
    }
    null == memoCache && (memoCache = { data: [], index: 0 });
    null === updateQueue && (updateQueue = createFunctionComponentUpdateQueue(), currentlyRenderingFiber.updateQueue = updateQueue);
    updateQueue.memoCache = memoCache;
    updateQueue = memoCache.data[memoCache.index];
    if (void 0 === updateQueue)
      for (updateQueue = memoCache.data[memoCache.index] = Array(size2), current = 0; current < size2; current++)
        updateQueue[current] = REACT_MEMO_CACHE_SENTINEL;
    memoCache.index++;
    return updateQueue;
  }
  function basicStateReducer(state, action) {
    return "function" === typeof action ? action(state) : action;
  }
  function updateReducer(reducer) {
    var hook = updateWorkInProgressHook();
    return updateReducerImpl(hook, currentHook, reducer);
  }
  function updateReducerImpl(hook, current, reducer) {
    var queue = hook.queue;
    if (null === queue) throw Error(formatProdErrorMessage(311));
    queue.lastRenderedReducer = reducer;
    var baseQueue = hook.baseQueue, pendingQueue = queue.pending;
    if (null !== pendingQueue) {
      if (null !== baseQueue) {
        var baseFirst = baseQueue.next;
        baseQueue.next = pendingQueue.next;
        pendingQueue.next = baseFirst;
      }
      current.baseQueue = baseQueue = pendingQueue;
      queue.pending = null;
    }
    pendingQueue = hook.baseState;
    if (null === baseQueue) hook.memoizedState = pendingQueue;
    else {
      current = baseQueue.next;
      var newBaseQueueFirst = baseFirst = null, newBaseQueueLast = null, update = current, didReadFromEntangledAsyncAction$60 = false;
      do {
        var updateLane = update.lane & -536870913;
        if (updateLane !== update.lane ? (workInProgressRootRenderLanes & updateLane) === updateLane : (renderLanes & updateLane) === updateLane) {
          var revertLane = update.revertLane;
          if (0 === revertLane)
            null !== newBaseQueueLast && (newBaseQueueLast = newBaseQueueLast.next = {
              lane: 0,
              revertLane: 0,
              gesture: null,
              action: update.action,
              hasEagerState: update.hasEagerState,
              eagerState: update.eagerState,
              next: null
            }), updateLane === currentEntangledLane && (didReadFromEntangledAsyncAction$60 = true);
          else if ((renderLanes & revertLane) === revertLane) {
            update = update.next;
            revertLane === currentEntangledLane && (didReadFromEntangledAsyncAction$60 = true);
            continue;
          } else
            updateLane = {
              lane: 0,
              revertLane: update.revertLane,
              gesture: null,
              action: update.action,
              hasEagerState: update.hasEagerState,
              eagerState: update.eagerState,
              next: null
            }, null === newBaseQueueLast ? (newBaseQueueFirst = newBaseQueueLast = updateLane, baseFirst = pendingQueue) : newBaseQueueLast = newBaseQueueLast.next = updateLane, currentlyRenderingFiber.lanes |= revertLane, workInProgressRootSkippedLanes |= revertLane;
          updateLane = update.action;
          shouldDoubleInvokeUserFnsInHooksDEV && reducer(pendingQueue, updateLane);
          pendingQueue = update.hasEagerState ? update.eagerState : reducer(pendingQueue, updateLane);
        } else
          revertLane = {
            lane: updateLane,
            revertLane: update.revertLane,
            gesture: update.gesture,
            action: update.action,
            hasEagerState: update.hasEagerState,
            eagerState: update.eagerState,
            next: null
          }, null === newBaseQueueLast ? (newBaseQueueFirst = newBaseQueueLast = revertLane, baseFirst = pendingQueue) : newBaseQueueLast = newBaseQueueLast.next = revertLane, currentlyRenderingFiber.lanes |= updateLane, workInProgressRootSkippedLanes |= updateLane;
        update = update.next;
      } while (null !== update && update !== current);
      null === newBaseQueueLast ? baseFirst = pendingQueue : newBaseQueueLast.next = newBaseQueueFirst;
      if (!objectIs(pendingQueue, hook.memoizedState) && (didReceiveUpdate = true, didReadFromEntangledAsyncAction$60 && (reducer = currentEntangledActionThenable, null !== reducer)))
        throw reducer;
      hook.memoizedState = pendingQueue;
      hook.baseState = baseFirst;
      hook.baseQueue = newBaseQueueLast;
      queue.lastRenderedState = pendingQueue;
    }
    null === baseQueue && (queue.lanes = 0);
    return [hook.memoizedState, queue.dispatch];
  }
  function rerenderReducer(reducer) {
    var hook = updateWorkInProgressHook(), queue = hook.queue;
    if (null === queue) throw Error(formatProdErrorMessage(311));
    queue.lastRenderedReducer = reducer;
    var dispatch = queue.dispatch, lastRenderPhaseUpdate = queue.pending, newState = hook.memoizedState;
    if (null !== lastRenderPhaseUpdate) {
      queue.pending = null;
      var update = lastRenderPhaseUpdate = lastRenderPhaseUpdate.next;
      do
        newState = reducer(newState, update.action), update = update.next;
      while (update !== lastRenderPhaseUpdate);
      objectIs(newState, hook.memoizedState) || (didReceiveUpdate = true);
      hook.memoizedState = newState;
      null === hook.baseQueue && (hook.baseState = newState);
      queue.lastRenderedState = newState;
    }
    return [newState, dispatch];
  }
  function updateSyncExternalStore(subscribe, getSnapshot, getServerSnapshot) {
    var fiber = currentlyRenderingFiber, hook = updateWorkInProgressHook(), isHydrating$jscomp$0 = isHydrating;
    if (isHydrating$jscomp$0) {
      if (void 0 === getServerSnapshot) throw Error(formatProdErrorMessage(407));
      getServerSnapshot = getServerSnapshot();
    } else getServerSnapshot = getSnapshot();
    var snapshotChanged = !objectIs(
      (currentHook || hook).memoizedState,
      getServerSnapshot
    );
    snapshotChanged && (hook.memoizedState = getServerSnapshot, didReceiveUpdate = true);
    hook = hook.queue;
    updateEffect(subscribeToStore.bind(null, fiber, hook, subscribe), [
      subscribe
    ]);
    if (hook.getSnapshot !== getSnapshot || snapshotChanged || null !== workInProgressHook && workInProgressHook.memoizedState.tag & 1) {
      fiber.flags |= 2048;
      pushSimpleEffect(
        9,
        { destroy: void 0 },
        updateStoreInstance.bind(
          null,
          fiber,
          hook,
          getServerSnapshot,
          getSnapshot
        ),
        null
      );
      if (null === workInProgressRoot) throw Error(formatProdErrorMessage(349));
      isHydrating$jscomp$0 || 0 !== (renderLanes & 127) || pushStoreConsistencyCheck(fiber, getSnapshot, getServerSnapshot);
    }
    return getServerSnapshot;
  }
  function pushStoreConsistencyCheck(fiber, getSnapshot, renderedSnapshot) {
    fiber.flags |= 16384;
    fiber = { getSnapshot, value: renderedSnapshot };
    getSnapshot = currentlyRenderingFiber.updateQueue;
    null === getSnapshot ? (getSnapshot = createFunctionComponentUpdateQueue(), currentlyRenderingFiber.updateQueue = getSnapshot, getSnapshot.stores = [fiber]) : (renderedSnapshot = getSnapshot.stores, null === renderedSnapshot ? getSnapshot.stores = [fiber] : renderedSnapshot.push(fiber));
  }
  function updateStoreInstance(fiber, inst, nextSnapshot, getSnapshot) {
    inst.value = nextSnapshot;
    inst.getSnapshot = getSnapshot;
    checkIfSnapshotChanged(inst) && forceStoreRerender(fiber);
  }
  function subscribeToStore(fiber, inst, subscribe) {
    return subscribe(function() {
      checkIfSnapshotChanged(inst) && forceStoreRerender(fiber);
    });
  }
  function checkIfSnapshotChanged(inst) {
    var latestGetSnapshot = inst.getSnapshot;
    inst = inst.value;
    try {
      var nextValue = latestGetSnapshot();
      return !objectIs(inst, nextValue);
    } catch (error) {
      return true;
    }
  }
  function forceStoreRerender(fiber) {
    var root2 = enqueueConcurrentRenderForLane(fiber, 2);
    null !== root2 && scheduleUpdateOnFiber(root2, fiber, 2);
  }
  function mountStateImpl(initialState) {
    var hook = mountWorkInProgressHook();
    if ("function" === typeof initialState) {
      var initialStateInitializer = initialState;
      initialState = initialStateInitializer();
      if (shouldDoubleInvokeUserFnsInHooksDEV) {
        setIsStrictModeForDevtools(true);
        try {
          initialStateInitializer();
        } finally {
          setIsStrictModeForDevtools(false);
        }
      }
    }
    hook.memoizedState = hook.baseState = initialState;
    hook.queue = {
      pending: null,
      lanes: 0,
      dispatch: null,
      lastRenderedReducer: basicStateReducer,
      lastRenderedState: initialState
    };
    return hook;
  }
  function updateOptimisticImpl(hook, current, passthrough, reducer) {
    hook.baseState = passthrough;
    return updateReducerImpl(
      hook,
      currentHook,
      "function" === typeof reducer ? reducer : basicStateReducer
    );
  }
  function dispatchActionState(fiber, actionQueue, setPendingState, setState, payload) {
    if (isRenderPhaseUpdate(fiber)) throw Error(formatProdErrorMessage(485));
    fiber = actionQueue.action;
    if (null !== fiber) {
      var actionNode = {
        payload,
        action: fiber,
        next: null,
        isTransition: true,
        status: "pending",
        value: null,
        reason: null,
        listeners: [],
        then: function(listener) {
          actionNode.listeners.push(listener);
        }
      };
      null !== ReactSharedInternals.T ? setPendingState(true) : actionNode.isTransition = false;
      setState(actionNode);
      setPendingState = actionQueue.pending;
      null === setPendingState ? (actionNode.next = actionQueue.pending = actionNode, runActionStateAction(actionQueue, actionNode)) : (actionNode.next = setPendingState.next, actionQueue.pending = setPendingState.next = actionNode);
    }
  }
  function runActionStateAction(actionQueue, node) {
    var action = node.action, payload = node.payload, prevState = actionQueue.state;
    if (node.isTransition) {
      var prevTransition = ReactSharedInternals.T, currentTransition = {};
      ReactSharedInternals.T = currentTransition;
      try {
        var returnValue = action(prevState, payload), onStartTransitionFinish = ReactSharedInternals.S;
        null !== onStartTransitionFinish && onStartTransitionFinish(currentTransition, returnValue);
        handleActionReturnValue(actionQueue, node, returnValue);
      } catch (error) {
        onActionError(actionQueue, node, error);
      } finally {
        null !== prevTransition && null !== currentTransition.types && (prevTransition.types = currentTransition.types), ReactSharedInternals.T = prevTransition;
      }
    } else
      try {
        prevTransition = action(prevState, payload), handleActionReturnValue(actionQueue, node, prevTransition);
      } catch (error$66) {
        onActionError(actionQueue, node, error$66);
      }
  }
  function handleActionReturnValue(actionQueue, node, returnValue) {
    null !== returnValue && "object" === typeof returnValue && "function" === typeof returnValue.then ? returnValue.then(
      function(nextState) {
        onActionSuccess(actionQueue, node, nextState);
      },
      function(error) {
        return onActionError(actionQueue, node, error);
      }
    ) : onActionSuccess(actionQueue, node, returnValue);
  }
  function onActionSuccess(actionQueue, actionNode, nextState) {
    actionNode.status = "fulfilled";
    actionNode.value = nextState;
    notifyActionListeners(actionNode);
    actionQueue.state = nextState;
    actionNode = actionQueue.pending;
    null !== actionNode && (nextState = actionNode.next, nextState === actionNode ? actionQueue.pending = null : (nextState = nextState.next, actionNode.next = nextState, runActionStateAction(actionQueue, nextState)));
  }
  function onActionError(actionQueue, actionNode, error) {
    var last = actionQueue.pending;
    actionQueue.pending = null;
    if (null !== last) {
      last = last.next;
      do
        actionNode.status = "rejected", actionNode.reason = error, notifyActionListeners(actionNode), actionNode = actionNode.next;
      while (actionNode !== last);
    }
    actionQueue.action = null;
  }
  function notifyActionListeners(actionNode) {
    actionNode = actionNode.listeners;
    for (var i3 = 0; i3 < actionNode.length; i3++) (0, actionNode[i3])();
  }
  function actionStateReducer(oldState, newState) {
    return newState;
  }
  function mountActionState(action, initialStateProp) {
    if (isHydrating) {
      var ssrFormState = workInProgressRoot.formState;
      if (null !== ssrFormState) {
        a: {
          var JSCompiler_inline_result = currentlyRenderingFiber;
          if (isHydrating) {
            if (nextHydratableInstance) {
              b: {
                var JSCompiler_inline_result$jscomp$0 = nextHydratableInstance;
                for (var inRootOrSingleton = rootOrSingletonContext; 8 !== JSCompiler_inline_result$jscomp$0.nodeType; ) {
                  if (!inRootOrSingleton) {
                    JSCompiler_inline_result$jscomp$0 = null;
                    break b;
                  }
                  JSCompiler_inline_result$jscomp$0 = getNextHydratable(
                    JSCompiler_inline_result$jscomp$0.nextSibling
                  );
                  if (null === JSCompiler_inline_result$jscomp$0) {
                    JSCompiler_inline_result$jscomp$0 = null;
                    break b;
                  }
                }
                inRootOrSingleton = JSCompiler_inline_result$jscomp$0.data;
                JSCompiler_inline_result$jscomp$0 = "F!" === inRootOrSingleton || "F" === inRootOrSingleton ? JSCompiler_inline_result$jscomp$0 : null;
              }
              if (JSCompiler_inline_result$jscomp$0) {
                nextHydratableInstance = getNextHydratable(
                  JSCompiler_inline_result$jscomp$0.nextSibling
                );
                JSCompiler_inline_result = "F!" === JSCompiler_inline_result$jscomp$0.data;
                break a;
              }
            }
            throwOnHydrationMismatch(JSCompiler_inline_result);
          }
          JSCompiler_inline_result = false;
        }
        JSCompiler_inline_result && (initialStateProp = ssrFormState[0]);
      }
    }
    ssrFormState = mountWorkInProgressHook();
    ssrFormState.memoizedState = ssrFormState.baseState = initialStateProp;
    JSCompiler_inline_result = {
      pending: null,
      lanes: 0,
      dispatch: null,
      lastRenderedReducer: actionStateReducer,
      lastRenderedState: initialStateProp
    };
    ssrFormState.queue = JSCompiler_inline_result;
    ssrFormState = dispatchSetState.bind(
      null,
      currentlyRenderingFiber,
      JSCompiler_inline_result
    );
    JSCompiler_inline_result.dispatch = ssrFormState;
    JSCompiler_inline_result = mountStateImpl(false);
    inRootOrSingleton = dispatchOptimisticSetState.bind(
      null,
      currentlyRenderingFiber,
      false,
      JSCompiler_inline_result.queue
    );
    JSCompiler_inline_result = mountWorkInProgressHook();
    JSCompiler_inline_result$jscomp$0 = {
      state: initialStateProp,
      dispatch: null,
      action,
      pending: null
    };
    JSCompiler_inline_result.queue = JSCompiler_inline_result$jscomp$0;
    ssrFormState = dispatchActionState.bind(
      null,
      currentlyRenderingFiber,
      JSCompiler_inline_result$jscomp$0,
      inRootOrSingleton,
      ssrFormState
    );
    JSCompiler_inline_result$jscomp$0.dispatch = ssrFormState;
    JSCompiler_inline_result.memoizedState = action;
    return [initialStateProp, ssrFormState, false];
  }
  function updateActionState(action) {
    var stateHook = updateWorkInProgressHook();
    return updateActionStateImpl(stateHook, currentHook, action);
  }
  function updateActionStateImpl(stateHook, currentStateHook, action) {
    currentStateHook = updateReducerImpl(
      stateHook,
      currentStateHook,
      actionStateReducer
    )[0];
    stateHook = updateReducer(basicStateReducer)[0];
    if ("object" === typeof currentStateHook && null !== currentStateHook && "function" === typeof currentStateHook.then)
      try {
        var state = useThenable(currentStateHook);
      } catch (x3) {
        if (x3 === SuspenseException) throw SuspenseActionException;
        throw x3;
      }
    else state = currentStateHook;
    currentStateHook = updateWorkInProgressHook();
    var actionQueue = currentStateHook.queue, dispatch = actionQueue.dispatch;
    action !== currentStateHook.memoizedState && (currentlyRenderingFiber.flags |= 2048, pushSimpleEffect(
      9,
      { destroy: void 0 },
      actionStateActionEffect.bind(null, actionQueue, action),
      null
    ));
    return [state, dispatch, stateHook];
  }
  function actionStateActionEffect(actionQueue, action) {
    actionQueue.action = action;
  }
  function rerenderActionState(action) {
    var stateHook = updateWorkInProgressHook(), currentStateHook = currentHook;
    if (null !== currentStateHook)
      return updateActionStateImpl(stateHook, currentStateHook, action);
    updateWorkInProgressHook();
    stateHook = stateHook.memoizedState;
    currentStateHook = updateWorkInProgressHook();
    var dispatch = currentStateHook.queue.dispatch;
    currentStateHook.memoizedState = action;
    return [stateHook, dispatch, false];
  }
  function pushSimpleEffect(tag, inst, create2, deps) {
    tag = { tag, create: create2, deps, inst, next: null };
    inst = currentlyRenderingFiber.updateQueue;
    null === inst && (inst = createFunctionComponentUpdateQueue(), currentlyRenderingFiber.updateQueue = inst);
    create2 = inst.lastEffect;
    null === create2 ? inst.lastEffect = tag.next = tag : (deps = create2.next, create2.next = tag, tag.next = deps, inst.lastEffect = tag);
    return tag;
  }
  function updateRef() {
    return updateWorkInProgressHook().memoizedState;
  }
  function mountEffectImpl(fiberFlags, hookFlags, create2, deps) {
    var hook = mountWorkInProgressHook();
    currentlyRenderingFiber.flags |= fiberFlags;
    hook.memoizedState = pushSimpleEffect(
      1 | hookFlags,
      { destroy: void 0 },
      create2,
      void 0 === deps ? null : deps
    );
  }
  function updateEffectImpl(fiberFlags, hookFlags, create2, deps) {
    var hook = updateWorkInProgressHook();
    deps = void 0 === deps ? null : deps;
    var inst = hook.memoizedState.inst;
    null !== currentHook && null !== deps && areHookInputsEqual(deps, currentHook.memoizedState.deps) ? hook.memoizedState = pushSimpleEffect(hookFlags, inst, create2, deps) : (currentlyRenderingFiber.flags |= fiberFlags, hook.memoizedState = pushSimpleEffect(
      1 | hookFlags,
      inst,
      create2,
      deps
    ));
  }
  function mountEffect(create2, deps) {
    mountEffectImpl(8390656, 8, create2, deps);
  }
  function updateEffect(create2, deps) {
    updateEffectImpl(2048, 8, create2, deps);
  }
  function useEffectEventImpl(payload) {
    currentlyRenderingFiber.flags |= 4;
    var componentUpdateQueue = currentlyRenderingFiber.updateQueue;
    if (null === componentUpdateQueue)
      componentUpdateQueue = createFunctionComponentUpdateQueue(), currentlyRenderingFiber.updateQueue = componentUpdateQueue, componentUpdateQueue.events = [payload];
    else {
      var events = componentUpdateQueue.events;
      null === events ? componentUpdateQueue.events = [payload] : events.push(payload);
    }
  }
  function updateEvent(callback) {
    var ref = updateWorkInProgressHook().memoizedState;
    useEffectEventImpl({ ref, nextImpl: callback });
    return function() {
      if (0 !== (executionContext & 2)) throw Error(formatProdErrorMessage(440));
      return ref.impl.apply(void 0, arguments);
    };
  }
  function updateInsertionEffect(create2, deps) {
    return updateEffectImpl(4, 2, create2, deps);
  }
  function updateLayoutEffect(create2, deps) {
    return updateEffectImpl(4, 4, create2, deps);
  }
  function imperativeHandleEffect(create2, ref) {
    if ("function" === typeof ref) {
      create2 = create2();
      var refCleanup = ref(create2);
      return function() {
        "function" === typeof refCleanup ? refCleanup() : ref(null);
      };
    }
    if (null !== ref && void 0 !== ref)
      return create2 = create2(), ref.current = create2, function() {
        ref.current = null;
      };
  }
  function updateImperativeHandle(ref, create2, deps) {
    deps = null !== deps && void 0 !== deps ? deps.concat([ref]) : null;
    updateEffectImpl(4, 4, imperativeHandleEffect.bind(null, create2, ref), deps);
  }
  function mountDebugValue() {
  }
  function updateCallback(callback, deps) {
    var hook = updateWorkInProgressHook();
    deps = void 0 === deps ? null : deps;
    var prevState = hook.memoizedState;
    if (null !== deps && areHookInputsEqual(deps, prevState[1]))
      return prevState[0];
    hook.memoizedState = [callback, deps];
    return callback;
  }
  function updateMemo(nextCreate, deps) {
    var hook = updateWorkInProgressHook();
    deps = void 0 === deps ? null : deps;
    var prevState = hook.memoizedState;
    if (null !== deps && areHookInputsEqual(deps, prevState[1]))
      return prevState[0];
    prevState = nextCreate();
    if (shouldDoubleInvokeUserFnsInHooksDEV) {
      setIsStrictModeForDevtools(true);
      try {
        nextCreate();
      } finally {
        setIsStrictModeForDevtools(false);
      }
    }
    hook.memoizedState = [prevState, deps];
    return prevState;
  }
  function mountDeferredValueImpl(hook, value, initialValue) {
    if (void 0 === initialValue || 0 !== (renderLanes & 1073741824) && 0 === (workInProgressRootRenderLanes & 261930))
      return hook.memoizedState = value;
    hook.memoizedState = initialValue;
    hook = requestDeferredLane();
    currentlyRenderingFiber.lanes |= hook;
    workInProgressRootSkippedLanes |= hook;
    return initialValue;
  }
  function updateDeferredValueImpl(hook, prevValue, value, initialValue) {
    if (objectIs(value, prevValue)) return value;
    if (null !== currentTreeHiddenStackCursor.current)
      return hook = mountDeferredValueImpl(hook, value, initialValue), objectIs(hook, prevValue) || (didReceiveUpdate = true), hook;
    if (0 === (renderLanes & 42) || 0 !== (renderLanes & 1073741824) && 0 === (workInProgressRootRenderLanes & 261930))
      return didReceiveUpdate = true, hook.memoizedState = value;
    hook = requestDeferredLane();
    currentlyRenderingFiber.lanes |= hook;
    workInProgressRootSkippedLanes |= hook;
    return prevValue;
  }
  function startTransition(fiber, queue, pendingState, finishedState, callback) {
    var previousPriority = ReactDOMSharedInternals.p;
    ReactDOMSharedInternals.p = 0 !== previousPriority && 8 > previousPriority ? previousPriority : 8;
    var prevTransition = ReactSharedInternals.T, currentTransition = {};
    ReactSharedInternals.T = currentTransition;
    dispatchOptimisticSetState(fiber, false, queue, pendingState);
    try {
      var returnValue = callback(), onStartTransitionFinish = ReactSharedInternals.S;
      null !== onStartTransitionFinish && onStartTransitionFinish(currentTransition, returnValue);
      if (null !== returnValue && "object" === typeof returnValue && "function" === typeof returnValue.then) {
        var thenableForFinishedState = chainThenableValue(
          returnValue,
          finishedState
        );
        dispatchSetStateInternal(
          fiber,
          queue,
          thenableForFinishedState,
          requestUpdateLane(fiber)
        );
      } else
        dispatchSetStateInternal(
          fiber,
          queue,
          finishedState,
          requestUpdateLane(fiber)
        );
    } catch (error) {
      dispatchSetStateInternal(
        fiber,
        queue,
        { then: function() {
        }, status: "rejected", reason: error },
        requestUpdateLane()
      );
    } finally {
      ReactDOMSharedInternals.p = previousPriority, null !== prevTransition && null !== currentTransition.types && (prevTransition.types = currentTransition.types), ReactSharedInternals.T = prevTransition;
    }
  }
  function noop3() {
  }
  function startHostTransition(formFiber, pendingState, action, formData) {
    if (5 !== formFiber.tag) throw Error(formatProdErrorMessage(476));
    var queue = ensureFormComponentIsStateful(formFiber).queue;
    startTransition(
      formFiber,
      queue,
      pendingState,
      sharedNotPendingObject,
      null === action ? noop3 : function() {
        requestFormReset$1(formFiber);
        return action(formData);
      }
    );
  }
  function ensureFormComponentIsStateful(formFiber) {
    var existingStateHook = formFiber.memoizedState;
    if (null !== existingStateHook) return existingStateHook;
    existingStateHook = {
      memoizedState: sharedNotPendingObject,
      baseState: sharedNotPendingObject,
      baseQueue: null,
      queue: {
        pending: null,
        lanes: 0,
        dispatch: null,
        lastRenderedReducer: basicStateReducer,
        lastRenderedState: sharedNotPendingObject
      },
      next: null
    };
    var initialResetState = {};
    existingStateHook.next = {
      memoizedState: initialResetState,
      baseState: initialResetState,
      baseQueue: null,
      queue: {
        pending: null,
        lanes: 0,
        dispatch: null,
        lastRenderedReducer: basicStateReducer,
        lastRenderedState: initialResetState
      },
      next: null
    };
    formFiber.memoizedState = existingStateHook;
    formFiber = formFiber.alternate;
    null !== formFiber && (formFiber.memoizedState = existingStateHook);
    return existingStateHook;
  }
  function requestFormReset$1(formFiber) {
    var stateHook = ensureFormComponentIsStateful(formFiber);
    null === stateHook.next && (stateHook = formFiber.alternate.memoizedState);
    dispatchSetStateInternal(
      formFiber,
      stateHook.next.queue,
      {},
      requestUpdateLane()
    );
  }
  function useHostTransitionStatus() {
    return readContext(HostTransitionContext);
  }
  function updateId() {
    return updateWorkInProgressHook().memoizedState;
  }
  function updateRefresh() {
    return updateWorkInProgressHook().memoizedState;
  }
  function refreshCache(fiber) {
    for (var provider = fiber.return; null !== provider; ) {
      switch (provider.tag) {
        case 24:
        case 3:
          var lane = requestUpdateLane();
          fiber = createUpdate(lane);
          var root$69 = enqueueUpdate(provider, fiber, lane);
          null !== root$69 && (scheduleUpdateOnFiber(root$69, provider, lane), entangleTransitions(root$69, provider, lane));
          provider = { cache: createCache() };
          fiber.payload = provider;
          return;
      }
      provider = provider.return;
    }
  }
  function dispatchReducerAction(fiber, queue, action) {
    var lane = requestUpdateLane();
    action = {
      lane,
      revertLane: 0,
      gesture: null,
      action,
      hasEagerState: false,
      eagerState: null,
      next: null
    };
    isRenderPhaseUpdate(fiber) ? enqueueRenderPhaseUpdate(queue, action) : (action = enqueueConcurrentHookUpdate(fiber, queue, action, lane), null !== action && (scheduleUpdateOnFiber(action, fiber, lane), entangleTransitionUpdate(action, queue, lane)));
  }
  function dispatchSetState(fiber, queue, action) {
    var lane = requestUpdateLane();
    dispatchSetStateInternal(fiber, queue, action, lane);
  }
  function dispatchSetStateInternal(fiber, queue, action, lane) {
    var update = {
      lane,
      revertLane: 0,
      gesture: null,
      action,
      hasEagerState: false,
      eagerState: null,
      next: null
    };
    if (isRenderPhaseUpdate(fiber)) enqueueRenderPhaseUpdate(queue, update);
    else {
      var alternate = fiber.alternate;
      if (0 === fiber.lanes && (null === alternate || 0 === alternate.lanes) && (alternate = queue.lastRenderedReducer, null !== alternate))
        try {
          var currentState = queue.lastRenderedState, eagerState = alternate(currentState, action);
          update.hasEagerState = true;
          update.eagerState = eagerState;
          if (objectIs(eagerState, currentState))
            return enqueueUpdate$1(fiber, queue, update, 0), null === workInProgressRoot && finishQueueingConcurrentUpdates(), false;
        } catch (error) {
        } finally {
        }
      action = enqueueConcurrentHookUpdate(fiber, queue, update, lane);
      if (null !== action)
        return scheduleUpdateOnFiber(action, fiber, lane), entangleTransitionUpdate(action, queue, lane), true;
    }
    return false;
  }
  function dispatchOptimisticSetState(fiber, throwIfDuringRender, queue, action) {
    action = {
      lane: 2,
      revertLane: requestTransitionLane(),
      gesture: null,
      action,
      hasEagerState: false,
      eagerState: null,
      next: null
    };
    if (isRenderPhaseUpdate(fiber)) {
      if (throwIfDuringRender) throw Error(formatProdErrorMessage(479));
    } else
      throwIfDuringRender = enqueueConcurrentHookUpdate(
        fiber,
        queue,
        action,
        2
      ), null !== throwIfDuringRender && scheduleUpdateOnFiber(throwIfDuringRender, fiber, 2);
  }
  function isRenderPhaseUpdate(fiber) {
    var alternate = fiber.alternate;
    return fiber === currentlyRenderingFiber || null !== alternate && alternate === currentlyRenderingFiber;
  }
  function enqueueRenderPhaseUpdate(queue, update) {
    didScheduleRenderPhaseUpdateDuringThisPass = didScheduleRenderPhaseUpdate = true;
    var pending = queue.pending;
    null === pending ? update.next = update : (update.next = pending.next, pending.next = update);
    queue.pending = update;
  }
  function entangleTransitionUpdate(root2, queue, lane) {
    if (0 !== (lane & 4194048)) {
      var queueLanes = queue.lanes;
      queueLanes &= root2.pendingLanes;
      lane |= queueLanes;
      queue.lanes = lane;
      markRootEntangled(root2, lane);
    }
  }
  var ContextOnlyDispatcher = {
    readContext,
    use: use2,
    useCallback: throwInvalidHookError,
    useContext: throwInvalidHookError,
    useEffect: throwInvalidHookError,
    useImperativeHandle: throwInvalidHookError,
    useLayoutEffect: throwInvalidHookError,
    useInsertionEffect: throwInvalidHookError,
    useMemo: throwInvalidHookError,
    useReducer: throwInvalidHookError,
    useRef: throwInvalidHookError,
    useState: throwInvalidHookError,
    useDebugValue: throwInvalidHookError,
    useDeferredValue: throwInvalidHookError,
    useTransition: throwInvalidHookError,
    useSyncExternalStore: throwInvalidHookError,
    useId: throwInvalidHookError,
    useHostTransitionStatus: throwInvalidHookError,
    useFormState: throwInvalidHookError,
    useActionState: throwInvalidHookError,
    useOptimistic: throwInvalidHookError,
    useMemoCache: throwInvalidHookError,
    useCacheRefresh: throwInvalidHookError
  };
  ContextOnlyDispatcher.useEffectEvent = throwInvalidHookError;
  var HooksDispatcherOnMount = {
    readContext,
    use: use2,
    useCallback: function(callback, deps) {
      mountWorkInProgressHook().memoizedState = [
        callback,
        void 0 === deps ? null : deps
      ];
      return callback;
    },
    useContext: readContext,
    useEffect: mountEffect,
    useImperativeHandle: function(ref, create2, deps) {
      deps = null !== deps && void 0 !== deps ? deps.concat([ref]) : null;
      mountEffectImpl(
        4194308,
        4,
        imperativeHandleEffect.bind(null, create2, ref),
        deps
      );
    },
    useLayoutEffect: function(create2, deps) {
      return mountEffectImpl(4194308, 4, create2, deps);
    },
    useInsertionEffect: function(create2, deps) {
      mountEffectImpl(4, 2, create2, deps);
    },
    useMemo: function(nextCreate, deps) {
      var hook = mountWorkInProgressHook();
      deps = void 0 === deps ? null : deps;
      var nextValue = nextCreate();
      if (shouldDoubleInvokeUserFnsInHooksDEV) {
        setIsStrictModeForDevtools(true);
        try {
          nextCreate();
        } finally {
          setIsStrictModeForDevtools(false);
        }
      }
      hook.memoizedState = [nextValue, deps];
      return nextValue;
    },
    useReducer: function(reducer, initialArg, init) {
      var hook = mountWorkInProgressHook();
      if (void 0 !== init) {
        var initialState = init(initialArg);
        if (shouldDoubleInvokeUserFnsInHooksDEV) {
          setIsStrictModeForDevtools(true);
          try {
            init(initialArg);
          } finally {
            setIsStrictModeForDevtools(false);
          }
        }
      } else initialState = initialArg;
      hook.memoizedState = hook.baseState = initialState;
      reducer = {
        pending: null,
        lanes: 0,
        dispatch: null,
        lastRenderedReducer: reducer,
        lastRenderedState: initialState
      };
      hook.queue = reducer;
      reducer = reducer.dispatch = dispatchReducerAction.bind(
        null,
        currentlyRenderingFiber,
        reducer
      );
      return [hook.memoizedState, reducer];
    },
    useRef: function(initialValue) {
      var hook = mountWorkInProgressHook();
      initialValue = { current: initialValue };
      return hook.memoizedState = initialValue;
    },
    useState: function(initialState) {
      initialState = mountStateImpl(initialState);
      var queue = initialState.queue, dispatch = dispatchSetState.bind(null, currentlyRenderingFiber, queue);
      queue.dispatch = dispatch;
      return [initialState.memoizedState, dispatch];
    },
    useDebugValue: mountDebugValue,
    useDeferredValue: function(value, initialValue) {
      var hook = mountWorkInProgressHook();
      return mountDeferredValueImpl(hook, value, initialValue);
    },
    useTransition: function() {
      var stateHook = mountStateImpl(false);
      stateHook = startTransition.bind(
        null,
        currentlyRenderingFiber,
        stateHook.queue,
        true,
        false
      );
      mountWorkInProgressHook().memoizedState = stateHook;
      return [false, stateHook];
    },
    useSyncExternalStore: function(subscribe, getSnapshot, getServerSnapshot) {
      var fiber = currentlyRenderingFiber, hook = mountWorkInProgressHook();
      if (isHydrating) {
        if (void 0 === getServerSnapshot)
          throw Error(formatProdErrorMessage(407));
        getServerSnapshot = getServerSnapshot();
      } else {
        getServerSnapshot = getSnapshot();
        if (null === workInProgressRoot)
          throw Error(formatProdErrorMessage(349));
        0 !== (workInProgressRootRenderLanes & 127) || pushStoreConsistencyCheck(fiber, getSnapshot, getServerSnapshot);
      }
      hook.memoizedState = getServerSnapshot;
      var inst = { value: getServerSnapshot, getSnapshot };
      hook.queue = inst;
      mountEffect(subscribeToStore.bind(null, fiber, inst, subscribe), [
        subscribe
      ]);
      fiber.flags |= 2048;
      pushSimpleEffect(
        9,
        { destroy: void 0 },
        updateStoreInstance.bind(
          null,
          fiber,
          inst,
          getServerSnapshot,
          getSnapshot
        ),
        null
      );
      return getServerSnapshot;
    },
    useId: function() {
      var hook = mountWorkInProgressHook(), identifierPrefix = workInProgressRoot.identifierPrefix;
      if (isHydrating) {
        var JSCompiler_inline_result = treeContextOverflow;
        var idWithLeadingBit = treeContextId;
        JSCompiler_inline_result = (idWithLeadingBit & ~(1 << 32 - clz32(idWithLeadingBit) - 1)).toString(32) + JSCompiler_inline_result;
        identifierPrefix = "_" + identifierPrefix + "R_" + JSCompiler_inline_result;
        JSCompiler_inline_result = localIdCounter++;
        0 < JSCompiler_inline_result && (identifierPrefix += "H" + JSCompiler_inline_result.toString(32));
        identifierPrefix += "_";
      } else
        JSCompiler_inline_result = globalClientIdCounter++, identifierPrefix = "_" + identifierPrefix + "r_" + JSCompiler_inline_result.toString(32) + "_";
      return hook.memoizedState = identifierPrefix;
    },
    useHostTransitionStatus,
    useFormState: mountActionState,
    useActionState: mountActionState,
    useOptimistic: function(passthrough) {
      var hook = mountWorkInProgressHook();
      hook.memoizedState = hook.baseState = passthrough;
      var queue = {
        pending: null,
        lanes: 0,
        dispatch: null,
        lastRenderedReducer: null,
        lastRenderedState: null
      };
      hook.queue = queue;
      hook = dispatchOptimisticSetState.bind(
        null,
        currentlyRenderingFiber,
        true,
        queue
      );
      queue.dispatch = hook;
      return [passthrough, hook];
    },
    useMemoCache,
    useCacheRefresh: function() {
      return mountWorkInProgressHook().memoizedState = refreshCache.bind(
        null,
        currentlyRenderingFiber
      );
    },
    useEffectEvent: function(callback) {
      var hook = mountWorkInProgressHook(), ref = { impl: callback };
      hook.memoizedState = ref;
      return function() {
        if (0 !== (executionContext & 2))
          throw Error(formatProdErrorMessage(440));
        return ref.impl.apply(void 0, arguments);
      };
    }
  }, HooksDispatcherOnUpdate = {
    readContext,
    use: use2,
    useCallback: updateCallback,
    useContext: readContext,
    useEffect: updateEffect,
    useImperativeHandle: updateImperativeHandle,
    useInsertionEffect: updateInsertionEffect,
    useLayoutEffect: updateLayoutEffect,
    useMemo: updateMemo,
    useReducer: updateReducer,
    useRef: updateRef,
    useState: function() {
      return updateReducer(basicStateReducer);
    },
    useDebugValue: mountDebugValue,
    useDeferredValue: function(value, initialValue) {
      var hook = updateWorkInProgressHook();
      return updateDeferredValueImpl(
        hook,
        currentHook.memoizedState,
        value,
        initialValue
      );
    },
    useTransition: function() {
      var booleanOrThenable = updateReducer(basicStateReducer)[0], start = updateWorkInProgressHook().memoizedState;
      return [
        "boolean" === typeof booleanOrThenable ? booleanOrThenable : useThenable(booleanOrThenable),
        start
      ];
    },
    useSyncExternalStore: updateSyncExternalStore,
    useId: updateId,
    useHostTransitionStatus,
    useFormState: updateActionState,
    useActionState: updateActionState,
    useOptimistic: function(passthrough, reducer) {
      var hook = updateWorkInProgressHook();
      return updateOptimisticImpl(hook, currentHook, passthrough, reducer);
    },
    useMemoCache,
    useCacheRefresh: updateRefresh
  };
  HooksDispatcherOnUpdate.useEffectEvent = updateEvent;
  var HooksDispatcherOnRerender = {
    readContext,
    use: use2,
    useCallback: updateCallback,
    useContext: readContext,
    useEffect: updateEffect,
    useImperativeHandle: updateImperativeHandle,
    useInsertionEffect: updateInsertionEffect,
    useLayoutEffect: updateLayoutEffect,
    useMemo: updateMemo,
    useReducer: rerenderReducer,
    useRef: updateRef,
    useState: function() {
      return rerenderReducer(basicStateReducer);
    },
    useDebugValue: mountDebugValue,
    useDeferredValue: function(value, initialValue) {
      var hook = updateWorkInProgressHook();
      return null === currentHook ? mountDeferredValueImpl(hook, value, initialValue) : updateDeferredValueImpl(
        hook,
        currentHook.memoizedState,
        value,
        initialValue
      );
    },
    useTransition: function() {
      var booleanOrThenable = rerenderReducer(basicStateReducer)[0], start = updateWorkInProgressHook().memoizedState;
      return [
        "boolean" === typeof booleanOrThenable ? booleanOrThenable : useThenable(booleanOrThenable),
        start
      ];
    },
    useSyncExternalStore: updateSyncExternalStore,
    useId: updateId,
    useHostTransitionStatus,
    useFormState: rerenderActionState,
    useActionState: rerenderActionState,
    useOptimistic: function(passthrough, reducer) {
      var hook = updateWorkInProgressHook();
      if (null !== currentHook)
        return updateOptimisticImpl(hook, currentHook, passthrough, reducer);
      hook.baseState = passthrough;
      return [passthrough, hook.queue.dispatch];
    },
    useMemoCache,
    useCacheRefresh: updateRefresh
  };
  HooksDispatcherOnRerender.useEffectEvent = updateEvent;
  function applyDerivedStateFromProps(workInProgress2, ctor, getDerivedStateFromProps, nextProps) {
    ctor = workInProgress2.memoizedState;
    getDerivedStateFromProps = getDerivedStateFromProps(nextProps, ctor);
    getDerivedStateFromProps = null === getDerivedStateFromProps || void 0 === getDerivedStateFromProps ? ctor : assign2({}, ctor, getDerivedStateFromProps);
    workInProgress2.memoizedState = getDerivedStateFromProps;
    0 === workInProgress2.lanes && (workInProgress2.updateQueue.baseState = getDerivedStateFromProps);
  }
  var classComponentUpdater = {
    enqueueSetState: function(inst, payload, callback) {
      inst = inst._reactInternals;
      var lane = requestUpdateLane(), update = createUpdate(lane);
      update.payload = payload;
      void 0 !== callback && null !== callback && (update.callback = callback);
      payload = enqueueUpdate(inst, update, lane);
      null !== payload && (scheduleUpdateOnFiber(payload, inst, lane), entangleTransitions(payload, inst, lane));
    },
    enqueueReplaceState: function(inst, payload, callback) {
      inst = inst._reactInternals;
      var lane = requestUpdateLane(), update = createUpdate(lane);
      update.tag = 1;
      update.payload = payload;
      void 0 !== callback && null !== callback && (update.callback = callback);
      payload = enqueueUpdate(inst, update, lane);
      null !== payload && (scheduleUpdateOnFiber(payload, inst, lane), entangleTransitions(payload, inst, lane));
    },
    enqueueForceUpdate: function(inst, callback) {
      inst = inst._reactInternals;
      var lane = requestUpdateLane(), update = createUpdate(lane);
      update.tag = 2;
      void 0 !== callback && null !== callback && (update.callback = callback);
      callback = enqueueUpdate(inst, update, lane);
      null !== callback && (scheduleUpdateOnFiber(callback, inst, lane), entangleTransitions(callback, inst, lane));
    }
  };
  function checkShouldComponentUpdate(workInProgress2, ctor, oldProps, newProps, oldState, newState, nextContext) {
    workInProgress2 = workInProgress2.stateNode;
    return "function" === typeof workInProgress2.shouldComponentUpdate ? workInProgress2.shouldComponentUpdate(newProps, newState, nextContext) : ctor.prototype && ctor.prototype.isPureReactComponent ? !shallowEqual(oldProps, newProps) || !shallowEqual(oldState, newState) : true;
  }
  function callComponentWillReceiveProps(workInProgress2, instance, newProps, nextContext) {
    workInProgress2 = instance.state;
    "function" === typeof instance.componentWillReceiveProps && instance.componentWillReceiveProps(newProps, nextContext);
    "function" === typeof instance.UNSAFE_componentWillReceiveProps && instance.UNSAFE_componentWillReceiveProps(newProps, nextContext);
    instance.state !== workInProgress2 && classComponentUpdater.enqueueReplaceState(instance, instance.state, null);
  }
  function resolveClassComponentProps(Component, baseProps) {
    var newProps = baseProps;
    if ("ref" in baseProps) {
      newProps = {};
      for (var propName in baseProps)
        "ref" !== propName && (newProps[propName] = baseProps[propName]);
    }
    if (Component = Component.defaultProps) {
      newProps === baseProps && (newProps = assign2({}, newProps));
      for (var propName$73 in Component)
        void 0 === newProps[propName$73] && (newProps[propName$73] = Component[propName$73]);
    }
    return newProps;
  }
  function defaultOnUncaughtError(error) {
    reportGlobalError(error);
  }
  function defaultOnCaughtError(error) {
    console.error(error);
  }
  function defaultOnRecoverableError(error) {
    reportGlobalError(error);
  }
  function logUncaughtError(root2, errorInfo) {
    try {
      var onUncaughtError = root2.onUncaughtError;
      onUncaughtError(errorInfo.value, { componentStack: errorInfo.stack });
    } catch (e$74) {
      setTimeout(function() {
        throw e$74;
      });
    }
  }
  function logCaughtError(root2, boundary, errorInfo) {
    try {
      var onCaughtError = root2.onCaughtError;
      onCaughtError(errorInfo.value, {
        componentStack: errorInfo.stack,
        errorBoundary: 1 === boundary.tag ? boundary.stateNode : null
      });
    } catch (e$75) {
      setTimeout(function() {
        throw e$75;
      });
    }
  }
  function createRootErrorUpdate(root2, errorInfo, lane) {
    lane = createUpdate(lane);
    lane.tag = 3;
    lane.payload = { element: null };
    lane.callback = function() {
      logUncaughtError(root2, errorInfo);
    };
    return lane;
  }
  function createClassErrorUpdate(lane) {
    lane = createUpdate(lane);
    lane.tag = 3;
    return lane;
  }
  function initializeClassErrorUpdate(update, root2, fiber, errorInfo) {
    var getDerivedStateFromError = fiber.type.getDerivedStateFromError;
    if ("function" === typeof getDerivedStateFromError) {
      var error = errorInfo.value;
      update.payload = function() {
        return getDerivedStateFromError(error);
      };
      update.callback = function() {
        logCaughtError(root2, fiber, errorInfo);
      };
    }
    var inst = fiber.stateNode;
    null !== inst && "function" === typeof inst.componentDidCatch && (update.callback = function() {
      logCaughtError(root2, fiber, errorInfo);
      "function" !== typeof getDerivedStateFromError && (null === legacyErrorBoundariesThatAlreadyFailed ? legacyErrorBoundariesThatAlreadyFailed = /* @__PURE__ */ new Set([this]) : legacyErrorBoundariesThatAlreadyFailed.add(this));
      var stack = errorInfo.stack;
      this.componentDidCatch(errorInfo.value, {
        componentStack: null !== stack ? stack : ""
      });
    });
  }
  function throwException(root2, returnFiber, sourceFiber, value, rootRenderLanes) {
    sourceFiber.flags |= 32768;
    if (null !== value && "object" === typeof value && "function" === typeof value.then) {
      returnFiber = sourceFiber.alternate;
      null !== returnFiber && propagateParentContextChanges(
        returnFiber,
        sourceFiber,
        rootRenderLanes,
        true
      );
      sourceFiber = suspenseHandlerStackCursor.current;
      if (null !== sourceFiber) {
        switch (sourceFiber.tag) {
          case 31:
          case 13:
            return null === shellBoundary ? renderDidSuspendDelayIfPossible() : null === sourceFiber.alternate && 0 === workInProgressRootExitStatus && (workInProgressRootExitStatus = 3), sourceFiber.flags &= -257, sourceFiber.flags |= 65536, sourceFiber.lanes = rootRenderLanes, value === noopSuspenseyCommitThenable ? sourceFiber.flags |= 16384 : (returnFiber = sourceFiber.updateQueue, null === returnFiber ? sourceFiber.updateQueue = /* @__PURE__ */ new Set([value]) : returnFiber.add(value), attachPingListener(root2, value, rootRenderLanes)), false;
          case 22:
            return sourceFiber.flags |= 65536, value === noopSuspenseyCommitThenable ? sourceFiber.flags |= 16384 : (returnFiber = sourceFiber.updateQueue, null === returnFiber ? (returnFiber = {
              transitions: null,
              markerInstances: null,
              retryQueue: /* @__PURE__ */ new Set([value])
            }, sourceFiber.updateQueue = returnFiber) : (sourceFiber = returnFiber.retryQueue, null === sourceFiber ? returnFiber.retryQueue = /* @__PURE__ */ new Set([value]) : sourceFiber.add(value)), attachPingListener(root2, value, rootRenderLanes)), false;
        }
        throw Error(formatProdErrorMessage(435, sourceFiber.tag));
      }
      attachPingListener(root2, value, rootRenderLanes);
      renderDidSuspendDelayIfPossible();
      return false;
    }
    if (isHydrating)
      return returnFiber = suspenseHandlerStackCursor.current, null !== returnFiber ? (0 === (returnFiber.flags & 65536) && (returnFiber.flags |= 256), returnFiber.flags |= 65536, returnFiber.lanes = rootRenderLanes, value !== HydrationMismatchException && (root2 = Error(formatProdErrorMessage(422), { cause: value }), queueHydrationError(createCapturedValueAtFiber(root2, sourceFiber)))) : (value !== HydrationMismatchException && (returnFiber = Error(formatProdErrorMessage(423), {
        cause: value
      }), queueHydrationError(
        createCapturedValueAtFiber(returnFiber, sourceFiber)
      )), root2 = root2.current.alternate, root2.flags |= 65536, rootRenderLanes &= -rootRenderLanes, root2.lanes |= rootRenderLanes, value = createCapturedValueAtFiber(value, sourceFiber), rootRenderLanes = createRootErrorUpdate(
        root2.stateNode,
        value,
        rootRenderLanes
      ), enqueueCapturedUpdate(root2, rootRenderLanes), 4 !== workInProgressRootExitStatus && (workInProgressRootExitStatus = 2)), false;
    var wrapperError = Error(formatProdErrorMessage(520), { cause: value });
    wrapperError = createCapturedValueAtFiber(wrapperError, sourceFiber);
    null === workInProgressRootConcurrentErrors ? workInProgressRootConcurrentErrors = [wrapperError] : workInProgressRootConcurrentErrors.push(wrapperError);
    4 !== workInProgressRootExitStatus && (workInProgressRootExitStatus = 2);
    if (null === returnFiber) return true;
    value = createCapturedValueAtFiber(value, sourceFiber);
    sourceFiber = returnFiber;
    do {
      switch (sourceFiber.tag) {
        case 3:
          return sourceFiber.flags |= 65536, root2 = rootRenderLanes & -rootRenderLanes, sourceFiber.lanes |= root2, root2 = createRootErrorUpdate(sourceFiber.stateNode, value, root2), enqueueCapturedUpdate(sourceFiber, root2), false;
        case 1:
          if (returnFiber = sourceFiber.type, wrapperError = sourceFiber.stateNode, 0 === (sourceFiber.flags & 128) && ("function" === typeof returnFiber.getDerivedStateFromError || null !== wrapperError && "function" === typeof wrapperError.componentDidCatch && (null === legacyErrorBoundariesThatAlreadyFailed || !legacyErrorBoundariesThatAlreadyFailed.has(wrapperError))))
            return sourceFiber.flags |= 65536, rootRenderLanes &= -rootRenderLanes, sourceFiber.lanes |= rootRenderLanes, rootRenderLanes = createClassErrorUpdate(rootRenderLanes), initializeClassErrorUpdate(
              rootRenderLanes,
              root2,
              sourceFiber,
              value
            ), enqueueCapturedUpdate(sourceFiber, rootRenderLanes), false;
      }
      sourceFiber = sourceFiber.return;
    } while (null !== sourceFiber);
    return false;
  }
  var SelectiveHydrationException = Error(formatProdErrorMessage(461)), didReceiveUpdate = false;
  function reconcileChildren(current, workInProgress2, nextChildren, renderLanes2) {
    workInProgress2.child = null === current ? mountChildFibers(workInProgress2, null, nextChildren, renderLanes2) : reconcileChildFibers(
      workInProgress2,
      current.child,
      nextChildren,
      renderLanes2
    );
  }
  function updateForwardRef(current, workInProgress2, Component, nextProps, renderLanes2) {
    Component = Component.render;
    var ref = workInProgress2.ref;
    if ("ref" in nextProps) {
      var propsWithoutRef = {};
      for (var key in nextProps)
        "ref" !== key && (propsWithoutRef[key] = nextProps[key]);
    } else propsWithoutRef = nextProps;
    prepareToReadContext(workInProgress2);
    nextProps = renderWithHooks(
      current,
      workInProgress2,
      Component,
      propsWithoutRef,
      ref,
      renderLanes2
    );
    key = checkDidRenderIdHook();
    if (null !== current && !didReceiveUpdate)
      return bailoutHooks(current, workInProgress2, renderLanes2), bailoutOnAlreadyFinishedWork(current, workInProgress2, renderLanes2);
    isHydrating && key && pushMaterializedTreeId(workInProgress2);
    workInProgress2.flags |= 1;
    reconcileChildren(current, workInProgress2, nextProps, renderLanes2);
    return workInProgress2.child;
  }
  function updateMemoComponent(current, workInProgress2, Component, nextProps, renderLanes2) {
    if (null === current) {
      var type = Component.type;
      if ("function" === typeof type && !shouldConstruct(type) && void 0 === type.defaultProps && null === Component.compare)
        return workInProgress2.tag = 15, workInProgress2.type = type, updateSimpleMemoComponent(
          current,
          workInProgress2,
          type,
          nextProps,
          renderLanes2
        );
      current = createFiberFromTypeAndProps(
        Component.type,
        null,
        nextProps,
        workInProgress2,
        workInProgress2.mode,
        renderLanes2
      );
      current.ref = workInProgress2.ref;
      current.return = workInProgress2;
      return workInProgress2.child = current;
    }
    type = current.child;
    if (!checkScheduledUpdateOrContext(current, renderLanes2)) {
      var prevProps = type.memoizedProps;
      Component = Component.compare;
      Component = null !== Component ? Component : shallowEqual;
      if (Component(prevProps, nextProps) && current.ref === workInProgress2.ref)
        return bailoutOnAlreadyFinishedWork(current, workInProgress2, renderLanes2);
    }
    workInProgress2.flags |= 1;
    current = createWorkInProgress(type, nextProps);
    current.ref = workInProgress2.ref;
    current.return = workInProgress2;
    return workInProgress2.child = current;
  }
  function updateSimpleMemoComponent(current, workInProgress2, Component, nextProps, renderLanes2) {
    if (null !== current) {
      var prevProps = current.memoizedProps;
      if (shallowEqual(prevProps, nextProps) && current.ref === workInProgress2.ref)
        if (didReceiveUpdate = false, workInProgress2.pendingProps = nextProps = prevProps, checkScheduledUpdateOrContext(current, renderLanes2))
          0 !== (current.flags & 131072) && (didReceiveUpdate = true);
        else
          return workInProgress2.lanes = current.lanes, bailoutOnAlreadyFinishedWork(current, workInProgress2, renderLanes2);
    }
    return updateFunctionComponent(
      current,
      workInProgress2,
      Component,
      nextProps,
      renderLanes2
    );
  }
  function updateOffscreenComponent(current, workInProgress2, renderLanes2, nextProps) {
    var nextChildren = nextProps.children, prevState = null !== current ? current.memoizedState : null;
    null === current && null === workInProgress2.stateNode && (workInProgress2.stateNode = {
      _visibility: 1,
      _pendingMarkers: null,
      _retryCache: null,
      _transitions: null
    });
    if ("hidden" === nextProps.mode) {
      if (0 !== (workInProgress2.flags & 128)) {
        prevState = null !== prevState ? prevState.baseLanes | renderLanes2 : renderLanes2;
        if (null !== current) {
          nextProps = workInProgress2.child = current.child;
          for (nextChildren = 0; null !== nextProps; )
            nextChildren = nextChildren | nextProps.lanes | nextProps.childLanes, nextProps = nextProps.sibling;
          nextProps = nextChildren & ~prevState;
        } else nextProps = 0, workInProgress2.child = null;
        return deferHiddenOffscreenComponent(
          current,
          workInProgress2,
          prevState,
          renderLanes2,
          nextProps
        );
      }
      if (0 !== (renderLanes2 & 536870912))
        workInProgress2.memoizedState = { baseLanes: 0, cachePool: null }, null !== current && pushTransition(
          workInProgress2,
          null !== prevState ? prevState.cachePool : null
        ), null !== prevState ? pushHiddenContext(workInProgress2, prevState) : reuseHiddenContextOnStack(), pushOffscreenSuspenseHandler(workInProgress2);
      else
        return nextProps = workInProgress2.lanes = 536870912, deferHiddenOffscreenComponent(
          current,
          workInProgress2,
          null !== prevState ? prevState.baseLanes | renderLanes2 : renderLanes2,
          renderLanes2,
          nextProps
        );
    } else
      null !== prevState ? (pushTransition(workInProgress2, prevState.cachePool), pushHiddenContext(workInProgress2, prevState), reuseSuspenseHandlerOnStack(), workInProgress2.memoizedState = null) : (null !== current && pushTransition(workInProgress2, null), reuseHiddenContextOnStack(), reuseSuspenseHandlerOnStack());
    reconcileChildren(current, workInProgress2, nextChildren, renderLanes2);
    return workInProgress2.child;
  }
  function bailoutOffscreenComponent(current, workInProgress2) {
    null !== current && 22 === current.tag || null !== workInProgress2.stateNode || (workInProgress2.stateNode = {
      _visibility: 1,
      _pendingMarkers: null,
      _retryCache: null,
      _transitions: null
    });
    return workInProgress2.sibling;
  }
  function deferHiddenOffscreenComponent(current, workInProgress2, nextBaseLanes, renderLanes2, remainingChildLanes) {
    var JSCompiler_inline_result = peekCacheFromPool();
    JSCompiler_inline_result = null === JSCompiler_inline_result ? null : { parent: CacheContext._currentValue, pool: JSCompiler_inline_result };
    workInProgress2.memoizedState = {
      baseLanes: nextBaseLanes,
      cachePool: JSCompiler_inline_result
    };
    null !== current && pushTransition(workInProgress2, null);
    reuseHiddenContextOnStack();
    pushOffscreenSuspenseHandler(workInProgress2);
    null !== current && propagateParentContextChanges(current, workInProgress2, renderLanes2, true);
    workInProgress2.childLanes = remainingChildLanes;
    return null;
  }
  function mountActivityChildren(workInProgress2, nextProps) {
    nextProps = mountWorkInProgressOffscreenFiber(
      { mode: nextProps.mode, children: nextProps.children },
      workInProgress2.mode
    );
    nextProps.ref = workInProgress2.ref;
    workInProgress2.child = nextProps;
    nextProps.return = workInProgress2;
    return nextProps;
  }
  function retryActivityComponentWithoutHydrating(current, workInProgress2, renderLanes2) {
    reconcileChildFibers(workInProgress2, current.child, null, renderLanes2);
    current = mountActivityChildren(workInProgress2, workInProgress2.pendingProps);
    current.flags |= 2;
    popSuspenseHandler(workInProgress2);
    workInProgress2.memoizedState = null;
    return current;
  }
  function updateActivityComponent(current, workInProgress2, renderLanes2) {
    var nextProps = workInProgress2.pendingProps, didSuspend = 0 !== (workInProgress2.flags & 128);
    workInProgress2.flags &= -129;
    if (null === current) {
      if (isHydrating) {
        if ("hidden" === nextProps.mode)
          return current = mountActivityChildren(workInProgress2, nextProps), workInProgress2.lanes = 536870912, bailoutOffscreenComponent(null, current);
        pushDehydratedActivitySuspenseHandler(workInProgress2);
        (current = nextHydratableInstance) ? (current = canHydrateHydrationBoundary(
          current,
          rootOrSingletonContext
        ), current = null !== current && "&" === current.data ? current : null, null !== current && (workInProgress2.memoizedState = {
          dehydrated: current,
          treeContext: null !== treeContextProvider ? { id: treeContextId, overflow: treeContextOverflow } : null,
          retryLane: 536870912,
          hydrationErrors: null
        }, renderLanes2 = createFiberFromDehydratedFragment(current), renderLanes2.return = workInProgress2, workInProgress2.child = renderLanes2, hydrationParentFiber = workInProgress2, nextHydratableInstance = null)) : current = null;
        if (null === current) throw throwOnHydrationMismatch(workInProgress2);
        workInProgress2.lanes = 536870912;
        return null;
      }
      return mountActivityChildren(workInProgress2, nextProps);
    }
    var prevState = current.memoizedState;
    if (null !== prevState) {
      var dehydrated = prevState.dehydrated;
      pushDehydratedActivitySuspenseHandler(workInProgress2);
      if (didSuspend)
        if (workInProgress2.flags & 256)
          workInProgress2.flags &= -257, workInProgress2 = retryActivityComponentWithoutHydrating(
            current,
            workInProgress2,
            renderLanes2
          );
        else if (null !== workInProgress2.memoizedState)
          workInProgress2.child = current.child, workInProgress2.flags |= 128, workInProgress2 = null;
        else throw Error(formatProdErrorMessage(558));
      else if (didReceiveUpdate || propagateParentContextChanges(current, workInProgress2, renderLanes2, false), didSuspend = 0 !== (renderLanes2 & current.childLanes), didReceiveUpdate || didSuspend) {
        nextProps = workInProgressRoot;
        if (null !== nextProps && (dehydrated = getBumpedLaneForHydration(nextProps, renderLanes2), 0 !== dehydrated && dehydrated !== prevState.retryLane))
          throw prevState.retryLane = dehydrated, enqueueConcurrentRenderForLane(current, dehydrated), scheduleUpdateOnFiber(nextProps, current, dehydrated), SelectiveHydrationException;
        renderDidSuspendDelayIfPossible();
        workInProgress2 = retryActivityComponentWithoutHydrating(
          current,
          workInProgress2,
          renderLanes2
        );
      } else
        current = prevState.treeContext, nextHydratableInstance = getNextHydratable(dehydrated.nextSibling), hydrationParentFiber = workInProgress2, isHydrating = true, hydrationErrors = null, rootOrSingletonContext = false, null !== current && restoreSuspendedTreeContext(workInProgress2, current), workInProgress2 = mountActivityChildren(workInProgress2, nextProps), workInProgress2.flags |= 4096;
      return workInProgress2;
    }
    current = createWorkInProgress(current.child, {
      mode: nextProps.mode,
      children: nextProps.children
    });
    current.ref = workInProgress2.ref;
    workInProgress2.child = current;
    current.return = workInProgress2;
    return current;
  }
  function markRef(current, workInProgress2) {
    var ref = workInProgress2.ref;
    if (null === ref)
      null !== current && null !== current.ref && (workInProgress2.flags |= 4194816);
    else {
      if ("function" !== typeof ref && "object" !== typeof ref)
        throw Error(formatProdErrorMessage(284));
      if (null === current || current.ref !== ref)
        workInProgress2.flags |= 4194816;
    }
  }
  function updateFunctionComponent(current, workInProgress2, Component, nextProps, renderLanes2) {
    prepareToReadContext(workInProgress2);
    Component = renderWithHooks(
      current,
      workInProgress2,
      Component,
      nextProps,
      void 0,
      renderLanes2
    );
    nextProps = checkDidRenderIdHook();
    if (null !== current && !didReceiveUpdate)
      return bailoutHooks(current, workInProgress2, renderLanes2), bailoutOnAlreadyFinishedWork(current, workInProgress2, renderLanes2);
    isHydrating && nextProps && pushMaterializedTreeId(workInProgress2);
    workInProgress2.flags |= 1;
    reconcileChildren(current, workInProgress2, Component, renderLanes2);
    return workInProgress2.child;
  }
  function replayFunctionComponent(current, workInProgress2, nextProps, Component, secondArg, renderLanes2) {
    prepareToReadContext(workInProgress2);
    workInProgress2.updateQueue = null;
    nextProps = renderWithHooksAgain(
      workInProgress2,
      Component,
      nextProps,
      secondArg
    );
    finishRenderingHooks(current);
    Component = checkDidRenderIdHook();
    if (null !== current && !didReceiveUpdate)
      return bailoutHooks(current, workInProgress2, renderLanes2), bailoutOnAlreadyFinishedWork(current, workInProgress2, renderLanes2);
    isHydrating && Component && pushMaterializedTreeId(workInProgress2);
    workInProgress2.flags |= 1;
    reconcileChildren(current, workInProgress2, nextProps, renderLanes2);
    return workInProgress2.child;
  }
  function updateClassComponent(current, workInProgress2, Component, nextProps, renderLanes2) {
    prepareToReadContext(workInProgress2);
    if (null === workInProgress2.stateNode) {
      var context = emptyContextObject, contextType = Component.contextType;
      "object" === typeof contextType && null !== contextType && (context = readContext(contextType));
      context = new Component(nextProps, context);
      workInProgress2.memoizedState = null !== context.state && void 0 !== context.state ? context.state : null;
      context.updater = classComponentUpdater;
      workInProgress2.stateNode = context;
      context._reactInternals = workInProgress2;
      context = workInProgress2.stateNode;
      context.props = nextProps;
      context.state = workInProgress2.memoizedState;
      context.refs = {};
      initializeUpdateQueue(workInProgress2);
      contextType = Component.contextType;
      context.context = "object" === typeof contextType && null !== contextType ? readContext(contextType) : emptyContextObject;
      context.state = workInProgress2.memoizedState;
      contextType = Component.getDerivedStateFromProps;
      "function" === typeof contextType && (applyDerivedStateFromProps(
        workInProgress2,
        Component,
        contextType,
        nextProps
      ), context.state = workInProgress2.memoizedState);
      "function" === typeof Component.getDerivedStateFromProps || "function" === typeof context.getSnapshotBeforeUpdate || "function" !== typeof context.UNSAFE_componentWillMount && "function" !== typeof context.componentWillMount || (contextType = context.state, "function" === typeof context.componentWillMount && context.componentWillMount(), "function" === typeof context.UNSAFE_componentWillMount && context.UNSAFE_componentWillMount(), contextType !== context.state && classComponentUpdater.enqueueReplaceState(context, context.state, null), processUpdateQueue(workInProgress2, nextProps, context, renderLanes2), suspendIfUpdateReadFromEntangledAsyncAction(), context.state = workInProgress2.memoizedState);
      "function" === typeof context.componentDidMount && (workInProgress2.flags |= 4194308);
      nextProps = true;
    } else if (null === current) {
      context = workInProgress2.stateNode;
      var unresolvedOldProps = workInProgress2.memoizedProps, oldProps = resolveClassComponentProps(Component, unresolvedOldProps);
      context.props = oldProps;
      var oldContext = context.context, contextType$jscomp$0 = Component.contextType;
      contextType = emptyContextObject;
      "object" === typeof contextType$jscomp$0 && null !== contextType$jscomp$0 && (contextType = readContext(contextType$jscomp$0));
      var getDerivedStateFromProps = Component.getDerivedStateFromProps;
      contextType$jscomp$0 = "function" === typeof getDerivedStateFromProps || "function" === typeof context.getSnapshotBeforeUpdate;
      unresolvedOldProps = workInProgress2.pendingProps !== unresolvedOldProps;
      contextType$jscomp$0 || "function" !== typeof context.UNSAFE_componentWillReceiveProps && "function" !== typeof context.componentWillReceiveProps || (unresolvedOldProps || oldContext !== contextType) && callComponentWillReceiveProps(
        workInProgress2,
        context,
        nextProps,
        contextType
      );
      hasForceUpdate = false;
      var oldState = workInProgress2.memoizedState;
      context.state = oldState;
      processUpdateQueue(workInProgress2, nextProps, context, renderLanes2);
      suspendIfUpdateReadFromEntangledAsyncAction();
      oldContext = workInProgress2.memoizedState;
      unresolvedOldProps || oldState !== oldContext || hasForceUpdate ? ("function" === typeof getDerivedStateFromProps && (applyDerivedStateFromProps(
        workInProgress2,
        Component,
        getDerivedStateFromProps,
        nextProps
      ), oldContext = workInProgress2.memoizedState), (oldProps = hasForceUpdate || checkShouldComponentUpdate(
        workInProgress2,
        Component,
        oldProps,
        nextProps,
        oldState,
        oldContext,
        contextType
      )) ? (contextType$jscomp$0 || "function" !== typeof context.UNSAFE_componentWillMount && "function" !== typeof context.componentWillMount || ("function" === typeof context.componentWillMount && context.componentWillMount(), "function" === typeof context.UNSAFE_componentWillMount && context.UNSAFE_componentWillMount()), "function" === typeof context.componentDidMount && (workInProgress2.flags |= 4194308)) : ("function" === typeof context.componentDidMount && (workInProgress2.flags |= 4194308), workInProgress2.memoizedProps = nextProps, workInProgress2.memoizedState = oldContext), context.props = nextProps, context.state = oldContext, context.context = contextType, nextProps = oldProps) : ("function" === typeof context.componentDidMount && (workInProgress2.flags |= 4194308), nextProps = false);
    } else {
      context = workInProgress2.stateNode;
      cloneUpdateQueue(current, workInProgress2);
      contextType = workInProgress2.memoizedProps;
      contextType$jscomp$0 = resolveClassComponentProps(Component, contextType);
      context.props = contextType$jscomp$0;
      getDerivedStateFromProps = workInProgress2.pendingProps;
      oldState = context.context;
      oldContext = Component.contextType;
      oldProps = emptyContextObject;
      "object" === typeof oldContext && null !== oldContext && (oldProps = readContext(oldContext));
      unresolvedOldProps = Component.getDerivedStateFromProps;
      (oldContext = "function" === typeof unresolvedOldProps || "function" === typeof context.getSnapshotBeforeUpdate) || "function" !== typeof context.UNSAFE_componentWillReceiveProps && "function" !== typeof context.componentWillReceiveProps || (contextType !== getDerivedStateFromProps || oldState !== oldProps) && callComponentWillReceiveProps(
        workInProgress2,
        context,
        nextProps,
        oldProps
      );
      hasForceUpdate = false;
      oldState = workInProgress2.memoizedState;
      context.state = oldState;
      processUpdateQueue(workInProgress2, nextProps, context, renderLanes2);
      suspendIfUpdateReadFromEntangledAsyncAction();
      var newState = workInProgress2.memoizedState;
      contextType !== getDerivedStateFromProps || oldState !== newState || hasForceUpdate || null !== current && null !== current.dependencies && checkIfContextChanged(current.dependencies) ? ("function" === typeof unresolvedOldProps && (applyDerivedStateFromProps(
        workInProgress2,
        Component,
        unresolvedOldProps,
        nextProps
      ), newState = workInProgress2.memoizedState), (contextType$jscomp$0 = hasForceUpdate || checkShouldComponentUpdate(
        workInProgress2,
        Component,
        contextType$jscomp$0,
        nextProps,
        oldState,
        newState,
        oldProps
      ) || null !== current && null !== current.dependencies && checkIfContextChanged(current.dependencies)) ? (oldContext || "function" !== typeof context.UNSAFE_componentWillUpdate && "function" !== typeof context.componentWillUpdate || ("function" === typeof context.componentWillUpdate && context.componentWillUpdate(nextProps, newState, oldProps), "function" === typeof context.UNSAFE_componentWillUpdate && context.UNSAFE_componentWillUpdate(
        nextProps,
        newState,
        oldProps
      )), "function" === typeof context.componentDidUpdate && (workInProgress2.flags |= 4), "function" === typeof context.getSnapshotBeforeUpdate && (workInProgress2.flags |= 1024)) : ("function" !== typeof context.componentDidUpdate || contextType === current.memoizedProps && oldState === current.memoizedState || (workInProgress2.flags |= 4), "function" !== typeof context.getSnapshotBeforeUpdate || contextType === current.memoizedProps && oldState === current.memoizedState || (workInProgress2.flags |= 1024), workInProgress2.memoizedProps = nextProps, workInProgress2.memoizedState = newState), context.props = nextProps, context.state = newState, context.context = oldProps, nextProps = contextType$jscomp$0) : ("function" !== typeof context.componentDidUpdate || contextType === current.memoizedProps && oldState === current.memoizedState || (workInProgress2.flags |= 4), "function" !== typeof context.getSnapshotBeforeUpdate || contextType === current.memoizedProps && oldState === current.memoizedState || (workInProgress2.flags |= 1024), nextProps = false);
    }
    context = nextProps;
    markRef(current, workInProgress2);
    nextProps = 0 !== (workInProgress2.flags & 128);
    context || nextProps ? (context = workInProgress2.stateNode, Component = nextProps && "function" !== typeof Component.getDerivedStateFromError ? null : context.render(), workInProgress2.flags |= 1, null !== current && nextProps ? (workInProgress2.child = reconcileChildFibers(
      workInProgress2,
      current.child,
      null,
      renderLanes2
    ), workInProgress2.child = reconcileChildFibers(
      workInProgress2,
      null,
      Component,
      renderLanes2
    )) : reconcileChildren(current, workInProgress2, Component, renderLanes2), workInProgress2.memoizedState = context.state, current = workInProgress2.child) : current = bailoutOnAlreadyFinishedWork(
      current,
      workInProgress2,
      renderLanes2
    );
    return current;
  }
  function mountHostRootWithoutHydrating(current, workInProgress2, nextChildren, renderLanes2) {
    resetHydrationState();
    workInProgress2.flags |= 256;
    reconcileChildren(current, workInProgress2, nextChildren, renderLanes2);
    return workInProgress2.child;
  }
  var SUSPENDED_MARKER = {
    dehydrated: null,
    treeContext: null,
    retryLane: 0,
    hydrationErrors: null
  };
  function mountSuspenseOffscreenState(renderLanes2) {
    return { baseLanes: renderLanes2, cachePool: getSuspendedCache() };
  }
  function getRemainingWorkInPrimaryTree(current, primaryTreeDidDefer, renderLanes2) {
    current = null !== current ? current.childLanes & ~renderLanes2 : 0;
    primaryTreeDidDefer && (current |= workInProgressDeferredLane);
    return current;
  }
  function updateSuspenseComponent(current, workInProgress2, renderLanes2) {
    var nextProps = workInProgress2.pendingProps, showFallback = false, didSuspend = 0 !== (workInProgress2.flags & 128), JSCompiler_temp;
    (JSCompiler_temp = didSuspend) || (JSCompiler_temp = null !== current && null === current.memoizedState ? false : 0 !== (suspenseStackCursor.current & 2));
    JSCompiler_temp && (showFallback = true, workInProgress2.flags &= -129);
    JSCompiler_temp = 0 !== (workInProgress2.flags & 32);
    workInProgress2.flags &= -33;
    if (null === current) {
      if (isHydrating) {
        showFallback ? pushPrimaryTreeSuspenseHandler(workInProgress2) : reuseSuspenseHandlerOnStack();
        (current = nextHydratableInstance) ? (current = canHydrateHydrationBoundary(
          current,
          rootOrSingletonContext
        ), current = null !== current && "&" !== current.data ? current : null, null !== current && (workInProgress2.memoizedState = {
          dehydrated: current,
          treeContext: null !== treeContextProvider ? { id: treeContextId, overflow: treeContextOverflow } : null,
          retryLane: 536870912,
          hydrationErrors: null
        }, renderLanes2 = createFiberFromDehydratedFragment(current), renderLanes2.return = workInProgress2, workInProgress2.child = renderLanes2, hydrationParentFiber = workInProgress2, nextHydratableInstance = null)) : current = null;
        if (null === current) throw throwOnHydrationMismatch(workInProgress2);
        isSuspenseInstanceFallback(current) ? workInProgress2.lanes = 32 : workInProgress2.lanes = 536870912;
        return null;
      }
      var nextPrimaryChildren = nextProps.children;
      nextProps = nextProps.fallback;
      if (showFallback)
        return reuseSuspenseHandlerOnStack(), showFallback = workInProgress2.mode, nextPrimaryChildren = mountWorkInProgressOffscreenFiber(
          { mode: "hidden", children: nextPrimaryChildren },
          showFallback
        ), nextProps = createFiberFromFragment(
          nextProps,
          showFallback,
          renderLanes2,
          null
        ), nextPrimaryChildren.return = workInProgress2, nextProps.return = workInProgress2, nextPrimaryChildren.sibling = nextProps, workInProgress2.child = nextPrimaryChildren, nextProps = workInProgress2.child, nextProps.memoizedState = mountSuspenseOffscreenState(renderLanes2), nextProps.childLanes = getRemainingWorkInPrimaryTree(
          current,
          JSCompiler_temp,
          renderLanes2
        ), workInProgress2.memoizedState = SUSPENDED_MARKER, bailoutOffscreenComponent(null, nextProps);
      pushPrimaryTreeSuspenseHandler(workInProgress2);
      return mountSuspensePrimaryChildren(workInProgress2, nextPrimaryChildren);
    }
    var prevState = current.memoizedState;
    if (null !== prevState && (nextPrimaryChildren = prevState.dehydrated, null !== nextPrimaryChildren)) {
      if (didSuspend)
        workInProgress2.flags & 256 ? (pushPrimaryTreeSuspenseHandler(workInProgress2), workInProgress2.flags &= -257, workInProgress2 = retrySuspenseComponentWithoutHydrating(
          current,
          workInProgress2,
          renderLanes2
        )) : null !== workInProgress2.memoizedState ? (reuseSuspenseHandlerOnStack(), workInProgress2.child = current.child, workInProgress2.flags |= 128, workInProgress2 = null) : (reuseSuspenseHandlerOnStack(), nextPrimaryChildren = nextProps.fallback, showFallback = workInProgress2.mode, nextProps = mountWorkInProgressOffscreenFiber(
          { mode: "visible", children: nextProps.children },
          showFallback
        ), nextPrimaryChildren = createFiberFromFragment(
          nextPrimaryChildren,
          showFallback,
          renderLanes2,
          null
        ), nextPrimaryChildren.flags |= 2, nextProps.return = workInProgress2, nextPrimaryChildren.return = workInProgress2, nextProps.sibling = nextPrimaryChildren, workInProgress2.child = nextProps, reconcileChildFibers(
          workInProgress2,
          current.child,
          null,
          renderLanes2
        ), nextProps = workInProgress2.child, nextProps.memoizedState = mountSuspenseOffscreenState(renderLanes2), nextProps.childLanes = getRemainingWorkInPrimaryTree(
          current,
          JSCompiler_temp,
          renderLanes2
        ), workInProgress2.memoizedState = SUSPENDED_MARKER, workInProgress2 = bailoutOffscreenComponent(null, nextProps));
      else if (pushPrimaryTreeSuspenseHandler(workInProgress2), isSuspenseInstanceFallback(nextPrimaryChildren)) {
        JSCompiler_temp = nextPrimaryChildren.nextSibling && nextPrimaryChildren.nextSibling.dataset;
        if (JSCompiler_temp) var digest = JSCompiler_temp.dgst;
        JSCompiler_temp = digest;
        nextProps = Error(formatProdErrorMessage(419));
        nextProps.stack = "";
        nextProps.digest = JSCompiler_temp;
        queueHydrationError({ value: nextProps, source: null, stack: null });
        workInProgress2 = retrySuspenseComponentWithoutHydrating(
          current,
          workInProgress2,
          renderLanes2
        );
      } else if (didReceiveUpdate || propagateParentContextChanges(current, workInProgress2, renderLanes2, false), JSCompiler_temp = 0 !== (renderLanes2 & current.childLanes), didReceiveUpdate || JSCompiler_temp) {
        JSCompiler_temp = workInProgressRoot;
        if (null !== JSCompiler_temp && (nextProps = getBumpedLaneForHydration(JSCompiler_temp, renderLanes2), 0 !== nextProps && nextProps !== prevState.retryLane))
          throw prevState.retryLane = nextProps, enqueueConcurrentRenderForLane(current, nextProps), scheduleUpdateOnFiber(JSCompiler_temp, current, nextProps), SelectiveHydrationException;
        isSuspenseInstancePending(nextPrimaryChildren) || renderDidSuspendDelayIfPossible();
        workInProgress2 = retrySuspenseComponentWithoutHydrating(
          current,
          workInProgress2,
          renderLanes2
        );
      } else
        isSuspenseInstancePending(nextPrimaryChildren) ? (workInProgress2.flags |= 192, workInProgress2.child = current.child, workInProgress2 = null) : (current = prevState.treeContext, nextHydratableInstance = getNextHydratable(
          nextPrimaryChildren.nextSibling
        ), hydrationParentFiber = workInProgress2, isHydrating = true, hydrationErrors = null, rootOrSingletonContext = false, null !== current && restoreSuspendedTreeContext(workInProgress2, current), workInProgress2 = mountSuspensePrimaryChildren(
          workInProgress2,
          nextProps.children
        ), workInProgress2.flags |= 4096);
      return workInProgress2;
    }
    if (showFallback)
      return reuseSuspenseHandlerOnStack(), nextPrimaryChildren = nextProps.fallback, showFallback = workInProgress2.mode, prevState = current.child, digest = prevState.sibling, nextProps = createWorkInProgress(prevState, {
        mode: "hidden",
        children: nextProps.children
      }), nextProps.subtreeFlags = prevState.subtreeFlags & 65011712, null !== digest ? nextPrimaryChildren = createWorkInProgress(
        digest,
        nextPrimaryChildren
      ) : (nextPrimaryChildren = createFiberFromFragment(
        nextPrimaryChildren,
        showFallback,
        renderLanes2,
        null
      ), nextPrimaryChildren.flags |= 2), nextPrimaryChildren.return = workInProgress2, nextProps.return = workInProgress2, nextProps.sibling = nextPrimaryChildren, workInProgress2.child = nextProps, bailoutOffscreenComponent(null, nextProps), nextProps = workInProgress2.child, nextPrimaryChildren = current.child.memoizedState, null === nextPrimaryChildren ? nextPrimaryChildren = mountSuspenseOffscreenState(renderLanes2) : (showFallback = nextPrimaryChildren.cachePool, null !== showFallback ? (prevState = CacheContext._currentValue, showFallback = showFallback.parent !== prevState ? { parent: prevState, pool: prevState } : showFallback) : showFallback = getSuspendedCache(), nextPrimaryChildren = {
        baseLanes: nextPrimaryChildren.baseLanes | renderLanes2,
        cachePool: showFallback
      }), nextProps.memoizedState = nextPrimaryChildren, nextProps.childLanes = getRemainingWorkInPrimaryTree(
        current,
        JSCompiler_temp,
        renderLanes2
      ), workInProgress2.memoizedState = SUSPENDED_MARKER, bailoutOffscreenComponent(current.child, nextProps);
    pushPrimaryTreeSuspenseHandler(workInProgress2);
    renderLanes2 = current.child;
    current = renderLanes2.sibling;
    renderLanes2 = createWorkInProgress(renderLanes2, {
      mode: "visible",
      children: nextProps.children
    });
    renderLanes2.return = workInProgress2;
    renderLanes2.sibling = null;
    null !== current && (JSCompiler_temp = workInProgress2.deletions, null === JSCompiler_temp ? (workInProgress2.deletions = [current], workInProgress2.flags |= 16) : JSCompiler_temp.push(current));
    workInProgress2.child = renderLanes2;
    workInProgress2.memoizedState = null;
    return renderLanes2;
  }
  function mountSuspensePrimaryChildren(workInProgress2, primaryChildren) {
    primaryChildren = mountWorkInProgressOffscreenFiber(
      { mode: "visible", children: primaryChildren },
      workInProgress2.mode
    );
    primaryChildren.return = workInProgress2;
    return workInProgress2.child = primaryChildren;
  }
  function mountWorkInProgressOffscreenFiber(offscreenProps, mode) {
    offscreenProps = createFiberImplClass(22, offscreenProps, null, mode);
    offscreenProps.lanes = 0;
    return offscreenProps;
  }
  function retrySuspenseComponentWithoutHydrating(current, workInProgress2, renderLanes2) {
    reconcileChildFibers(workInProgress2, current.child, null, renderLanes2);
    current = mountSuspensePrimaryChildren(
      workInProgress2,
      workInProgress2.pendingProps.children
    );
    current.flags |= 2;
    workInProgress2.memoizedState = null;
    return current;
  }
  function scheduleSuspenseWorkOnFiber(fiber, renderLanes2, propagationRoot) {
    fiber.lanes |= renderLanes2;
    var alternate = fiber.alternate;
    null !== alternate && (alternate.lanes |= renderLanes2);
    scheduleContextWorkOnParentPath(fiber.return, renderLanes2, propagationRoot);
  }
  function initSuspenseListRenderState(workInProgress2, isBackwards, tail, lastContentRow, tailMode, treeForkCount2) {
    var renderState = workInProgress2.memoizedState;
    null === renderState ? workInProgress2.memoizedState = {
      isBackwards,
      rendering: null,
      renderingStartTime: 0,
      last: lastContentRow,
      tail,
      tailMode,
      treeForkCount: treeForkCount2
    } : (renderState.isBackwards = isBackwards, renderState.rendering = null, renderState.renderingStartTime = 0, renderState.last = lastContentRow, renderState.tail = tail, renderState.tailMode = tailMode, renderState.treeForkCount = treeForkCount2);
  }
  function updateSuspenseListComponent(current, workInProgress2, renderLanes2) {
    var nextProps = workInProgress2.pendingProps, revealOrder = nextProps.revealOrder, tailMode = nextProps.tail;
    nextProps = nextProps.children;
    var suspenseContext = suspenseStackCursor.current, shouldForceFallback = 0 !== (suspenseContext & 2);
    shouldForceFallback ? (suspenseContext = suspenseContext & 1 | 2, workInProgress2.flags |= 128) : suspenseContext &= 1;
    push(suspenseStackCursor, suspenseContext);
    reconcileChildren(current, workInProgress2, nextProps, renderLanes2);
    nextProps = isHydrating ? treeForkCount : 0;
    if (!shouldForceFallback && null !== current && 0 !== (current.flags & 128))
      a: for (current = workInProgress2.child; null !== current; ) {
        if (13 === current.tag)
          null !== current.memoizedState && scheduleSuspenseWorkOnFiber(current, renderLanes2, workInProgress2);
        else if (19 === current.tag)
          scheduleSuspenseWorkOnFiber(current, renderLanes2, workInProgress2);
        else if (null !== current.child) {
          current.child.return = current;
          current = current.child;
          continue;
        }
        if (current === workInProgress2) break a;
        for (; null === current.sibling; ) {
          if (null === current.return || current.return === workInProgress2)
            break a;
          current = current.return;
        }
        current.sibling.return = current.return;
        current = current.sibling;
      }
    switch (revealOrder) {
      case "forwards":
        renderLanes2 = workInProgress2.child;
        for (revealOrder = null; null !== renderLanes2; )
          current = renderLanes2.alternate, null !== current && null === findFirstSuspended(current) && (revealOrder = renderLanes2), renderLanes2 = renderLanes2.sibling;
        renderLanes2 = revealOrder;
        null === renderLanes2 ? (revealOrder = workInProgress2.child, workInProgress2.child = null) : (revealOrder = renderLanes2.sibling, renderLanes2.sibling = null);
        initSuspenseListRenderState(
          workInProgress2,
          false,
          revealOrder,
          renderLanes2,
          tailMode,
          nextProps
        );
        break;
      case "backwards":
      case "unstable_legacy-backwards":
        renderLanes2 = null;
        revealOrder = workInProgress2.child;
        for (workInProgress2.child = null; null !== revealOrder; ) {
          current = revealOrder.alternate;
          if (null !== current && null === findFirstSuspended(current)) {
            workInProgress2.child = revealOrder;
            break;
          }
          current = revealOrder.sibling;
          revealOrder.sibling = renderLanes2;
          renderLanes2 = revealOrder;
          revealOrder = current;
        }
        initSuspenseListRenderState(
          workInProgress2,
          true,
          renderLanes2,
          null,
          tailMode,
          nextProps
        );
        break;
      case "together":
        initSuspenseListRenderState(
          workInProgress2,
          false,
          null,
          null,
          void 0,
          nextProps
        );
        break;
      default:
        workInProgress2.memoizedState = null;
    }
    return workInProgress2.child;
  }
  function bailoutOnAlreadyFinishedWork(current, workInProgress2, renderLanes2) {
    null !== current && (workInProgress2.dependencies = current.dependencies);
    workInProgressRootSkippedLanes |= workInProgress2.lanes;
    if (0 === (renderLanes2 & workInProgress2.childLanes))
      if (null !== current) {
        if (propagateParentContextChanges(
          current,
          workInProgress2,
          renderLanes2,
          false
        ), 0 === (renderLanes2 & workInProgress2.childLanes))
          return null;
      } else return null;
    if (null !== current && workInProgress2.child !== current.child)
      throw Error(formatProdErrorMessage(153));
    if (null !== workInProgress2.child) {
      current = workInProgress2.child;
      renderLanes2 = createWorkInProgress(current, current.pendingProps);
      workInProgress2.child = renderLanes2;
      for (renderLanes2.return = workInProgress2; null !== current.sibling; )
        current = current.sibling, renderLanes2 = renderLanes2.sibling = createWorkInProgress(current, current.pendingProps), renderLanes2.return = workInProgress2;
      renderLanes2.sibling = null;
    }
    return workInProgress2.child;
  }
  function checkScheduledUpdateOrContext(current, renderLanes2) {
    if (0 !== (current.lanes & renderLanes2)) return true;
    current = current.dependencies;
    return null !== current && checkIfContextChanged(current) ? true : false;
  }
  function attemptEarlyBailoutIfNoScheduledUpdate(current, workInProgress2, renderLanes2) {
    switch (workInProgress2.tag) {
      case 3:
        pushHostContainer(workInProgress2, workInProgress2.stateNode.containerInfo);
        pushProvider(workInProgress2, CacheContext, current.memoizedState.cache);
        resetHydrationState();
        break;
      case 27:
      case 5:
        pushHostContext(workInProgress2);
        break;
      case 4:
        pushHostContainer(workInProgress2, workInProgress2.stateNode.containerInfo);
        break;
      case 10:
        pushProvider(
          workInProgress2,
          workInProgress2.type,
          workInProgress2.memoizedProps.value
        );
        break;
      case 31:
        if (null !== workInProgress2.memoizedState)
          return workInProgress2.flags |= 128, pushDehydratedActivitySuspenseHandler(workInProgress2), null;
        break;
      case 13:
        var state$102 = workInProgress2.memoizedState;
        if (null !== state$102) {
          if (null !== state$102.dehydrated)
            return pushPrimaryTreeSuspenseHandler(workInProgress2), workInProgress2.flags |= 128, null;
          if (0 !== (renderLanes2 & workInProgress2.child.childLanes))
            return updateSuspenseComponent(current, workInProgress2, renderLanes2);
          pushPrimaryTreeSuspenseHandler(workInProgress2);
          current = bailoutOnAlreadyFinishedWork(
            current,
            workInProgress2,
            renderLanes2
          );
          return null !== current ? current.sibling : null;
        }
        pushPrimaryTreeSuspenseHandler(workInProgress2);
        break;
      case 19:
        var didSuspendBefore = 0 !== (current.flags & 128);
        state$102 = 0 !== (renderLanes2 & workInProgress2.childLanes);
        state$102 || (propagateParentContextChanges(
          current,
          workInProgress2,
          renderLanes2,
          false
        ), state$102 = 0 !== (renderLanes2 & workInProgress2.childLanes));
        if (didSuspendBefore) {
          if (state$102)
            return updateSuspenseListComponent(
              current,
              workInProgress2,
              renderLanes2
            );
          workInProgress2.flags |= 128;
        }
        didSuspendBefore = workInProgress2.memoizedState;
        null !== didSuspendBefore && (didSuspendBefore.rendering = null, didSuspendBefore.tail = null, didSuspendBefore.lastEffect = null);
        push(suspenseStackCursor, suspenseStackCursor.current);
        if (state$102) break;
        else return null;
      case 22:
        return workInProgress2.lanes = 0, updateOffscreenComponent(
          current,
          workInProgress2,
          renderLanes2,
          workInProgress2.pendingProps
        );
      case 24:
        pushProvider(workInProgress2, CacheContext, current.memoizedState.cache);
    }
    return bailoutOnAlreadyFinishedWork(current, workInProgress2, renderLanes2);
  }
  function beginWork(current, workInProgress2, renderLanes2) {
    if (null !== current)
      if (current.memoizedProps !== workInProgress2.pendingProps)
        didReceiveUpdate = true;
      else {
        if (!checkScheduledUpdateOrContext(current, renderLanes2) && 0 === (workInProgress2.flags & 128))
          return didReceiveUpdate = false, attemptEarlyBailoutIfNoScheduledUpdate(
            current,
            workInProgress2,
            renderLanes2
          );
        didReceiveUpdate = 0 !== (current.flags & 131072) ? true : false;
      }
    else
      didReceiveUpdate = false, isHydrating && 0 !== (workInProgress2.flags & 1048576) && pushTreeId(workInProgress2, treeForkCount, workInProgress2.index);
    workInProgress2.lanes = 0;
    switch (workInProgress2.tag) {
      case 16:
        a: {
          var props = workInProgress2.pendingProps;
          current = resolveLazy(workInProgress2.elementType);
          workInProgress2.type = current;
          if ("function" === typeof current)
            shouldConstruct(current) ? (props = resolveClassComponentProps(current, props), workInProgress2.tag = 1, workInProgress2 = updateClassComponent(
              null,
              workInProgress2,
              current,
              props,
              renderLanes2
            )) : (workInProgress2.tag = 0, workInProgress2 = updateFunctionComponent(
              null,
              workInProgress2,
              current,
              props,
              renderLanes2
            ));
          else {
            if (void 0 !== current && null !== current) {
              var $$typeof = current.$$typeof;
              if ($$typeof === REACT_FORWARD_REF_TYPE) {
                workInProgress2.tag = 11;
                workInProgress2 = updateForwardRef(
                  null,
                  workInProgress2,
                  current,
                  props,
                  renderLanes2
                );
                break a;
              } else if ($$typeof === REACT_MEMO_TYPE) {
                workInProgress2.tag = 14;
                workInProgress2 = updateMemoComponent(
                  null,
                  workInProgress2,
                  current,
                  props,
                  renderLanes2
                );
                break a;
              }
            }
            workInProgress2 = getComponentNameFromType(current) || current;
            throw Error(formatProdErrorMessage(306, workInProgress2, ""));
          }
        }
        return workInProgress2;
      case 0:
        return updateFunctionComponent(
          current,
          workInProgress2,
          workInProgress2.type,
          workInProgress2.pendingProps,
          renderLanes2
        );
      case 1:
        return props = workInProgress2.type, $$typeof = resolveClassComponentProps(
          props,
          workInProgress2.pendingProps
        ), updateClassComponent(
          current,
          workInProgress2,
          props,
          $$typeof,
          renderLanes2
        );
      case 3:
        a: {
          pushHostContainer(
            workInProgress2,
            workInProgress2.stateNode.containerInfo
          );
          if (null === current) throw Error(formatProdErrorMessage(387));
          props = workInProgress2.pendingProps;
          var prevState = workInProgress2.memoizedState;
          $$typeof = prevState.element;
          cloneUpdateQueue(current, workInProgress2);
          processUpdateQueue(workInProgress2, props, null, renderLanes2);
          var nextState = workInProgress2.memoizedState;
          props = nextState.cache;
          pushProvider(workInProgress2, CacheContext, props);
          props !== prevState.cache && propagateContextChanges(
            workInProgress2,
            [CacheContext],
            renderLanes2,
            true
          );
          suspendIfUpdateReadFromEntangledAsyncAction();
          props = nextState.element;
          if (prevState.isDehydrated)
            if (prevState = {
              element: props,
              isDehydrated: false,
              cache: nextState.cache
            }, workInProgress2.updateQueue.baseState = prevState, workInProgress2.memoizedState = prevState, workInProgress2.flags & 256) {
              workInProgress2 = mountHostRootWithoutHydrating(
                current,
                workInProgress2,
                props,
                renderLanes2
              );
              break a;
            } else if (props !== $$typeof) {
              $$typeof = createCapturedValueAtFiber(
                Error(formatProdErrorMessage(424)),
                workInProgress2
              );
              queueHydrationError($$typeof);
              workInProgress2 = mountHostRootWithoutHydrating(
                current,
                workInProgress2,
                props,
                renderLanes2
              );
              break a;
            } else {
              current = workInProgress2.stateNode.containerInfo;
              switch (current.nodeType) {
                case 9:
                  current = current.body;
                  break;
                default:
                  current = "HTML" === current.nodeName ? current.ownerDocument.body : current;
              }
              nextHydratableInstance = getNextHydratable(current.firstChild);
              hydrationParentFiber = workInProgress2;
              isHydrating = true;
              hydrationErrors = null;
              rootOrSingletonContext = true;
              renderLanes2 = mountChildFibers(
                workInProgress2,
                null,
                props,
                renderLanes2
              );
              for (workInProgress2.child = renderLanes2; renderLanes2; )
                renderLanes2.flags = renderLanes2.flags & -3 | 4096, renderLanes2 = renderLanes2.sibling;
            }
          else {
            resetHydrationState();
            if (props === $$typeof) {
              workInProgress2 = bailoutOnAlreadyFinishedWork(
                current,
                workInProgress2,
                renderLanes2
              );
              break a;
            }
            reconcileChildren(current, workInProgress2, props, renderLanes2);
          }
          workInProgress2 = workInProgress2.child;
        }
        return workInProgress2;
      case 26:
        return markRef(current, workInProgress2), null === current ? (renderLanes2 = getResource(
          workInProgress2.type,
          null,
          workInProgress2.pendingProps,
          null
        )) ? workInProgress2.memoizedState = renderLanes2 : isHydrating || (renderLanes2 = workInProgress2.type, current = workInProgress2.pendingProps, props = getOwnerDocumentFromRootContainer(
          rootInstanceStackCursor.current
        ).createElement(renderLanes2), props[internalInstanceKey] = workInProgress2, props[internalPropsKey] = current, setInitialProperties(props, renderLanes2, current), markNodeAsHoistable(props), workInProgress2.stateNode = props) : workInProgress2.memoizedState = getResource(
          workInProgress2.type,
          current.memoizedProps,
          workInProgress2.pendingProps,
          current.memoizedState
        ), null;
      case 27:
        return pushHostContext(workInProgress2), null === current && isHydrating && (props = workInProgress2.stateNode = resolveSingletonInstance(
          workInProgress2.type,
          workInProgress2.pendingProps,
          rootInstanceStackCursor.current
        ), hydrationParentFiber = workInProgress2, rootOrSingletonContext = true, $$typeof = nextHydratableInstance, isSingletonScope(workInProgress2.type) ? (previousHydratableOnEnteringScopedSingleton = $$typeof, nextHydratableInstance = getNextHydratable(props.firstChild)) : nextHydratableInstance = $$typeof), reconcileChildren(
          current,
          workInProgress2,
          workInProgress2.pendingProps.children,
          renderLanes2
        ), markRef(current, workInProgress2), null === current && (workInProgress2.flags |= 4194304), workInProgress2.child;
      case 5:
        if (null === current && isHydrating) {
          if ($$typeof = props = nextHydratableInstance)
            props = canHydrateInstance(
              props,
              workInProgress2.type,
              workInProgress2.pendingProps,
              rootOrSingletonContext
            ), null !== props ? (workInProgress2.stateNode = props, hydrationParentFiber = workInProgress2, nextHydratableInstance = getNextHydratable(props.firstChild), rootOrSingletonContext = false, $$typeof = true) : $$typeof = false;
          $$typeof || throwOnHydrationMismatch(workInProgress2);
        }
        pushHostContext(workInProgress2);
        $$typeof = workInProgress2.type;
        prevState = workInProgress2.pendingProps;
        nextState = null !== current ? current.memoizedProps : null;
        props = prevState.children;
        shouldSetTextContent($$typeof, prevState) ? props = null : null !== nextState && shouldSetTextContent($$typeof, nextState) && (workInProgress2.flags |= 32);
        null !== workInProgress2.memoizedState && ($$typeof = renderWithHooks(
          current,
          workInProgress2,
          TransitionAwareHostComponent,
          null,
          null,
          renderLanes2
        ), HostTransitionContext._currentValue = $$typeof);
        markRef(current, workInProgress2);
        reconcileChildren(current, workInProgress2, props, renderLanes2);
        return workInProgress2.child;
      case 6:
        if (null === current && isHydrating) {
          if (current = renderLanes2 = nextHydratableInstance)
            renderLanes2 = canHydrateTextInstance(
              renderLanes2,
              workInProgress2.pendingProps,
              rootOrSingletonContext
            ), null !== renderLanes2 ? (workInProgress2.stateNode = renderLanes2, hydrationParentFiber = workInProgress2, nextHydratableInstance = null, current = true) : current = false;
          current || throwOnHydrationMismatch(workInProgress2);
        }
        return null;
      case 13:
        return updateSuspenseComponent(current, workInProgress2, renderLanes2);
      case 4:
        return pushHostContainer(
          workInProgress2,
          workInProgress2.stateNode.containerInfo
        ), props = workInProgress2.pendingProps, null === current ? workInProgress2.child = reconcileChildFibers(
          workInProgress2,
          null,
          props,
          renderLanes2
        ) : reconcileChildren(current, workInProgress2, props, renderLanes2), workInProgress2.child;
      case 11:
        return updateForwardRef(
          current,
          workInProgress2,
          workInProgress2.type,
          workInProgress2.pendingProps,
          renderLanes2
        );
      case 7:
        return reconcileChildren(
          current,
          workInProgress2,
          workInProgress2.pendingProps,
          renderLanes2
        ), workInProgress2.child;
      case 8:
        return reconcileChildren(
          current,
          workInProgress2,
          workInProgress2.pendingProps.children,
          renderLanes2
        ), workInProgress2.child;
      case 12:
        return reconcileChildren(
          current,
          workInProgress2,
          workInProgress2.pendingProps.children,
          renderLanes2
        ), workInProgress2.child;
      case 10:
        return props = workInProgress2.pendingProps, pushProvider(workInProgress2, workInProgress2.type, props.value), reconcileChildren(current, workInProgress2, props.children, renderLanes2), workInProgress2.child;
      case 9:
        return $$typeof = workInProgress2.type._context, props = workInProgress2.pendingProps.children, prepareToReadContext(workInProgress2), $$typeof = readContext($$typeof), props = props($$typeof), workInProgress2.flags |= 1, reconcileChildren(current, workInProgress2, props, renderLanes2), workInProgress2.child;
      case 14:
        return updateMemoComponent(
          current,
          workInProgress2,
          workInProgress2.type,
          workInProgress2.pendingProps,
          renderLanes2
        );
      case 15:
        return updateSimpleMemoComponent(
          current,
          workInProgress2,
          workInProgress2.type,
          workInProgress2.pendingProps,
          renderLanes2
        );
      case 19:
        return updateSuspenseListComponent(current, workInProgress2, renderLanes2);
      case 31:
        return updateActivityComponent(current, workInProgress2, renderLanes2);
      case 22:
        return updateOffscreenComponent(
          current,
          workInProgress2,
          renderLanes2,
          workInProgress2.pendingProps
        );
      case 24:
        return prepareToReadContext(workInProgress2), props = readContext(CacheContext), null === current ? ($$typeof = peekCacheFromPool(), null === $$typeof && ($$typeof = workInProgressRoot, prevState = createCache(), $$typeof.pooledCache = prevState, prevState.refCount++, null !== prevState && ($$typeof.pooledCacheLanes |= renderLanes2), $$typeof = prevState), workInProgress2.memoizedState = { parent: props, cache: $$typeof }, initializeUpdateQueue(workInProgress2), pushProvider(workInProgress2, CacheContext, $$typeof)) : (0 !== (current.lanes & renderLanes2) && (cloneUpdateQueue(current, workInProgress2), processUpdateQueue(workInProgress2, null, null, renderLanes2), suspendIfUpdateReadFromEntangledAsyncAction()), $$typeof = current.memoizedState, prevState = workInProgress2.memoizedState, $$typeof.parent !== props ? ($$typeof = { parent: props, cache: props }, workInProgress2.memoizedState = $$typeof, 0 === workInProgress2.lanes && (workInProgress2.memoizedState = workInProgress2.updateQueue.baseState = $$typeof), pushProvider(workInProgress2, CacheContext, props)) : (props = prevState.cache, pushProvider(workInProgress2, CacheContext, props), props !== $$typeof.cache && propagateContextChanges(
          workInProgress2,
          [CacheContext],
          renderLanes2,
          true
        ))), reconcileChildren(
          current,
          workInProgress2,
          workInProgress2.pendingProps.children,
          renderLanes2
        ), workInProgress2.child;
      case 29:
        throw workInProgress2.pendingProps;
    }
    throw Error(formatProdErrorMessage(156, workInProgress2.tag));
  }
  function markUpdate(workInProgress2) {
    workInProgress2.flags |= 4;
  }
  function preloadInstanceAndSuspendIfNeeded(workInProgress2, type, oldProps, newProps, renderLanes2) {
    if (type = 0 !== (workInProgress2.mode & 32)) type = false;
    if (type) {
      if (workInProgress2.flags |= 16777216, (renderLanes2 & 335544128) === renderLanes2)
        if (workInProgress2.stateNode.complete) workInProgress2.flags |= 8192;
        else if (shouldRemainOnPreviousScreen()) workInProgress2.flags |= 8192;
        else
          throw suspendedThenable = noopSuspenseyCommitThenable, SuspenseyCommitException;
    } else workInProgress2.flags &= -16777217;
  }
  function preloadResourceAndSuspendIfNeeded(workInProgress2, resource) {
    if ("stylesheet" !== resource.type || 0 !== (resource.state.loading & 4))
      workInProgress2.flags &= -16777217;
    else if (workInProgress2.flags |= 16777216, !preloadResource(resource))
      if (shouldRemainOnPreviousScreen()) workInProgress2.flags |= 8192;
      else
        throw suspendedThenable = noopSuspenseyCommitThenable, SuspenseyCommitException;
  }
  function scheduleRetryEffect(workInProgress2, retryQueue) {
    null !== retryQueue && (workInProgress2.flags |= 4);
    workInProgress2.flags & 16384 && (retryQueue = 22 !== workInProgress2.tag ? claimNextRetryLane() : 536870912, workInProgress2.lanes |= retryQueue, workInProgressSuspendedRetryLanes |= retryQueue);
  }
  function cutOffTailIfNeeded(renderState, hasRenderedATailFallback) {
    if (!isHydrating)
      switch (renderState.tailMode) {
        case "hidden":
          hasRenderedATailFallback = renderState.tail;
          for (var lastTailNode = null; null !== hasRenderedATailFallback; )
            null !== hasRenderedATailFallback.alternate && (lastTailNode = hasRenderedATailFallback), hasRenderedATailFallback = hasRenderedATailFallback.sibling;
          null === lastTailNode ? renderState.tail = null : lastTailNode.sibling = null;
          break;
        case "collapsed":
          lastTailNode = renderState.tail;
          for (var lastTailNode$106 = null; null !== lastTailNode; )
            null !== lastTailNode.alternate && (lastTailNode$106 = lastTailNode), lastTailNode = lastTailNode.sibling;
          null === lastTailNode$106 ? hasRenderedATailFallback || null === renderState.tail ? renderState.tail = null : renderState.tail.sibling = null : lastTailNode$106.sibling = null;
      }
  }
  function bubbleProperties(completedWork) {
    var didBailout = null !== completedWork.alternate && completedWork.alternate.child === completedWork.child, newChildLanes = 0, subtreeFlags = 0;
    if (didBailout)
      for (var child$107 = completedWork.child; null !== child$107; )
        newChildLanes |= child$107.lanes | child$107.childLanes, subtreeFlags |= child$107.subtreeFlags & 65011712, subtreeFlags |= child$107.flags & 65011712, child$107.return = completedWork, child$107 = child$107.sibling;
    else
      for (child$107 = completedWork.child; null !== child$107; )
        newChildLanes |= child$107.lanes | child$107.childLanes, subtreeFlags |= child$107.subtreeFlags, subtreeFlags |= child$107.flags, child$107.return = completedWork, child$107 = child$107.sibling;
    completedWork.subtreeFlags |= subtreeFlags;
    completedWork.childLanes = newChildLanes;
    return didBailout;
  }
  function completeWork(current, workInProgress2, renderLanes2) {
    var newProps = workInProgress2.pendingProps;
    popTreeContext(workInProgress2);
    switch (workInProgress2.tag) {
      case 16:
      case 15:
      case 0:
      case 11:
      case 7:
      case 8:
      case 12:
      case 9:
      case 14:
        return bubbleProperties(workInProgress2), null;
      case 1:
        return bubbleProperties(workInProgress2), null;
      case 3:
        renderLanes2 = workInProgress2.stateNode;
        newProps = null;
        null !== current && (newProps = current.memoizedState.cache);
        workInProgress2.memoizedState.cache !== newProps && (workInProgress2.flags |= 2048);
        popProvider(CacheContext);
        popHostContainer();
        renderLanes2.pendingContext && (renderLanes2.context = renderLanes2.pendingContext, renderLanes2.pendingContext = null);
        if (null === current || null === current.child)
          popHydrationState(workInProgress2) ? markUpdate(workInProgress2) : null === current || current.memoizedState.isDehydrated && 0 === (workInProgress2.flags & 256) || (workInProgress2.flags |= 1024, upgradeHydrationErrorsToRecoverable());
        bubbleProperties(workInProgress2);
        return null;
      case 26:
        var type = workInProgress2.type, nextResource = workInProgress2.memoizedState;
        null === current ? (markUpdate(workInProgress2), null !== nextResource ? (bubbleProperties(workInProgress2), preloadResourceAndSuspendIfNeeded(workInProgress2, nextResource)) : (bubbleProperties(workInProgress2), preloadInstanceAndSuspendIfNeeded(
          workInProgress2,
          type,
          null,
          newProps,
          renderLanes2
        ))) : nextResource ? nextResource !== current.memoizedState ? (markUpdate(workInProgress2), bubbleProperties(workInProgress2), preloadResourceAndSuspendIfNeeded(workInProgress2, nextResource)) : (bubbleProperties(workInProgress2), workInProgress2.flags &= -16777217) : (current = current.memoizedProps, current !== newProps && markUpdate(workInProgress2), bubbleProperties(workInProgress2), preloadInstanceAndSuspendIfNeeded(
          workInProgress2,
          type,
          current,
          newProps,
          renderLanes2
        ));
        return null;
      case 27:
        popHostContext(workInProgress2);
        renderLanes2 = rootInstanceStackCursor.current;
        type = workInProgress2.type;
        if (null !== current && null != workInProgress2.stateNode)
          current.memoizedProps !== newProps && markUpdate(workInProgress2);
        else {
          if (!newProps) {
            if (null === workInProgress2.stateNode)
              throw Error(formatProdErrorMessage(166));
            bubbleProperties(workInProgress2);
            return null;
          }
          current = contextStackCursor.current;
          popHydrationState(workInProgress2) ? prepareToHydrateHostInstance(workInProgress2) : (current = resolveSingletonInstance(type, newProps, renderLanes2), workInProgress2.stateNode = current, markUpdate(workInProgress2));
        }
        bubbleProperties(workInProgress2);
        return null;
      case 5:
        popHostContext(workInProgress2);
        type = workInProgress2.type;
        if (null !== current && null != workInProgress2.stateNode)
          current.memoizedProps !== newProps && markUpdate(workInProgress2);
        else {
          if (!newProps) {
            if (null === workInProgress2.stateNode)
              throw Error(formatProdErrorMessage(166));
            bubbleProperties(workInProgress2);
            return null;
          }
          nextResource = contextStackCursor.current;
          if (popHydrationState(workInProgress2))
            prepareToHydrateHostInstance(workInProgress2);
          else {
            var ownerDocument = getOwnerDocumentFromRootContainer(
              rootInstanceStackCursor.current
            );
            switch (nextResource) {
              case 1:
                nextResource = ownerDocument.createElementNS(
                  "http://www.w3.org/2000/svg",
                  type
                );
                break;
              case 2:
                nextResource = ownerDocument.createElementNS(
                  "http://www.w3.org/1998/Math/MathML",
                  type
                );
                break;
              default:
                switch (type) {
                  case "svg":
                    nextResource = ownerDocument.createElementNS(
                      "http://www.w3.org/2000/svg",
                      type
                    );
                    break;
                  case "math":
                    nextResource = ownerDocument.createElementNS(
                      "http://www.w3.org/1998/Math/MathML",
                      type
                    );
                    break;
                  case "script":
                    nextResource = ownerDocument.createElement("div");
                    nextResource.innerHTML = "<script><\/script>";
                    nextResource = nextResource.removeChild(
                      nextResource.firstChild
                    );
                    break;
                  case "select":
                    nextResource = "string" === typeof newProps.is ? ownerDocument.createElement("select", {
                      is: newProps.is
                    }) : ownerDocument.createElement("select");
                    newProps.multiple ? nextResource.multiple = true : newProps.size && (nextResource.size = newProps.size);
                    break;
                  default:
                    nextResource = "string" === typeof newProps.is ? ownerDocument.createElement(type, { is: newProps.is }) : ownerDocument.createElement(type);
                }
            }
            nextResource[internalInstanceKey] = workInProgress2;
            nextResource[internalPropsKey] = newProps;
            a: for (ownerDocument = workInProgress2.child; null !== ownerDocument; ) {
              if (5 === ownerDocument.tag || 6 === ownerDocument.tag)
                nextResource.appendChild(ownerDocument.stateNode);
              else if (4 !== ownerDocument.tag && 27 !== ownerDocument.tag && null !== ownerDocument.child) {
                ownerDocument.child.return = ownerDocument;
                ownerDocument = ownerDocument.child;
                continue;
              }
              if (ownerDocument === workInProgress2) break a;
              for (; null === ownerDocument.sibling; ) {
                if (null === ownerDocument.return || ownerDocument.return === workInProgress2)
                  break a;
                ownerDocument = ownerDocument.return;
              }
              ownerDocument.sibling.return = ownerDocument.return;
              ownerDocument = ownerDocument.sibling;
            }
            workInProgress2.stateNode = nextResource;
            a: switch (setInitialProperties(nextResource, type, newProps), type) {
              case "button":
              case "input":
              case "select":
              case "textarea":
                newProps = !!newProps.autoFocus;
                break a;
              case "img":
                newProps = true;
                break a;
              default:
                newProps = false;
            }
            newProps && markUpdate(workInProgress2);
          }
        }
        bubbleProperties(workInProgress2);
        preloadInstanceAndSuspendIfNeeded(
          workInProgress2,
          workInProgress2.type,
          null === current ? null : current.memoizedProps,
          workInProgress2.pendingProps,
          renderLanes2
        );
        return null;
      case 6:
        if (current && null != workInProgress2.stateNode)
          current.memoizedProps !== newProps && markUpdate(workInProgress2);
        else {
          if ("string" !== typeof newProps && null === workInProgress2.stateNode)
            throw Error(formatProdErrorMessage(166));
          current = rootInstanceStackCursor.current;
          if (popHydrationState(workInProgress2)) {
            current = workInProgress2.stateNode;
            renderLanes2 = workInProgress2.memoizedProps;
            newProps = null;
            type = hydrationParentFiber;
            if (null !== type)
              switch (type.tag) {
                case 27:
                case 5:
                  newProps = type.memoizedProps;
              }
            current[internalInstanceKey] = workInProgress2;
            current = current.nodeValue === renderLanes2 || null !== newProps && true === newProps.suppressHydrationWarning || checkForUnmatchedText(current.nodeValue, renderLanes2) ? true : false;
            current || throwOnHydrationMismatch(workInProgress2, true);
          } else
            current = getOwnerDocumentFromRootContainer(current).createTextNode(
              newProps
            ), current[internalInstanceKey] = workInProgress2, workInProgress2.stateNode = current;
        }
        bubbleProperties(workInProgress2);
        return null;
      case 31:
        renderLanes2 = workInProgress2.memoizedState;
        if (null === current || null !== current.memoizedState) {
          newProps = popHydrationState(workInProgress2);
          if (null !== renderLanes2) {
            if (null === current) {
              if (!newProps) throw Error(formatProdErrorMessage(318));
              current = workInProgress2.memoizedState;
              current = null !== current ? current.dehydrated : null;
              if (!current) throw Error(formatProdErrorMessage(557));
              current[internalInstanceKey] = workInProgress2;
            } else
              resetHydrationState(), 0 === (workInProgress2.flags & 128) && (workInProgress2.memoizedState = null), workInProgress2.flags |= 4;
            bubbleProperties(workInProgress2);
            current = false;
          } else
            renderLanes2 = upgradeHydrationErrorsToRecoverable(), null !== current && null !== current.memoizedState && (current.memoizedState.hydrationErrors = renderLanes2), current = true;
          if (!current) {
            if (workInProgress2.flags & 256)
              return popSuspenseHandler(workInProgress2), workInProgress2;
            popSuspenseHandler(workInProgress2);
            return null;
          }
          if (0 !== (workInProgress2.flags & 128))
            throw Error(formatProdErrorMessage(558));
        }
        bubbleProperties(workInProgress2);
        return null;
      case 13:
        newProps = workInProgress2.memoizedState;
        if (null === current || null !== current.memoizedState && null !== current.memoizedState.dehydrated) {
          type = popHydrationState(workInProgress2);
          if (null !== newProps && null !== newProps.dehydrated) {
            if (null === current) {
              if (!type) throw Error(formatProdErrorMessage(318));
              type = workInProgress2.memoizedState;
              type = null !== type ? type.dehydrated : null;
              if (!type) throw Error(formatProdErrorMessage(317));
              type[internalInstanceKey] = workInProgress2;
            } else
              resetHydrationState(), 0 === (workInProgress2.flags & 128) && (workInProgress2.memoizedState = null), workInProgress2.flags |= 4;
            bubbleProperties(workInProgress2);
            type = false;
          } else
            type = upgradeHydrationErrorsToRecoverable(), null !== current && null !== current.memoizedState && (current.memoizedState.hydrationErrors = type), type = true;
          if (!type) {
            if (workInProgress2.flags & 256)
              return popSuspenseHandler(workInProgress2), workInProgress2;
            popSuspenseHandler(workInProgress2);
            return null;
          }
        }
        popSuspenseHandler(workInProgress2);
        if (0 !== (workInProgress2.flags & 128))
          return workInProgress2.lanes = renderLanes2, workInProgress2;
        renderLanes2 = null !== newProps;
        current = null !== current && null !== current.memoizedState;
        renderLanes2 && (newProps = workInProgress2.child, type = null, null !== newProps.alternate && null !== newProps.alternate.memoizedState && null !== newProps.alternate.memoizedState.cachePool && (type = newProps.alternate.memoizedState.cachePool.pool), nextResource = null, null !== newProps.memoizedState && null !== newProps.memoizedState.cachePool && (nextResource = newProps.memoizedState.cachePool.pool), nextResource !== type && (newProps.flags |= 2048));
        renderLanes2 !== current && renderLanes2 && (workInProgress2.child.flags |= 8192);
        scheduleRetryEffect(workInProgress2, workInProgress2.updateQueue);
        bubbleProperties(workInProgress2);
        return null;
      case 4:
        return popHostContainer(), null === current && listenToAllSupportedEvents(workInProgress2.stateNode.containerInfo), bubbleProperties(workInProgress2), null;
      case 10:
        return popProvider(workInProgress2.type), bubbleProperties(workInProgress2), null;
      case 19:
        pop(suspenseStackCursor);
        newProps = workInProgress2.memoizedState;
        if (null === newProps) return bubbleProperties(workInProgress2), null;
        type = 0 !== (workInProgress2.flags & 128);
        nextResource = newProps.rendering;
        if (null === nextResource)
          if (type) cutOffTailIfNeeded(newProps, false);
          else {
            if (0 !== workInProgressRootExitStatus || null !== current && 0 !== (current.flags & 128))
              for (current = workInProgress2.child; null !== current; ) {
                nextResource = findFirstSuspended(current);
                if (null !== nextResource) {
                  workInProgress2.flags |= 128;
                  cutOffTailIfNeeded(newProps, false);
                  current = nextResource.updateQueue;
                  workInProgress2.updateQueue = current;
                  scheduleRetryEffect(workInProgress2, current);
                  workInProgress2.subtreeFlags = 0;
                  current = renderLanes2;
                  for (renderLanes2 = workInProgress2.child; null !== renderLanes2; )
                    resetWorkInProgress(renderLanes2, current), renderLanes2 = renderLanes2.sibling;
                  push(
                    suspenseStackCursor,
                    suspenseStackCursor.current & 1 | 2
                  );
                  isHydrating && pushTreeFork(workInProgress2, newProps.treeForkCount);
                  return workInProgress2.child;
                }
                current = current.sibling;
              }
            null !== newProps.tail && now() > workInProgressRootRenderTargetTime && (workInProgress2.flags |= 128, type = true, cutOffTailIfNeeded(newProps, false), workInProgress2.lanes = 4194304);
          }
        else {
          if (!type)
            if (current = findFirstSuspended(nextResource), null !== current) {
              if (workInProgress2.flags |= 128, type = true, current = current.updateQueue, workInProgress2.updateQueue = current, scheduleRetryEffect(workInProgress2, current), cutOffTailIfNeeded(newProps, true), null === newProps.tail && "hidden" === newProps.tailMode && !nextResource.alternate && !isHydrating)
                return bubbleProperties(workInProgress2), null;
            } else
              2 * now() - newProps.renderingStartTime > workInProgressRootRenderTargetTime && 536870912 !== renderLanes2 && (workInProgress2.flags |= 128, type = true, cutOffTailIfNeeded(newProps, false), workInProgress2.lanes = 4194304);
          newProps.isBackwards ? (nextResource.sibling = workInProgress2.child, workInProgress2.child = nextResource) : (current = newProps.last, null !== current ? current.sibling = nextResource : workInProgress2.child = nextResource, newProps.last = nextResource);
        }
        if (null !== newProps.tail)
          return current = newProps.tail, newProps.rendering = current, newProps.tail = current.sibling, newProps.renderingStartTime = now(), current.sibling = null, renderLanes2 = suspenseStackCursor.current, push(
            suspenseStackCursor,
            type ? renderLanes2 & 1 | 2 : renderLanes2 & 1
          ), isHydrating && pushTreeFork(workInProgress2, newProps.treeForkCount), current;
        bubbleProperties(workInProgress2);
        return null;
      case 22:
      case 23:
        return popSuspenseHandler(workInProgress2), popHiddenContext(), newProps = null !== workInProgress2.memoizedState, null !== current ? null !== current.memoizedState !== newProps && (workInProgress2.flags |= 8192) : newProps && (workInProgress2.flags |= 8192), newProps ? 0 !== (renderLanes2 & 536870912) && 0 === (workInProgress2.flags & 128) && (bubbleProperties(workInProgress2), workInProgress2.subtreeFlags & 6 && (workInProgress2.flags |= 8192)) : bubbleProperties(workInProgress2), renderLanes2 = workInProgress2.updateQueue, null !== renderLanes2 && scheduleRetryEffect(workInProgress2, renderLanes2.retryQueue), renderLanes2 = null, null !== current && null !== current.memoizedState && null !== current.memoizedState.cachePool && (renderLanes2 = current.memoizedState.cachePool.pool), newProps = null, null !== workInProgress2.memoizedState && null !== workInProgress2.memoizedState.cachePool && (newProps = workInProgress2.memoizedState.cachePool.pool), newProps !== renderLanes2 && (workInProgress2.flags |= 2048), null !== current && pop(resumedCache), null;
      case 24:
        return renderLanes2 = null, null !== current && (renderLanes2 = current.memoizedState.cache), workInProgress2.memoizedState.cache !== renderLanes2 && (workInProgress2.flags |= 2048), popProvider(CacheContext), bubbleProperties(workInProgress2), null;
      case 25:
        return null;
      case 30:
        return null;
    }
    throw Error(formatProdErrorMessage(156, workInProgress2.tag));
  }
  function unwindWork(current, workInProgress2) {
    popTreeContext(workInProgress2);
    switch (workInProgress2.tag) {
      case 1:
        return current = workInProgress2.flags, current & 65536 ? (workInProgress2.flags = current & -65537 | 128, workInProgress2) : null;
      case 3:
        return popProvider(CacheContext), popHostContainer(), current = workInProgress2.flags, 0 !== (current & 65536) && 0 === (current & 128) ? (workInProgress2.flags = current & -65537 | 128, workInProgress2) : null;
      case 26:
      case 27:
      case 5:
        return popHostContext(workInProgress2), null;
      case 31:
        if (null !== workInProgress2.memoizedState) {
          popSuspenseHandler(workInProgress2);
          if (null === workInProgress2.alternate)
            throw Error(formatProdErrorMessage(340));
          resetHydrationState();
        }
        current = workInProgress2.flags;
        return current & 65536 ? (workInProgress2.flags = current & -65537 | 128, workInProgress2) : null;
      case 13:
        popSuspenseHandler(workInProgress2);
        current = workInProgress2.memoizedState;
        if (null !== current && null !== current.dehydrated) {
          if (null === workInProgress2.alternate)
            throw Error(formatProdErrorMessage(340));
          resetHydrationState();
        }
        current = workInProgress2.flags;
        return current & 65536 ? (workInProgress2.flags = current & -65537 | 128, workInProgress2) : null;
      case 19:
        return pop(suspenseStackCursor), null;
      case 4:
        return popHostContainer(), null;
      case 10:
        return popProvider(workInProgress2.type), null;
      case 22:
      case 23:
        return popSuspenseHandler(workInProgress2), popHiddenContext(), null !== current && pop(resumedCache), current = workInProgress2.flags, current & 65536 ? (workInProgress2.flags = current & -65537 | 128, workInProgress2) : null;
      case 24:
        return popProvider(CacheContext), null;
      case 25:
        return null;
      default:
        return null;
    }
  }
  function unwindInterruptedWork(current, interruptedWork) {
    popTreeContext(interruptedWork);
    switch (interruptedWork.tag) {
      case 3:
        popProvider(CacheContext);
        popHostContainer();
        break;
      case 26:
      case 27:
      case 5:
        popHostContext(interruptedWork);
        break;
      case 4:
        popHostContainer();
        break;
      case 31:
        null !== interruptedWork.memoizedState && popSuspenseHandler(interruptedWork);
        break;
      case 13:
        popSuspenseHandler(interruptedWork);
        break;
      case 19:
        pop(suspenseStackCursor);
        break;
      case 10:
        popProvider(interruptedWork.type);
        break;
      case 22:
      case 23:
        popSuspenseHandler(interruptedWork);
        popHiddenContext();
        null !== current && pop(resumedCache);
        break;
      case 24:
        popProvider(CacheContext);
    }
  }
  function commitHookEffectListMount(flags, finishedWork) {
    try {
      var updateQueue = finishedWork.updateQueue, lastEffect = null !== updateQueue ? updateQueue.lastEffect : null;
      if (null !== lastEffect) {
        var firstEffect = lastEffect.next;
        updateQueue = firstEffect;
        do {
          if ((updateQueue.tag & flags) === flags) {
            lastEffect = void 0;
            var create2 = updateQueue.create, inst = updateQueue.inst;
            lastEffect = create2();
            inst.destroy = lastEffect;
          }
          updateQueue = updateQueue.next;
        } while (updateQueue !== firstEffect);
      }
    } catch (error) {
      captureCommitPhaseError(finishedWork, finishedWork.return, error);
    }
  }
  function commitHookEffectListUnmount(flags, finishedWork, nearestMountedAncestor$jscomp$0) {
    try {
      var updateQueue = finishedWork.updateQueue, lastEffect = null !== updateQueue ? updateQueue.lastEffect : null;
      if (null !== lastEffect) {
        var firstEffect = lastEffect.next;
        updateQueue = firstEffect;
        do {
          if ((updateQueue.tag & flags) === flags) {
            var inst = updateQueue.inst, destroy = inst.destroy;
            if (void 0 !== destroy) {
              inst.destroy = void 0;
              lastEffect = finishedWork;
              var nearestMountedAncestor = nearestMountedAncestor$jscomp$0, destroy_ = destroy;
              try {
                destroy_();
              } catch (error) {
                captureCommitPhaseError(
                  lastEffect,
                  nearestMountedAncestor,
                  error
                );
              }
            }
          }
          updateQueue = updateQueue.next;
        } while (updateQueue !== firstEffect);
      }
    } catch (error) {
      captureCommitPhaseError(finishedWork, finishedWork.return, error);
    }
  }
  function commitClassCallbacks(finishedWork) {
    var updateQueue = finishedWork.updateQueue;
    if (null !== updateQueue) {
      var instance = finishedWork.stateNode;
      try {
        commitCallbacks(updateQueue, instance);
      } catch (error) {
        captureCommitPhaseError(finishedWork, finishedWork.return, error);
      }
    }
  }
  function safelyCallComponentWillUnmount(current, nearestMountedAncestor, instance) {
    instance.props = resolveClassComponentProps(
      current.type,
      current.memoizedProps
    );
    instance.state = current.memoizedState;
    try {
      instance.componentWillUnmount();
    } catch (error) {
      captureCommitPhaseError(current, nearestMountedAncestor, error);
    }
  }
  function safelyAttachRef(current, nearestMountedAncestor) {
    try {
      var ref = current.ref;
      if (null !== ref) {
        switch (current.tag) {
          case 26:
          case 27:
          case 5:
            var instanceToUse = current.stateNode;
            break;
          case 30:
            instanceToUse = current.stateNode;
            break;
          default:
            instanceToUse = current.stateNode;
        }
        "function" === typeof ref ? current.refCleanup = ref(instanceToUse) : ref.current = instanceToUse;
      }
    } catch (error) {
      captureCommitPhaseError(current, nearestMountedAncestor, error);
    }
  }
  function safelyDetachRef(current, nearestMountedAncestor) {
    var ref = current.ref, refCleanup = current.refCleanup;
    if (null !== ref)
      if ("function" === typeof refCleanup)
        try {
          refCleanup();
        } catch (error) {
          captureCommitPhaseError(current, nearestMountedAncestor, error);
        } finally {
          current.refCleanup = null, current = current.alternate, null != current && (current.refCleanup = null);
        }
      else if ("function" === typeof ref)
        try {
          ref(null);
        } catch (error$140) {
          captureCommitPhaseError(current, nearestMountedAncestor, error$140);
        }
      else ref.current = null;
  }
  function commitHostMount(finishedWork) {
    var type = finishedWork.type, props = finishedWork.memoizedProps, instance = finishedWork.stateNode;
    try {
      a: switch (type) {
        case "button":
        case "input":
        case "select":
        case "textarea":
          props.autoFocus && instance.focus();
          break a;
        case "img":
          props.src ? instance.src = props.src : props.srcSet && (instance.srcset = props.srcSet);
      }
    } catch (error) {
      captureCommitPhaseError(finishedWork, finishedWork.return, error);
    }
  }
  function commitHostUpdate(finishedWork, newProps, oldProps) {
    try {
      var domElement = finishedWork.stateNode;
      updateProperties(domElement, finishedWork.type, oldProps, newProps);
      domElement[internalPropsKey] = newProps;
    } catch (error) {
      captureCommitPhaseError(finishedWork, finishedWork.return, error);
    }
  }
  function isHostParent(fiber) {
    return 5 === fiber.tag || 3 === fiber.tag || 26 === fiber.tag || 27 === fiber.tag && isSingletonScope(fiber.type) || 4 === fiber.tag;
  }
  function getHostSibling(fiber) {
    a: for (; ; ) {
      for (; null === fiber.sibling; ) {
        if (null === fiber.return || isHostParent(fiber.return)) return null;
        fiber = fiber.return;
      }
      fiber.sibling.return = fiber.return;
      for (fiber = fiber.sibling; 5 !== fiber.tag && 6 !== fiber.tag && 18 !== fiber.tag; ) {
        if (27 === fiber.tag && isSingletonScope(fiber.type)) continue a;
        if (fiber.flags & 2) continue a;
        if (null === fiber.child || 4 === fiber.tag) continue a;
        else fiber.child.return = fiber, fiber = fiber.child;
      }
      if (!(fiber.flags & 2)) return fiber.stateNode;
    }
  }
  function insertOrAppendPlacementNodeIntoContainer(node, before, parent) {
    var tag = node.tag;
    if (5 === tag || 6 === tag)
      node = node.stateNode, before ? (9 === parent.nodeType ? parent.body : "HTML" === parent.nodeName ? parent.ownerDocument.body : parent).insertBefore(node, before) : (before = 9 === parent.nodeType ? parent.body : "HTML" === parent.nodeName ? parent.ownerDocument.body : parent, before.appendChild(node), parent = parent._reactRootContainer, null !== parent && void 0 !== parent || null !== before.onclick || (before.onclick = noop$12));
    else if (4 !== tag && (27 === tag && isSingletonScope(node.type) && (parent = node.stateNode, before = null), node = node.child, null !== node))
      for (insertOrAppendPlacementNodeIntoContainer(node, before, parent), node = node.sibling; null !== node; )
        insertOrAppendPlacementNodeIntoContainer(node, before, parent), node = node.sibling;
  }
  function insertOrAppendPlacementNode(node, before, parent) {
    var tag = node.tag;
    if (5 === tag || 6 === tag)
      node = node.stateNode, before ? parent.insertBefore(node, before) : parent.appendChild(node);
    else if (4 !== tag && (27 === tag && isSingletonScope(node.type) && (parent = node.stateNode), node = node.child, null !== node))
      for (insertOrAppendPlacementNode(node, before, parent), node = node.sibling; null !== node; )
        insertOrAppendPlacementNode(node, before, parent), node = node.sibling;
  }
  function commitHostSingletonAcquisition(finishedWork) {
    var singleton = finishedWork.stateNode, props = finishedWork.memoizedProps;
    try {
      for (var type = finishedWork.type, attributes = singleton.attributes; attributes.length; )
        singleton.removeAttributeNode(attributes[0]);
      setInitialProperties(singleton, type, props);
      singleton[internalInstanceKey] = finishedWork;
      singleton[internalPropsKey] = props;
    } catch (error) {
      captureCommitPhaseError(finishedWork, finishedWork.return, error);
    }
  }
  var offscreenSubtreeIsHidden = false, offscreenSubtreeWasHidden = false, needsFormReset = false, PossiblyWeakSet = "function" === typeof WeakSet ? WeakSet : Set, nextEffect = null;
  function commitBeforeMutationEffects(root2, firstChild) {
    root2 = root2.containerInfo;
    eventsEnabled = _enabled;
    root2 = getActiveElementDeep(root2);
    if (hasSelectionCapabilities(root2)) {
      if ("selectionStart" in root2)
        var JSCompiler_temp = {
          start: root2.selectionStart,
          end: root2.selectionEnd
        };
      else
        a: {
          JSCompiler_temp = (JSCompiler_temp = root2.ownerDocument) && JSCompiler_temp.defaultView || window;
          var selection = JSCompiler_temp.getSelection && JSCompiler_temp.getSelection();
          if (selection && 0 !== selection.rangeCount) {
            JSCompiler_temp = selection.anchorNode;
            var anchorOffset = selection.anchorOffset, focusNode = selection.focusNode;
            selection = selection.focusOffset;
            try {
              JSCompiler_temp.nodeType, focusNode.nodeType;
            } catch (e$20) {
              JSCompiler_temp = null;
              break a;
            }
            var length = 0, start = -1, end = -1, indexWithinAnchor = 0, indexWithinFocus = 0, node = root2, parentNode = null;
            b: for (; ; ) {
              for (var next; ; ) {
                node !== JSCompiler_temp || 0 !== anchorOffset && 3 !== node.nodeType || (start = length + anchorOffset);
                node !== focusNode || 0 !== selection && 3 !== node.nodeType || (end = length + selection);
                3 === node.nodeType && (length += node.nodeValue.length);
                if (null === (next = node.firstChild)) break;
                parentNode = node;
                node = next;
              }
              for (; ; ) {
                if (node === root2) break b;
                parentNode === JSCompiler_temp && ++indexWithinAnchor === anchorOffset && (start = length);
                parentNode === focusNode && ++indexWithinFocus === selection && (end = length);
                if (null !== (next = node.nextSibling)) break;
                node = parentNode;
                parentNode = node.parentNode;
              }
              node = next;
            }
            JSCompiler_temp = -1 === start || -1 === end ? null : { start, end };
          } else JSCompiler_temp = null;
        }
      JSCompiler_temp = JSCompiler_temp || { start: 0, end: 0 };
    } else JSCompiler_temp = null;
    selectionInformation = { focusedElem: root2, selectionRange: JSCompiler_temp };
    _enabled = false;
    for (nextEffect = firstChild; null !== nextEffect; )
      if (firstChild = nextEffect, root2 = firstChild.child, 0 !== (firstChild.subtreeFlags & 1028) && null !== root2)
        root2.return = firstChild, nextEffect = root2;
      else
        for (; null !== nextEffect; ) {
          firstChild = nextEffect;
          focusNode = firstChild.alternate;
          root2 = firstChild.flags;
          switch (firstChild.tag) {
            case 0:
              if (0 !== (root2 & 4) && (root2 = firstChild.updateQueue, root2 = null !== root2 ? root2.events : null, null !== root2))
                for (JSCompiler_temp = 0; JSCompiler_temp < root2.length; JSCompiler_temp++)
                  anchorOffset = root2[JSCompiler_temp], anchorOffset.ref.impl = anchorOffset.nextImpl;
              break;
            case 11:
            case 15:
              break;
            case 1:
              if (0 !== (root2 & 1024) && null !== focusNode) {
                root2 = void 0;
                JSCompiler_temp = firstChild;
                anchorOffset = focusNode.memoizedProps;
                focusNode = focusNode.memoizedState;
                selection = JSCompiler_temp.stateNode;
                try {
                  var resolvedPrevProps = resolveClassComponentProps(
                    JSCompiler_temp.type,
                    anchorOffset
                  );
                  root2 = selection.getSnapshotBeforeUpdate(
                    resolvedPrevProps,
                    focusNode
                  );
                  selection.__reactInternalSnapshotBeforeUpdate = root2;
                } catch (error) {
                  captureCommitPhaseError(
                    JSCompiler_temp,
                    JSCompiler_temp.return,
                    error
                  );
                }
              }
              break;
            case 3:
              if (0 !== (root2 & 1024)) {
                if (root2 = firstChild.stateNode.containerInfo, JSCompiler_temp = root2.nodeType, 9 === JSCompiler_temp)
                  clearContainerSparingly(root2);
                else if (1 === JSCompiler_temp)
                  switch (root2.nodeName) {
                    case "HEAD":
                    case "HTML":
                    case "BODY":
                      clearContainerSparingly(root2);
                      break;
                    default:
                      root2.textContent = "";
                  }
              }
              break;
            case 5:
            case 26:
            case 27:
            case 6:
            case 4:
            case 17:
              break;
            default:
              if (0 !== (root2 & 1024)) throw Error(formatProdErrorMessage(163));
          }
          root2 = firstChild.sibling;
          if (null !== root2) {
            root2.return = firstChild.return;
            nextEffect = root2;
            break;
          }
          nextEffect = firstChild.return;
        }
  }
  function commitLayoutEffectOnFiber(finishedRoot, current, finishedWork) {
    var flags = finishedWork.flags;
    switch (finishedWork.tag) {
      case 0:
      case 11:
      case 15:
        recursivelyTraverseLayoutEffects(finishedRoot, finishedWork);
        flags & 4 && commitHookEffectListMount(5, finishedWork);
        break;
      case 1:
        recursivelyTraverseLayoutEffects(finishedRoot, finishedWork);
        if (flags & 4)
          if (finishedRoot = finishedWork.stateNode, null === current)
            try {
              finishedRoot.componentDidMount();
            } catch (error) {
              captureCommitPhaseError(finishedWork, finishedWork.return, error);
            }
          else {
            var prevProps = resolveClassComponentProps(
              finishedWork.type,
              current.memoizedProps
            );
            current = current.memoizedState;
            try {
              finishedRoot.componentDidUpdate(
                prevProps,
                current,
                finishedRoot.__reactInternalSnapshotBeforeUpdate
              );
            } catch (error$139) {
              captureCommitPhaseError(
                finishedWork,
                finishedWork.return,
                error$139
              );
            }
          }
        flags & 64 && commitClassCallbacks(finishedWork);
        flags & 512 && safelyAttachRef(finishedWork, finishedWork.return);
        break;
      case 3:
        recursivelyTraverseLayoutEffects(finishedRoot, finishedWork);
        if (flags & 64 && (finishedRoot = finishedWork.updateQueue, null !== finishedRoot)) {
          current = null;
          if (null !== finishedWork.child)
            switch (finishedWork.child.tag) {
              case 27:
              case 5:
                current = finishedWork.child.stateNode;
                break;
              case 1:
                current = finishedWork.child.stateNode;
            }
          try {
            commitCallbacks(finishedRoot, current);
          } catch (error) {
            captureCommitPhaseError(finishedWork, finishedWork.return, error);
          }
        }
        break;
      case 27:
        null === current && flags & 4 && commitHostSingletonAcquisition(finishedWork);
      case 26:
      case 5:
        recursivelyTraverseLayoutEffects(finishedRoot, finishedWork);
        null === current && flags & 4 && commitHostMount(finishedWork);
        flags & 512 && safelyAttachRef(finishedWork, finishedWork.return);
        break;
      case 12:
        recursivelyTraverseLayoutEffects(finishedRoot, finishedWork);
        break;
      case 31:
        recursivelyTraverseLayoutEffects(finishedRoot, finishedWork);
        flags & 4 && commitActivityHydrationCallbacks(finishedRoot, finishedWork);
        break;
      case 13:
        recursivelyTraverseLayoutEffects(finishedRoot, finishedWork);
        flags & 4 && commitSuspenseHydrationCallbacks(finishedRoot, finishedWork);
        flags & 64 && (finishedRoot = finishedWork.memoizedState, null !== finishedRoot && (finishedRoot = finishedRoot.dehydrated, null !== finishedRoot && (finishedWork = retryDehydratedSuspenseBoundary.bind(
          null,
          finishedWork
        ), registerSuspenseInstanceRetry(finishedRoot, finishedWork))));
        break;
      case 22:
        flags = null !== finishedWork.memoizedState || offscreenSubtreeIsHidden;
        if (!flags) {
          current = null !== current && null !== current.memoizedState || offscreenSubtreeWasHidden;
          prevProps = offscreenSubtreeIsHidden;
          var prevOffscreenSubtreeWasHidden = offscreenSubtreeWasHidden;
          offscreenSubtreeIsHidden = flags;
          (offscreenSubtreeWasHidden = current) && !prevOffscreenSubtreeWasHidden ? recursivelyTraverseReappearLayoutEffects(
            finishedRoot,
            finishedWork,
            0 !== (finishedWork.subtreeFlags & 8772)
          ) : recursivelyTraverseLayoutEffects(finishedRoot, finishedWork);
          offscreenSubtreeIsHidden = prevProps;
          offscreenSubtreeWasHidden = prevOffscreenSubtreeWasHidden;
        }
        break;
      case 30:
        break;
      default:
        recursivelyTraverseLayoutEffects(finishedRoot, finishedWork);
    }
  }
  function detachFiberAfterEffects(fiber) {
    var alternate = fiber.alternate;
    null !== alternate && (fiber.alternate = null, detachFiberAfterEffects(alternate));
    fiber.child = null;
    fiber.deletions = null;
    fiber.sibling = null;
    5 === fiber.tag && (alternate = fiber.stateNode, null !== alternate && detachDeletedInstance(alternate));
    fiber.stateNode = null;
    fiber.return = null;
    fiber.dependencies = null;
    fiber.memoizedProps = null;
    fiber.memoizedState = null;
    fiber.pendingProps = null;
    fiber.stateNode = null;
    fiber.updateQueue = null;
  }
  var hostParent = null, hostParentIsContainer = false;
  function recursivelyTraverseDeletionEffects(finishedRoot, nearestMountedAncestor, parent) {
    for (parent = parent.child; null !== parent; )
      commitDeletionEffectsOnFiber(finishedRoot, nearestMountedAncestor, parent), parent = parent.sibling;
  }
  function commitDeletionEffectsOnFiber(finishedRoot, nearestMountedAncestor, deletedFiber) {
    if (injectedHook && "function" === typeof injectedHook.onCommitFiberUnmount)
      try {
        injectedHook.onCommitFiberUnmount(rendererID, deletedFiber);
      } catch (err2) {
      }
    switch (deletedFiber.tag) {
      case 26:
        offscreenSubtreeWasHidden || safelyDetachRef(deletedFiber, nearestMountedAncestor);
        recursivelyTraverseDeletionEffects(
          finishedRoot,
          nearestMountedAncestor,
          deletedFiber
        );
        deletedFiber.memoizedState ? deletedFiber.memoizedState.count-- : deletedFiber.stateNode && (deletedFiber = deletedFiber.stateNode, deletedFiber.parentNode.removeChild(deletedFiber));
        break;
      case 27:
        offscreenSubtreeWasHidden || safelyDetachRef(deletedFiber, nearestMountedAncestor);
        var prevHostParent = hostParent, prevHostParentIsContainer = hostParentIsContainer;
        isSingletonScope(deletedFiber.type) && (hostParent = deletedFiber.stateNode, hostParentIsContainer = false);
        recursivelyTraverseDeletionEffects(
          finishedRoot,
          nearestMountedAncestor,
          deletedFiber
        );
        releaseSingletonInstance(deletedFiber.stateNode);
        hostParent = prevHostParent;
        hostParentIsContainer = prevHostParentIsContainer;
        break;
      case 5:
        offscreenSubtreeWasHidden || safelyDetachRef(deletedFiber, nearestMountedAncestor);
      case 6:
        prevHostParent = hostParent;
        prevHostParentIsContainer = hostParentIsContainer;
        hostParent = null;
        recursivelyTraverseDeletionEffects(
          finishedRoot,
          nearestMountedAncestor,
          deletedFiber
        );
        hostParent = prevHostParent;
        hostParentIsContainer = prevHostParentIsContainer;
        if (null !== hostParent)
          if (hostParentIsContainer)
            try {
              (9 === hostParent.nodeType ? hostParent.body : "HTML" === hostParent.nodeName ? hostParent.ownerDocument.body : hostParent).removeChild(deletedFiber.stateNode);
            } catch (error) {
              captureCommitPhaseError(
                deletedFiber,
                nearestMountedAncestor,
                error
              );
            }
          else
            try {
              hostParent.removeChild(deletedFiber.stateNode);
            } catch (error) {
              captureCommitPhaseError(
                deletedFiber,
                nearestMountedAncestor,
                error
              );
            }
        break;
      case 18:
        null !== hostParent && (hostParentIsContainer ? (finishedRoot = hostParent, clearHydrationBoundary(
          9 === finishedRoot.nodeType ? finishedRoot.body : "HTML" === finishedRoot.nodeName ? finishedRoot.ownerDocument.body : finishedRoot,
          deletedFiber.stateNode
        ), retryIfBlockedOn(finishedRoot)) : clearHydrationBoundary(hostParent, deletedFiber.stateNode));
        break;
      case 4:
        prevHostParent = hostParent;
        prevHostParentIsContainer = hostParentIsContainer;
        hostParent = deletedFiber.stateNode.containerInfo;
        hostParentIsContainer = true;
        recursivelyTraverseDeletionEffects(
          finishedRoot,
          nearestMountedAncestor,
          deletedFiber
        );
        hostParent = prevHostParent;
        hostParentIsContainer = prevHostParentIsContainer;
        break;
      case 0:
      case 11:
      case 14:
      case 15:
        commitHookEffectListUnmount(2, deletedFiber, nearestMountedAncestor);
        offscreenSubtreeWasHidden || commitHookEffectListUnmount(4, deletedFiber, nearestMountedAncestor);
        recursivelyTraverseDeletionEffects(
          finishedRoot,
          nearestMountedAncestor,
          deletedFiber
        );
        break;
      case 1:
        offscreenSubtreeWasHidden || (safelyDetachRef(deletedFiber, nearestMountedAncestor), prevHostParent = deletedFiber.stateNode, "function" === typeof prevHostParent.componentWillUnmount && safelyCallComponentWillUnmount(
          deletedFiber,
          nearestMountedAncestor,
          prevHostParent
        ));
        recursivelyTraverseDeletionEffects(
          finishedRoot,
          nearestMountedAncestor,
          deletedFiber
        );
        break;
      case 21:
        recursivelyTraverseDeletionEffects(
          finishedRoot,
          nearestMountedAncestor,
          deletedFiber
        );
        break;
      case 22:
        offscreenSubtreeWasHidden = (prevHostParent = offscreenSubtreeWasHidden) || null !== deletedFiber.memoizedState;
        recursivelyTraverseDeletionEffects(
          finishedRoot,
          nearestMountedAncestor,
          deletedFiber
        );
        offscreenSubtreeWasHidden = prevHostParent;
        break;
      default:
        recursivelyTraverseDeletionEffects(
          finishedRoot,
          nearestMountedAncestor,
          deletedFiber
        );
    }
  }
  function commitActivityHydrationCallbacks(finishedRoot, finishedWork) {
    if (null === finishedWork.memoizedState && (finishedRoot = finishedWork.alternate, null !== finishedRoot && (finishedRoot = finishedRoot.memoizedState, null !== finishedRoot))) {
      finishedRoot = finishedRoot.dehydrated;
      try {
        retryIfBlockedOn(finishedRoot);
      } catch (error) {
        captureCommitPhaseError(finishedWork, finishedWork.return, error);
      }
    }
  }
  function commitSuspenseHydrationCallbacks(finishedRoot, finishedWork) {
    if (null === finishedWork.memoizedState && (finishedRoot = finishedWork.alternate, null !== finishedRoot && (finishedRoot = finishedRoot.memoizedState, null !== finishedRoot && (finishedRoot = finishedRoot.dehydrated, null !== finishedRoot))))
      try {
        retryIfBlockedOn(finishedRoot);
      } catch (error) {
        captureCommitPhaseError(finishedWork, finishedWork.return, error);
      }
  }
  function getRetryCache(finishedWork) {
    switch (finishedWork.tag) {
      case 31:
      case 13:
      case 19:
        var retryCache = finishedWork.stateNode;
        null === retryCache && (retryCache = finishedWork.stateNode = new PossiblyWeakSet());
        return retryCache;
      case 22:
        return finishedWork = finishedWork.stateNode, retryCache = finishedWork._retryCache, null === retryCache && (retryCache = finishedWork._retryCache = new PossiblyWeakSet()), retryCache;
      default:
        throw Error(formatProdErrorMessage(435, finishedWork.tag));
    }
  }
  function attachSuspenseRetryListeners(finishedWork, wakeables) {
    var retryCache = getRetryCache(finishedWork);
    wakeables.forEach(function(wakeable) {
      if (!retryCache.has(wakeable)) {
        retryCache.add(wakeable);
        var retry = resolveRetryWakeable.bind(null, finishedWork, wakeable);
        wakeable.then(retry, retry);
      }
    });
  }
  function recursivelyTraverseMutationEffects(root$jscomp$0, parentFiber) {
    var deletions = parentFiber.deletions;
    if (null !== deletions)
      for (var i3 = 0; i3 < deletions.length; i3++) {
        var childToDelete = deletions[i3], root2 = root$jscomp$0, returnFiber = parentFiber, parent = returnFiber;
        a: for (; null !== parent; ) {
          switch (parent.tag) {
            case 27:
              if (isSingletonScope(parent.type)) {
                hostParent = parent.stateNode;
                hostParentIsContainer = false;
                break a;
              }
              break;
            case 5:
              hostParent = parent.stateNode;
              hostParentIsContainer = false;
              break a;
            case 3:
            case 4:
              hostParent = parent.stateNode.containerInfo;
              hostParentIsContainer = true;
              break a;
          }
          parent = parent.return;
        }
        if (null === hostParent) throw Error(formatProdErrorMessage(160));
        commitDeletionEffectsOnFiber(root2, returnFiber, childToDelete);
        hostParent = null;
        hostParentIsContainer = false;
        root2 = childToDelete.alternate;
        null !== root2 && (root2.return = null);
        childToDelete.return = null;
      }
    if (parentFiber.subtreeFlags & 13886)
      for (parentFiber = parentFiber.child; null !== parentFiber; )
        commitMutationEffectsOnFiber(parentFiber, root$jscomp$0), parentFiber = parentFiber.sibling;
  }
  var currentHoistableRoot = null;
  function commitMutationEffectsOnFiber(finishedWork, root2) {
    var current = finishedWork.alternate, flags = finishedWork.flags;
    switch (finishedWork.tag) {
      case 0:
      case 11:
      case 14:
      case 15:
        recursivelyTraverseMutationEffects(root2, finishedWork);
        commitReconciliationEffects(finishedWork);
        flags & 4 && (commitHookEffectListUnmount(3, finishedWork, finishedWork.return), commitHookEffectListMount(3, finishedWork), commitHookEffectListUnmount(5, finishedWork, finishedWork.return));
        break;
      case 1:
        recursivelyTraverseMutationEffects(root2, finishedWork);
        commitReconciliationEffects(finishedWork);
        flags & 512 && (offscreenSubtreeWasHidden || null === current || safelyDetachRef(current, current.return));
        flags & 64 && offscreenSubtreeIsHidden && (finishedWork = finishedWork.updateQueue, null !== finishedWork && (flags = finishedWork.callbacks, null !== flags && (current = finishedWork.shared.hiddenCallbacks, finishedWork.shared.hiddenCallbacks = null === current ? flags : current.concat(flags))));
        break;
      case 26:
        var hoistableRoot = currentHoistableRoot;
        recursivelyTraverseMutationEffects(root2, finishedWork);
        commitReconciliationEffects(finishedWork);
        flags & 512 && (offscreenSubtreeWasHidden || null === current || safelyDetachRef(current, current.return));
        if (flags & 4) {
          var currentResource = null !== current ? current.memoizedState : null;
          flags = finishedWork.memoizedState;
          if (null === current)
            if (null === flags)
              if (null === finishedWork.stateNode) {
                a: {
                  flags = finishedWork.type;
                  current = finishedWork.memoizedProps;
                  hoistableRoot = hoistableRoot.ownerDocument || hoistableRoot;
                  b: switch (flags) {
                    case "title":
                      currentResource = hoistableRoot.getElementsByTagName("title")[0];
                      if (!currentResource || currentResource[internalHoistableMarker] || currentResource[internalInstanceKey] || "http://www.w3.org/2000/svg" === currentResource.namespaceURI || currentResource.hasAttribute("itemprop"))
                        currentResource = hoistableRoot.createElement(flags), hoistableRoot.head.insertBefore(
                          currentResource,
                          hoistableRoot.querySelector("head > title")
                        );
                      setInitialProperties(currentResource, flags, current);
                      currentResource[internalInstanceKey] = finishedWork;
                      markNodeAsHoistable(currentResource);
                      flags = currentResource;
                      break a;
                    case "link":
                      var maybeNodes = getHydratableHoistableCache(
                        "link",
                        "href",
                        hoistableRoot
                      ).get(flags + (current.href || ""));
                      if (maybeNodes) {
                        for (var i3 = 0; i3 < maybeNodes.length; i3++)
                          if (currentResource = maybeNodes[i3], currentResource.getAttribute("href") === (null == current.href || "" === current.href ? null : current.href) && currentResource.getAttribute("rel") === (null == current.rel ? null : current.rel) && currentResource.getAttribute("title") === (null == current.title ? null : current.title) && currentResource.getAttribute("crossorigin") === (null == current.crossOrigin ? null : current.crossOrigin)) {
                            maybeNodes.splice(i3, 1);
                            break b;
                          }
                      }
                      currentResource = hoistableRoot.createElement(flags);
                      setInitialProperties(currentResource, flags, current);
                      hoistableRoot.head.appendChild(currentResource);
                      break;
                    case "meta":
                      if (maybeNodes = getHydratableHoistableCache(
                        "meta",
                        "content",
                        hoistableRoot
                      ).get(flags + (current.content || ""))) {
                        for (i3 = 0; i3 < maybeNodes.length; i3++)
                          if (currentResource = maybeNodes[i3], currentResource.getAttribute("content") === (null == current.content ? null : "" + current.content) && currentResource.getAttribute("name") === (null == current.name ? null : current.name) && currentResource.getAttribute("property") === (null == current.property ? null : current.property) && currentResource.getAttribute("http-equiv") === (null == current.httpEquiv ? null : current.httpEquiv) && currentResource.getAttribute("charset") === (null == current.charSet ? null : current.charSet)) {
                            maybeNodes.splice(i3, 1);
                            break b;
                          }
                      }
                      currentResource = hoistableRoot.createElement(flags);
                      setInitialProperties(currentResource, flags, current);
                      hoistableRoot.head.appendChild(currentResource);
                      break;
                    default:
                      throw Error(formatProdErrorMessage(468, flags));
                  }
                  currentResource[internalInstanceKey] = finishedWork;
                  markNodeAsHoistable(currentResource);
                  flags = currentResource;
                }
                finishedWork.stateNode = flags;
              } else
                mountHoistable(
                  hoistableRoot,
                  finishedWork.type,
                  finishedWork.stateNode
                );
            else
              finishedWork.stateNode = acquireResource(
                hoistableRoot,
                flags,
                finishedWork.memoizedProps
              );
          else
            currentResource !== flags ? (null === currentResource ? null !== current.stateNode && (current = current.stateNode, current.parentNode.removeChild(current)) : currentResource.count--, null === flags ? mountHoistable(
              hoistableRoot,
              finishedWork.type,
              finishedWork.stateNode
            ) : acquireResource(
              hoistableRoot,
              flags,
              finishedWork.memoizedProps
            )) : null === flags && null !== finishedWork.stateNode && commitHostUpdate(
              finishedWork,
              finishedWork.memoizedProps,
              current.memoizedProps
            );
        }
        break;
      case 27:
        recursivelyTraverseMutationEffects(root2, finishedWork);
        commitReconciliationEffects(finishedWork);
        flags & 512 && (offscreenSubtreeWasHidden || null === current || safelyDetachRef(current, current.return));
        null !== current && flags & 4 && commitHostUpdate(
          finishedWork,
          finishedWork.memoizedProps,
          current.memoizedProps
        );
        break;
      case 5:
        recursivelyTraverseMutationEffects(root2, finishedWork);
        commitReconciliationEffects(finishedWork);
        flags & 512 && (offscreenSubtreeWasHidden || null === current || safelyDetachRef(current, current.return));
        if (finishedWork.flags & 32) {
          hoistableRoot = finishedWork.stateNode;
          try {
            setTextContent(hoistableRoot, "");
          } catch (error) {
            captureCommitPhaseError(finishedWork, finishedWork.return, error);
          }
        }
        flags & 4 && null != finishedWork.stateNode && (hoistableRoot = finishedWork.memoizedProps, commitHostUpdate(
          finishedWork,
          hoistableRoot,
          null !== current ? current.memoizedProps : hoistableRoot
        ));
        flags & 1024 && (needsFormReset = true);
        break;
      case 6:
        recursivelyTraverseMutationEffects(root2, finishedWork);
        commitReconciliationEffects(finishedWork);
        if (flags & 4) {
          if (null === finishedWork.stateNode)
            throw Error(formatProdErrorMessage(162));
          flags = finishedWork.memoizedProps;
          current = finishedWork.stateNode;
          try {
            current.nodeValue = flags;
          } catch (error) {
            captureCommitPhaseError(finishedWork, finishedWork.return, error);
          }
        }
        break;
      case 3:
        tagCaches = null;
        hoistableRoot = currentHoistableRoot;
        currentHoistableRoot = getHoistableRoot(root2.containerInfo);
        recursivelyTraverseMutationEffects(root2, finishedWork);
        currentHoistableRoot = hoistableRoot;
        commitReconciliationEffects(finishedWork);
        if (flags & 4 && null !== current && current.memoizedState.isDehydrated)
          try {
            retryIfBlockedOn(root2.containerInfo);
          } catch (error) {
            captureCommitPhaseError(finishedWork, finishedWork.return, error);
          }
        needsFormReset && (needsFormReset = false, recursivelyResetForms(finishedWork));
        break;
      case 4:
        flags = currentHoistableRoot;
        currentHoistableRoot = getHoistableRoot(
          finishedWork.stateNode.containerInfo
        );
        recursivelyTraverseMutationEffects(root2, finishedWork);
        commitReconciliationEffects(finishedWork);
        currentHoistableRoot = flags;
        break;
      case 12:
        recursivelyTraverseMutationEffects(root2, finishedWork);
        commitReconciliationEffects(finishedWork);
        break;
      case 31:
        recursivelyTraverseMutationEffects(root2, finishedWork);
        commitReconciliationEffects(finishedWork);
        flags & 4 && (flags = finishedWork.updateQueue, null !== flags && (finishedWork.updateQueue = null, attachSuspenseRetryListeners(finishedWork, flags)));
        break;
      case 13:
        recursivelyTraverseMutationEffects(root2, finishedWork);
        commitReconciliationEffects(finishedWork);
        finishedWork.child.flags & 8192 && null !== finishedWork.memoizedState !== (null !== current && null !== current.memoizedState) && (globalMostRecentFallbackTime = now());
        flags & 4 && (flags = finishedWork.updateQueue, null !== flags && (finishedWork.updateQueue = null, attachSuspenseRetryListeners(finishedWork, flags)));
        break;
      case 22:
        hoistableRoot = null !== finishedWork.memoizedState;
        var wasHidden = null !== current && null !== current.memoizedState, prevOffscreenSubtreeIsHidden = offscreenSubtreeIsHidden, prevOffscreenSubtreeWasHidden = offscreenSubtreeWasHidden;
        offscreenSubtreeIsHidden = prevOffscreenSubtreeIsHidden || hoistableRoot;
        offscreenSubtreeWasHidden = prevOffscreenSubtreeWasHidden || wasHidden;
        recursivelyTraverseMutationEffects(root2, finishedWork);
        offscreenSubtreeWasHidden = prevOffscreenSubtreeWasHidden;
        offscreenSubtreeIsHidden = prevOffscreenSubtreeIsHidden;
        commitReconciliationEffects(finishedWork);
        if (flags & 8192)
          a: for (root2 = finishedWork.stateNode, root2._visibility = hoistableRoot ? root2._visibility & -2 : root2._visibility | 1, hoistableRoot && (null === current || wasHidden || offscreenSubtreeIsHidden || offscreenSubtreeWasHidden || recursivelyTraverseDisappearLayoutEffects(finishedWork)), current = null, root2 = finishedWork; ; ) {
            if (5 === root2.tag || 26 === root2.tag) {
              if (null === current) {
                wasHidden = current = root2;
                try {
                  if (currentResource = wasHidden.stateNode, hoistableRoot)
                    maybeNodes = currentResource.style, "function" === typeof maybeNodes.setProperty ? maybeNodes.setProperty("display", "none", "important") : maybeNodes.display = "none";
                  else {
                    i3 = wasHidden.stateNode;
                    var styleProp = wasHidden.memoizedProps.style, display = void 0 !== styleProp && null !== styleProp && styleProp.hasOwnProperty("display") ? styleProp.display : null;
                    i3.style.display = null == display || "boolean" === typeof display ? "" : ("" + display).trim();
                  }
                } catch (error) {
                  captureCommitPhaseError(wasHidden, wasHidden.return, error);
                }
              }
            } else if (6 === root2.tag) {
              if (null === current) {
                wasHidden = root2;
                try {
                  wasHidden.stateNode.nodeValue = hoistableRoot ? "" : wasHidden.memoizedProps;
                } catch (error) {
                  captureCommitPhaseError(wasHidden, wasHidden.return, error);
                }
              }
            } else if (18 === root2.tag) {
              if (null === current) {
                wasHidden = root2;
                try {
                  var instance = wasHidden.stateNode;
                  hoistableRoot ? hideOrUnhideDehydratedBoundary(instance, true) : hideOrUnhideDehydratedBoundary(wasHidden.stateNode, false);
                } catch (error) {
                  captureCommitPhaseError(wasHidden, wasHidden.return, error);
                }
              }
            } else if ((22 !== root2.tag && 23 !== root2.tag || null === root2.memoizedState || root2 === finishedWork) && null !== root2.child) {
              root2.child.return = root2;
              root2 = root2.child;
              continue;
            }
            if (root2 === finishedWork) break a;
            for (; null === root2.sibling; ) {
              if (null === root2.return || root2.return === finishedWork) break a;
              current === root2 && (current = null);
              root2 = root2.return;
            }
            current === root2 && (current = null);
            root2.sibling.return = root2.return;
            root2 = root2.sibling;
          }
        flags & 4 && (flags = finishedWork.updateQueue, null !== flags && (current = flags.retryQueue, null !== current && (flags.retryQueue = null, attachSuspenseRetryListeners(finishedWork, current))));
        break;
      case 19:
        recursivelyTraverseMutationEffects(root2, finishedWork);
        commitReconciliationEffects(finishedWork);
        flags & 4 && (flags = finishedWork.updateQueue, null !== flags && (finishedWork.updateQueue = null, attachSuspenseRetryListeners(finishedWork, flags)));
        break;
      case 30:
        break;
      case 21:
        break;
      default:
        recursivelyTraverseMutationEffects(root2, finishedWork), commitReconciliationEffects(finishedWork);
    }
  }
  function commitReconciliationEffects(finishedWork) {
    var flags = finishedWork.flags;
    if (flags & 2) {
      try {
        for (var hostParentFiber, parentFiber = finishedWork.return; null !== parentFiber; ) {
          if (isHostParent(parentFiber)) {
            hostParentFiber = parentFiber;
            break;
          }
          parentFiber = parentFiber.return;
        }
        if (null == hostParentFiber) throw Error(formatProdErrorMessage(160));
        switch (hostParentFiber.tag) {
          case 27:
            var parent = hostParentFiber.stateNode, before = getHostSibling(finishedWork);
            insertOrAppendPlacementNode(finishedWork, before, parent);
            break;
          case 5:
            var parent$141 = hostParentFiber.stateNode;
            hostParentFiber.flags & 32 && (setTextContent(parent$141, ""), hostParentFiber.flags &= -33);
            var before$142 = getHostSibling(finishedWork);
            insertOrAppendPlacementNode(finishedWork, before$142, parent$141);
            break;
          case 3:
          case 4:
            var parent$143 = hostParentFiber.stateNode.containerInfo, before$144 = getHostSibling(finishedWork);
            insertOrAppendPlacementNodeIntoContainer(
              finishedWork,
              before$144,
              parent$143
            );
            break;
          default:
            throw Error(formatProdErrorMessage(161));
        }
      } catch (error) {
        captureCommitPhaseError(finishedWork, finishedWork.return, error);
      }
      finishedWork.flags &= -3;
    }
    flags & 4096 && (finishedWork.flags &= -4097);
  }
  function recursivelyResetForms(parentFiber) {
    if (parentFiber.subtreeFlags & 1024)
      for (parentFiber = parentFiber.child; null !== parentFiber; ) {
        var fiber = parentFiber;
        recursivelyResetForms(fiber);
        5 === fiber.tag && fiber.flags & 1024 && fiber.stateNode.reset();
        parentFiber = parentFiber.sibling;
      }
  }
  function recursivelyTraverseLayoutEffects(root2, parentFiber) {
    if (parentFiber.subtreeFlags & 8772)
      for (parentFiber = parentFiber.child; null !== parentFiber; )
        commitLayoutEffectOnFiber(root2, parentFiber.alternate, parentFiber), parentFiber = parentFiber.sibling;
  }
  function recursivelyTraverseDisappearLayoutEffects(parentFiber) {
    for (parentFiber = parentFiber.child; null !== parentFiber; ) {
      var finishedWork = parentFiber;
      switch (finishedWork.tag) {
        case 0:
        case 11:
        case 14:
        case 15:
          commitHookEffectListUnmount(4, finishedWork, finishedWork.return);
          recursivelyTraverseDisappearLayoutEffects(finishedWork);
          break;
        case 1:
          safelyDetachRef(finishedWork, finishedWork.return);
          var instance = finishedWork.stateNode;
          "function" === typeof instance.componentWillUnmount && safelyCallComponentWillUnmount(
            finishedWork,
            finishedWork.return,
            instance
          );
          recursivelyTraverseDisappearLayoutEffects(finishedWork);
          break;
        case 27:
          releaseSingletonInstance(finishedWork.stateNode);
        case 26:
        case 5:
          safelyDetachRef(finishedWork, finishedWork.return);
          recursivelyTraverseDisappearLayoutEffects(finishedWork);
          break;
        case 22:
          null === finishedWork.memoizedState && recursivelyTraverseDisappearLayoutEffects(finishedWork);
          break;
        case 30:
          recursivelyTraverseDisappearLayoutEffects(finishedWork);
          break;
        default:
          recursivelyTraverseDisappearLayoutEffects(finishedWork);
      }
      parentFiber = parentFiber.sibling;
    }
  }
  function recursivelyTraverseReappearLayoutEffects(finishedRoot$jscomp$0, parentFiber, includeWorkInProgressEffects) {
    includeWorkInProgressEffects = includeWorkInProgressEffects && 0 !== (parentFiber.subtreeFlags & 8772);
    for (parentFiber = parentFiber.child; null !== parentFiber; ) {
      var current = parentFiber.alternate, finishedRoot = finishedRoot$jscomp$0, finishedWork = parentFiber, flags = finishedWork.flags;
      switch (finishedWork.tag) {
        case 0:
        case 11:
        case 15:
          recursivelyTraverseReappearLayoutEffects(
            finishedRoot,
            finishedWork,
            includeWorkInProgressEffects
          );
          commitHookEffectListMount(4, finishedWork);
          break;
        case 1:
          recursivelyTraverseReappearLayoutEffects(
            finishedRoot,
            finishedWork,
            includeWorkInProgressEffects
          );
          current = finishedWork;
          finishedRoot = current.stateNode;
          if ("function" === typeof finishedRoot.componentDidMount)
            try {
              finishedRoot.componentDidMount();
            } catch (error) {
              captureCommitPhaseError(current, current.return, error);
            }
          current = finishedWork;
          finishedRoot = current.updateQueue;
          if (null !== finishedRoot) {
            var instance = current.stateNode;
            try {
              var hiddenCallbacks = finishedRoot.shared.hiddenCallbacks;
              if (null !== hiddenCallbacks)
                for (finishedRoot.shared.hiddenCallbacks = null, finishedRoot = 0; finishedRoot < hiddenCallbacks.length; finishedRoot++)
                  callCallback(hiddenCallbacks[finishedRoot], instance);
            } catch (error) {
              captureCommitPhaseError(current, current.return, error);
            }
          }
          includeWorkInProgressEffects && flags & 64 && commitClassCallbacks(finishedWork);
          safelyAttachRef(finishedWork, finishedWork.return);
          break;
        case 27:
          commitHostSingletonAcquisition(finishedWork);
        case 26:
        case 5:
          recursivelyTraverseReappearLayoutEffects(
            finishedRoot,
            finishedWork,
            includeWorkInProgressEffects
          );
          includeWorkInProgressEffects && null === current && flags & 4 && commitHostMount(finishedWork);
          safelyAttachRef(finishedWork, finishedWork.return);
          break;
        case 12:
          recursivelyTraverseReappearLayoutEffects(
            finishedRoot,
            finishedWork,
            includeWorkInProgressEffects
          );
          break;
        case 31:
          recursivelyTraverseReappearLayoutEffects(
            finishedRoot,
            finishedWork,
            includeWorkInProgressEffects
          );
          includeWorkInProgressEffects && flags & 4 && commitActivityHydrationCallbacks(finishedRoot, finishedWork);
          break;
        case 13:
          recursivelyTraverseReappearLayoutEffects(
            finishedRoot,
            finishedWork,
            includeWorkInProgressEffects
          );
          includeWorkInProgressEffects && flags & 4 && commitSuspenseHydrationCallbacks(finishedRoot, finishedWork);
          break;
        case 22:
          null === finishedWork.memoizedState && recursivelyTraverseReappearLayoutEffects(
            finishedRoot,
            finishedWork,
            includeWorkInProgressEffects
          );
          safelyAttachRef(finishedWork, finishedWork.return);
          break;
        case 30:
          break;
        default:
          recursivelyTraverseReappearLayoutEffects(
            finishedRoot,
            finishedWork,
            includeWorkInProgressEffects
          );
      }
      parentFiber = parentFiber.sibling;
    }
  }
  function commitOffscreenPassiveMountEffects(current, finishedWork) {
    var previousCache = null;
    null !== current && null !== current.memoizedState && null !== current.memoizedState.cachePool && (previousCache = current.memoizedState.cachePool.pool);
    current = null;
    null !== finishedWork.memoizedState && null !== finishedWork.memoizedState.cachePool && (current = finishedWork.memoizedState.cachePool.pool);
    current !== previousCache && (null != current && current.refCount++, null != previousCache && releaseCache(previousCache));
  }
  function commitCachePassiveMountEffect(current, finishedWork) {
    current = null;
    null !== finishedWork.alternate && (current = finishedWork.alternate.memoizedState.cache);
    finishedWork = finishedWork.memoizedState.cache;
    finishedWork !== current && (finishedWork.refCount++, null != current && releaseCache(current));
  }
  function recursivelyTraversePassiveMountEffects(root2, parentFiber, committedLanes, committedTransitions) {
    if (parentFiber.subtreeFlags & 10256)
      for (parentFiber = parentFiber.child; null !== parentFiber; )
        commitPassiveMountOnFiber(
          root2,
          parentFiber,
          committedLanes,
          committedTransitions
        ), parentFiber = parentFiber.sibling;
  }
  function commitPassiveMountOnFiber(finishedRoot, finishedWork, committedLanes, committedTransitions) {
    var flags = finishedWork.flags;
    switch (finishedWork.tag) {
      case 0:
      case 11:
      case 15:
        recursivelyTraversePassiveMountEffects(
          finishedRoot,
          finishedWork,
          committedLanes,
          committedTransitions
        );
        flags & 2048 && commitHookEffectListMount(9, finishedWork);
        break;
      case 1:
        recursivelyTraversePassiveMountEffects(
          finishedRoot,
          finishedWork,
          committedLanes,
          committedTransitions
        );
        break;
      case 3:
        recursivelyTraversePassiveMountEffects(
          finishedRoot,
          finishedWork,
          committedLanes,
          committedTransitions
        );
        flags & 2048 && (finishedRoot = null, null !== finishedWork.alternate && (finishedRoot = finishedWork.alternate.memoizedState.cache), finishedWork = finishedWork.memoizedState.cache, finishedWork !== finishedRoot && (finishedWork.refCount++, null != finishedRoot && releaseCache(finishedRoot)));
        break;
      case 12:
        if (flags & 2048) {
          recursivelyTraversePassiveMountEffects(
            finishedRoot,
            finishedWork,
            committedLanes,
            committedTransitions
          );
          finishedRoot = finishedWork.stateNode;
          try {
            var _finishedWork$memoize2 = finishedWork.memoizedProps, id2 = _finishedWork$memoize2.id, onPostCommit = _finishedWork$memoize2.onPostCommit;
            "function" === typeof onPostCommit && onPostCommit(
              id2,
              null === finishedWork.alternate ? "mount" : "update",
              finishedRoot.passiveEffectDuration,
              -0
            );
          } catch (error) {
            captureCommitPhaseError(finishedWork, finishedWork.return, error);
          }
        } else
          recursivelyTraversePassiveMountEffects(
            finishedRoot,
            finishedWork,
            committedLanes,
            committedTransitions
          );
        break;
      case 31:
        recursivelyTraversePassiveMountEffects(
          finishedRoot,
          finishedWork,
          committedLanes,
          committedTransitions
        );
        break;
      case 13:
        recursivelyTraversePassiveMountEffects(
          finishedRoot,
          finishedWork,
          committedLanes,
          committedTransitions
        );
        break;
      case 23:
        break;
      case 22:
        _finishedWork$memoize2 = finishedWork.stateNode;
        id2 = finishedWork.alternate;
        null !== finishedWork.memoizedState ? _finishedWork$memoize2._visibility & 2 ? recursivelyTraversePassiveMountEffects(
          finishedRoot,
          finishedWork,
          committedLanes,
          committedTransitions
        ) : recursivelyTraverseAtomicPassiveEffects(finishedRoot, finishedWork) : _finishedWork$memoize2._visibility & 2 ? recursivelyTraversePassiveMountEffects(
          finishedRoot,
          finishedWork,
          committedLanes,
          committedTransitions
        ) : (_finishedWork$memoize2._visibility |= 2, recursivelyTraverseReconnectPassiveEffects(
          finishedRoot,
          finishedWork,
          committedLanes,
          committedTransitions,
          0 !== (finishedWork.subtreeFlags & 10256) || false
        ));
        flags & 2048 && commitOffscreenPassiveMountEffects(id2, finishedWork);
        break;
      case 24:
        recursivelyTraversePassiveMountEffects(
          finishedRoot,
          finishedWork,
          committedLanes,
          committedTransitions
        );
        flags & 2048 && commitCachePassiveMountEffect(finishedWork.alternate, finishedWork);
        break;
      default:
        recursivelyTraversePassiveMountEffects(
          finishedRoot,
          finishedWork,
          committedLanes,
          committedTransitions
        );
    }
  }
  function recursivelyTraverseReconnectPassiveEffects(finishedRoot$jscomp$0, parentFiber, committedLanes$jscomp$0, committedTransitions$jscomp$0, includeWorkInProgressEffects) {
    includeWorkInProgressEffects = includeWorkInProgressEffects && (0 !== (parentFiber.subtreeFlags & 10256) || false);
    for (parentFiber = parentFiber.child; null !== parentFiber; ) {
      var finishedRoot = finishedRoot$jscomp$0, finishedWork = parentFiber, committedLanes = committedLanes$jscomp$0, committedTransitions = committedTransitions$jscomp$0, flags = finishedWork.flags;
      switch (finishedWork.tag) {
        case 0:
        case 11:
        case 15:
          recursivelyTraverseReconnectPassiveEffects(
            finishedRoot,
            finishedWork,
            committedLanes,
            committedTransitions,
            includeWorkInProgressEffects
          );
          commitHookEffectListMount(8, finishedWork);
          break;
        case 23:
          break;
        case 22:
          var instance = finishedWork.stateNode;
          null !== finishedWork.memoizedState ? instance._visibility & 2 ? recursivelyTraverseReconnectPassiveEffects(
            finishedRoot,
            finishedWork,
            committedLanes,
            committedTransitions,
            includeWorkInProgressEffects
          ) : recursivelyTraverseAtomicPassiveEffects(
            finishedRoot,
            finishedWork
          ) : (instance._visibility |= 2, recursivelyTraverseReconnectPassiveEffects(
            finishedRoot,
            finishedWork,
            committedLanes,
            committedTransitions,
            includeWorkInProgressEffects
          ));
          includeWorkInProgressEffects && flags & 2048 && commitOffscreenPassiveMountEffects(
            finishedWork.alternate,
            finishedWork
          );
          break;
        case 24:
          recursivelyTraverseReconnectPassiveEffects(
            finishedRoot,
            finishedWork,
            committedLanes,
            committedTransitions,
            includeWorkInProgressEffects
          );
          includeWorkInProgressEffects && flags & 2048 && commitCachePassiveMountEffect(finishedWork.alternate, finishedWork);
          break;
        default:
          recursivelyTraverseReconnectPassiveEffects(
            finishedRoot,
            finishedWork,
            committedLanes,
            committedTransitions,
            includeWorkInProgressEffects
          );
      }
      parentFiber = parentFiber.sibling;
    }
  }
  function recursivelyTraverseAtomicPassiveEffects(finishedRoot$jscomp$0, parentFiber) {
    if (parentFiber.subtreeFlags & 10256)
      for (parentFiber = parentFiber.child; null !== parentFiber; ) {
        var finishedRoot = finishedRoot$jscomp$0, finishedWork = parentFiber, flags = finishedWork.flags;
        switch (finishedWork.tag) {
          case 22:
            recursivelyTraverseAtomicPassiveEffects(finishedRoot, finishedWork);
            flags & 2048 && commitOffscreenPassiveMountEffects(
              finishedWork.alternate,
              finishedWork
            );
            break;
          case 24:
            recursivelyTraverseAtomicPassiveEffects(finishedRoot, finishedWork);
            flags & 2048 && commitCachePassiveMountEffect(finishedWork.alternate, finishedWork);
            break;
          default:
            recursivelyTraverseAtomicPassiveEffects(finishedRoot, finishedWork);
        }
        parentFiber = parentFiber.sibling;
      }
  }
  var suspenseyCommitFlag = 8192;
  function recursivelyAccumulateSuspenseyCommit(parentFiber, committedLanes, suspendedState) {
    if (parentFiber.subtreeFlags & suspenseyCommitFlag)
      for (parentFiber = parentFiber.child; null !== parentFiber; )
        accumulateSuspenseyCommitOnFiber(
          parentFiber,
          committedLanes,
          suspendedState
        ), parentFiber = parentFiber.sibling;
  }
  function accumulateSuspenseyCommitOnFiber(fiber, committedLanes, suspendedState) {
    switch (fiber.tag) {
      case 26:
        recursivelyAccumulateSuspenseyCommit(
          fiber,
          committedLanes,
          suspendedState
        );
        fiber.flags & suspenseyCommitFlag && null !== fiber.memoizedState && suspendResource(
          suspendedState,
          currentHoistableRoot,
          fiber.memoizedState,
          fiber.memoizedProps
        );
        break;
      case 5:
        recursivelyAccumulateSuspenseyCommit(
          fiber,
          committedLanes,
          suspendedState
        );
        break;
      case 3:
      case 4:
        var previousHoistableRoot = currentHoistableRoot;
        currentHoistableRoot = getHoistableRoot(fiber.stateNode.containerInfo);
        recursivelyAccumulateSuspenseyCommit(
          fiber,
          committedLanes,
          suspendedState
        );
        currentHoistableRoot = previousHoistableRoot;
        break;
      case 22:
        null === fiber.memoizedState && (previousHoistableRoot = fiber.alternate, null !== previousHoistableRoot && null !== previousHoistableRoot.memoizedState ? (previousHoistableRoot = suspenseyCommitFlag, suspenseyCommitFlag = 16777216, recursivelyAccumulateSuspenseyCommit(
          fiber,
          committedLanes,
          suspendedState
        ), suspenseyCommitFlag = previousHoistableRoot) : recursivelyAccumulateSuspenseyCommit(
          fiber,
          committedLanes,
          suspendedState
        ));
        break;
      default:
        recursivelyAccumulateSuspenseyCommit(
          fiber,
          committedLanes,
          suspendedState
        );
    }
  }
  function detachAlternateSiblings(parentFiber) {
    var previousFiber = parentFiber.alternate;
    if (null !== previousFiber && (parentFiber = previousFiber.child, null !== parentFiber)) {
      previousFiber.child = null;
      do
        previousFiber = parentFiber.sibling, parentFiber.sibling = null, parentFiber = previousFiber;
      while (null !== parentFiber);
    }
  }
  function recursivelyTraversePassiveUnmountEffects(parentFiber) {
    var deletions = parentFiber.deletions;
    if (0 !== (parentFiber.flags & 16)) {
      if (null !== deletions)
        for (var i3 = 0; i3 < deletions.length; i3++) {
          var childToDelete = deletions[i3];
          nextEffect = childToDelete;
          commitPassiveUnmountEffectsInsideOfDeletedTree_begin(
            childToDelete,
            parentFiber
          );
        }
      detachAlternateSiblings(parentFiber);
    }
    if (parentFiber.subtreeFlags & 10256)
      for (parentFiber = parentFiber.child; null !== parentFiber; )
        commitPassiveUnmountOnFiber(parentFiber), parentFiber = parentFiber.sibling;
  }
  function commitPassiveUnmountOnFiber(finishedWork) {
    switch (finishedWork.tag) {
      case 0:
      case 11:
      case 15:
        recursivelyTraversePassiveUnmountEffects(finishedWork);
        finishedWork.flags & 2048 && commitHookEffectListUnmount(9, finishedWork, finishedWork.return);
        break;
      case 3:
        recursivelyTraversePassiveUnmountEffects(finishedWork);
        break;
      case 12:
        recursivelyTraversePassiveUnmountEffects(finishedWork);
        break;
      case 22:
        var instance = finishedWork.stateNode;
        null !== finishedWork.memoizedState && instance._visibility & 2 && (null === finishedWork.return || 13 !== finishedWork.return.tag) ? (instance._visibility &= -3, recursivelyTraverseDisconnectPassiveEffects(finishedWork)) : recursivelyTraversePassiveUnmountEffects(finishedWork);
        break;
      default:
        recursivelyTraversePassiveUnmountEffects(finishedWork);
    }
  }
  function recursivelyTraverseDisconnectPassiveEffects(parentFiber) {
    var deletions = parentFiber.deletions;
    if (0 !== (parentFiber.flags & 16)) {
      if (null !== deletions)
        for (var i3 = 0; i3 < deletions.length; i3++) {
          var childToDelete = deletions[i3];
          nextEffect = childToDelete;
          commitPassiveUnmountEffectsInsideOfDeletedTree_begin(
            childToDelete,
            parentFiber
          );
        }
      detachAlternateSiblings(parentFiber);
    }
    for (parentFiber = parentFiber.child; null !== parentFiber; ) {
      deletions = parentFiber;
      switch (deletions.tag) {
        case 0:
        case 11:
        case 15:
          commitHookEffectListUnmount(8, deletions, deletions.return);
          recursivelyTraverseDisconnectPassiveEffects(deletions);
          break;
        case 22:
          i3 = deletions.stateNode;
          i3._visibility & 2 && (i3._visibility &= -3, recursivelyTraverseDisconnectPassiveEffects(deletions));
          break;
        default:
          recursivelyTraverseDisconnectPassiveEffects(deletions);
      }
      parentFiber = parentFiber.sibling;
    }
  }
  function commitPassiveUnmountEffectsInsideOfDeletedTree_begin(deletedSubtreeRoot, nearestMountedAncestor) {
    for (; null !== nextEffect; ) {
      var fiber = nextEffect;
      switch (fiber.tag) {
        case 0:
        case 11:
        case 15:
          commitHookEffectListUnmount(8, fiber, nearestMountedAncestor);
          break;
        case 23:
        case 22:
          if (null !== fiber.memoizedState && null !== fiber.memoizedState.cachePool) {
            var cache = fiber.memoizedState.cachePool.pool;
            null != cache && cache.refCount++;
          }
          break;
        case 24:
          releaseCache(fiber.memoizedState.cache);
      }
      cache = fiber.child;
      if (null !== cache) cache.return = fiber, nextEffect = cache;
      else
        a: for (fiber = deletedSubtreeRoot; null !== nextEffect; ) {
          cache = nextEffect;
          var sibling = cache.sibling, returnFiber = cache.return;
          detachFiberAfterEffects(cache);
          if (cache === fiber) {
            nextEffect = null;
            break a;
          }
          if (null !== sibling) {
            sibling.return = returnFiber;
            nextEffect = sibling;
            break a;
          }
          nextEffect = returnFiber;
        }
    }
  }
  var DefaultAsyncDispatcher = {
    getCacheForType: function(resourceType) {
      var cache = readContext(CacheContext), cacheForType = cache.data.get(resourceType);
      void 0 === cacheForType && (cacheForType = resourceType(), cache.data.set(resourceType, cacheForType));
      return cacheForType;
    },
    cacheSignal: function() {
      return readContext(CacheContext).controller.signal;
    }
  }, PossiblyWeakMap = "function" === typeof WeakMap ? WeakMap : Map, executionContext = 0, workInProgressRoot = null, workInProgress = null, workInProgressRootRenderLanes = 0, workInProgressSuspendedReason = 0, workInProgressThrownValue = null, workInProgressRootDidSkipSuspendedSiblings = false, workInProgressRootIsPrerendering = false, workInProgressRootDidAttachPingListener = false, entangledRenderLanes = 0, workInProgressRootExitStatus = 0, workInProgressRootSkippedLanes = 0, workInProgressRootInterleavedUpdatedLanes = 0, workInProgressRootPingedLanes = 0, workInProgressDeferredLane = 0, workInProgressSuspendedRetryLanes = 0, workInProgressRootConcurrentErrors = null, workInProgressRootRecoverableErrors = null, workInProgressRootDidIncludeRecursiveRenderUpdate = false, globalMostRecentFallbackTime = 0, globalMostRecentTransitionTime = 0, workInProgressRootRenderTargetTime = Infinity, workInProgressTransitions = null, legacyErrorBoundariesThatAlreadyFailed = null, pendingEffectsStatus = 0, pendingEffectsRoot = null, pendingFinishedWork = null, pendingEffectsLanes = 0, pendingEffectsRemainingLanes = 0, pendingPassiveTransitions = null, pendingRecoverableErrors = null, nestedUpdateCount = 0, rootWithNestedUpdates = null;
  function requestUpdateLane() {
    return 0 !== (executionContext & 2) && 0 !== workInProgressRootRenderLanes ? workInProgressRootRenderLanes & -workInProgressRootRenderLanes : null !== ReactSharedInternals.T ? requestTransitionLane() : resolveUpdatePriority();
  }
  function requestDeferredLane() {
    if (0 === workInProgressDeferredLane)
      if (0 === (workInProgressRootRenderLanes & 536870912) || isHydrating) {
        var lane = nextTransitionDeferredLane;
        nextTransitionDeferredLane <<= 1;
        0 === (nextTransitionDeferredLane & 3932160) && (nextTransitionDeferredLane = 262144);
        workInProgressDeferredLane = lane;
      } else workInProgressDeferredLane = 536870912;
    lane = suspenseHandlerStackCursor.current;
    null !== lane && (lane.flags |= 32);
    return workInProgressDeferredLane;
  }
  function scheduleUpdateOnFiber(root2, fiber, lane) {
    if (root2 === workInProgressRoot && (2 === workInProgressSuspendedReason || 9 === workInProgressSuspendedReason) || null !== root2.cancelPendingCommit)
      prepareFreshStack(root2, 0), markRootSuspended(
        root2,
        workInProgressRootRenderLanes,
        workInProgressDeferredLane,
        false
      );
    markRootUpdated$1(root2, lane);
    if (0 === (executionContext & 2) || root2 !== workInProgressRoot)
      root2 === workInProgressRoot && (0 === (executionContext & 2) && (workInProgressRootInterleavedUpdatedLanes |= lane), 4 === workInProgressRootExitStatus && markRootSuspended(
        root2,
        workInProgressRootRenderLanes,
        workInProgressDeferredLane,
        false
      )), ensureRootIsScheduled(root2);
  }
  function performWorkOnRoot(root$jscomp$0, lanes, forceSync) {
    if (0 !== (executionContext & 6)) throw Error(formatProdErrorMessage(327));
    var shouldTimeSlice = !forceSync && 0 === (lanes & 127) && 0 === (lanes & root$jscomp$0.expiredLanes) || checkIfRootIsPrerendering(root$jscomp$0, lanes), exitStatus = shouldTimeSlice ? renderRootConcurrent(root$jscomp$0, lanes) : renderRootSync(root$jscomp$0, lanes, true), renderWasConcurrent = shouldTimeSlice;
    do {
      if (0 === exitStatus) {
        workInProgressRootIsPrerendering && !shouldTimeSlice && markRootSuspended(root$jscomp$0, lanes, 0, false);
        break;
      } else {
        forceSync = root$jscomp$0.current.alternate;
        if (renderWasConcurrent && !isRenderConsistentWithExternalStores(forceSync)) {
          exitStatus = renderRootSync(root$jscomp$0, lanes, false);
          renderWasConcurrent = false;
          continue;
        }
        if (2 === exitStatus) {
          renderWasConcurrent = lanes;
          if (root$jscomp$0.errorRecoveryDisabledLanes & renderWasConcurrent)
            var JSCompiler_inline_result = 0;
          else
            JSCompiler_inline_result = root$jscomp$0.pendingLanes & -536870913, JSCompiler_inline_result = 0 !== JSCompiler_inline_result ? JSCompiler_inline_result : JSCompiler_inline_result & 536870912 ? 536870912 : 0;
          if (0 !== JSCompiler_inline_result) {
            lanes = JSCompiler_inline_result;
            a: {
              var root2 = root$jscomp$0;
              exitStatus = workInProgressRootConcurrentErrors;
              var wasRootDehydrated = root2.current.memoizedState.isDehydrated;
              wasRootDehydrated && (prepareFreshStack(root2, JSCompiler_inline_result).flags |= 256);
              JSCompiler_inline_result = renderRootSync(
                root2,
                JSCompiler_inline_result,
                false
              );
              if (2 !== JSCompiler_inline_result) {
                if (workInProgressRootDidAttachPingListener && !wasRootDehydrated) {
                  root2.errorRecoveryDisabledLanes |= renderWasConcurrent;
                  workInProgressRootInterleavedUpdatedLanes |= renderWasConcurrent;
                  exitStatus = 4;
                  break a;
                }
                renderWasConcurrent = workInProgressRootRecoverableErrors;
                workInProgressRootRecoverableErrors = exitStatus;
                null !== renderWasConcurrent && (null === workInProgressRootRecoverableErrors ? workInProgressRootRecoverableErrors = renderWasConcurrent : workInProgressRootRecoverableErrors.push.apply(
                  workInProgressRootRecoverableErrors,
                  renderWasConcurrent
                ));
              }
              exitStatus = JSCompiler_inline_result;
            }
            renderWasConcurrent = false;
            if (2 !== exitStatus) continue;
          }
        }
        if (1 === exitStatus) {
          prepareFreshStack(root$jscomp$0, 0);
          markRootSuspended(root$jscomp$0, lanes, 0, true);
          break;
        }
        a: {
          shouldTimeSlice = root$jscomp$0;
          renderWasConcurrent = exitStatus;
          switch (renderWasConcurrent) {
            case 0:
            case 1:
              throw Error(formatProdErrorMessage(345));
            case 4:
              if ((lanes & 4194048) !== lanes) break;
            case 6:
              markRootSuspended(
                shouldTimeSlice,
                lanes,
                workInProgressDeferredLane,
                !workInProgressRootDidSkipSuspendedSiblings
              );
              break a;
            case 2:
              workInProgressRootRecoverableErrors = null;
              break;
            case 3:
            case 5:
              break;
            default:
              throw Error(formatProdErrorMessage(329));
          }
          if ((lanes & 62914560) === lanes && (exitStatus = globalMostRecentFallbackTime + 300 - now(), 10 < exitStatus)) {
            markRootSuspended(
              shouldTimeSlice,
              lanes,
              workInProgressDeferredLane,
              !workInProgressRootDidSkipSuspendedSiblings
            );
            if (0 !== getNextLanes(shouldTimeSlice, 0, true)) break a;
            pendingEffectsLanes = lanes;
            shouldTimeSlice.timeoutHandle = scheduleTimeout(
              commitRootWhenReady.bind(
                null,
                shouldTimeSlice,
                forceSync,
                workInProgressRootRecoverableErrors,
                workInProgressTransitions,
                workInProgressRootDidIncludeRecursiveRenderUpdate,
                lanes,
                workInProgressDeferredLane,
                workInProgressRootInterleavedUpdatedLanes,
                workInProgressSuspendedRetryLanes,
                workInProgressRootDidSkipSuspendedSiblings,
                renderWasConcurrent,
                "Throttled",
                -0,
                0
              ),
              exitStatus
            );
            break a;
          }
          commitRootWhenReady(
            shouldTimeSlice,
            forceSync,
            workInProgressRootRecoverableErrors,
            workInProgressTransitions,
            workInProgressRootDidIncludeRecursiveRenderUpdate,
            lanes,
            workInProgressDeferredLane,
            workInProgressRootInterleavedUpdatedLanes,
            workInProgressSuspendedRetryLanes,
            workInProgressRootDidSkipSuspendedSiblings,
            renderWasConcurrent,
            null,
            -0,
            0
          );
        }
      }
      break;
    } while (1);
    ensureRootIsScheduled(root$jscomp$0);
  }
  function commitRootWhenReady(root2, finishedWork, recoverableErrors, transitions, didIncludeRenderPhaseUpdate, lanes, spawnedLane, updatedLanes, suspendedRetryLanes, didSkipSuspendedSiblings, exitStatus, suspendedCommitReason, completedRenderStartTime, completedRenderEndTime) {
    root2.timeoutHandle = -1;
    suspendedCommitReason = finishedWork.subtreeFlags;
    if (suspendedCommitReason & 8192 || 16785408 === (suspendedCommitReason & 16785408)) {
      suspendedCommitReason = {
        stylesheets: null,
        count: 0,
        imgCount: 0,
        imgBytes: 0,
        suspenseyImages: [],
        waitingForImages: true,
        waitingForViewTransition: false,
        unsuspend: noop$12
      };
      accumulateSuspenseyCommitOnFiber(
        finishedWork,
        lanes,
        suspendedCommitReason
      );
      var timeoutOffset = (lanes & 62914560) === lanes ? globalMostRecentFallbackTime - now() : (lanes & 4194048) === lanes ? globalMostRecentTransitionTime - now() : 0;
      timeoutOffset = waitForCommitToBeReady(
        suspendedCommitReason,
        timeoutOffset
      );
      if (null !== timeoutOffset) {
        pendingEffectsLanes = lanes;
        root2.cancelPendingCommit = timeoutOffset(
          commitRoot.bind(
            null,
            root2,
            finishedWork,
            lanes,
            recoverableErrors,
            transitions,
            didIncludeRenderPhaseUpdate,
            spawnedLane,
            updatedLanes,
            suspendedRetryLanes,
            exitStatus,
            suspendedCommitReason,
            null,
            completedRenderStartTime,
            completedRenderEndTime
          )
        );
        markRootSuspended(root2, lanes, spawnedLane, !didSkipSuspendedSiblings);
        return;
      }
    }
    commitRoot(
      root2,
      finishedWork,
      lanes,
      recoverableErrors,
      transitions,
      didIncludeRenderPhaseUpdate,
      spawnedLane,
      updatedLanes,
      suspendedRetryLanes
    );
  }
  function isRenderConsistentWithExternalStores(finishedWork) {
    for (var node = finishedWork; ; ) {
      var tag = node.tag;
      if ((0 === tag || 11 === tag || 15 === tag) && node.flags & 16384 && (tag = node.updateQueue, null !== tag && (tag = tag.stores, null !== tag)))
        for (var i3 = 0; i3 < tag.length; i3++) {
          var check = tag[i3], getSnapshot = check.getSnapshot;
          check = check.value;
          try {
            if (!objectIs(getSnapshot(), check)) return false;
          } catch (error) {
            return false;
          }
        }
      tag = node.child;
      if (node.subtreeFlags & 16384 && null !== tag)
        tag.return = node, node = tag;
      else {
        if (node === finishedWork) break;
        for (; null === node.sibling; ) {
          if (null === node.return || node.return === finishedWork) return true;
          node = node.return;
        }
        node.sibling.return = node.return;
        node = node.sibling;
      }
    }
    return true;
  }
  function markRootSuspended(root2, suspendedLanes, spawnedLane, didAttemptEntireTree) {
    suspendedLanes &= ~workInProgressRootPingedLanes;
    suspendedLanes &= ~workInProgressRootInterleavedUpdatedLanes;
    root2.suspendedLanes |= suspendedLanes;
    root2.pingedLanes &= ~suspendedLanes;
    didAttemptEntireTree && (root2.warmLanes |= suspendedLanes);
    didAttemptEntireTree = root2.expirationTimes;
    for (var lanes = suspendedLanes; 0 < lanes; ) {
      var index$6 = 31 - clz32(lanes), lane = 1 << index$6;
      didAttemptEntireTree[index$6] = -1;
      lanes &= ~lane;
    }
    0 !== spawnedLane && markSpawnedDeferredLane(root2, spawnedLane, suspendedLanes);
  }
  function flushSyncWork$1() {
    return 0 === (executionContext & 6) ? (flushSyncWorkAcrossRoots_impl(0), false) : true;
  }
  function resetWorkInProgressStack() {
    if (null !== workInProgress) {
      if (0 === workInProgressSuspendedReason)
        var interruptedWork = workInProgress.return;
      else
        interruptedWork = workInProgress, lastContextDependency = currentlyRenderingFiber$1 = null, resetHooksOnUnwind(interruptedWork), thenableState$1 = null, thenableIndexCounter$1 = 0, interruptedWork = workInProgress;
      for (; null !== interruptedWork; )
        unwindInterruptedWork(interruptedWork.alternate, interruptedWork), interruptedWork = interruptedWork.return;
      workInProgress = null;
    }
  }
  function prepareFreshStack(root2, lanes) {
    var timeoutHandle = root2.timeoutHandle;
    -1 !== timeoutHandle && (root2.timeoutHandle = -1, cancelTimeout(timeoutHandle));
    timeoutHandle = root2.cancelPendingCommit;
    null !== timeoutHandle && (root2.cancelPendingCommit = null, timeoutHandle());
    pendingEffectsLanes = 0;
    resetWorkInProgressStack();
    workInProgressRoot = root2;
    workInProgress = timeoutHandle = createWorkInProgress(root2.current, null);
    workInProgressRootRenderLanes = lanes;
    workInProgressSuspendedReason = 0;
    workInProgressThrownValue = null;
    workInProgressRootDidSkipSuspendedSiblings = false;
    workInProgressRootIsPrerendering = checkIfRootIsPrerendering(root2, lanes);
    workInProgressRootDidAttachPingListener = false;
    workInProgressSuspendedRetryLanes = workInProgressDeferredLane = workInProgressRootPingedLanes = workInProgressRootInterleavedUpdatedLanes = workInProgressRootSkippedLanes = workInProgressRootExitStatus = 0;
    workInProgressRootRecoverableErrors = workInProgressRootConcurrentErrors = null;
    workInProgressRootDidIncludeRecursiveRenderUpdate = false;
    0 !== (lanes & 8) && (lanes |= lanes & 32);
    var allEntangledLanes = root2.entangledLanes;
    if (0 !== allEntangledLanes)
      for (root2 = root2.entanglements, allEntangledLanes &= lanes; 0 < allEntangledLanes; ) {
        var index$4 = 31 - clz32(allEntangledLanes), lane = 1 << index$4;
        lanes |= root2[index$4];
        allEntangledLanes &= ~lane;
      }
    entangledRenderLanes = lanes;
    finishQueueingConcurrentUpdates();
    return timeoutHandle;
  }
  function handleThrow(root2, thrownValue) {
    currentlyRenderingFiber = null;
    ReactSharedInternals.H = ContextOnlyDispatcher;
    thrownValue === SuspenseException || thrownValue === SuspenseActionException ? (thrownValue = getSuspendedThenable(), workInProgressSuspendedReason = 3) : thrownValue === SuspenseyCommitException ? (thrownValue = getSuspendedThenable(), workInProgressSuspendedReason = 4) : workInProgressSuspendedReason = thrownValue === SelectiveHydrationException ? 8 : null !== thrownValue && "object" === typeof thrownValue && "function" === typeof thrownValue.then ? 6 : 1;
    workInProgressThrownValue = thrownValue;
    null === workInProgress && (workInProgressRootExitStatus = 1, logUncaughtError(
      root2,
      createCapturedValueAtFiber(thrownValue, root2.current)
    ));
  }
  function shouldRemainOnPreviousScreen() {
    var handler = suspenseHandlerStackCursor.current;
    return null === handler ? true : (workInProgressRootRenderLanes & 4194048) === workInProgressRootRenderLanes ? null === shellBoundary ? true : false : (workInProgressRootRenderLanes & 62914560) === workInProgressRootRenderLanes || 0 !== (workInProgressRootRenderLanes & 536870912) ? handler === shellBoundary : false;
  }
  function pushDispatcher() {
    var prevDispatcher = ReactSharedInternals.H;
    ReactSharedInternals.H = ContextOnlyDispatcher;
    return null === prevDispatcher ? ContextOnlyDispatcher : prevDispatcher;
  }
  function pushAsyncDispatcher() {
    var prevAsyncDispatcher = ReactSharedInternals.A;
    ReactSharedInternals.A = DefaultAsyncDispatcher;
    return prevAsyncDispatcher;
  }
  function renderDidSuspendDelayIfPossible() {
    workInProgressRootExitStatus = 4;
    workInProgressRootDidSkipSuspendedSiblings || (workInProgressRootRenderLanes & 4194048) !== workInProgressRootRenderLanes && null !== suspenseHandlerStackCursor.current || (workInProgressRootIsPrerendering = true);
    0 === (workInProgressRootSkippedLanes & 134217727) && 0 === (workInProgressRootInterleavedUpdatedLanes & 134217727) || null === workInProgressRoot || markRootSuspended(
      workInProgressRoot,
      workInProgressRootRenderLanes,
      workInProgressDeferredLane,
      false
    );
  }
  function renderRootSync(root2, lanes, shouldYieldForPrerendering) {
    var prevExecutionContext = executionContext;
    executionContext |= 2;
    var prevDispatcher = pushDispatcher(), prevAsyncDispatcher = pushAsyncDispatcher();
    if (workInProgressRoot !== root2 || workInProgressRootRenderLanes !== lanes)
      workInProgressTransitions = null, prepareFreshStack(root2, lanes);
    lanes = false;
    var exitStatus = workInProgressRootExitStatus;
    a: do
      try {
        if (0 !== workInProgressSuspendedReason && null !== workInProgress) {
          var unitOfWork = workInProgress, thrownValue = workInProgressThrownValue;
          switch (workInProgressSuspendedReason) {
            case 8:
              resetWorkInProgressStack();
              exitStatus = 6;
              break a;
            case 3:
            case 2:
            case 9:
            case 6:
              null === suspenseHandlerStackCursor.current && (lanes = true);
              var reason = workInProgressSuspendedReason;
              workInProgressSuspendedReason = 0;
              workInProgressThrownValue = null;
              throwAndUnwindWorkLoop(root2, unitOfWork, thrownValue, reason);
              if (shouldYieldForPrerendering && workInProgressRootIsPrerendering) {
                exitStatus = 0;
                break a;
              }
              break;
            default:
              reason = workInProgressSuspendedReason, workInProgressSuspendedReason = 0, workInProgressThrownValue = null, throwAndUnwindWorkLoop(root2, unitOfWork, thrownValue, reason);
          }
        }
        workLoopSync();
        exitStatus = workInProgressRootExitStatus;
        break;
      } catch (thrownValue$165) {
        handleThrow(root2, thrownValue$165);
      }
    while (1);
    lanes && root2.shellSuspendCounter++;
    lastContextDependency = currentlyRenderingFiber$1 = null;
    executionContext = prevExecutionContext;
    ReactSharedInternals.H = prevDispatcher;
    ReactSharedInternals.A = prevAsyncDispatcher;
    null === workInProgress && (workInProgressRoot = null, workInProgressRootRenderLanes = 0, finishQueueingConcurrentUpdates());
    return exitStatus;
  }
  function workLoopSync() {
    for (; null !== workInProgress; ) performUnitOfWork(workInProgress);
  }
  function renderRootConcurrent(root2, lanes) {
    var prevExecutionContext = executionContext;
    executionContext |= 2;
    var prevDispatcher = pushDispatcher(), prevAsyncDispatcher = pushAsyncDispatcher();
    workInProgressRoot !== root2 || workInProgressRootRenderLanes !== lanes ? (workInProgressTransitions = null, workInProgressRootRenderTargetTime = now() + 500, prepareFreshStack(root2, lanes)) : workInProgressRootIsPrerendering = checkIfRootIsPrerendering(
      root2,
      lanes
    );
    a: do
      try {
        if (0 !== workInProgressSuspendedReason && null !== workInProgress) {
          lanes = workInProgress;
          var thrownValue = workInProgressThrownValue;
          b: switch (workInProgressSuspendedReason) {
            case 1:
              workInProgressSuspendedReason = 0;
              workInProgressThrownValue = null;
              throwAndUnwindWorkLoop(root2, lanes, thrownValue, 1);
              break;
            case 2:
            case 9:
              if (isThenableResolved(thrownValue)) {
                workInProgressSuspendedReason = 0;
                workInProgressThrownValue = null;
                replaySuspendedUnitOfWork(lanes);
                break;
              }
              lanes = function() {
                2 !== workInProgressSuspendedReason && 9 !== workInProgressSuspendedReason || workInProgressRoot !== root2 || (workInProgressSuspendedReason = 7);
                ensureRootIsScheduled(root2);
              };
              thrownValue.then(lanes, lanes);
              break a;
            case 3:
              workInProgressSuspendedReason = 7;
              break a;
            case 4:
              workInProgressSuspendedReason = 5;
              break a;
            case 7:
              isThenableResolved(thrownValue) ? (workInProgressSuspendedReason = 0, workInProgressThrownValue = null, replaySuspendedUnitOfWork(lanes)) : (workInProgressSuspendedReason = 0, workInProgressThrownValue = null, throwAndUnwindWorkLoop(root2, lanes, thrownValue, 7));
              break;
            case 5:
              var resource = null;
              switch (workInProgress.tag) {
                case 26:
                  resource = workInProgress.memoizedState;
                case 5:
                case 27:
                  var hostFiber = workInProgress;
                  if (resource ? preloadResource(resource) : hostFiber.stateNode.complete) {
                    workInProgressSuspendedReason = 0;
                    workInProgressThrownValue = null;
                    var sibling = hostFiber.sibling;
                    if (null !== sibling) workInProgress = sibling;
                    else {
                      var returnFiber = hostFiber.return;
                      null !== returnFiber ? (workInProgress = returnFiber, completeUnitOfWork(returnFiber)) : workInProgress = null;
                    }
                    break b;
                  }
              }
              workInProgressSuspendedReason = 0;
              workInProgressThrownValue = null;
              throwAndUnwindWorkLoop(root2, lanes, thrownValue, 5);
              break;
            case 6:
              workInProgressSuspendedReason = 0;
              workInProgressThrownValue = null;
              throwAndUnwindWorkLoop(root2, lanes, thrownValue, 6);
              break;
            case 8:
              resetWorkInProgressStack();
              workInProgressRootExitStatus = 6;
              break a;
            default:
              throw Error(formatProdErrorMessage(462));
          }
        }
        workLoopConcurrentByScheduler();
        break;
      } catch (thrownValue$167) {
        handleThrow(root2, thrownValue$167);
      }
    while (1);
    lastContextDependency = currentlyRenderingFiber$1 = null;
    ReactSharedInternals.H = prevDispatcher;
    ReactSharedInternals.A = prevAsyncDispatcher;
    executionContext = prevExecutionContext;
    if (null !== workInProgress) return 0;
    workInProgressRoot = null;
    workInProgressRootRenderLanes = 0;
    finishQueueingConcurrentUpdates();
    return workInProgressRootExitStatus;
  }
  function workLoopConcurrentByScheduler() {
    for (; null !== workInProgress && !shouldYield(); )
      performUnitOfWork(workInProgress);
  }
  function performUnitOfWork(unitOfWork) {
    var next = beginWork(unitOfWork.alternate, unitOfWork, entangledRenderLanes);
    unitOfWork.memoizedProps = unitOfWork.pendingProps;
    null === next ? completeUnitOfWork(unitOfWork) : workInProgress = next;
  }
  function replaySuspendedUnitOfWork(unitOfWork) {
    var next = unitOfWork;
    var current = next.alternate;
    switch (next.tag) {
      case 15:
      case 0:
        next = replayFunctionComponent(
          current,
          next,
          next.pendingProps,
          next.type,
          void 0,
          workInProgressRootRenderLanes
        );
        break;
      case 11:
        next = replayFunctionComponent(
          current,
          next,
          next.pendingProps,
          next.type.render,
          next.ref,
          workInProgressRootRenderLanes
        );
        break;
      case 5:
        resetHooksOnUnwind(next);
      default:
        unwindInterruptedWork(current, next), next = workInProgress = resetWorkInProgress(next, entangledRenderLanes), next = beginWork(current, next, entangledRenderLanes);
    }
    unitOfWork.memoizedProps = unitOfWork.pendingProps;
    null === next ? completeUnitOfWork(unitOfWork) : workInProgress = next;
  }
  function throwAndUnwindWorkLoop(root2, unitOfWork, thrownValue, suspendedReason) {
    lastContextDependency = currentlyRenderingFiber$1 = null;
    resetHooksOnUnwind(unitOfWork);
    thenableState$1 = null;
    thenableIndexCounter$1 = 0;
    var returnFiber = unitOfWork.return;
    try {
      if (throwException(
        root2,
        returnFiber,
        unitOfWork,
        thrownValue,
        workInProgressRootRenderLanes
      )) {
        workInProgressRootExitStatus = 1;
        logUncaughtError(
          root2,
          createCapturedValueAtFiber(thrownValue, root2.current)
        );
        workInProgress = null;
        return;
      }
    } catch (error) {
      if (null !== returnFiber) throw workInProgress = returnFiber, error;
      workInProgressRootExitStatus = 1;
      logUncaughtError(
        root2,
        createCapturedValueAtFiber(thrownValue, root2.current)
      );
      workInProgress = null;
      return;
    }
    if (unitOfWork.flags & 32768) {
      if (isHydrating || 1 === suspendedReason) root2 = true;
      else if (workInProgressRootIsPrerendering || 0 !== (workInProgressRootRenderLanes & 536870912))
        root2 = false;
      else if (workInProgressRootDidSkipSuspendedSiblings = root2 = true, 2 === suspendedReason || 9 === suspendedReason || 3 === suspendedReason || 6 === suspendedReason)
        suspendedReason = suspenseHandlerStackCursor.current, null !== suspendedReason && 13 === suspendedReason.tag && (suspendedReason.flags |= 16384);
      unwindUnitOfWork(unitOfWork, root2);
    } else completeUnitOfWork(unitOfWork);
  }
  function completeUnitOfWork(unitOfWork) {
    var completedWork = unitOfWork;
    do {
      if (0 !== (completedWork.flags & 32768)) {
        unwindUnitOfWork(
          completedWork,
          workInProgressRootDidSkipSuspendedSiblings
        );
        return;
      }
      unitOfWork = completedWork.return;
      var next = completeWork(
        completedWork.alternate,
        completedWork,
        entangledRenderLanes
      );
      if (null !== next) {
        workInProgress = next;
        return;
      }
      completedWork = completedWork.sibling;
      if (null !== completedWork) {
        workInProgress = completedWork;
        return;
      }
      workInProgress = completedWork = unitOfWork;
    } while (null !== completedWork);
    0 === workInProgressRootExitStatus && (workInProgressRootExitStatus = 5);
  }
  function unwindUnitOfWork(unitOfWork, skipSiblings) {
    do {
      var next = unwindWork(unitOfWork.alternate, unitOfWork);
      if (null !== next) {
        next.flags &= 32767;
        workInProgress = next;
        return;
      }
      next = unitOfWork.return;
      null !== next && (next.flags |= 32768, next.subtreeFlags = 0, next.deletions = null);
      if (!skipSiblings && (unitOfWork = unitOfWork.sibling, null !== unitOfWork)) {
        workInProgress = unitOfWork;
        return;
      }
      workInProgress = unitOfWork = next;
    } while (null !== unitOfWork);
    workInProgressRootExitStatus = 6;
    workInProgress = null;
  }
  function commitRoot(root2, finishedWork, lanes, recoverableErrors, transitions, didIncludeRenderPhaseUpdate, spawnedLane, updatedLanes, suspendedRetryLanes) {
    root2.cancelPendingCommit = null;
    do
      flushPendingEffects();
    while (0 !== pendingEffectsStatus);
    if (0 !== (executionContext & 6)) throw Error(formatProdErrorMessage(327));
    if (null !== finishedWork) {
      if (finishedWork === root2.current) throw Error(formatProdErrorMessage(177));
      didIncludeRenderPhaseUpdate = finishedWork.lanes | finishedWork.childLanes;
      didIncludeRenderPhaseUpdate |= concurrentlyUpdatedLanes;
      markRootFinished(
        root2,
        lanes,
        didIncludeRenderPhaseUpdate,
        spawnedLane,
        updatedLanes,
        suspendedRetryLanes
      );
      root2 === workInProgressRoot && (workInProgress = workInProgressRoot = null, workInProgressRootRenderLanes = 0);
      pendingFinishedWork = finishedWork;
      pendingEffectsRoot = root2;
      pendingEffectsLanes = lanes;
      pendingEffectsRemainingLanes = didIncludeRenderPhaseUpdate;
      pendingPassiveTransitions = transitions;
      pendingRecoverableErrors = recoverableErrors;
      0 !== (finishedWork.subtreeFlags & 10256) || 0 !== (finishedWork.flags & 10256) ? (root2.callbackNode = null, root2.callbackPriority = 0, scheduleCallback$1(NormalPriority$1, function() {
        flushPassiveEffects();
        return null;
      })) : (root2.callbackNode = null, root2.callbackPriority = 0);
      recoverableErrors = 0 !== (finishedWork.flags & 13878);
      if (0 !== (finishedWork.subtreeFlags & 13878) || recoverableErrors) {
        recoverableErrors = ReactSharedInternals.T;
        ReactSharedInternals.T = null;
        transitions = ReactDOMSharedInternals.p;
        ReactDOMSharedInternals.p = 2;
        spawnedLane = executionContext;
        executionContext |= 4;
        try {
          commitBeforeMutationEffects(root2, finishedWork, lanes);
        } finally {
          executionContext = spawnedLane, ReactDOMSharedInternals.p = transitions, ReactSharedInternals.T = recoverableErrors;
        }
      }
      pendingEffectsStatus = 1;
      flushMutationEffects();
      flushLayoutEffects();
      flushSpawnedWork();
    }
  }
  function flushMutationEffects() {
    if (1 === pendingEffectsStatus) {
      pendingEffectsStatus = 0;
      var root2 = pendingEffectsRoot, finishedWork = pendingFinishedWork, rootMutationHasEffect = 0 !== (finishedWork.flags & 13878);
      if (0 !== (finishedWork.subtreeFlags & 13878) || rootMutationHasEffect) {
        rootMutationHasEffect = ReactSharedInternals.T;
        ReactSharedInternals.T = null;
        var previousPriority = ReactDOMSharedInternals.p;
        ReactDOMSharedInternals.p = 2;
        var prevExecutionContext = executionContext;
        executionContext |= 4;
        try {
          commitMutationEffectsOnFiber(finishedWork, root2);
          var priorSelectionInformation = selectionInformation, curFocusedElem = getActiveElementDeep(root2.containerInfo), priorFocusedElem = priorSelectionInformation.focusedElem, priorSelectionRange = priorSelectionInformation.selectionRange;
          if (curFocusedElem !== priorFocusedElem && priorFocusedElem && priorFocusedElem.ownerDocument && containsNode(
            priorFocusedElem.ownerDocument.documentElement,
            priorFocusedElem
          )) {
            if (null !== priorSelectionRange && hasSelectionCapabilities(priorFocusedElem)) {
              var start = priorSelectionRange.start, end = priorSelectionRange.end;
              void 0 === end && (end = start);
              if ("selectionStart" in priorFocusedElem)
                priorFocusedElem.selectionStart = start, priorFocusedElem.selectionEnd = Math.min(
                  end,
                  priorFocusedElem.value.length
                );
              else {
                var doc = priorFocusedElem.ownerDocument || document, win = doc && doc.defaultView || window;
                if (win.getSelection) {
                  var selection = win.getSelection(), length = priorFocusedElem.textContent.length, start$jscomp$0 = Math.min(priorSelectionRange.start, length), end$jscomp$0 = void 0 === priorSelectionRange.end ? start$jscomp$0 : Math.min(priorSelectionRange.end, length);
                  !selection.extend && start$jscomp$0 > end$jscomp$0 && (curFocusedElem = end$jscomp$0, end$jscomp$0 = start$jscomp$0, start$jscomp$0 = curFocusedElem);
                  var startMarker = getNodeForCharacterOffset(
                    priorFocusedElem,
                    start$jscomp$0
                  ), endMarker = getNodeForCharacterOffset(
                    priorFocusedElem,
                    end$jscomp$0
                  );
                  if (startMarker && endMarker && (1 !== selection.rangeCount || selection.anchorNode !== startMarker.node || selection.anchorOffset !== startMarker.offset || selection.focusNode !== endMarker.node || selection.focusOffset !== endMarker.offset)) {
                    var range = doc.createRange();
                    range.setStart(startMarker.node, startMarker.offset);
                    selection.removeAllRanges();
                    start$jscomp$0 > end$jscomp$0 ? (selection.addRange(range), selection.extend(endMarker.node, endMarker.offset)) : (range.setEnd(endMarker.node, endMarker.offset), selection.addRange(range));
                  }
                }
              }
            }
            doc = [];
            for (selection = priorFocusedElem; selection = selection.parentNode; )
              1 === selection.nodeType && doc.push({
                element: selection,
                left: selection.scrollLeft,
                top: selection.scrollTop
              });
            "function" === typeof priorFocusedElem.focus && priorFocusedElem.focus();
            for (priorFocusedElem = 0; priorFocusedElem < doc.length; priorFocusedElem++) {
              var info = doc[priorFocusedElem];
              info.element.scrollLeft = info.left;
              info.element.scrollTop = info.top;
            }
          }
          _enabled = !!eventsEnabled;
          selectionInformation = eventsEnabled = null;
        } finally {
          executionContext = prevExecutionContext, ReactDOMSharedInternals.p = previousPriority, ReactSharedInternals.T = rootMutationHasEffect;
        }
      }
      root2.current = finishedWork;
      pendingEffectsStatus = 2;
    }
  }
  function flushLayoutEffects() {
    if (2 === pendingEffectsStatus) {
      pendingEffectsStatus = 0;
      var root2 = pendingEffectsRoot, finishedWork = pendingFinishedWork, rootHasLayoutEffect = 0 !== (finishedWork.flags & 8772);
      if (0 !== (finishedWork.subtreeFlags & 8772) || rootHasLayoutEffect) {
        rootHasLayoutEffect = ReactSharedInternals.T;
        ReactSharedInternals.T = null;
        var previousPriority = ReactDOMSharedInternals.p;
        ReactDOMSharedInternals.p = 2;
        var prevExecutionContext = executionContext;
        executionContext |= 4;
        try {
          commitLayoutEffectOnFiber(root2, finishedWork.alternate, finishedWork);
        } finally {
          executionContext = prevExecutionContext, ReactDOMSharedInternals.p = previousPriority, ReactSharedInternals.T = rootHasLayoutEffect;
        }
      }
      pendingEffectsStatus = 3;
    }
  }
  function flushSpawnedWork() {
    if (4 === pendingEffectsStatus || 3 === pendingEffectsStatus) {
      pendingEffectsStatus = 0;
      requestPaint();
      var root2 = pendingEffectsRoot, finishedWork = pendingFinishedWork, lanes = pendingEffectsLanes, recoverableErrors = pendingRecoverableErrors;
      0 !== (finishedWork.subtreeFlags & 10256) || 0 !== (finishedWork.flags & 10256) ? pendingEffectsStatus = 5 : (pendingEffectsStatus = 0, pendingFinishedWork = pendingEffectsRoot = null, releaseRootPooledCache(root2, root2.pendingLanes));
      var remainingLanes = root2.pendingLanes;
      0 === remainingLanes && (legacyErrorBoundariesThatAlreadyFailed = null);
      lanesToEventPriority(lanes);
      finishedWork = finishedWork.stateNode;
      if (injectedHook && "function" === typeof injectedHook.onCommitFiberRoot)
        try {
          injectedHook.onCommitFiberRoot(
            rendererID,
            finishedWork,
            void 0,
            128 === (finishedWork.current.flags & 128)
          );
        } catch (err2) {
        }
      if (null !== recoverableErrors) {
        finishedWork = ReactSharedInternals.T;
        remainingLanes = ReactDOMSharedInternals.p;
        ReactDOMSharedInternals.p = 2;
        ReactSharedInternals.T = null;
        try {
          for (var onRecoverableError = root2.onRecoverableError, i3 = 0; i3 < recoverableErrors.length; i3++) {
            var recoverableError = recoverableErrors[i3];
            onRecoverableError(recoverableError.value, {
              componentStack: recoverableError.stack
            });
          }
        } finally {
          ReactSharedInternals.T = finishedWork, ReactDOMSharedInternals.p = remainingLanes;
        }
      }
      0 !== (pendingEffectsLanes & 3) && flushPendingEffects();
      ensureRootIsScheduled(root2);
      remainingLanes = root2.pendingLanes;
      0 !== (lanes & 261930) && 0 !== (remainingLanes & 42) ? root2 === rootWithNestedUpdates ? nestedUpdateCount++ : (nestedUpdateCount = 0, rootWithNestedUpdates = root2) : nestedUpdateCount = 0;
      flushSyncWorkAcrossRoots_impl(0);
    }
  }
  function releaseRootPooledCache(root2, remainingLanes) {
    0 === (root2.pooledCacheLanes &= remainingLanes) && (remainingLanes = root2.pooledCache, null != remainingLanes && (root2.pooledCache = null, releaseCache(remainingLanes)));
  }
  function flushPendingEffects() {
    flushMutationEffects();
    flushLayoutEffects();
    flushSpawnedWork();
    return flushPassiveEffects();
  }
  function flushPassiveEffects() {
    if (5 !== pendingEffectsStatus) return false;
    var root2 = pendingEffectsRoot, remainingLanes = pendingEffectsRemainingLanes;
    pendingEffectsRemainingLanes = 0;
    var renderPriority = lanesToEventPriority(pendingEffectsLanes), prevTransition = ReactSharedInternals.T, previousPriority = ReactDOMSharedInternals.p;
    try {
      ReactDOMSharedInternals.p = 32 > renderPriority ? 32 : renderPriority;
      ReactSharedInternals.T = null;
      renderPriority = pendingPassiveTransitions;
      pendingPassiveTransitions = null;
      var root$jscomp$0 = pendingEffectsRoot, lanes = pendingEffectsLanes;
      pendingEffectsStatus = 0;
      pendingFinishedWork = pendingEffectsRoot = null;
      pendingEffectsLanes = 0;
      if (0 !== (executionContext & 6)) throw Error(formatProdErrorMessage(331));
      var prevExecutionContext = executionContext;
      executionContext |= 4;
      commitPassiveUnmountOnFiber(root$jscomp$0.current);
      commitPassiveMountOnFiber(
        root$jscomp$0,
        root$jscomp$0.current,
        lanes,
        renderPriority
      );
      executionContext = prevExecutionContext;
      flushSyncWorkAcrossRoots_impl(0, false);
      if (injectedHook && "function" === typeof injectedHook.onPostCommitFiberRoot)
        try {
          injectedHook.onPostCommitFiberRoot(rendererID, root$jscomp$0);
        } catch (err2) {
        }
      return true;
    } finally {
      ReactDOMSharedInternals.p = previousPriority, ReactSharedInternals.T = prevTransition, releaseRootPooledCache(root2, remainingLanes);
    }
  }
  function captureCommitPhaseErrorOnRoot(rootFiber, sourceFiber, error) {
    sourceFiber = createCapturedValueAtFiber(error, sourceFiber);
    sourceFiber = createRootErrorUpdate(rootFiber.stateNode, sourceFiber, 2);
    rootFiber = enqueueUpdate(rootFiber, sourceFiber, 2);
    null !== rootFiber && (markRootUpdated$1(rootFiber, 2), ensureRootIsScheduled(rootFiber));
  }
  function captureCommitPhaseError(sourceFiber, nearestMountedAncestor, error) {
    if (3 === sourceFiber.tag)
      captureCommitPhaseErrorOnRoot(sourceFiber, sourceFiber, error);
    else
      for (; null !== nearestMountedAncestor; ) {
        if (3 === nearestMountedAncestor.tag) {
          captureCommitPhaseErrorOnRoot(
            nearestMountedAncestor,
            sourceFiber,
            error
          );
          break;
        } else if (1 === nearestMountedAncestor.tag) {
          var instance = nearestMountedAncestor.stateNode;
          if ("function" === typeof nearestMountedAncestor.type.getDerivedStateFromError || "function" === typeof instance.componentDidCatch && (null === legacyErrorBoundariesThatAlreadyFailed || !legacyErrorBoundariesThatAlreadyFailed.has(instance))) {
            sourceFiber = createCapturedValueAtFiber(error, sourceFiber);
            error = createClassErrorUpdate(2);
            instance = enqueueUpdate(nearestMountedAncestor, error, 2);
            null !== instance && (initializeClassErrorUpdate(
              error,
              instance,
              nearestMountedAncestor,
              sourceFiber
            ), markRootUpdated$1(instance, 2), ensureRootIsScheduled(instance));
            break;
          }
        }
        nearestMountedAncestor = nearestMountedAncestor.return;
      }
  }
  function attachPingListener(root2, wakeable, lanes) {
    var pingCache = root2.pingCache;
    if (null === pingCache) {
      pingCache = root2.pingCache = new PossiblyWeakMap();
      var threadIDs = /* @__PURE__ */ new Set();
      pingCache.set(wakeable, threadIDs);
    } else
      threadIDs = pingCache.get(wakeable), void 0 === threadIDs && (threadIDs = /* @__PURE__ */ new Set(), pingCache.set(wakeable, threadIDs));
    threadIDs.has(lanes) || (workInProgressRootDidAttachPingListener = true, threadIDs.add(lanes), root2 = pingSuspendedRoot.bind(null, root2, wakeable, lanes), wakeable.then(root2, root2));
  }
  function pingSuspendedRoot(root2, wakeable, pingedLanes) {
    var pingCache = root2.pingCache;
    null !== pingCache && pingCache.delete(wakeable);
    root2.pingedLanes |= root2.suspendedLanes & pingedLanes;
    root2.warmLanes &= ~pingedLanes;
    workInProgressRoot === root2 && (workInProgressRootRenderLanes & pingedLanes) === pingedLanes && (4 === workInProgressRootExitStatus || 3 === workInProgressRootExitStatus && (workInProgressRootRenderLanes & 62914560) === workInProgressRootRenderLanes && 300 > now() - globalMostRecentFallbackTime ? 0 === (executionContext & 2) && prepareFreshStack(root2, 0) : workInProgressRootPingedLanes |= pingedLanes, workInProgressSuspendedRetryLanes === workInProgressRootRenderLanes && (workInProgressSuspendedRetryLanes = 0));
    ensureRootIsScheduled(root2);
  }
  function retryTimedOutBoundary(boundaryFiber, retryLane) {
    0 === retryLane && (retryLane = claimNextRetryLane());
    boundaryFiber = enqueueConcurrentRenderForLane(boundaryFiber, retryLane);
    null !== boundaryFiber && (markRootUpdated$1(boundaryFiber, retryLane), ensureRootIsScheduled(boundaryFiber));
  }
  function retryDehydratedSuspenseBoundary(boundaryFiber) {
    var suspenseState = boundaryFiber.memoizedState, retryLane = 0;
    null !== suspenseState && (retryLane = suspenseState.retryLane);
    retryTimedOutBoundary(boundaryFiber, retryLane);
  }
  function resolveRetryWakeable(boundaryFiber, wakeable) {
    var retryLane = 0;
    switch (boundaryFiber.tag) {
      case 31:
      case 13:
        var retryCache = boundaryFiber.stateNode;
        var suspenseState = boundaryFiber.memoizedState;
        null !== suspenseState && (retryLane = suspenseState.retryLane);
        break;
      case 19:
        retryCache = boundaryFiber.stateNode;
        break;
      case 22:
        retryCache = boundaryFiber.stateNode._retryCache;
        break;
      default:
        throw Error(formatProdErrorMessage(314));
    }
    null !== retryCache && retryCache.delete(wakeable);
    retryTimedOutBoundary(boundaryFiber, retryLane);
  }
  function scheduleCallback$1(priorityLevel, callback) {
    return scheduleCallback$3(priorityLevel, callback);
  }
  var firstScheduledRoot = null, lastScheduledRoot = null, didScheduleMicrotask = false, mightHavePendingSyncWork = false, isFlushingWork = false, currentEventTransitionLane = 0;
  function ensureRootIsScheduled(root2) {
    root2 !== lastScheduledRoot && null === root2.next && (null === lastScheduledRoot ? firstScheduledRoot = lastScheduledRoot = root2 : lastScheduledRoot = lastScheduledRoot.next = root2);
    mightHavePendingSyncWork = true;
    didScheduleMicrotask || (didScheduleMicrotask = true, scheduleImmediateRootScheduleTask());
  }
  function flushSyncWorkAcrossRoots_impl(syncTransitionLanes, onlyLegacy) {
    if (!isFlushingWork && mightHavePendingSyncWork) {
      isFlushingWork = true;
      do {
        var didPerformSomeWork = false;
        for (var root$170 = firstScheduledRoot; null !== root$170; ) {
          if (0 !== syncTransitionLanes) {
            var pendingLanes = root$170.pendingLanes;
            if (0 === pendingLanes) var JSCompiler_inline_result = 0;
            else {
              var suspendedLanes = root$170.suspendedLanes, pingedLanes = root$170.pingedLanes;
              JSCompiler_inline_result = (1 << 31 - clz32(42 | syncTransitionLanes) + 1) - 1;
              JSCompiler_inline_result &= pendingLanes & ~(suspendedLanes & ~pingedLanes);
              JSCompiler_inline_result = JSCompiler_inline_result & 201326741 ? JSCompiler_inline_result & 201326741 | 1 : JSCompiler_inline_result ? JSCompiler_inline_result | 2 : 0;
            }
            0 !== JSCompiler_inline_result && (didPerformSomeWork = true, performSyncWorkOnRoot(root$170, JSCompiler_inline_result));
          } else
            JSCompiler_inline_result = workInProgressRootRenderLanes, JSCompiler_inline_result = getNextLanes(
              root$170,
              root$170 === workInProgressRoot ? JSCompiler_inline_result : 0,
              null !== root$170.cancelPendingCommit || -1 !== root$170.timeoutHandle
            ), 0 === (JSCompiler_inline_result & 3) || checkIfRootIsPrerendering(root$170, JSCompiler_inline_result) || (didPerformSomeWork = true, performSyncWorkOnRoot(root$170, JSCompiler_inline_result));
          root$170 = root$170.next;
        }
      } while (didPerformSomeWork);
      isFlushingWork = false;
    }
  }
  function processRootScheduleInImmediateTask() {
    processRootScheduleInMicrotask();
  }
  function processRootScheduleInMicrotask() {
    mightHavePendingSyncWork = didScheduleMicrotask = false;
    var syncTransitionLanes = 0;
    0 !== currentEventTransitionLane && shouldAttemptEagerTransition() && (syncTransitionLanes = currentEventTransitionLane);
    for (var currentTime = now(), prev = null, root2 = firstScheduledRoot; null !== root2; ) {
      var next = root2.next, nextLanes = scheduleTaskForRootDuringMicrotask(root2, currentTime);
      if (0 === nextLanes)
        root2.next = null, null === prev ? firstScheduledRoot = next : prev.next = next, null === next && (lastScheduledRoot = prev);
      else if (prev = root2, 0 !== syncTransitionLanes || 0 !== (nextLanes & 3))
        mightHavePendingSyncWork = true;
      root2 = next;
    }
    0 !== pendingEffectsStatus && 5 !== pendingEffectsStatus || flushSyncWorkAcrossRoots_impl(syncTransitionLanes);
    0 !== currentEventTransitionLane && (currentEventTransitionLane = 0);
  }
  function scheduleTaskForRootDuringMicrotask(root2, currentTime) {
    for (var suspendedLanes = root2.suspendedLanes, pingedLanes = root2.pingedLanes, expirationTimes = root2.expirationTimes, lanes = root2.pendingLanes & -62914561; 0 < lanes; ) {
      var index$5 = 31 - clz32(lanes), lane = 1 << index$5, expirationTime = expirationTimes[index$5];
      if (-1 === expirationTime) {
        if (0 === (lane & suspendedLanes) || 0 !== (lane & pingedLanes))
          expirationTimes[index$5] = computeExpirationTime(lane, currentTime);
      } else expirationTime <= currentTime && (root2.expiredLanes |= lane);
      lanes &= ~lane;
    }
    currentTime = workInProgressRoot;
    suspendedLanes = workInProgressRootRenderLanes;
    suspendedLanes = getNextLanes(
      root2,
      root2 === currentTime ? suspendedLanes : 0,
      null !== root2.cancelPendingCommit || -1 !== root2.timeoutHandle
    );
    pingedLanes = root2.callbackNode;
    if (0 === suspendedLanes || root2 === currentTime && (2 === workInProgressSuspendedReason || 9 === workInProgressSuspendedReason) || null !== root2.cancelPendingCommit)
      return null !== pingedLanes && null !== pingedLanes && cancelCallback$1(pingedLanes), root2.callbackNode = null, root2.callbackPriority = 0;
    if (0 === (suspendedLanes & 3) || checkIfRootIsPrerendering(root2, suspendedLanes)) {
      currentTime = suspendedLanes & -suspendedLanes;
      if (currentTime === root2.callbackPriority) return currentTime;
      null !== pingedLanes && cancelCallback$1(pingedLanes);
      switch (lanesToEventPriority(suspendedLanes)) {
        case 2:
        case 8:
          suspendedLanes = UserBlockingPriority;
          break;
        case 32:
          suspendedLanes = NormalPriority$1;
          break;
        case 268435456:
          suspendedLanes = IdlePriority;
          break;
        default:
          suspendedLanes = NormalPriority$1;
      }
      pingedLanes = performWorkOnRootViaSchedulerTask.bind(null, root2);
      suspendedLanes = scheduleCallback$3(suspendedLanes, pingedLanes);
      root2.callbackPriority = currentTime;
      root2.callbackNode = suspendedLanes;
      return currentTime;
    }
    null !== pingedLanes && null !== pingedLanes && cancelCallback$1(pingedLanes);
    root2.callbackPriority = 2;
    root2.callbackNode = null;
    return 2;
  }
  function performWorkOnRootViaSchedulerTask(root2, didTimeout) {
    if (0 !== pendingEffectsStatus && 5 !== pendingEffectsStatus)
      return root2.callbackNode = null, root2.callbackPriority = 0, null;
    var originalCallbackNode = root2.callbackNode;
    if (flushPendingEffects() && root2.callbackNode !== originalCallbackNode)
      return null;
    var workInProgressRootRenderLanes$jscomp$0 = workInProgressRootRenderLanes;
    workInProgressRootRenderLanes$jscomp$0 = getNextLanes(
      root2,
      root2 === workInProgressRoot ? workInProgressRootRenderLanes$jscomp$0 : 0,
      null !== root2.cancelPendingCommit || -1 !== root2.timeoutHandle
    );
    if (0 === workInProgressRootRenderLanes$jscomp$0) return null;
    performWorkOnRoot(root2, workInProgressRootRenderLanes$jscomp$0, didTimeout);
    scheduleTaskForRootDuringMicrotask(root2, now());
    return null != root2.callbackNode && root2.callbackNode === originalCallbackNode ? performWorkOnRootViaSchedulerTask.bind(null, root2) : null;
  }
  function performSyncWorkOnRoot(root2, lanes) {
    if (flushPendingEffects()) return null;
    performWorkOnRoot(root2, lanes, true);
  }
  function scheduleImmediateRootScheduleTask() {
    scheduleMicrotask(function() {
      0 !== (executionContext & 6) ? scheduleCallback$3(
        ImmediatePriority,
        processRootScheduleInImmediateTask
      ) : processRootScheduleInMicrotask();
    });
  }
  function requestTransitionLane() {
    if (0 === currentEventTransitionLane) {
      var actionScopeLane = currentEntangledLane;
      0 === actionScopeLane && (actionScopeLane = nextTransitionUpdateLane, nextTransitionUpdateLane <<= 1, 0 === (nextTransitionUpdateLane & 261888) && (nextTransitionUpdateLane = 256));
      currentEventTransitionLane = actionScopeLane;
    }
    return currentEventTransitionLane;
  }
  function coerceFormActionProp(actionProp) {
    return null == actionProp || "symbol" === typeof actionProp || "boolean" === typeof actionProp ? null : "function" === typeof actionProp ? actionProp : sanitizeURL("" + actionProp);
  }
  function createFormDataWithSubmitter(form, submitter) {
    var temp = submitter.ownerDocument.createElement("input");
    temp.name = submitter.name;
    temp.value = submitter.value;
    form.id && temp.setAttribute("form", form.id);
    submitter.parentNode.insertBefore(temp, submitter);
    form = new FormData(form);
    temp.parentNode.removeChild(temp);
    return form;
  }
  function extractEvents$1(dispatchQueue, domEventName, maybeTargetInst, nativeEvent, nativeEventTarget) {
    if ("submit" === domEventName && maybeTargetInst && maybeTargetInst.stateNode === nativeEventTarget) {
      var action = coerceFormActionProp(
        (nativeEventTarget[internalPropsKey] || null).action
      ), submitter = nativeEvent.submitter;
      submitter && (domEventName = (domEventName = submitter[internalPropsKey] || null) ? coerceFormActionProp(domEventName.formAction) : submitter.getAttribute("formAction"), null !== domEventName && (action = domEventName, submitter = null));
      var event = new SyntheticEvent(
        "action",
        "action",
        null,
        nativeEvent,
        nativeEventTarget
      );
      dispatchQueue.push({
        event,
        listeners: [
          {
            instance: null,
            listener: function() {
              if (nativeEvent.defaultPrevented) {
                if (0 !== currentEventTransitionLane) {
                  var formData = submitter ? createFormDataWithSubmitter(nativeEventTarget, submitter) : new FormData(nativeEventTarget);
                  startHostTransition(
                    maybeTargetInst,
                    {
                      pending: true,
                      data: formData,
                      method: nativeEventTarget.method,
                      action
                    },
                    null,
                    formData
                  );
                }
              } else
                "function" === typeof action && (event.preventDefault(), formData = submitter ? createFormDataWithSubmitter(nativeEventTarget, submitter) : new FormData(nativeEventTarget), startHostTransition(
                  maybeTargetInst,
                  {
                    pending: true,
                    data: formData,
                    method: nativeEventTarget.method,
                    action
                  },
                  action,
                  formData
                ));
            },
            currentTarget: nativeEventTarget
          }
        ]
      });
    }
  }
  for (var i$jscomp$inline_1577 = 0; i$jscomp$inline_1577 < simpleEventPluginEvents.length; i$jscomp$inline_1577++) {
    var eventName$jscomp$inline_1578 = simpleEventPluginEvents[i$jscomp$inline_1577], domEventName$jscomp$inline_1579 = eventName$jscomp$inline_1578.toLowerCase(), capitalizedEvent$jscomp$inline_1580 = eventName$jscomp$inline_1578[0].toUpperCase() + eventName$jscomp$inline_1578.slice(1);
    registerSimpleEvent(
      domEventName$jscomp$inline_1579,
      "on" + capitalizedEvent$jscomp$inline_1580
    );
  }
  registerSimpleEvent(ANIMATION_END, "onAnimationEnd");
  registerSimpleEvent(ANIMATION_ITERATION, "onAnimationIteration");
  registerSimpleEvent(ANIMATION_START, "onAnimationStart");
  registerSimpleEvent("dblclick", "onDoubleClick");
  registerSimpleEvent("focusin", "onFocus");
  registerSimpleEvent("focusout", "onBlur");
  registerSimpleEvent(TRANSITION_RUN, "onTransitionRun");
  registerSimpleEvent(TRANSITION_START, "onTransitionStart");
  registerSimpleEvent(TRANSITION_CANCEL, "onTransitionCancel");
  registerSimpleEvent(TRANSITION_END, "onTransitionEnd");
  registerDirectEvent("onMouseEnter", ["mouseout", "mouseover"]);
  registerDirectEvent("onMouseLeave", ["mouseout", "mouseover"]);
  registerDirectEvent("onPointerEnter", ["pointerout", "pointerover"]);
  registerDirectEvent("onPointerLeave", ["pointerout", "pointerover"]);
  registerTwoPhaseEvent(
    "onChange",
    "change click focusin focusout input keydown keyup selectionchange".split(" ")
  );
  registerTwoPhaseEvent(
    "onSelect",
    "focusout contextmenu dragend focusin keydown keyup mousedown mouseup selectionchange".split(
      " "
    )
  );
  registerTwoPhaseEvent("onBeforeInput", [
    "compositionend",
    "keypress",
    "textInput",
    "paste"
  ]);
  registerTwoPhaseEvent(
    "onCompositionEnd",
    "compositionend focusout keydown keypress keyup mousedown".split(" ")
  );
  registerTwoPhaseEvent(
    "onCompositionStart",
    "compositionstart focusout keydown keypress keyup mousedown".split(" ")
  );
  registerTwoPhaseEvent(
    "onCompositionUpdate",
    "compositionupdate focusout keydown keypress keyup mousedown".split(" ")
  );
  var mediaEventTypes = "abort canplay canplaythrough durationchange emptied encrypted ended error loadeddata loadedmetadata loadstart pause play playing progress ratechange resize seeked seeking stalled suspend timeupdate volumechange waiting".split(
    " "
  ), nonDelegatedEvents = new Set(
    "beforetoggle cancel close invalid load scroll scrollend toggle".split(" ").concat(mediaEventTypes)
  );
  function processDispatchQueue(dispatchQueue, eventSystemFlags) {
    eventSystemFlags = 0 !== (eventSystemFlags & 4);
    for (var i3 = 0; i3 < dispatchQueue.length; i3++) {
      var _dispatchQueue$i = dispatchQueue[i3], event = _dispatchQueue$i.event;
      _dispatchQueue$i = _dispatchQueue$i.listeners;
      a: {
        var previousInstance = void 0;
        if (eventSystemFlags)
          for (var i$jscomp$0 = _dispatchQueue$i.length - 1; 0 <= i$jscomp$0; i$jscomp$0--) {
            var _dispatchListeners$i = _dispatchQueue$i[i$jscomp$0], instance = _dispatchListeners$i.instance, currentTarget = _dispatchListeners$i.currentTarget;
            _dispatchListeners$i = _dispatchListeners$i.listener;
            if (instance !== previousInstance && event.isPropagationStopped())
              break a;
            previousInstance = _dispatchListeners$i;
            event.currentTarget = currentTarget;
            try {
              previousInstance(event);
            } catch (error) {
              reportGlobalError(error);
            }
            event.currentTarget = null;
            previousInstance = instance;
          }
        else
          for (i$jscomp$0 = 0; i$jscomp$0 < _dispatchQueue$i.length; i$jscomp$0++) {
            _dispatchListeners$i = _dispatchQueue$i[i$jscomp$0];
            instance = _dispatchListeners$i.instance;
            currentTarget = _dispatchListeners$i.currentTarget;
            _dispatchListeners$i = _dispatchListeners$i.listener;
            if (instance !== previousInstance && event.isPropagationStopped())
              break a;
            previousInstance = _dispatchListeners$i;
            event.currentTarget = currentTarget;
            try {
              previousInstance(event);
            } catch (error) {
              reportGlobalError(error);
            }
            event.currentTarget = null;
            previousInstance = instance;
          }
      }
    }
  }
  function listenToNonDelegatedEvent(domEventName, targetElement) {
    var JSCompiler_inline_result = targetElement[internalEventHandlersKey];
    void 0 === JSCompiler_inline_result && (JSCompiler_inline_result = targetElement[internalEventHandlersKey] = /* @__PURE__ */ new Set());
    var listenerSetKey = domEventName + "__bubble";
    JSCompiler_inline_result.has(listenerSetKey) || (addTrappedEventListener(targetElement, domEventName, 2, false), JSCompiler_inline_result.add(listenerSetKey));
  }
  function listenToNativeEvent(domEventName, isCapturePhaseListener, target) {
    var eventSystemFlags = 0;
    isCapturePhaseListener && (eventSystemFlags |= 4);
    addTrappedEventListener(
      target,
      domEventName,
      eventSystemFlags,
      isCapturePhaseListener
    );
  }
  var listeningMarker = "_reactListening" + Math.random().toString(36).slice(2);
  function listenToAllSupportedEvents(rootContainerElement) {
    if (!rootContainerElement[listeningMarker]) {
      rootContainerElement[listeningMarker] = true;
      allNativeEvents.forEach(function(domEventName) {
        "selectionchange" !== domEventName && (nonDelegatedEvents.has(domEventName) || listenToNativeEvent(domEventName, false, rootContainerElement), listenToNativeEvent(domEventName, true, rootContainerElement));
      });
      var ownerDocument = 9 === rootContainerElement.nodeType ? rootContainerElement : rootContainerElement.ownerDocument;
      null === ownerDocument || ownerDocument[listeningMarker] || (ownerDocument[listeningMarker] = true, listenToNativeEvent("selectionchange", false, ownerDocument));
    }
  }
  function addTrappedEventListener(targetContainer, domEventName, eventSystemFlags, isCapturePhaseListener) {
    switch (getEventPriority(domEventName)) {
      case 2:
        var listenerWrapper = dispatchDiscreteEvent;
        break;
      case 8:
        listenerWrapper = dispatchContinuousEvent;
        break;
      default:
        listenerWrapper = dispatchEvent;
    }
    eventSystemFlags = listenerWrapper.bind(
      null,
      domEventName,
      eventSystemFlags,
      targetContainer
    );
    listenerWrapper = void 0;
    !passiveBrowserEventsSupported || "touchstart" !== domEventName && "touchmove" !== domEventName && "wheel" !== domEventName || (listenerWrapper = true);
    isCapturePhaseListener ? void 0 !== listenerWrapper ? targetContainer.addEventListener(domEventName, eventSystemFlags, {
      capture: true,
      passive: listenerWrapper
    }) : targetContainer.addEventListener(domEventName, eventSystemFlags, true) : void 0 !== listenerWrapper ? targetContainer.addEventListener(domEventName, eventSystemFlags, {
      passive: listenerWrapper
    }) : targetContainer.addEventListener(domEventName, eventSystemFlags, false);
  }
  function dispatchEventForPluginEventSystem(domEventName, eventSystemFlags, nativeEvent, targetInst$jscomp$0, targetContainer) {
    var ancestorInst = targetInst$jscomp$0;
    if (0 === (eventSystemFlags & 1) && 0 === (eventSystemFlags & 2) && null !== targetInst$jscomp$0)
      a: for (; ; ) {
        if (null === targetInst$jscomp$0) return;
        var nodeTag = targetInst$jscomp$0.tag;
        if (3 === nodeTag || 4 === nodeTag) {
          var container = targetInst$jscomp$0.stateNode.containerInfo;
          if (container === targetContainer) break;
          if (4 === nodeTag)
            for (nodeTag = targetInst$jscomp$0.return; null !== nodeTag; ) {
              var grandTag = nodeTag.tag;
              if ((3 === grandTag || 4 === grandTag) && nodeTag.stateNode.containerInfo === targetContainer)
                return;
              nodeTag = nodeTag.return;
            }
          for (; null !== container; ) {
            nodeTag = getClosestInstanceFromNode(container);
            if (null === nodeTag) return;
            grandTag = nodeTag.tag;
            if (5 === grandTag || 6 === grandTag || 26 === grandTag || 27 === grandTag) {
              targetInst$jscomp$0 = ancestorInst = nodeTag;
              continue a;
            }
            container = container.parentNode;
          }
        }
        targetInst$jscomp$0 = targetInst$jscomp$0.return;
      }
    batchedUpdates$1(function() {
      var targetInst = ancestorInst, nativeEventTarget = getEventTarget(nativeEvent), dispatchQueue = [];
      a: {
        var reactName = topLevelEventsToReactNames.get(domEventName);
        if (void 0 !== reactName) {
          var SyntheticEventCtor = SyntheticEvent, reactEventType = domEventName;
          switch (domEventName) {
            case "keypress":
              if (0 === getEventCharCode(nativeEvent)) break a;
            case "keydown":
            case "keyup":
              SyntheticEventCtor = SyntheticKeyboardEvent;
              break;
            case "focusin":
              reactEventType = "focus";
              SyntheticEventCtor = SyntheticFocusEvent;
              break;
            case "focusout":
              reactEventType = "blur";
              SyntheticEventCtor = SyntheticFocusEvent;
              break;
            case "beforeblur":
            case "afterblur":
              SyntheticEventCtor = SyntheticFocusEvent;
              break;
            case "click":
              if (2 === nativeEvent.button) break a;
            case "auxclick":
            case "dblclick":
            case "mousedown":
            case "mousemove":
            case "mouseup":
            case "mouseout":
            case "mouseover":
            case "contextmenu":
              SyntheticEventCtor = SyntheticMouseEvent;
              break;
            case "drag":
            case "dragend":
            case "dragenter":
            case "dragexit":
            case "dragleave":
            case "dragover":
            case "dragstart":
            case "drop":
              SyntheticEventCtor = SyntheticDragEvent;
              break;
            case "touchcancel":
            case "touchend":
            case "touchmove":
            case "touchstart":
              SyntheticEventCtor = SyntheticTouchEvent;
              break;
            case ANIMATION_END:
            case ANIMATION_ITERATION:
            case ANIMATION_START:
              SyntheticEventCtor = SyntheticAnimationEvent;
              break;
            case TRANSITION_END:
              SyntheticEventCtor = SyntheticTransitionEvent;
              break;
            case "scroll":
            case "scrollend":
              SyntheticEventCtor = SyntheticUIEvent;
              break;
            case "wheel":
              SyntheticEventCtor = SyntheticWheelEvent;
              break;
            case "copy":
            case "cut":
            case "paste":
              SyntheticEventCtor = SyntheticClipboardEvent;
              break;
            case "gotpointercapture":
            case "lostpointercapture":
            case "pointercancel":
            case "pointerdown":
            case "pointermove":
            case "pointerout":
            case "pointerover":
            case "pointerup":
              SyntheticEventCtor = SyntheticPointerEvent;
              break;
            case "toggle":
            case "beforetoggle":
              SyntheticEventCtor = SyntheticToggleEvent;
          }
          var inCapturePhase = 0 !== (eventSystemFlags & 4), accumulateTargetOnly = !inCapturePhase && ("scroll" === domEventName || "scrollend" === domEventName), reactEventName = inCapturePhase ? null !== reactName ? reactName + "Capture" : null : reactName;
          inCapturePhase = [];
          for (var instance = targetInst, lastHostComponent; null !== instance; ) {
            var _instance = instance;
            lastHostComponent = _instance.stateNode;
            _instance = _instance.tag;
            5 !== _instance && 26 !== _instance && 27 !== _instance || null === lastHostComponent || null === reactEventName || (_instance = getListener(instance, reactEventName), null != _instance && inCapturePhase.push(
              createDispatchListener(instance, _instance, lastHostComponent)
            ));
            if (accumulateTargetOnly) break;
            instance = instance.return;
          }
          0 < inCapturePhase.length && (reactName = new SyntheticEventCtor(
            reactName,
            reactEventType,
            null,
            nativeEvent,
            nativeEventTarget
          ), dispatchQueue.push({ event: reactName, listeners: inCapturePhase }));
        }
      }
      if (0 === (eventSystemFlags & 7)) {
        a: {
          reactName = "mouseover" === domEventName || "pointerover" === domEventName;
          SyntheticEventCtor = "mouseout" === domEventName || "pointerout" === domEventName;
          if (reactName && nativeEvent !== currentReplayingEvent && (reactEventType = nativeEvent.relatedTarget || nativeEvent.fromElement) && (getClosestInstanceFromNode(reactEventType) || reactEventType[internalContainerInstanceKey]))
            break a;
          if (SyntheticEventCtor || reactName) {
            reactName = nativeEventTarget.window === nativeEventTarget ? nativeEventTarget : (reactName = nativeEventTarget.ownerDocument) ? reactName.defaultView || reactName.parentWindow : window;
            if (SyntheticEventCtor) {
              if (reactEventType = nativeEvent.relatedTarget || nativeEvent.toElement, SyntheticEventCtor = targetInst, reactEventType = reactEventType ? getClosestInstanceFromNode(reactEventType) : null, null !== reactEventType && (accumulateTargetOnly = getNearestMountedFiber(reactEventType), inCapturePhase = reactEventType.tag, reactEventType !== accumulateTargetOnly || 5 !== inCapturePhase && 27 !== inCapturePhase && 6 !== inCapturePhase))
                reactEventType = null;
            } else SyntheticEventCtor = null, reactEventType = targetInst;
            if (SyntheticEventCtor !== reactEventType) {
              inCapturePhase = SyntheticMouseEvent;
              _instance = "onMouseLeave";
              reactEventName = "onMouseEnter";
              instance = "mouse";
              if ("pointerout" === domEventName || "pointerover" === domEventName)
                inCapturePhase = SyntheticPointerEvent, _instance = "onPointerLeave", reactEventName = "onPointerEnter", instance = "pointer";
              accumulateTargetOnly = null == SyntheticEventCtor ? reactName : getNodeFromInstance(SyntheticEventCtor);
              lastHostComponent = null == reactEventType ? reactName : getNodeFromInstance(reactEventType);
              reactName = new inCapturePhase(
                _instance,
                instance + "leave",
                SyntheticEventCtor,
                nativeEvent,
                nativeEventTarget
              );
              reactName.target = accumulateTargetOnly;
              reactName.relatedTarget = lastHostComponent;
              _instance = null;
              getClosestInstanceFromNode(nativeEventTarget) === targetInst && (inCapturePhase = new inCapturePhase(
                reactEventName,
                instance + "enter",
                reactEventType,
                nativeEvent,
                nativeEventTarget
              ), inCapturePhase.target = lastHostComponent, inCapturePhase.relatedTarget = accumulateTargetOnly, _instance = inCapturePhase);
              accumulateTargetOnly = _instance;
              if (SyntheticEventCtor && reactEventType)
                b: {
                  inCapturePhase = getParent;
                  reactEventName = SyntheticEventCtor;
                  instance = reactEventType;
                  lastHostComponent = 0;
                  for (_instance = reactEventName; _instance; _instance = inCapturePhase(_instance))
                    lastHostComponent++;
                  _instance = 0;
                  for (var tempB = instance; tempB; tempB = inCapturePhase(tempB))
                    _instance++;
                  for (; 0 < lastHostComponent - _instance; )
                    reactEventName = inCapturePhase(reactEventName), lastHostComponent--;
                  for (; 0 < _instance - lastHostComponent; )
                    instance = inCapturePhase(instance), _instance--;
                  for (; lastHostComponent--; ) {
                    if (reactEventName === instance || null !== instance && reactEventName === instance.alternate) {
                      inCapturePhase = reactEventName;
                      break b;
                    }
                    reactEventName = inCapturePhase(reactEventName);
                    instance = inCapturePhase(instance);
                  }
                  inCapturePhase = null;
                }
              else inCapturePhase = null;
              null !== SyntheticEventCtor && accumulateEnterLeaveListenersForEvent(
                dispatchQueue,
                reactName,
                SyntheticEventCtor,
                inCapturePhase,
                false
              );
              null !== reactEventType && null !== accumulateTargetOnly && accumulateEnterLeaveListenersForEvent(
                dispatchQueue,
                accumulateTargetOnly,
                reactEventType,
                inCapturePhase,
                true
              );
            }
          }
        }
        a: {
          reactName = targetInst ? getNodeFromInstance(targetInst) : window;
          SyntheticEventCtor = reactName.nodeName && reactName.nodeName.toLowerCase();
          if ("select" === SyntheticEventCtor || "input" === SyntheticEventCtor && "file" === reactName.type)
            var getTargetInstFunc = getTargetInstForChangeEvent;
          else if (isTextInputElement(reactName))
            if (isInputEventSupported)
              getTargetInstFunc = getTargetInstForInputOrChangeEvent;
            else {
              getTargetInstFunc = getTargetInstForInputEventPolyfill;
              var handleEventFunc = handleEventsForInputEventPolyfill;
            }
          else
            SyntheticEventCtor = reactName.nodeName, !SyntheticEventCtor || "input" !== SyntheticEventCtor.toLowerCase() || "checkbox" !== reactName.type && "radio" !== reactName.type ? targetInst && isCustomElement(targetInst.elementType) && (getTargetInstFunc = getTargetInstForChangeEvent) : getTargetInstFunc = getTargetInstForClickEvent;
          if (getTargetInstFunc && (getTargetInstFunc = getTargetInstFunc(domEventName, targetInst))) {
            createAndAccumulateChangeEvent(
              dispatchQueue,
              getTargetInstFunc,
              nativeEvent,
              nativeEventTarget
            );
            break a;
          }
          handleEventFunc && handleEventFunc(domEventName, reactName, targetInst);
          "focusout" === domEventName && targetInst && "number" === reactName.type && null != targetInst.memoizedProps.value && setDefaultValue(reactName, "number", reactName.value);
        }
        handleEventFunc = targetInst ? getNodeFromInstance(targetInst) : window;
        switch (domEventName) {
          case "focusin":
            if (isTextInputElement(handleEventFunc) || "true" === handleEventFunc.contentEditable)
              activeElement = handleEventFunc, activeElementInst = targetInst, lastSelection = null;
            break;
          case "focusout":
            lastSelection = activeElementInst = activeElement = null;
            break;
          case "mousedown":
            mouseDown = true;
            break;
          case "contextmenu":
          case "mouseup":
          case "dragend":
            mouseDown = false;
            constructSelectEvent(dispatchQueue, nativeEvent, nativeEventTarget);
            break;
          case "selectionchange":
            if (skipSelectionChangeEvent) break;
          case "keydown":
          case "keyup":
            constructSelectEvent(dispatchQueue, nativeEvent, nativeEventTarget);
        }
        var fallbackData;
        if (canUseCompositionEvent)
          b: {
            switch (domEventName) {
              case "compositionstart":
                var eventType = "onCompositionStart";
                break b;
              case "compositionend":
                eventType = "onCompositionEnd";
                break b;
              case "compositionupdate":
                eventType = "onCompositionUpdate";
                break b;
            }
            eventType = void 0;
          }
        else
          isComposing ? isFallbackCompositionEnd(domEventName, nativeEvent) && (eventType = "onCompositionEnd") : "keydown" === domEventName && 229 === nativeEvent.keyCode && (eventType = "onCompositionStart");
        eventType && (useFallbackCompositionData && "ko" !== nativeEvent.locale && (isComposing || "onCompositionStart" !== eventType ? "onCompositionEnd" === eventType && isComposing && (fallbackData = getData()) : (root = nativeEventTarget, startText = "value" in root ? root.value : root.textContent, isComposing = true)), handleEventFunc = accumulateTwoPhaseListeners(targetInst, eventType), 0 < handleEventFunc.length && (eventType = new SyntheticCompositionEvent(
          eventType,
          domEventName,
          null,
          nativeEvent,
          nativeEventTarget
        ), dispatchQueue.push({ event: eventType, listeners: handleEventFunc }), fallbackData ? eventType.data = fallbackData : (fallbackData = getDataFromCustomEvent(nativeEvent), null !== fallbackData && (eventType.data = fallbackData))));
        if (fallbackData = canUseTextInputEvent ? getNativeBeforeInputChars(domEventName, nativeEvent) : getFallbackBeforeInputChars(domEventName, nativeEvent))
          eventType = accumulateTwoPhaseListeners(targetInst, "onBeforeInput"), 0 < eventType.length && (handleEventFunc = new SyntheticCompositionEvent(
            "onBeforeInput",
            "beforeinput",
            null,
            nativeEvent,
            nativeEventTarget
          ), dispatchQueue.push({
            event: handleEventFunc,
            listeners: eventType
          }), handleEventFunc.data = fallbackData);
        extractEvents$1(
          dispatchQueue,
          domEventName,
          targetInst,
          nativeEvent,
          nativeEventTarget
        );
      }
      processDispatchQueue(dispatchQueue, eventSystemFlags);
    });
  }
  function createDispatchListener(instance, listener, currentTarget) {
    return {
      instance,
      listener,
      currentTarget
    };
  }
  function accumulateTwoPhaseListeners(targetFiber, reactName) {
    for (var captureName = reactName + "Capture", listeners = []; null !== targetFiber; ) {
      var _instance2 = targetFiber, stateNode = _instance2.stateNode;
      _instance2 = _instance2.tag;
      5 !== _instance2 && 26 !== _instance2 && 27 !== _instance2 || null === stateNode || (_instance2 = getListener(targetFiber, captureName), null != _instance2 && listeners.unshift(
        createDispatchListener(targetFiber, _instance2, stateNode)
      ), _instance2 = getListener(targetFiber, reactName), null != _instance2 && listeners.push(
        createDispatchListener(targetFiber, _instance2, stateNode)
      ));
      if (3 === targetFiber.tag) return listeners;
      targetFiber = targetFiber.return;
    }
    return [];
  }
  function getParent(inst) {
    if (null === inst) return null;
    do
      inst = inst.return;
    while (inst && 5 !== inst.tag && 27 !== inst.tag);
    return inst ? inst : null;
  }
  function accumulateEnterLeaveListenersForEvent(dispatchQueue, event, target, common2, inCapturePhase) {
    for (var registrationName = event._reactName, listeners = []; null !== target && target !== common2; ) {
      var _instance3 = target, alternate = _instance3.alternate, stateNode = _instance3.stateNode;
      _instance3 = _instance3.tag;
      if (null !== alternate && alternate === common2) break;
      5 !== _instance3 && 26 !== _instance3 && 27 !== _instance3 || null === stateNode || (alternate = stateNode, inCapturePhase ? (stateNode = getListener(target, registrationName), null != stateNode && listeners.unshift(
        createDispatchListener(target, stateNode, alternate)
      )) : inCapturePhase || (stateNode = getListener(target, registrationName), null != stateNode && listeners.push(
        createDispatchListener(target, stateNode, alternate)
      )));
      target = target.return;
    }
    0 !== listeners.length && dispatchQueue.push({ event, listeners });
  }
  var NORMALIZE_NEWLINES_REGEX = /\r\n?/g, NORMALIZE_NULL_AND_REPLACEMENT_REGEX = /\u0000|\uFFFD/g;
  function normalizeMarkupForTextOrAttribute(markup) {
    return ("string" === typeof markup ? markup : "" + markup).replace(NORMALIZE_NEWLINES_REGEX, "\n").replace(NORMALIZE_NULL_AND_REPLACEMENT_REGEX, "");
  }
  function checkForUnmatchedText(serverText, clientText) {
    clientText = normalizeMarkupForTextOrAttribute(clientText);
    return normalizeMarkupForTextOrAttribute(serverText) === clientText ? true : false;
  }
  function setProp(domElement, tag, key, value, props, prevValue) {
    switch (key) {
      case "children":
        "string" === typeof value ? "body" === tag || "textarea" === tag && "" === value || setTextContent(domElement, value) : ("number" === typeof value || "bigint" === typeof value) && "body" !== tag && setTextContent(domElement, "" + value);
        break;
      case "className":
        setValueForKnownAttribute(domElement, "class", value);
        break;
      case "tabIndex":
        setValueForKnownAttribute(domElement, "tabindex", value);
        break;
      case "dir":
      case "role":
      case "viewBox":
      case "width":
      case "height":
        setValueForKnownAttribute(domElement, key, value);
        break;
      case "style":
        setValueForStyles(domElement, value, prevValue);
        break;
      case "data":
        if ("object" !== tag) {
          setValueForKnownAttribute(domElement, "data", value);
          break;
        }
      case "src":
      case "href":
        if ("" === value && ("a" !== tag || "href" !== key)) {
          domElement.removeAttribute(key);
          break;
        }
        if (null == value || "function" === typeof value || "symbol" === typeof value || "boolean" === typeof value) {
          domElement.removeAttribute(key);
          break;
        }
        value = sanitizeURL("" + value);
        domElement.setAttribute(key, value);
        break;
      case "action":
      case "formAction":
        if ("function" === typeof value) {
          domElement.setAttribute(
            key,
            "javascript:throw new Error('A React form was unexpectedly submitted. If you called form.submit() manually, consider using form.requestSubmit() instead. If you\\'re trying to use event.stopPropagation() in a submit event handler, consider also calling event.preventDefault().')"
          );
          break;
        } else
          "function" === typeof prevValue && ("formAction" === key ? ("input" !== tag && setProp(domElement, tag, "name", props.name, props, null), setProp(
            domElement,
            tag,
            "formEncType",
            props.formEncType,
            props,
            null
          ), setProp(
            domElement,
            tag,
            "formMethod",
            props.formMethod,
            props,
            null
          ), setProp(
            domElement,
            tag,
            "formTarget",
            props.formTarget,
            props,
            null
          )) : (setProp(domElement, tag, "encType", props.encType, props, null), setProp(domElement, tag, "method", props.method, props, null), setProp(domElement, tag, "target", props.target, props, null)));
        if (null == value || "symbol" === typeof value || "boolean" === typeof value) {
          domElement.removeAttribute(key);
          break;
        }
        value = sanitizeURL("" + value);
        domElement.setAttribute(key, value);
        break;
      case "onClick":
        null != value && (domElement.onclick = noop$12);
        break;
      case "onScroll":
        null != value && listenToNonDelegatedEvent("scroll", domElement);
        break;
      case "onScrollEnd":
        null != value && listenToNonDelegatedEvent("scrollend", domElement);
        break;
      case "dangerouslySetInnerHTML":
        if (null != value) {
          if ("object" !== typeof value || !("__html" in value))
            throw Error(formatProdErrorMessage(61));
          key = value.__html;
          if (null != key) {
            if (null != props.children) throw Error(formatProdErrorMessage(60));
            domElement.innerHTML = key;
          }
        }
        break;
      case "multiple":
        domElement.multiple = value && "function" !== typeof value && "symbol" !== typeof value;
        break;
      case "muted":
        domElement.muted = value && "function" !== typeof value && "symbol" !== typeof value;
        break;
      case "suppressContentEditableWarning":
      case "suppressHydrationWarning":
      case "defaultValue":
      case "defaultChecked":
      case "innerHTML":
      case "ref":
        break;
      case "autoFocus":
        break;
      case "xlinkHref":
        if (null == value || "function" === typeof value || "boolean" === typeof value || "symbol" === typeof value) {
          domElement.removeAttribute("xlink:href");
          break;
        }
        key = sanitizeURL("" + value);
        domElement.setAttributeNS(
          "http://www.w3.org/1999/xlink",
          "xlink:href",
          key
        );
        break;
      case "contentEditable":
      case "spellCheck":
      case "draggable":
      case "value":
      case "autoReverse":
      case "externalResourcesRequired":
      case "focusable":
      case "preserveAlpha":
        null != value && "function" !== typeof value && "symbol" !== typeof value ? domElement.setAttribute(key, "" + value) : domElement.removeAttribute(key);
        break;
      case "inert":
      case "allowFullScreen":
      case "async":
      case "autoPlay":
      case "controls":
      case "default":
      case "defer":
      case "disabled":
      case "disablePictureInPicture":
      case "disableRemotePlayback":
      case "formNoValidate":
      case "hidden":
      case "loop":
      case "noModule":
      case "noValidate":
      case "open":
      case "playsInline":
      case "readOnly":
      case "required":
      case "reversed":
      case "scoped":
      case "seamless":
      case "itemScope":
        value && "function" !== typeof value && "symbol" !== typeof value ? domElement.setAttribute(key, "") : domElement.removeAttribute(key);
        break;
      case "capture":
      case "download":
        true === value ? domElement.setAttribute(key, "") : false !== value && null != value && "function" !== typeof value && "symbol" !== typeof value ? domElement.setAttribute(key, value) : domElement.removeAttribute(key);
        break;
      case "cols":
      case "rows":
      case "size":
      case "span":
        null != value && "function" !== typeof value && "symbol" !== typeof value && !isNaN(value) && 1 <= value ? domElement.setAttribute(key, value) : domElement.removeAttribute(key);
        break;
      case "rowSpan":
      case "start":
        null == value || "function" === typeof value || "symbol" === typeof value || isNaN(value) ? domElement.removeAttribute(key) : domElement.setAttribute(key, value);
        break;
      case "popover":
        listenToNonDelegatedEvent("beforetoggle", domElement);
        listenToNonDelegatedEvent("toggle", domElement);
        setValueForAttribute(domElement, "popover", value);
        break;
      case "xlinkActuate":
        setValueForNamespacedAttribute(
          domElement,
          "http://www.w3.org/1999/xlink",
          "xlink:actuate",
          value
        );
        break;
      case "xlinkArcrole":
        setValueForNamespacedAttribute(
          domElement,
          "http://www.w3.org/1999/xlink",
          "xlink:arcrole",
          value
        );
        break;
      case "xlinkRole":
        setValueForNamespacedAttribute(
          domElement,
          "http://www.w3.org/1999/xlink",
          "xlink:role",
          value
        );
        break;
      case "xlinkShow":
        setValueForNamespacedAttribute(
          domElement,
          "http://www.w3.org/1999/xlink",
          "xlink:show",
          value
        );
        break;
      case "xlinkTitle":
        setValueForNamespacedAttribute(
          domElement,
          "http://www.w3.org/1999/xlink",
          "xlink:title",
          value
        );
        break;
      case "xlinkType":
        setValueForNamespacedAttribute(
          domElement,
          "http://www.w3.org/1999/xlink",
          "xlink:type",
          value
        );
        break;
      case "xmlBase":
        setValueForNamespacedAttribute(
          domElement,
          "http://www.w3.org/XML/1998/namespace",
          "xml:base",
          value
        );
        break;
      case "xmlLang":
        setValueForNamespacedAttribute(
          domElement,
          "http://www.w3.org/XML/1998/namespace",
          "xml:lang",
          value
        );
        break;
      case "xmlSpace":
        setValueForNamespacedAttribute(
          domElement,
          "http://www.w3.org/XML/1998/namespace",
          "xml:space",
          value
        );
        break;
      case "is":
        setValueForAttribute(domElement, "is", value);
        break;
      case "innerText":
      case "textContent":
        break;
      default:
        if (!(2 < key.length) || "o" !== key[0] && "O" !== key[0] || "n" !== key[1] && "N" !== key[1])
          key = aliases.get(key) || key, setValueForAttribute(domElement, key, value);
    }
  }
  function setPropOnCustomElement(domElement, tag, key, value, props, prevValue) {
    switch (key) {
      case "style":
        setValueForStyles(domElement, value, prevValue);
        break;
      case "dangerouslySetInnerHTML":
        if (null != value) {
          if ("object" !== typeof value || !("__html" in value))
            throw Error(formatProdErrorMessage(61));
          key = value.__html;
          if (null != key) {
            if (null != props.children) throw Error(formatProdErrorMessage(60));
            domElement.innerHTML = key;
          }
        }
        break;
      case "children":
        "string" === typeof value ? setTextContent(domElement, value) : ("number" === typeof value || "bigint" === typeof value) && setTextContent(domElement, "" + value);
        break;
      case "onScroll":
        null != value && listenToNonDelegatedEvent("scroll", domElement);
        break;
      case "onScrollEnd":
        null != value && listenToNonDelegatedEvent("scrollend", domElement);
        break;
      case "onClick":
        null != value && (domElement.onclick = noop$12);
        break;
      case "suppressContentEditableWarning":
      case "suppressHydrationWarning":
      case "innerHTML":
      case "ref":
        break;
      case "innerText":
      case "textContent":
        break;
      default:
        if (!registrationNameDependencies.hasOwnProperty(key))
          a: {
            if ("o" === key[0] && "n" === key[1] && (props = key.endsWith("Capture"), tag = key.slice(2, props ? key.length - 7 : void 0), prevValue = domElement[internalPropsKey] || null, prevValue = null != prevValue ? prevValue[key] : null, "function" === typeof prevValue && domElement.removeEventListener(tag, prevValue, props), "function" === typeof value)) {
              "function" !== typeof prevValue && null !== prevValue && (key in domElement ? domElement[key] = null : domElement.hasAttribute(key) && domElement.removeAttribute(key));
              domElement.addEventListener(tag, value, props);
              break a;
            }
            key in domElement ? domElement[key] = value : true === value ? domElement.setAttribute(key, "") : setValueForAttribute(domElement, key, value);
          }
    }
  }
  function setInitialProperties(domElement, tag, props) {
    switch (tag) {
      case "div":
      case "span":
      case "svg":
      case "path":
      case "a":
      case "g":
      case "p":
      case "li":
        break;
      case "img":
        listenToNonDelegatedEvent("error", domElement);
        listenToNonDelegatedEvent("load", domElement);
        var hasSrc = false, hasSrcSet = false, propKey;
        for (propKey in props)
          if (props.hasOwnProperty(propKey)) {
            var propValue = props[propKey];
            if (null != propValue)
              switch (propKey) {
                case "src":
                  hasSrc = true;
                  break;
                case "srcSet":
                  hasSrcSet = true;
                  break;
                case "children":
                case "dangerouslySetInnerHTML":
                  throw Error(formatProdErrorMessage(137, tag));
                default:
                  setProp(domElement, tag, propKey, propValue, props, null);
              }
          }
        hasSrcSet && setProp(domElement, tag, "srcSet", props.srcSet, props, null);
        hasSrc && setProp(domElement, tag, "src", props.src, props, null);
        return;
      case "input":
        listenToNonDelegatedEvent("invalid", domElement);
        var defaultValue = propKey = propValue = hasSrcSet = null, checked = null, defaultChecked = null;
        for (hasSrc in props)
          if (props.hasOwnProperty(hasSrc)) {
            var propValue$184 = props[hasSrc];
            if (null != propValue$184)
              switch (hasSrc) {
                case "name":
                  hasSrcSet = propValue$184;
                  break;
                case "type":
                  propValue = propValue$184;
                  break;
                case "checked":
                  checked = propValue$184;
                  break;
                case "defaultChecked":
                  defaultChecked = propValue$184;
                  break;
                case "value":
                  propKey = propValue$184;
                  break;
                case "defaultValue":
                  defaultValue = propValue$184;
                  break;
                case "children":
                case "dangerouslySetInnerHTML":
                  if (null != propValue$184)
                    throw Error(formatProdErrorMessage(137, tag));
                  break;
                default:
                  setProp(domElement, tag, hasSrc, propValue$184, props, null);
              }
          }
        initInput(
          domElement,
          propKey,
          defaultValue,
          checked,
          defaultChecked,
          propValue,
          hasSrcSet,
          false
        );
        return;
      case "select":
        listenToNonDelegatedEvent("invalid", domElement);
        hasSrc = propValue = propKey = null;
        for (hasSrcSet in props)
          if (props.hasOwnProperty(hasSrcSet) && (defaultValue = props[hasSrcSet], null != defaultValue))
            switch (hasSrcSet) {
              case "value":
                propKey = defaultValue;
                break;
              case "defaultValue":
                propValue = defaultValue;
                break;
              case "multiple":
                hasSrc = defaultValue;
              default:
                setProp(domElement, tag, hasSrcSet, defaultValue, props, null);
            }
        tag = propKey;
        props = propValue;
        domElement.multiple = !!hasSrc;
        null != tag ? updateOptions(domElement, !!hasSrc, tag, false) : null != props && updateOptions(domElement, !!hasSrc, props, true);
        return;
      case "textarea":
        listenToNonDelegatedEvent("invalid", domElement);
        propKey = hasSrcSet = hasSrc = null;
        for (propValue in props)
          if (props.hasOwnProperty(propValue) && (defaultValue = props[propValue], null != defaultValue))
            switch (propValue) {
              case "value":
                hasSrc = defaultValue;
                break;
              case "defaultValue":
                hasSrcSet = defaultValue;
                break;
              case "children":
                propKey = defaultValue;
                break;
              case "dangerouslySetInnerHTML":
                if (null != defaultValue) throw Error(formatProdErrorMessage(91));
                break;
              default:
                setProp(domElement, tag, propValue, defaultValue, props, null);
            }
        initTextarea(domElement, hasSrc, hasSrcSet, propKey);
        return;
      case "option":
        for (checked in props)
          if (props.hasOwnProperty(checked) && (hasSrc = props[checked], null != hasSrc))
            switch (checked) {
              case "selected":
                domElement.selected = hasSrc && "function" !== typeof hasSrc && "symbol" !== typeof hasSrc;
                break;
              default:
                setProp(domElement, tag, checked, hasSrc, props, null);
            }
        return;
      case "dialog":
        listenToNonDelegatedEvent("beforetoggle", domElement);
        listenToNonDelegatedEvent("toggle", domElement);
        listenToNonDelegatedEvent("cancel", domElement);
        listenToNonDelegatedEvent("close", domElement);
        break;
      case "iframe":
      case "object":
        listenToNonDelegatedEvent("load", domElement);
        break;
      case "video":
      case "audio":
        for (hasSrc = 0; hasSrc < mediaEventTypes.length; hasSrc++)
          listenToNonDelegatedEvent(mediaEventTypes[hasSrc], domElement);
        break;
      case "image":
        listenToNonDelegatedEvent("error", domElement);
        listenToNonDelegatedEvent("load", domElement);
        break;
      case "details":
        listenToNonDelegatedEvent("toggle", domElement);
        break;
      case "embed":
      case "source":
      case "link":
        listenToNonDelegatedEvent("error", domElement), listenToNonDelegatedEvent("load", domElement);
      case "area":
      case "base":
      case "br":
      case "col":
      case "hr":
      case "keygen":
      case "meta":
      case "param":
      case "track":
      case "wbr":
      case "menuitem":
        for (defaultChecked in props)
          if (props.hasOwnProperty(defaultChecked) && (hasSrc = props[defaultChecked], null != hasSrc))
            switch (defaultChecked) {
              case "children":
              case "dangerouslySetInnerHTML":
                throw Error(formatProdErrorMessage(137, tag));
              default:
                setProp(domElement, tag, defaultChecked, hasSrc, props, null);
            }
        return;
      default:
        if (isCustomElement(tag)) {
          for (propValue$184 in props)
            props.hasOwnProperty(propValue$184) && (hasSrc = props[propValue$184], void 0 !== hasSrc && setPropOnCustomElement(
              domElement,
              tag,
              propValue$184,
              hasSrc,
              props,
              void 0
            ));
          return;
        }
    }
    for (defaultValue in props)
      props.hasOwnProperty(defaultValue) && (hasSrc = props[defaultValue], null != hasSrc && setProp(domElement, tag, defaultValue, hasSrc, props, null));
  }
  function updateProperties(domElement, tag, lastProps, nextProps) {
    switch (tag) {
      case "div":
      case "span":
      case "svg":
      case "path":
      case "a":
      case "g":
      case "p":
      case "li":
        break;
      case "input":
        var name = null, type = null, value = null, defaultValue = null, lastDefaultValue = null, checked = null, defaultChecked = null;
        for (propKey in lastProps) {
          var lastProp = lastProps[propKey];
          if (lastProps.hasOwnProperty(propKey) && null != lastProp)
            switch (propKey) {
              case "checked":
                break;
              case "value":
                break;
              case "defaultValue":
                lastDefaultValue = lastProp;
              default:
                nextProps.hasOwnProperty(propKey) || setProp(domElement, tag, propKey, null, nextProps, lastProp);
            }
        }
        for (var propKey$201 in nextProps) {
          var propKey = nextProps[propKey$201];
          lastProp = lastProps[propKey$201];
          if (nextProps.hasOwnProperty(propKey$201) && (null != propKey || null != lastProp))
            switch (propKey$201) {
              case "type":
                type = propKey;
                break;
              case "name":
                name = propKey;
                break;
              case "checked":
                checked = propKey;
                break;
              case "defaultChecked":
                defaultChecked = propKey;
                break;
              case "value":
                value = propKey;
                break;
              case "defaultValue":
                defaultValue = propKey;
                break;
              case "children":
              case "dangerouslySetInnerHTML":
                if (null != propKey)
                  throw Error(formatProdErrorMessage(137, tag));
                break;
              default:
                propKey !== lastProp && setProp(
                  domElement,
                  tag,
                  propKey$201,
                  propKey,
                  nextProps,
                  lastProp
                );
            }
        }
        updateInput(
          domElement,
          value,
          defaultValue,
          lastDefaultValue,
          checked,
          defaultChecked,
          type,
          name
        );
        return;
      case "select":
        propKey = value = defaultValue = propKey$201 = null;
        for (type in lastProps)
          if (lastDefaultValue = lastProps[type], lastProps.hasOwnProperty(type) && null != lastDefaultValue)
            switch (type) {
              case "value":
                break;
              case "multiple":
                propKey = lastDefaultValue;
              default:
                nextProps.hasOwnProperty(type) || setProp(
                  domElement,
                  tag,
                  type,
                  null,
                  nextProps,
                  lastDefaultValue
                );
            }
        for (name in nextProps)
          if (type = nextProps[name], lastDefaultValue = lastProps[name], nextProps.hasOwnProperty(name) && (null != type || null != lastDefaultValue))
            switch (name) {
              case "value":
                propKey$201 = type;
                break;
              case "defaultValue":
                defaultValue = type;
                break;
              case "multiple":
                value = type;
              default:
                type !== lastDefaultValue && setProp(
                  domElement,
                  tag,
                  name,
                  type,
                  nextProps,
                  lastDefaultValue
                );
            }
        tag = defaultValue;
        lastProps = value;
        nextProps = propKey;
        null != propKey$201 ? updateOptions(domElement, !!lastProps, propKey$201, false) : !!nextProps !== !!lastProps && (null != tag ? updateOptions(domElement, !!lastProps, tag, true) : updateOptions(domElement, !!lastProps, lastProps ? [] : "", false));
        return;
      case "textarea":
        propKey = propKey$201 = null;
        for (defaultValue in lastProps)
          if (name = lastProps[defaultValue], lastProps.hasOwnProperty(defaultValue) && null != name && !nextProps.hasOwnProperty(defaultValue))
            switch (defaultValue) {
              case "value":
                break;
              case "children":
                break;
              default:
                setProp(domElement, tag, defaultValue, null, nextProps, name);
            }
        for (value in nextProps)
          if (name = nextProps[value], type = lastProps[value], nextProps.hasOwnProperty(value) && (null != name || null != type))
            switch (value) {
              case "value":
                propKey$201 = name;
                break;
              case "defaultValue":
                propKey = name;
                break;
              case "children":
                break;
              case "dangerouslySetInnerHTML":
                if (null != name) throw Error(formatProdErrorMessage(91));
                break;
              default:
                name !== type && setProp(domElement, tag, value, name, nextProps, type);
            }
        updateTextarea(domElement, propKey$201, propKey);
        return;
      case "option":
        for (var propKey$217 in lastProps)
          if (propKey$201 = lastProps[propKey$217], lastProps.hasOwnProperty(propKey$217) && null != propKey$201 && !nextProps.hasOwnProperty(propKey$217))
            switch (propKey$217) {
              case "selected":
                domElement.selected = false;
                break;
              default:
                setProp(
                  domElement,
                  tag,
                  propKey$217,
                  null,
                  nextProps,
                  propKey$201
                );
            }
        for (lastDefaultValue in nextProps)
          if (propKey$201 = nextProps[lastDefaultValue], propKey = lastProps[lastDefaultValue], nextProps.hasOwnProperty(lastDefaultValue) && propKey$201 !== propKey && (null != propKey$201 || null != propKey))
            switch (lastDefaultValue) {
              case "selected":
                domElement.selected = propKey$201 && "function" !== typeof propKey$201 && "symbol" !== typeof propKey$201;
                break;
              default:
                setProp(
                  domElement,
                  tag,
                  lastDefaultValue,
                  propKey$201,
                  nextProps,
                  propKey
                );
            }
        return;
      case "img":
      case "link":
      case "area":
      case "base":
      case "br":
      case "col":
      case "embed":
      case "hr":
      case "keygen":
      case "meta":
      case "param":
      case "source":
      case "track":
      case "wbr":
      case "menuitem":
        for (var propKey$222 in lastProps)
          propKey$201 = lastProps[propKey$222], lastProps.hasOwnProperty(propKey$222) && null != propKey$201 && !nextProps.hasOwnProperty(propKey$222) && setProp(domElement, tag, propKey$222, null, nextProps, propKey$201);
        for (checked in nextProps)
          if (propKey$201 = nextProps[checked], propKey = lastProps[checked], nextProps.hasOwnProperty(checked) && propKey$201 !== propKey && (null != propKey$201 || null != propKey))
            switch (checked) {
              case "children":
              case "dangerouslySetInnerHTML":
                if (null != propKey$201)
                  throw Error(formatProdErrorMessage(137, tag));
                break;
              default:
                setProp(
                  domElement,
                  tag,
                  checked,
                  propKey$201,
                  nextProps,
                  propKey
                );
            }
        return;
      default:
        if (isCustomElement(tag)) {
          for (var propKey$227 in lastProps)
            propKey$201 = lastProps[propKey$227], lastProps.hasOwnProperty(propKey$227) && void 0 !== propKey$201 && !nextProps.hasOwnProperty(propKey$227) && setPropOnCustomElement(
              domElement,
              tag,
              propKey$227,
              void 0,
              nextProps,
              propKey$201
            );
          for (defaultChecked in nextProps)
            propKey$201 = nextProps[defaultChecked], propKey = lastProps[defaultChecked], !nextProps.hasOwnProperty(defaultChecked) || propKey$201 === propKey || void 0 === propKey$201 && void 0 === propKey || setPropOnCustomElement(
              domElement,
              tag,
              defaultChecked,
              propKey$201,
              nextProps,
              propKey
            );
          return;
        }
    }
    for (var propKey$232 in lastProps)
      propKey$201 = lastProps[propKey$232], lastProps.hasOwnProperty(propKey$232) && null != propKey$201 && !nextProps.hasOwnProperty(propKey$232) && setProp(domElement, tag, propKey$232, null, nextProps, propKey$201);
    for (lastProp in nextProps)
      propKey$201 = nextProps[lastProp], propKey = lastProps[lastProp], !nextProps.hasOwnProperty(lastProp) || propKey$201 === propKey || null == propKey$201 && null == propKey || setProp(domElement, tag, lastProp, propKey$201, nextProps, propKey);
  }
  function isLikelyStaticResource(initiatorType) {
    switch (initiatorType) {
      case "css":
      case "script":
      case "font":
      case "img":
      case "image":
      case "input":
      case "link":
        return true;
      default:
        return false;
    }
  }
  function estimateBandwidth() {
    if ("function" === typeof performance.getEntriesByType) {
      for (var count2 = 0, bits = 0, resourceEntries = performance.getEntriesByType("resource"), i3 = 0; i3 < resourceEntries.length; i3++) {
        var entry = resourceEntries[i3], transferSize = entry.transferSize, initiatorType = entry.initiatorType, duration = entry.duration;
        if (transferSize && duration && isLikelyStaticResource(initiatorType)) {
          initiatorType = 0;
          duration = entry.responseEnd;
          for (i3 += 1; i3 < resourceEntries.length; i3++) {
            var overlapEntry = resourceEntries[i3], overlapStartTime = overlapEntry.startTime;
            if (overlapStartTime > duration) break;
            var overlapTransferSize = overlapEntry.transferSize, overlapInitiatorType = overlapEntry.initiatorType;
            overlapTransferSize && isLikelyStaticResource(overlapInitiatorType) && (overlapEntry = overlapEntry.responseEnd, initiatorType += overlapTransferSize * (overlapEntry < duration ? 1 : (duration - overlapStartTime) / (overlapEntry - overlapStartTime)));
          }
          --i3;
          bits += 8 * (transferSize + initiatorType) / (entry.duration / 1e3);
          count2++;
          if (10 < count2) break;
        }
      }
      if (0 < count2) return bits / count2 / 1e6;
    }
    return navigator.connection && (count2 = navigator.connection.downlink, "number" === typeof count2) ? count2 : 5;
  }
  var eventsEnabled = null, selectionInformation = null;
  function getOwnerDocumentFromRootContainer(rootContainerElement) {
    return 9 === rootContainerElement.nodeType ? rootContainerElement : rootContainerElement.ownerDocument;
  }
  function getOwnHostContext(namespaceURI) {
    switch (namespaceURI) {
      case "http://www.w3.org/2000/svg":
        return 1;
      case "http://www.w3.org/1998/Math/MathML":
        return 2;
      default:
        return 0;
    }
  }
  function getChildHostContextProd(parentNamespace, type) {
    if (0 === parentNamespace)
      switch (type) {
        case "svg":
          return 1;
        case "math":
          return 2;
        default:
          return 0;
      }
    return 1 === parentNamespace && "foreignObject" === type ? 0 : parentNamespace;
  }
  function shouldSetTextContent(type, props) {
    return "textarea" === type || "noscript" === type || "string" === typeof props.children || "number" === typeof props.children || "bigint" === typeof props.children || "object" === typeof props.dangerouslySetInnerHTML && null !== props.dangerouslySetInnerHTML && null != props.dangerouslySetInnerHTML.__html;
  }
  var currentPopstateTransitionEvent = null;
  function shouldAttemptEagerTransition() {
    var event = window.event;
    if (event && "popstate" === event.type) {
      if (event === currentPopstateTransitionEvent) return false;
      currentPopstateTransitionEvent = event;
      return true;
    }
    currentPopstateTransitionEvent = null;
    return false;
  }
  var scheduleTimeout = "function" === typeof setTimeout ? setTimeout : void 0, cancelTimeout = "function" === typeof clearTimeout ? clearTimeout : void 0, localPromise = "function" === typeof Promise ? Promise : void 0, scheduleMicrotask = "function" === typeof queueMicrotask ? queueMicrotask : "undefined" !== typeof localPromise ? function(callback) {
    return localPromise.resolve(null).then(callback).catch(handleErrorInNextTick);
  } : scheduleTimeout;
  function handleErrorInNextTick(error) {
    setTimeout(function() {
      throw error;
    });
  }
  function isSingletonScope(type) {
    return "head" === type;
  }
  function clearHydrationBoundary(parentInstance, hydrationInstance) {
    var node = hydrationInstance, depth = 0;
    do {
      var nextNode = node.nextSibling;
      parentInstance.removeChild(node);
      if (nextNode && 8 === nextNode.nodeType)
        if (node = nextNode.data, "/$" === node || "/&" === node) {
          if (0 === depth) {
            parentInstance.removeChild(nextNode);
            retryIfBlockedOn(hydrationInstance);
            return;
          }
          depth--;
        } else if ("$" === node || "$?" === node || "$~" === node || "$!" === node || "&" === node)
          depth++;
        else if ("html" === node)
          releaseSingletonInstance(parentInstance.ownerDocument.documentElement);
        else if ("head" === node) {
          node = parentInstance.ownerDocument.head;
          releaseSingletonInstance(node);
          for (var node$jscomp$0 = node.firstChild; node$jscomp$0; ) {
            var nextNode$jscomp$0 = node$jscomp$0.nextSibling, nodeName = node$jscomp$0.nodeName;
            node$jscomp$0[internalHoistableMarker] || "SCRIPT" === nodeName || "STYLE" === nodeName || "LINK" === nodeName && "stylesheet" === node$jscomp$0.rel.toLowerCase() || node.removeChild(node$jscomp$0);
            node$jscomp$0 = nextNode$jscomp$0;
          }
        } else
          "body" === node && releaseSingletonInstance(parentInstance.ownerDocument.body);
      node = nextNode;
    } while (node);
    retryIfBlockedOn(hydrationInstance);
  }
  function hideOrUnhideDehydratedBoundary(suspenseInstance, isHidden2) {
    var node = suspenseInstance;
    suspenseInstance = 0;
    do {
      var nextNode = node.nextSibling;
      1 === node.nodeType ? isHidden2 ? (node._stashedDisplay = node.style.display, node.style.display = "none") : (node.style.display = node._stashedDisplay || "", "" === node.getAttribute("style") && node.removeAttribute("style")) : 3 === node.nodeType && (isHidden2 ? (node._stashedText = node.nodeValue, node.nodeValue = "") : node.nodeValue = node._stashedText || "");
      if (nextNode && 8 === nextNode.nodeType)
        if (node = nextNode.data, "/$" === node)
          if (0 === suspenseInstance) break;
          else suspenseInstance--;
        else
          "$" !== node && "$?" !== node && "$~" !== node && "$!" !== node || suspenseInstance++;
      node = nextNode;
    } while (node);
  }
  function clearContainerSparingly(container) {
    var nextNode = container.firstChild;
    nextNode && 10 === nextNode.nodeType && (nextNode = nextNode.nextSibling);
    for (; nextNode; ) {
      var node = nextNode;
      nextNode = nextNode.nextSibling;
      switch (node.nodeName) {
        case "HTML":
        case "HEAD":
        case "BODY":
          clearContainerSparingly(node);
          detachDeletedInstance(node);
          continue;
        case "SCRIPT":
        case "STYLE":
          continue;
        case "LINK":
          if ("stylesheet" === node.rel.toLowerCase()) continue;
      }
      container.removeChild(node);
    }
  }
  function canHydrateInstance(instance, type, props, inRootOrSingleton) {
    for (; 1 === instance.nodeType; ) {
      var anyProps = props;
      if (instance.nodeName.toLowerCase() !== type.toLowerCase()) {
        if (!inRootOrSingleton && ("INPUT" !== instance.nodeName || "hidden" !== instance.type))
          break;
      } else if (!inRootOrSingleton)
        if ("input" === type && "hidden" === instance.type) {
          var name = null == anyProps.name ? null : "" + anyProps.name;
          if ("hidden" === anyProps.type && instance.getAttribute("name") === name)
            return instance;
        } else return instance;
      else if (!instance[internalHoistableMarker])
        switch (type) {
          case "meta":
            if (!instance.hasAttribute("itemprop")) break;
            return instance;
          case "link":
            name = instance.getAttribute("rel");
            if ("stylesheet" === name && instance.hasAttribute("data-precedence"))
              break;
            else if (name !== anyProps.rel || instance.getAttribute("href") !== (null == anyProps.href || "" === anyProps.href ? null : anyProps.href) || instance.getAttribute("crossorigin") !== (null == anyProps.crossOrigin ? null : anyProps.crossOrigin) || instance.getAttribute("title") !== (null == anyProps.title ? null : anyProps.title))
              break;
            return instance;
          case "style":
            if (instance.hasAttribute("data-precedence")) break;
            return instance;
          case "script":
            name = instance.getAttribute("src");
            if ((name !== (null == anyProps.src ? null : anyProps.src) || instance.getAttribute("type") !== (null == anyProps.type ? null : anyProps.type) || instance.getAttribute("crossorigin") !== (null == anyProps.crossOrigin ? null : anyProps.crossOrigin)) && name && instance.hasAttribute("async") && !instance.hasAttribute("itemprop"))
              break;
            return instance;
          default:
            return instance;
        }
      instance = getNextHydratable(instance.nextSibling);
      if (null === instance) break;
    }
    return null;
  }
  function canHydrateTextInstance(instance, text, inRootOrSingleton) {
    if ("" === text) return null;
    for (; 3 !== instance.nodeType; ) {
      if ((1 !== instance.nodeType || "INPUT" !== instance.nodeName || "hidden" !== instance.type) && !inRootOrSingleton)
        return null;
      instance = getNextHydratable(instance.nextSibling);
      if (null === instance) return null;
    }
    return instance;
  }
  function canHydrateHydrationBoundary(instance, inRootOrSingleton) {
    for (; 8 !== instance.nodeType; ) {
      if ((1 !== instance.nodeType || "INPUT" !== instance.nodeName || "hidden" !== instance.type) && !inRootOrSingleton)
        return null;
      instance = getNextHydratable(instance.nextSibling);
      if (null === instance) return null;
    }
    return instance;
  }
  function isSuspenseInstancePending(instance) {
    return "$?" === instance.data || "$~" === instance.data;
  }
  function isSuspenseInstanceFallback(instance) {
    return "$!" === instance.data || "$?" === instance.data && "loading" !== instance.ownerDocument.readyState;
  }
  function registerSuspenseInstanceRetry(instance, callback) {
    var ownerDocument = instance.ownerDocument;
    if ("$~" === instance.data) instance._reactRetry = callback;
    else if ("$?" !== instance.data || "loading" !== ownerDocument.readyState)
      callback();
    else {
      var listener = function() {
        callback();
        ownerDocument.removeEventListener("DOMContentLoaded", listener);
      };
      ownerDocument.addEventListener("DOMContentLoaded", listener);
      instance._reactRetry = listener;
    }
  }
  function getNextHydratable(node) {
    for (; null != node; node = node.nextSibling) {
      var nodeType = node.nodeType;
      if (1 === nodeType || 3 === nodeType) break;
      if (8 === nodeType) {
        nodeType = node.data;
        if ("$" === nodeType || "$!" === nodeType || "$?" === nodeType || "$~" === nodeType || "&" === nodeType || "F!" === nodeType || "F" === nodeType)
          break;
        if ("/$" === nodeType || "/&" === nodeType) return null;
      }
    }
    return node;
  }
  var previousHydratableOnEnteringScopedSingleton = null;
  function getNextHydratableInstanceAfterHydrationBoundary(hydrationInstance) {
    hydrationInstance = hydrationInstance.nextSibling;
    for (var depth = 0; hydrationInstance; ) {
      if (8 === hydrationInstance.nodeType) {
        var data = hydrationInstance.data;
        if ("/$" === data || "/&" === data) {
          if (0 === depth)
            return getNextHydratable(hydrationInstance.nextSibling);
          depth--;
        } else
          "$" !== data && "$!" !== data && "$?" !== data && "$~" !== data && "&" !== data || depth++;
      }
      hydrationInstance = hydrationInstance.nextSibling;
    }
    return null;
  }
  function getParentHydrationBoundary(targetInstance) {
    targetInstance = targetInstance.previousSibling;
    for (var depth = 0; targetInstance; ) {
      if (8 === targetInstance.nodeType) {
        var data = targetInstance.data;
        if ("$" === data || "$!" === data || "$?" === data || "$~" === data || "&" === data) {
          if (0 === depth) return targetInstance;
          depth--;
        } else "/$" !== data && "/&" !== data || depth++;
      }
      targetInstance = targetInstance.previousSibling;
    }
    return null;
  }
  function resolveSingletonInstance(type, props, rootContainerInstance) {
    props = getOwnerDocumentFromRootContainer(rootContainerInstance);
    switch (type) {
      case "html":
        type = props.documentElement;
        if (!type) throw Error(formatProdErrorMessage(452));
        return type;
      case "head":
        type = props.head;
        if (!type) throw Error(formatProdErrorMessage(453));
        return type;
      case "body":
        type = props.body;
        if (!type) throw Error(formatProdErrorMessage(454));
        return type;
      default:
        throw Error(formatProdErrorMessage(451));
    }
  }
  function releaseSingletonInstance(instance) {
    for (var attributes = instance.attributes; attributes.length; )
      instance.removeAttributeNode(attributes[0]);
    detachDeletedInstance(instance);
  }
  var preloadPropsMap = /* @__PURE__ */ new Map(), preconnectsSet = /* @__PURE__ */ new Set();
  function getHoistableRoot(container) {
    return "function" === typeof container.getRootNode ? container.getRootNode() : 9 === container.nodeType ? container : container.ownerDocument;
  }
  var previousDispatcher = ReactDOMSharedInternals.d;
  ReactDOMSharedInternals.d = {
    f: flushSyncWork,
    r: requestFormReset,
    D: prefetchDNS,
    C: preconnect,
    L: preload2,
    m: preloadModule,
    X: preinitScript,
    S: preinitStyle,
    M: preinitModuleScript
  };
  function flushSyncWork() {
    var previousWasRendering = previousDispatcher.f(), wasRendering = flushSyncWork$1();
    return previousWasRendering || wasRendering;
  }
  function requestFormReset(form) {
    var formInst = getInstanceFromNode(form);
    null !== formInst && 5 === formInst.tag && "form" === formInst.type ? requestFormReset$1(formInst) : previousDispatcher.r(form);
  }
  var globalDocument = "undefined" === typeof document ? null : document;
  function preconnectAs(rel, href, crossOrigin) {
    var ownerDocument = globalDocument;
    if (ownerDocument && "string" === typeof href && href) {
      var limitedEscapedHref = escapeSelectorAttributeValueInsideDoubleQuotes(href);
      limitedEscapedHref = 'link[rel="' + rel + '"][href="' + limitedEscapedHref + '"]';
      "string" === typeof crossOrigin && (limitedEscapedHref += '[crossorigin="' + crossOrigin + '"]');
      preconnectsSet.has(limitedEscapedHref) || (preconnectsSet.add(limitedEscapedHref), rel = { rel, crossOrigin, href }, null === ownerDocument.querySelector(limitedEscapedHref) && (href = ownerDocument.createElement("link"), setInitialProperties(href, "link", rel), markNodeAsHoistable(href), ownerDocument.head.appendChild(href)));
    }
  }
  function prefetchDNS(href) {
    previousDispatcher.D(href);
    preconnectAs("dns-prefetch", href, null);
  }
  function preconnect(href, crossOrigin) {
    previousDispatcher.C(href, crossOrigin);
    preconnectAs("preconnect", href, crossOrigin);
  }
  function preload2(href, as2, options2) {
    previousDispatcher.L(href, as2, options2);
    var ownerDocument = globalDocument;
    if (ownerDocument && href && as2) {
      var preloadSelector = 'link[rel="preload"][as="' + escapeSelectorAttributeValueInsideDoubleQuotes(as2) + '"]';
      "image" === as2 ? options2 && options2.imageSrcSet ? (preloadSelector += '[imagesrcset="' + escapeSelectorAttributeValueInsideDoubleQuotes(
        options2.imageSrcSet
      ) + '"]', "string" === typeof options2.imageSizes && (preloadSelector += '[imagesizes="' + escapeSelectorAttributeValueInsideDoubleQuotes(
        options2.imageSizes
      ) + '"]')) : preloadSelector += '[href="' + escapeSelectorAttributeValueInsideDoubleQuotes(href) + '"]' : preloadSelector += '[href="' + escapeSelectorAttributeValueInsideDoubleQuotes(href) + '"]';
      var key = preloadSelector;
      switch (as2) {
        case "style":
          key = getStyleKey(href);
          break;
        case "script":
          key = getScriptKey(href);
      }
      preloadPropsMap.has(key) || (href = assign2(
        {
          rel: "preload",
          href: "image" === as2 && options2 && options2.imageSrcSet ? void 0 : href,
          as: as2
        },
        options2
      ), preloadPropsMap.set(key, href), null !== ownerDocument.querySelector(preloadSelector) || "style" === as2 && ownerDocument.querySelector(getStylesheetSelectorFromKey(key)) || "script" === as2 && ownerDocument.querySelector(getScriptSelectorFromKey(key)) || (as2 = ownerDocument.createElement("link"), setInitialProperties(as2, "link", href), markNodeAsHoistable(as2), ownerDocument.head.appendChild(as2)));
    }
  }
  function preloadModule(href, options2) {
    previousDispatcher.m(href, options2);
    var ownerDocument = globalDocument;
    if (ownerDocument && href) {
      var as2 = options2 && "string" === typeof options2.as ? options2.as : "script", preloadSelector = 'link[rel="modulepreload"][as="' + escapeSelectorAttributeValueInsideDoubleQuotes(as2) + '"][href="' + escapeSelectorAttributeValueInsideDoubleQuotes(href) + '"]', key = preloadSelector;
      switch (as2) {
        case "audioworklet":
        case "paintworklet":
        case "serviceworker":
        case "sharedworker":
        case "worker":
        case "script":
          key = getScriptKey(href);
      }
      if (!preloadPropsMap.has(key) && (href = assign2({ rel: "modulepreload", href }, options2), preloadPropsMap.set(key, href), null === ownerDocument.querySelector(preloadSelector))) {
        switch (as2) {
          case "audioworklet":
          case "paintworklet":
          case "serviceworker":
          case "sharedworker":
          case "worker":
          case "script":
            if (ownerDocument.querySelector(getScriptSelectorFromKey(key)))
              return;
        }
        as2 = ownerDocument.createElement("link");
        setInitialProperties(as2, "link", href);
        markNodeAsHoistable(as2);
        ownerDocument.head.appendChild(as2);
      }
    }
  }
  function preinitStyle(href, precedence, options2) {
    previousDispatcher.S(href, precedence, options2);
    var ownerDocument = globalDocument;
    if (ownerDocument && href) {
      var styles = getResourcesFromRoot(ownerDocument).hoistableStyles, key = getStyleKey(href);
      precedence = precedence || "default";
      var resource = styles.get(key);
      if (!resource) {
        var state = { loading: 0, preload: null };
        if (resource = ownerDocument.querySelector(
          getStylesheetSelectorFromKey(key)
        ))
          state.loading = 5;
        else {
          href = assign2(
            { rel: "stylesheet", href, "data-precedence": precedence },
            options2
          );
          (options2 = preloadPropsMap.get(key)) && adoptPreloadPropsForStylesheet(href, options2);
          var link = resource = ownerDocument.createElement("link");
          markNodeAsHoistable(link);
          setInitialProperties(link, "link", href);
          link._p = new Promise(function(resolve, reject) {
            link.onload = resolve;
            link.onerror = reject;
          });
          link.addEventListener("load", function() {
            state.loading |= 1;
          });
          link.addEventListener("error", function() {
            state.loading |= 2;
          });
          state.loading |= 4;
          insertStylesheet(resource, precedence, ownerDocument);
        }
        resource = {
          type: "stylesheet",
          instance: resource,
          count: 1,
          state
        };
        styles.set(key, resource);
      }
    }
  }
  function preinitScript(src, options2) {
    previousDispatcher.X(src, options2);
    var ownerDocument = globalDocument;
    if (ownerDocument && src) {
      var scripts = getResourcesFromRoot(ownerDocument).hoistableScripts, key = getScriptKey(src), resource = scripts.get(key);
      resource || (resource = ownerDocument.querySelector(getScriptSelectorFromKey(key)), resource || (src = assign2({ src, async: true }, options2), (options2 = preloadPropsMap.get(key)) && adoptPreloadPropsForScript(src, options2), resource = ownerDocument.createElement("script"), markNodeAsHoistable(resource), setInitialProperties(resource, "link", src), ownerDocument.head.appendChild(resource)), resource = {
        type: "script",
        instance: resource,
        count: 1,
        state: null
      }, scripts.set(key, resource));
    }
  }
  function preinitModuleScript(src, options2) {
    previousDispatcher.M(src, options2);
    var ownerDocument = globalDocument;
    if (ownerDocument && src) {
      var scripts = getResourcesFromRoot(ownerDocument).hoistableScripts, key = getScriptKey(src), resource = scripts.get(key);
      resource || (resource = ownerDocument.querySelector(getScriptSelectorFromKey(key)), resource || (src = assign2({ src, async: true, type: "module" }, options2), (options2 = preloadPropsMap.get(key)) && adoptPreloadPropsForScript(src, options2), resource = ownerDocument.createElement("script"), markNodeAsHoistable(resource), setInitialProperties(resource, "link", src), ownerDocument.head.appendChild(resource)), resource = {
        type: "script",
        instance: resource,
        count: 1,
        state: null
      }, scripts.set(key, resource));
    }
  }
  function getResource(type, currentProps, pendingProps, currentResource) {
    var JSCompiler_inline_result = (JSCompiler_inline_result = rootInstanceStackCursor.current) ? getHoistableRoot(JSCompiler_inline_result) : null;
    if (!JSCompiler_inline_result) throw Error(formatProdErrorMessage(446));
    switch (type) {
      case "meta":
      case "title":
        return null;
      case "style":
        return "string" === typeof pendingProps.precedence && "string" === typeof pendingProps.href ? (currentProps = getStyleKey(pendingProps.href), pendingProps = getResourcesFromRoot(
          JSCompiler_inline_result
        ).hoistableStyles, currentResource = pendingProps.get(currentProps), currentResource || (currentResource = {
          type: "style",
          instance: null,
          count: 0,
          state: null
        }, pendingProps.set(currentProps, currentResource)), currentResource) : { type: "void", instance: null, count: 0, state: null };
      case "link":
        if ("stylesheet" === pendingProps.rel && "string" === typeof pendingProps.href && "string" === typeof pendingProps.precedence) {
          type = getStyleKey(pendingProps.href);
          var styles$243 = getResourcesFromRoot(
            JSCompiler_inline_result
          ).hoistableStyles, resource$244 = styles$243.get(type);
          resource$244 || (JSCompiler_inline_result = JSCompiler_inline_result.ownerDocument || JSCompiler_inline_result, resource$244 = {
            type: "stylesheet",
            instance: null,
            count: 0,
            state: { loading: 0, preload: null }
          }, styles$243.set(type, resource$244), (styles$243 = JSCompiler_inline_result.querySelector(
            getStylesheetSelectorFromKey(type)
          )) && !styles$243._p && (resource$244.instance = styles$243, resource$244.state.loading = 5), preloadPropsMap.has(type) || (pendingProps = {
            rel: "preload",
            as: "style",
            href: pendingProps.href,
            crossOrigin: pendingProps.crossOrigin,
            integrity: pendingProps.integrity,
            media: pendingProps.media,
            hrefLang: pendingProps.hrefLang,
            referrerPolicy: pendingProps.referrerPolicy
          }, preloadPropsMap.set(type, pendingProps), styles$243 || preloadStylesheet(
            JSCompiler_inline_result,
            type,
            pendingProps,
            resource$244.state
          )));
          if (currentProps && null === currentResource)
            throw Error(formatProdErrorMessage(528, ""));
          return resource$244;
        }
        if (currentProps && null !== currentResource)
          throw Error(formatProdErrorMessage(529, ""));
        return null;
      case "script":
        return currentProps = pendingProps.async, pendingProps = pendingProps.src, "string" === typeof pendingProps && currentProps && "function" !== typeof currentProps && "symbol" !== typeof currentProps ? (currentProps = getScriptKey(pendingProps), pendingProps = getResourcesFromRoot(
          JSCompiler_inline_result
        ).hoistableScripts, currentResource = pendingProps.get(currentProps), currentResource || (currentResource = {
          type: "script",
          instance: null,
          count: 0,
          state: null
        }, pendingProps.set(currentProps, currentResource)), currentResource) : { type: "void", instance: null, count: 0, state: null };
      default:
        throw Error(formatProdErrorMessage(444, type));
    }
  }
  function getStyleKey(href) {
    return 'href="' + escapeSelectorAttributeValueInsideDoubleQuotes(href) + '"';
  }
  function getStylesheetSelectorFromKey(key) {
    return 'link[rel="stylesheet"][' + key + "]";
  }
  function stylesheetPropsFromRawProps(rawProps) {
    return assign2({}, rawProps, {
      "data-precedence": rawProps.precedence,
      precedence: null
    });
  }
  function preloadStylesheet(ownerDocument, key, preloadProps, state) {
    ownerDocument.querySelector('link[rel="preload"][as="style"][' + key + "]") ? state.loading = 1 : (key = ownerDocument.createElement("link"), state.preload = key, key.addEventListener("load", function() {
      return state.loading |= 1;
    }), key.addEventListener("error", function() {
      return state.loading |= 2;
    }), setInitialProperties(key, "link", preloadProps), markNodeAsHoistable(key), ownerDocument.head.appendChild(key));
  }
  function getScriptKey(src) {
    return '[src="' + escapeSelectorAttributeValueInsideDoubleQuotes(src) + '"]';
  }
  function getScriptSelectorFromKey(key) {
    return "script[async]" + key;
  }
  function acquireResource(hoistableRoot, resource, props) {
    resource.count++;
    if (null === resource.instance)
      switch (resource.type) {
        case "style":
          var instance = hoistableRoot.querySelector(
            'style[data-href~="' + escapeSelectorAttributeValueInsideDoubleQuotes(props.href) + '"]'
          );
          if (instance)
            return resource.instance = instance, markNodeAsHoistable(instance), instance;
          var styleProps = assign2({}, props, {
            "data-href": props.href,
            "data-precedence": props.precedence,
            href: null,
            precedence: null
          });
          instance = (hoistableRoot.ownerDocument || hoistableRoot).createElement(
            "style"
          );
          markNodeAsHoistable(instance);
          setInitialProperties(instance, "style", styleProps);
          insertStylesheet(instance, props.precedence, hoistableRoot);
          return resource.instance = instance;
        case "stylesheet":
          styleProps = getStyleKey(props.href);
          var instance$249 = hoistableRoot.querySelector(
            getStylesheetSelectorFromKey(styleProps)
          );
          if (instance$249)
            return resource.state.loading |= 4, resource.instance = instance$249, markNodeAsHoistable(instance$249), instance$249;
          instance = stylesheetPropsFromRawProps(props);
          (styleProps = preloadPropsMap.get(styleProps)) && adoptPreloadPropsForStylesheet(instance, styleProps);
          instance$249 = (hoistableRoot.ownerDocument || hoistableRoot).createElement("link");
          markNodeAsHoistable(instance$249);
          var linkInstance = instance$249;
          linkInstance._p = new Promise(function(resolve, reject) {
            linkInstance.onload = resolve;
            linkInstance.onerror = reject;
          });
          setInitialProperties(instance$249, "link", instance);
          resource.state.loading |= 4;
          insertStylesheet(instance$249, props.precedence, hoistableRoot);
          return resource.instance = instance$249;
        case "script":
          instance$249 = getScriptKey(props.src);
          if (styleProps = hoistableRoot.querySelector(
            getScriptSelectorFromKey(instance$249)
          ))
            return resource.instance = styleProps, markNodeAsHoistable(styleProps), styleProps;
          instance = props;
          if (styleProps = preloadPropsMap.get(instance$249))
            instance = assign2({}, props), adoptPreloadPropsForScript(instance, styleProps);
          hoistableRoot = hoistableRoot.ownerDocument || hoistableRoot;
          styleProps = hoistableRoot.createElement("script");
          markNodeAsHoistable(styleProps);
          setInitialProperties(styleProps, "link", instance);
          hoistableRoot.head.appendChild(styleProps);
          return resource.instance = styleProps;
        case "void":
          return null;
        default:
          throw Error(formatProdErrorMessage(443, resource.type));
      }
    else
      "stylesheet" === resource.type && 0 === (resource.state.loading & 4) && (instance = resource.instance, resource.state.loading |= 4, insertStylesheet(instance, props.precedence, hoistableRoot));
    return resource.instance;
  }
  function insertStylesheet(instance, precedence, root2) {
    for (var nodes = root2.querySelectorAll(
      'link[rel="stylesheet"][data-precedence],style[data-precedence]'
    ), last = nodes.length ? nodes[nodes.length - 1] : null, prior = last, i3 = 0; i3 < nodes.length; i3++) {
      var node = nodes[i3];
      if (node.dataset.precedence === precedence) prior = node;
      else if (prior !== last) break;
    }
    prior ? prior.parentNode.insertBefore(instance, prior.nextSibling) : (precedence = 9 === root2.nodeType ? root2.head : root2, precedence.insertBefore(instance, precedence.firstChild));
  }
  function adoptPreloadPropsForStylesheet(stylesheetProps, preloadProps) {
    null == stylesheetProps.crossOrigin && (stylesheetProps.crossOrigin = preloadProps.crossOrigin);
    null == stylesheetProps.referrerPolicy && (stylesheetProps.referrerPolicy = preloadProps.referrerPolicy);
    null == stylesheetProps.title && (stylesheetProps.title = preloadProps.title);
  }
  function adoptPreloadPropsForScript(scriptProps, preloadProps) {
    null == scriptProps.crossOrigin && (scriptProps.crossOrigin = preloadProps.crossOrigin);
    null == scriptProps.referrerPolicy && (scriptProps.referrerPolicy = preloadProps.referrerPolicy);
    null == scriptProps.integrity && (scriptProps.integrity = preloadProps.integrity);
  }
  var tagCaches = null;
  function getHydratableHoistableCache(type, keyAttribute, ownerDocument) {
    if (null === tagCaches) {
      var cache = /* @__PURE__ */ new Map();
      var caches2 = tagCaches = /* @__PURE__ */ new Map();
      caches2.set(ownerDocument, cache);
    } else
      caches2 = tagCaches, cache = caches2.get(ownerDocument), cache || (cache = /* @__PURE__ */ new Map(), caches2.set(ownerDocument, cache));
    if (cache.has(type)) return cache;
    cache.set(type, null);
    ownerDocument = ownerDocument.getElementsByTagName(type);
    for (caches2 = 0; caches2 < ownerDocument.length; caches2++) {
      var node = ownerDocument[caches2];
      if (!(node[internalHoistableMarker] || node[internalInstanceKey] || "link" === type && "stylesheet" === node.getAttribute("rel")) && "http://www.w3.org/2000/svg" !== node.namespaceURI) {
        var nodeKey = node.getAttribute(keyAttribute) || "";
        nodeKey = type + nodeKey;
        var existing = cache.get(nodeKey);
        existing ? existing.push(node) : cache.set(nodeKey, [node]);
      }
    }
    return cache;
  }
  function mountHoistable(hoistableRoot, type, instance) {
    hoistableRoot = hoistableRoot.ownerDocument || hoistableRoot;
    hoistableRoot.head.insertBefore(
      instance,
      "title" === type ? hoistableRoot.querySelector("head > title") : null
    );
  }
  function isHostHoistableType(type, props, hostContext) {
    if (1 === hostContext || null != props.itemProp) return false;
    switch (type) {
      case "meta":
      case "title":
        return true;
      case "style":
        if ("string" !== typeof props.precedence || "string" !== typeof props.href || "" === props.href)
          break;
        return true;
      case "link":
        if ("string" !== typeof props.rel || "string" !== typeof props.href || "" === props.href || props.onLoad || props.onError)
          break;
        switch (props.rel) {
          case "stylesheet":
            return type = props.disabled, "string" === typeof props.precedence && null == type;
          default:
            return true;
        }
      case "script":
        if (props.async && "function" !== typeof props.async && "symbol" !== typeof props.async && !props.onLoad && !props.onError && props.src && "string" === typeof props.src)
          return true;
    }
    return false;
  }
  function preloadResource(resource) {
    return "stylesheet" === resource.type && 0 === (resource.state.loading & 3) ? false : true;
  }
  function suspendResource(state, hoistableRoot, resource, props) {
    if ("stylesheet" === resource.type && ("string" !== typeof props.media || false !== matchMedia(props.media).matches) && 0 === (resource.state.loading & 4)) {
      if (null === resource.instance) {
        var key = getStyleKey(props.href), instance = hoistableRoot.querySelector(
          getStylesheetSelectorFromKey(key)
        );
        if (instance) {
          hoistableRoot = instance._p;
          null !== hoistableRoot && "object" === typeof hoistableRoot && "function" === typeof hoistableRoot.then && (state.count++, state = onUnsuspend.bind(state), hoistableRoot.then(state, state));
          resource.state.loading |= 4;
          resource.instance = instance;
          markNodeAsHoistable(instance);
          return;
        }
        instance = hoistableRoot.ownerDocument || hoistableRoot;
        props = stylesheetPropsFromRawProps(props);
        (key = preloadPropsMap.get(key)) && adoptPreloadPropsForStylesheet(props, key);
        instance = instance.createElement("link");
        markNodeAsHoistable(instance);
        var linkInstance = instance;
        linkInstance._p = new Promise(function(resolve, reject) {
          linkInstance.onload = resolve;
          linkInstance.onerror = reject;
        });
        setInitialProperties(instance, "link", props);
        resource.instance = instance;
      }
      null === state.stylesheets && (state.stylesheets = /* @__PURE__ */ new Map());
      state.stylesheets.set(resource, hoistableRoot);
      (hoistableRoot = resource.state.preload) && 0 === (resource.state.loading & 3) && (state.count++, resource = onUnsuspend.bind(state), hoistableRoot.addEventListener("load", resource), hoistableRoot.addEventListener("error", resource));
    }
  }
  var estimatedBytesWithinLimit = 0;
  function waitForCommitToBeReady(state, timeoutOffset) {
    state.stylesheets && 0 === state.count && insertSuspendedStylesheets(state, state.stylesheets);
    return 0 < state.count || 0 < state.imgCount ? function(commit) {
      var stylesheetTimer = setTimeout(function() {
        state.stylesheets && insertSuspendedStylesheets(state, state.stylesheets);
        if (state.unsuspend) {
          var unsuspend = state.unsuspend;
          state.unsuspend = null;
          unsuspend();
        }
      }, 6e4 + timeoutOffset);
      0 < state.imgBytes && 0 === estimatedBytesWithinLimit && (estimatedBytesWithinLimit = 62500 * estimateBandwidth());
      var imgTimer = setTimeout(
        function() {
          state.waitingForImages = false;
          if (0 === state.count && (state.stylesheets && insertSuspendedStylesheets(state, state.stylesheets), state.unsuspend)) {
            var unsuspend = state.unsuspend;
            state.unsuspend = null;
            unsuspend();
          }
        },
        (state.imgBytes > estimatedBytesWithinLimit ? 50 : 800) + timeoutOffset
      );
      state.unsuspend = commit;
      return function() {
        state.unsuspend = null;
        clearTimeout(stylesheetTimer);
        clearTimeout(imgTimer);
      };
    } : null;
  }
  function onUnsuspend() {
    this.count--;
    if (0 === this.count && (0 === this.imgCount || !this.waitingForImages)) {
      if (this.stylesheets) insertSuspendedStylesheets(this, this.stylesheets);
      else if (this.unsuspend) {
        var unsuspend = this.unsuspend;
        this.unsuspend = null;
        unsuspend();
      }
    }
  }
  var precedencesByRoot = null;
  function insertSuspendedStylesheets(state, resources) {
    state.stylesheets = null;
    null !== state.unsuspend && (state.count++, precedencesByRoot = /* @__PURE__ */ new Map(), resources.forEach(insertStylesheetIntoRoot, state), precedencesByRoot = null, onUnsuspend.call(state));
  }
  function insertStylesheetIntoRoot(root2, resource) {
    if (!(resource.state.loading & 4)) {
      var precedences = precedencesByRoot.get(root2);
      if (precedences) var last = precedences.get(null);
      else {
        precedences = /* @__PURE__ */ new Map();
        precedencesByRoot.set(root2, precedences);
        for (var nodes = root2.querySelectorAll(
          "link[data-precedence],style[data-precedence]"
        ), i3 = 0; i3 < nodes.length; i3++) {
          var node = nodes[i3];
          if ("LINK" === node.nodeName || "not all" !== node.getAttribute("media"))
            precedences.set(node.dataset.precedence, node), last = node;
        }
        last && precedences.set(null, last);
      }
      nodes = resource.instance;
      node = nodes.getAttribute("data-precedence");
      i3 = precedences.get(node) || last;
      i3 === last && precedences.set(null, nodes);
      precedences.set(node, nodes);
      this.count++;
      last = onUnsuspend.bind(this);
      nodes.addEventListener("load", last);
      nodes.addEventListener("error", last);
      i3 ? i3.parentNode.insertBefore(nodes, i3.nextSibling) : (root2 = 9 === root2.nodeType ? root2.head : root2, root2.insertBefore(nodes, root2.firstChild));
      resource.state.loading |= 4;
    }
  }
  var HostTransitionContext = {
    $$typeof: REACT_CONTEXT_TYPE,
    Provider: null,
    Consumer: null,
    _currentValue: sharedNotPendingObject,
    _currentValue2: sharedNotPendingObject,
    _threadCount: 0
  };
  function FiberRootNode(containerInfo, tag, hydrate, identifierPrefix, onUncaughtError, onCaughtError, onRecoverableError, onDefaultTransitionIndicator, formState) {
    this.tag = 1;
    this.containerInfo = containerInfo;
    this.pingCache = this.current = this.pendingChildren = null;
    this.timeoutHandle = -1;
    this.callbackNode = this.next = this.pendingContext = this.context = this.cancelPendingCommit = null;
    this.callbackPriority = 0;
    this.expirationTimes = createLaneMap(-1);
    this.entangledLanes = this.shellSuspendCounter = this.errorRecoveryDisabledLanes = this.expiredLanes = this.warmLanes = this.pingedLanes = this.suspendedLanes = this.pendingLanes = 0;
    this.entanglements = createLaneMap(0);
    this.hiddenUpdates = createLaneMap(null);
    this.identifierPrefix = identifierPrefix;
    this.onUncaughtError = onUncaughtError;
    this.onCaughtError = onCaughtError;
    this.onRecoverableError = onRecoverableError;
    this.pooledCache = null;
    this.pooledCacheLanes = 0;
    this.formState = formState;
    this.incompleteTransitions = /* @__PURE__ */ new Map();
  }
  function createFiberRoot(containerInfo, tag, hydrate, initialChildren, hydrationCallbacks, isStrictMode, identifierPrefix, formState, onUncaughtError, onCaughtError, onRecoverableError, onDefaultTransitionIndicator) {
    containerInfo = new FiberRootNode(
      containerInfo,
      tag,
      hydrate,
      identifierPrefix,
      onUncaughtError,
      onCaughtError,
      onRecoverableError,
      onDefaultTransitionIndicator,
      formState
    );
    tag = 1;
    true === isStrictMode && (tag |= 24);
    isStrictMode = createFiberImplClass(3, null, null, tag);
    containerInfo.current = isStrictMode;
    isStrictMode.stateNode = containerInfo;
    tag = createCache();
    tag.refCount++;
    containerInfo.pooledCache = tag;
    tag.refCount++;
    isStrictMode.memoizedState = {
      element: initialChildren,
      isDehydrated: hydrate,
      cache: tag
    };
    initializeUpdateQueue(isStrictMode);
    return containerInfo;
  }
  function getContextForSubtree(parentComponent) {
    if (!parentComponent) return emptyContextObject;
    parentComponent = emptyContextObject;
    return parentComponent;
  }
  function updateContainerImpl(rootFiber, lane, element, container, parentComponent, callback) {
    parentComponent = getContextForSubtree(parentComponent);
    null === container.context ? container.context = parentComponent : container.pendingContext = parentComponent;
    container = createUpdate(lane);
    container.payload = { element };
    callback = void 0 === callback ? null : callback;
    null !== callback && (container.callback = callback);
    element = enqueueUpdate(rootFiber, container, lane);
    null !== element && (scheduleUpdateOnFiber(element, rootFiber, lane), entangleTransitions(element, rootFiber, lane));
  }
  function markRetryLaneImpl(fiber, retryLane) {
    fiber = fiber.memoizedState;
    if (null !== fiber && null !== fiber.dehydrated) {
      var a3 = fiber.retryLane;
      fiber.retryLane = 0 !== a3 && a3 < retryLane ? a3 : retryLane;
    }
  }
  function markRetryLaneIfNotHydrated(fiber, retryLane) {
    markRetryLaneImpl(fiber, retryLane);
    (fiber = fiber.alternate) && markRetryLaneImpl(fiber, retryLane);
  }
  function attemptContinuousHydration(fiber) {
    if (13 === fiber.tag || 31 === fiber.tag) {
      var root2 = enqueueConcurrentRenderForLane(fiber, 67108864);
      null !== root2 && scheduleUpdateOnFiber(root2, fiber, 67108864);
      markRetryLaneIfNotHydrated(fiber, 67108864);
    }
  }
  function attemptHydrationAtCurrentPriority(fiber) {
    if (13 === fiber.tag || 31 === fiber.tag) {
      var lane = requestUpdateLane();
      lane = getBumpedLaneForHydrationByLane(lane);
      var root2 = enqueueConcurrentRenderForLane(fiber, lane);
      null !== root2 && scheduleUpdateOnFiber(root2, fiber, lane);
      markRetryLaneIfNotHydrated(fiber, lane);
    }
  }
  var _enabled = true;
  function dispatchDiscreteEvent(domEventName, eventSystemFlags, container, nativeEvent) {
    var prevTransition = ReactSharedInternals.T;
    ReactSharedInternals.T = null;
    var previousPriority = ReactDOMSharedInternals.p;
    try {
      ReactDOMSharedInternals.p = 2, dispatchEvent(domEventName, eventSystemFlags, container, nativeEvent);
    } finally {
      ReactDOMSharedInternals.p = previousPriority, ReactSharedInternals.T = prevTransition;
    }
  }
  function dispatchContinuousEvent(domEventName, eventSystemFlags, container, nativeEvent) {
    var prevTransition = ReactSharedInternals.T;
    ReactSharedInternals.T = null;
    var previousPriority = ReactDOMSharedInternals.p;
    try {
      ReactDOMSharedInternals.p = 8, dispatchEvent(domEventName, eventSystemFlags, container, nativeEvent);
    } finally {
      ReactDOMSharedInternals.p = previousPriority, ReactSharedInternals.T = prevTransition;
    }
  }
  function dispatchEvent(domEventName, eventSystemFlags, targetContainer, nativeEvent) {
    if (_enabled) {
      var blockedOn = findInstanceBlockingEvent(nativeEvent);
      if (null === blockedOn)
        dispatchEventForPluginEventSystem(
          domEventName,
          eventSystemFlags,
          nativeEvent,
          return_targetInst,
          targetContainer
        ), clearIfContinuousEvent(domEventName, nativeEvent);
      else if (queueIfContinuousEvent(
        blockedOn,
        domEventName,
        eventSystemFlags,
        targetContainer,
        nativeEvent
      ))
        nativeEvent.stopPropagation();
      else if (clearIfContinuousEvent(domEventName, nativeEvent), eventSystemFlags & 4 && -1 < discreteReplayableEvents.indexOf(domEventName)) {
        for (; null !== blockedOn; ) {
          var fiber = getInstanceFromNode(blockedOn);
          if (null !== fiber)
            switch (fiber.tag) {
              case 3:
                fiber = fiber.stateNode;
                if (fiber.current.memoizedState.isDehydrated) {
                  var lanes = getHighestPriorityLanes(fiber.pendingLanes);
                  if (0 !== lanes) {
                    var root2 = fiber;
                    root2.pendingLanes |= 2;
                    for (root2.entangledLanes |= 2; lanes; ) {
                      var lane = 1 << 31 - clz32(lanes);
                      root2.entanglements[1] |= lane;
                      lanes &= ~lane;
                    }
                    ensureRootIsScheduled(fiber);
                    0 === (executionContext & 6) && (workInProgressRootRenderTargetTime = now() + 500, flushSyncWorkAcrossRoots_impl(0));
                  }
                }
                break;
              case 31:
              case 13:
                root2 = enqueueConcurrentRenderForLane(fiber, 2), null !== root2 && scheduleUpdateOnFiber(root2, fiber, 2), flushSyncWork$1(), markRetryLaneIfNotHydrated(fiber, 2);
            }
          fiber = findInstanceBlockingEvent(nativeEvent);
          null === fiber && dispatchEventForPluginEventSystem(
            domEventName,
            eventSystemFlags,
            nativeEvent,
            return_targetInst,
            targetContainer
          );
          if (fiber === blockedOn) break;
          blockedOn = fiber;
        }
        null !== blockedOn && nativeEvent.stopPropagation();
      } else
        dispatchEventForPluginEventSystem(
          domEventName,
          eventSystemFlags,
          nativeEvent,
          null,
          targetContainer
        );
    }
  }
  function findInstanceBlockingEvent(nativeEvent) {
    nativeEvent = getEventTarget(nativeEvent);
    return findInstanceBlockingTarget(nativeEvent);
  }
  var return_targetInst = null;
  function findInstanceBlockingTarget(targetNode) {
    return_targetInst = null;
    targetNode = getClosestInstanceFromNode(targetNode);
    if (null !== targetNode) {
      var nearestMounted = getNearestMountedFiber(targetNode);
      if (null === nearestMounted) targetNode = null;
      else {
        var tag = nearestMounted.tag;
        if (13 === tag) {
          targetNode = getSuspenseInstanceFromFiber(nearestMounted);
          if (null !== targetNode) return targetNode;
          targetNode = null;
        } else if (31 === tag) {
          targetNode = getActivityInstanceFromFiber(nearestMounted);
          if (null !== targetNode) return targetNode;
          targetNode = null;
        } else if (3 === tag) {
          if (nearestMounted.stateNode.current.memoizedState.isDehydrated)
            return 3 === nearestMounted.tag ? nearestMounted.stateNode.containerInfo : null;
          targetNode = null;
        } else nearestMounted !== targetNode && (targetNode = null);
      }
    }
    return_targetInst = targetNode;
    return null;
  }
  function getEventPriority(domEventName) {
    switch (domEventName) {
      case "beforetoggle":
      case "cancel":
      case "click":
      case "close":
      case "contextmenu":
      case "copy":
      case "cut":
      case "auxclick":
      case "dblclick":
      case "dragend":
      case "dragstart":
      case "drop":
      case "focusin":
      case "focusout":
      case "input":
      case "invalid":
      case "keydown":
      case "keypress":
      case "keyup":
      case "mousedown":
      case "mouseup":
      case "paste":
      case "pause":
      case "play":
      case "pointercancel":
      case "pointerdown":
      case "pointerup":
      case "ratechange":
      case "reset":
      case "resize":
      case "seeked":
      case "submit":
      case "toggle":
      case "touchcancel":
      case "touchend":
      case "touchstart":
      case "volumechange":
      case "change":
      case "selectionchange":
      case "textInput":
      case "compositionstart":
      case "compositionend":
      case "compositionupdate":
      case "beforeblur":
      case "afterblur":
      case "beforeinput":
      case "blur":
      case "fullscreenchange":
      case "focus":
      case "hashchange":
      case "popstate":
      case "select":
      case "selectstart":
        return 2;
      case "drag":
      case "dragenter":
      case "dragexit":
      case "dragleave":
      case "dragover":
      case "mousemove":
      case "mouseout":
      case "mouseover":
      case "pointermove":
      case "pointerout":
      case "pointerover":
      case "scroll":
      case "touchmove":
      case "wheel":
      case "mouseenter":
      case "mouseleave":
      case "pointerenter":
      case "pointerleave":
        return 8;
      case "message":
        switch (getCurrentPriorityLevel()) {
          case ImmediatePriority:
            return 2;
          case UserBlockingPriority:
            return 8;
          case NormalPriority$1:
          case LowPriority:
            return 32;
          case IdlePriority:
            return 268435456;
          default:
            return 32;
        }
      default:
        return 32;
    }
  }
  var hasScheduledReplayAttempt = false, queuedFocus = null, queuedDrag = null, queuedMouse = null, queuedPointers = /* @__PURE__ */ new Map(), queuedPointerCaptures = /* @__PURE__ */ new Map(), queuedExplicitHydrationTargets = [], discreteReplayableEvents = "mousedown mouseup touchcancel touchend touchstart auxclick dblclick pointercancel pointerdown pointerup dragend dragstart drop compositionend compositionstart keydown keypress keyup input textInput copy cut paste click change contextmenu reset".split(
    " "
  );
  function clearIfContinuousEvent(domEventName, nativeEvent) {
    switch (domEventName) {
      case "focusin":
      case "focusout":
        queuedFocus = null;
        break;
      case "dragenter":
      case "dragleave":
        queuedDrag = null;
        break;
      case "mouseover":
      case "mouseout":
        queuedMouse = null;
        break;
      case "pointerover":
      case "pointerout":
        queuedPointers.delete(nativeEvent.pointerId);
        break;
      case "gotpointercapture":
      case "lostpointercapture":
        queuedPointerCaptures.delete(nativeEvent.pointerId);
    }
  }
  function accumulateOrCreateContinuousQueuedReplayableEvent(existingQueuedEvent, blockedOn, domEventName, eventSystemFlags, targetContainer, nativeEvent) {
    if (null === existingQueuedEvent || existingQueuedEvent.nativeEvent !== nativeEvent)
      return existingQueuedEvent = {
        blockedOn,
        domEventName,
        eventSystemFlags,
        nativeEvent,
        targetContainers: [targetContainer]
      }, null !== blockedOn && (blockedOn = getInstanceFromNode(blockedOn), null !== blockedOn && attemptContinuousHydration(blockedOn)), existingQueuedEvent;
    existingQueuedEvent.eventSystemFlags |= eventSystemFlags;
    blockedOn = existingQueuedEvent.targetContainers;
    null !== targetContainer && -1 === blockedOn.indexOf(targetContainer) && blockedOn.push(targetContainer);
    return existingQueuedEvent;
  }
  function queueIfContinuousEvent(blockedOn, domEventName, eventSystemFlags, targetContainer, nativeEvent) {
    switch (domEventName) {
      case "focusin":
        return queuedFocus = accumulateOrCreateContinuousQueuedReplayableEvent(
          queuedFocus,
          blockedOn,
          domEventName,
          eventSystemFlags,
          targetContainer,
          nativeEvent
        ), true;
      case "dragenter":
        return queuedDrag = accumulateOrCreateContinuousQueuedReplayableEvent(
          queuedDrag,
          blockedOn,
          domEventName,
          eventSystemFlags,
          targetContainer,
          nativeEvent
        ), true;
      case "mouseover":
        return queuedMouse = accumulateOrCreateContinuousQueuedReplayableEvent(
          queuedMouse,
          blockedOn,
          domEventName,
          eventSystemFlags,
          targetContainer,
          nativeEvent
        ), true;
      case "pointerover":
        var pointerId = nativeEvent.pointerId;
        queuedPointers.set(
          pointerId,
          accumulateOrCreateContinuousQueuedReplayableEvent(
            queuedPointers.get(pointerId) || null,
            blockedOn,
            domEventName,
            eventSystemFlags,
            targetContainer,
            nativeEvent
          )
        );
        return true;
      case "gotpointercapture":
        return pointerId = nativeEvent.pointerId, queuedPointerCaptures.set(
          pointerId,
          accumulateOrCreateContinuousQueuedReplayableEvent(
            queuedPointerCaptures.get(pointerId) || null,
            blockedOn,
            domEventName,
            eventSystemFlags,
            targetContainer,
            nativeEvent
          )
        ), true;
    }
    return false;
  }
  function attemptExplicitHydrationTarget(queuedTarget) {
    var targetInst = getClosestInstanceFromNode(queuedTarget.target);
    if (null !== targetInst) {
      var nearestMounted = getNearestMountedFiber(targetInst);
      if (null !== nearestMounted) {
        if (targetInst = nearestMounted.tag, 13 === targetInst) {
          if (targetInst = getSuspenseInstanceFromFiber(nearestMounted), null !== targetInst) {
            queuedTarget.blockedOn = targetInst;
            runWithPriority(queuedTarget.priority, function() {
              attemptHydrationAtCurrentPriority(nearestMounted);
            });
            return;
          }
        } else if (31 === targetInst) {
          if (targetInst = getActivityInstanceFromFiber(nearestMounted), null !== targetInst) {
            queuedTarget.blockedOn = targetInst;
            runWithPriority(queuedTarget.priority, function() {
              attemptHydrationAtCurrentPriority(nearestMounted);
            });
            return;
          }
        } else if (3 === targetInst && nearestMounted.stateNode.current.memoizedState.isDehydrated) {
          queuedTarget.blockedOn = 3 === nearestMounted.tag ? nearestMounted.stateNode.containerInfo : null;
          return;
        }
      }
    }
    queuedTarget.blockedOn = null;
  }
  function attemptReplayContinuousQueuedEvent(queuedEvent) {
    if (null !== queuedEvent.blockedOn) return false;
    for (var targetContainers = queuedEvent.targetContainers; 0 < targetContainers.length; ) {
      var nextBlockedOn = findInstanceBlockingEvent(queuedEvent.nativeEvent);
      if (null === nextBlockedOn) {
        nextBlockedOn = queuedEvent.nativeEvent;
        var nativeEventClone = new nextBlockedOn.constructor(
          nextBlockedOn.type,
          nextBlockedOn
        );
        currentReplayingEvent = nativeEventClone;
        nextBlockedOn.target.dispatchEvent(nativeEventClone);
        currentReplayingEvent = null;
      } else
        return targetContainers = getInstanceFromNode(nextBlockedOn), null !== targetContainers && attemptContinuousHydration(targetContainers), queuedEvent.blockedOn = nextBlockedOn, false;
      targetContainers.shift();
    }
    return true;
  }
  function attemptReplayContinuousQueuedEventInMap(queuedEvent, key, map) {
    attemptReplayContinuousQueuedEvent(queuedEvent) && map.delete(key);
  }
  function replayUnblockedEvents() {
    hasScheduledReplayAttempt = false;
    null !== queuedFocus && attemptReplayContinuousQueuedEvent(queuedFocus) && (queuedFocus = null);
    null !== queuedDrag && attemptReplayContinuousQueuedEvent(queuedDrag) && (queuedDrag = null);
    null !== queuedMouse && attemptReplayContinuousQueuedEvent(queuedMouse) && (queuedMouse = null);
    queuedPointers.forEach(attemptReplayContinuousQueuedEventInMap);
    queuedPointerCaptures.forEach(attemptReplayContinuousQueuedEventInMap);
  }
  function scheduleCallbackIfUnblocked(queuedEvent, unblocked) {
    queuedEvent.blockedOn === unblocked && (queuedEvent.blockedOn = null, hasScheduledReplayAttempt || (hasScheduledReplayAttempt = true, Scheduler.unstable_scheduleCallback(
      Scheduler.unstable_NormalPriority,
      replayUnblockedEvents
    )));
  }
  var lastScheduledReplayQueue = null;
  function scheduleReplayQueueIfNeeded(formReplayingQueue) {
    lastScheduledReplayQueue !== formReplayingQueue && (lastScheduledReplayQueue = formReplayingQueue, Scheduler.unstable_scheduleCallback(
      Scheduler.unstable_NormalPriority,
      function() {
        lastScheduledReplayQueue === formReplayingQueue && (lastScheduledReplayQueue = null);
        for (var i3 = 0; i3 < formReplayingQueue.length; i3 += 3) {
          var form = formReplayingQueue[i3], submitterOrAction = formReplayingQueue[i3 + 1], formData = formReplayingQueue[i3 + 2];
          if ("function" !== typeof submitterOrAction)
            if (null === findInstanceBlockingTarget(submitterOrAction || form))
              continue;
            else break;
          var formInst = getInstanceFromNode(form);
          null !== formInst && (formReplayingQueue.splice(i3, 3), i3 -= 3, startHostTransition(
            formInst,
            {
              pending: true,
              data: formData,
              method: form.method,
              action: submitterOrAction
            },
            submitterOrAction,
            formData
          ));
        }
      }
    ));
  }
  function retryIfBlockedOn(unblocked) {
    function unblock(queuedEvent) {
      return scheduleCallbackIfUnblocked(queuedEvent, unblocked);
    }
    null !== queuedFocus && scheduleCallbackIfUnblocked(queuedFocus, unblocked);
    null !== queuedDrag && scheduleCallbackIfUnblocked(queuedDrag, unblocked);
    null !== queuedMouse && scheduleCallbackIfUnblocked(queuedMouse, unblocked);
    queuedPointers.forEach(unblock);
    queuedPointerCaptures.forEach(unblock);
    for (var i3 = 0; i3 < queuedExplicitHydrationTargets.length; i3++) {
      var queuedTarget = queuedExplicitHydrationTargets[i3];
      queuedTarget.blockedOn === unblocked && (queuedTarget.blockedOn = null);
    }
    for (; 0 < queuedExplicitHydrationTargets.length && (i3 = queuedExplicitHydrationTargets[0], null === i3.blockedOn); )
      attemptExplicitHydrationTarget(i3), null === i3.blockedOn && queuedExplicitHydrationTargets.shift();
    i3 = (unblocked.ownerDocument || unblocked).$$reactFormReplay;
    if (null != i3)
      for (queuedTarget = 0; queuedTarget < i3.length; queuedTarget += 3) {
        var form = i3[queuedTarget], submitterOrAction = i3[queuedTarget + 1], formProps = form[internalPropsKey] || null;
        if ("function" === typeof submitterOrAction)
          formProps || scheduleReplayQueueIfNeeded(i3);
        else if (formProps) {
          var action = null;
          if (submitterOrAction && submitterOrAction.hasAttribute("formAction"))
            if (form = submitterOrAction, formProps = submitterOrAction[internalPropsKey] || null)
              action = formProps.formAction;
            else {
              if (null !== findInstanceBlockingTarget(form)) continue;
            }
          else action = formProps.action;
          "function" === typeof action ? i3[queuedTarget + 1] = action : (i3.splice(queuedTarget, 3), queuedTarget -= 3);
          scheduleReplayQueueIfNeeded(i3);
        }
      }
  }
  function defaultOnDefaultTransitionIndicator() {
    function handleNavigate(event) {
      event.canIntercept && "react-transition" === event.info && event.intercept({
        handler: function() {
          return new Promise(function(resolve) {
            return pendingResolve = resolve;
          });
        },
        focusReset: "manual",
        scroll: "manual"
      });
    }
    function handleNavigateComplete() {
      null !== pendingResolve && (pendingResolve(), pendingResolve = null);
      isCancelled || setTimeout(startFakeNavigation, 20);
    }
    function startFakeNavigation() {
      if (!isCancelled && !navigation.transition) {
        var currentEntry = navigation.currentEntry;
        currentEntry && null != currentEntry.url && navigation.navigate(currentEntry.url, {
          state: currentEntry.getState(),
          info: "react-transition",
          history: "replace"
        });
      }
    }
    if ("object" === typeof navigation) {
      var isCancelled = false, pendingResolve = null;
      navigation.addEventListener("navigate", handleNavigate);
      navigation.addEventListener("navigatesuccess", handleNavigateComplete);
      navigation.addEventListener("navigateerror", handleNavigateComplete);
      setTimeout(startFakeNavigation, 100);
      return function() {
        isCancelled = true;
        navigation.removeEventListener("navigate", handleNavigate);
        navigation.removeEventListener("navigatesuccess", handleNavigateComplete);
        navigation.removeEventListener("navigateerror", handleNavigateComplete);
        null !== pendingResolve && (pendingResolve(), pendingResolve = null);
      };
    }
  }
  function ReactDOMRoot(internalRoot) {
    this._internalRoot = internalRoot;
  }
  ReactDOMHydrationRoot.prototype.render = ReactDOMRoot.prototype.render = function(children) {
    var root2 = this._internalRoot;
    if (null === root2) throw Error(formatProdErrorMessage(409));
    var current = root2.current, lane = requestUpdateLane();
    updateContainerImpl(current, lane, children, root2, null, null);
  };
  ReactDOMHydrationRoot.prototype.unmount = ReactDOMRoot.prototype.unmount = function() {
    var root2 = this._internalRoot;
    if (null !== root2) {
      this._internalRoot = null;
      var container = root2.containerInfo;
      updateContainerImpl(root2.current, 2, null, root2, null, null);
      flushSyncWork$1();
      container[internalContainerInstanceKey] = null;
    }
  };
  function ReactDOMHydrationRoot(internalRoot) {
    this._internalRoot = internalRoot;
  }
  ReactDOMHydrationRoot.prototype.unstable_scheduleHydration = function(target) {
    if (target) {
      var updatePriority = resolveUpdatePriority();
      target = { blockedOn: null, target, priority: updatePriority };
      for (var i3 = 0; i3 < queuedExplicitHydrationTargets.length && 0 !== updatePriority && updatePriority < queuedExplicitHydrationTargets[i3].priority; i3++) ;
      queuedExplicitHydrationTargets.splice(i3, 0, target);
      0 === i3 && attemptExplicitHydrationTarget(target);
    }
  };
  var isomorphicReactPackageVersion$jscomp$inline_1840 = React2.version;
  if ("19.2.0" !== isomorphicReactPackageVersion$jscomp$inline_1840)
    throw Error(
      formatProdErrorMessage(
        527,
        isomorphicReactPackageVersion$jscomp$inline_1840,
        "19.2.0"
      )
    );
  ReactDOMSharedInternals.findDOMNode = function(componentOrElement) {
    var fiber = componentOrElement._reactInternals;
    if (void 0 === fiber) {
      if ("function" === typeof componentOrElement.render)
        throw Error(formatProdErrorMessage(188));
      componentOrElement = Object.keys(componentOrElement).join(",");
      throw Error(formatProdErrorMessage(268, componentOrElement));
    }
    componentOrElement = findCurrentFiberUsingSlowPath(fiber);
    componentOrElement = null !== componentOrElement ? findCurrentHostFiberImpl(componentOrElement) : null;
    componentOrElement = null === componentOrElement ? null : componentOrElement.stateNode;
    return componentOrElement;
  };
  var internals$jscomp$inline_2347 = {
    bundleType: 0,
    version: "19.2.0",
    rendererPackageName: "react-dom",
    currentDispatcherRef: ReactSharedInternals,
    reconcilerVersion: "19.2.0"
  };
  if ("undefined" !== typeof __REACT_DEVTOOLS_GLOBAL_HOOK__) {
    var hook$jscomp$inline_2348 = __REACT_DEVTOOLS_GLOBAL_HOOK__;
    if (!hook$jscomp$inline_2348.isDisabled && hook$jscomp$inline_2348.supportsFiber)
      try {
        rendererID = hook$jscomp$inline_2348.inject(
          internals$jscomp$inline_2347
        ), injectedHook = hook$jscomp$inline_2348;
      } catch (err2) {
      }
  }
  reactDomClient_production.createRoot = function(container, options2) {
    if (!isValidContainer(container)) throw Error(formatProdErrorMessage(299));
    var isStrictMode = false, identifierPrefix = "", onUncaughtError = defaultOnUncaughtError, onCaughtError = defaultOnCaughtError, onRecoverableError = defaultOnRecoverableError;
    null !== options2 && void 0 !== options2 && (true === options2.unstable_strictMode && (isStrictMode = true), void 0 !== options2.identifierPrefix && (identifierPrefix = options2.identifierPrefix), void 0 !== options2.onUncaughtError && (onUncaughtError = options2.onUncaughtError), void 0 !== options2.onCaughtError && (onCaughtError = options2.onCaughtError), void 0 !== options2.onRecoverableError && (onRecoverableError = options2.onRecoverableError));
    options2 = createFiberRoot(
      container,
      1,
      false,
      null,
      null,
      isStrictMode,
      identifierPrefix,
      null,
      onUncaughtError,
      onCaughtError,
      onRecoverableError,
      defaultOnDefaultTransitionIndicator
    );
    container[internalContainerInstanceKey] = options2.current;
    listenToAllSupportedEvents(container);
    return new ReactDOMRoot(options2);
  };
  reactDomClient_production.hydrateRoot = function(container, initialChildren, options2) {
    if (!isValidContainer(container)) throw Error(formatProdErrorMessage(299));
    var isStrictMode = false, identifierPrefix = "", onUncaughtError = defaultOnUncaughtError, onCaughtError = defaultOnCaughtError, onRecoverableError = defaultOnRecoverableError, formState = null;
    null !== options2 && void 0 !== options2 && (true === options2.unstable_strictMode && (isStrictMode = true), void 0 !== options2.identifierPrefix && (identifierPrefix = options2.identifierPrefix), void 0 !== options2.onUncaughtError && (onUncaughtError = options2.onUncaughtError), void 0 !== options2.onCaughtError && (onCaughtError = options2.onCaughtError), void 0 !== options2.onRecoverableError && (onRecoverableError = options2.onRecoverableError), void 0 !== options2.formState && (formState = options2.formState));
    initialChildren = createFiberRoot(
      container,
      1,
      true,
      initialChildren,
      null != options2 ? options2 : null,
      isStrictMode,
      identifierPrefix,
      formState,
      onUncaughtError,
      onCaughtError,
      onRecoverableError,
      defaultOnDefaultTransitionIndicator
    );
    initialChildren.context = getContextForSubtree(null);
    options2 = initialChildren.current;
    isStrictMode = requestUpdateLane();
    isStrictMode = getBumpedLaneForHydrationByLane(isStrictMode);
    identifierPrefix = createUpdate(isStrictMode);
    identifierPrefix.callback = null;
    enqueueUpdate(options2, identifierPrefix, isStrictMode);
    options2 = isStrictMode;
    initialChildren.current.lanes = options2;
    markRootUpdated$1(initialChildren, options2);
    ensureRootIsScheduled(initialChildren);
    container[internalContainerInstanceKey] = initialChildren.current;
    listenToAllSupportedEvents(container);
    return new ReactDOMHydrationRoot(initialChildren);
  };
  reactDomClient_production.version = "19.2.0";
  return reactDomClient_production;
}
var hasRequiredClient;
function requireClient() {
  if (hasRequiredClient) return client.exports;
  hasRequiredClient = 1;
  function checkDCE() {
    if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ === "undefined" || typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE !== "function") {
      return;
    }
    try {
      __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE(checkDCE);
    } catch (err2) {
      console.error(err2);
    }
  }
  {
    checkDCE();
    client.exports = requireReactDomClient_production();
  }
  return client.exports;
}
var clientExports = requireClient();
const ReactDOM$1 = /* @__PURE__ */ getDefaultExportFromCjs(clientExports);
var Subscribable = class {
  constructor() {
    this.listeners = /* @__PURE__ */ new Set();
    this.subscribe = this.subscribe.bind(this);
  }
  subscribe(listener) {
    this.listeners.add(listener);
    this.onSubscribe();
    return () => {
      this.listeners.delete(listener);
      this.onUnsubscribe();
    };
  }
  hasListeners() {
    return this.listeners.size > 0;
  }
  onSubscribe() {
  }
  onUnsubscribe() {
  }
};
var defaultTimeoutProvider = {
  // We need the wrapper function syntax below instead of direct references to
  // global setTimeout etc.
  //
  // BAD: `setTimeout: setTimeout`
  // GOOD: `setTimeout: (cb, delay) => setTimeout(cb, delay)`
  //
  // If we use direct references here, then anything that wants to spy on or
  // replace the global setTimeout (like tests) won't work since we'll already
  // have a hard reference to the original implementation at the time when this
  // file was imported.
  setTimeout: (callback, delay) => setTimeout(callback, delay),
  clearTimeout: (timeoutId) => clearTimeout(timeoutId),
  setInterval: (callback, delay) => setInterval(callback, delay),
  clearInterval: (intervalId) => clearInterval(intervalId)
};
var TimeoutManager = class {
  // We cannot have TimeoutManager<T> as we must instantiate it with a concrete
  // type at app boot; and if we leave that type, then any new timer provider
  // would need to support ReturnType<typeof setTimeout>, which is infeasible.
  //
  // We settle for type safety for the TimeoutProvider type, and accept that
  // this class is unsafe internally to allow for extension.
  #provider = defaultTimeoutProvider;
  #providerCalled = false;
  setTimeoutProvider(provider) {
    this.#provider = provider;
  }
  setTimeout(callback, delay) {
    return this.#provider.setTimeout(callback, delay);
  }
  clearTimeout(timeoutId) {
    this.#provider.clearTimeout(timeoutId);
  }
  setInterval(callback, delay) {
    return this.#provider.setInterval(callback, delay);
  }
  clearInterval(intervalId) {
    this.#provider.clearInterval(intervalId);
  }
};
var timeoutManager = new TimeoutManager();
function systemSetTimeoutZero(callback) {
  setTimeout(callback, 0);
}
var isServer = typeof window === "undefined" || "Deno" in globalThis;
function noop$1() {
}
function functionalUpdate(updater, input) {
  return typeof updater === "function" ? updater(input) : updater;
}
function isValidTimeout(value) {
  return typeof value === "number" && value >= 0 && value !== Infinity;
}
function timeUntilStale(updatedAt, staleTime) {
  return Math.max(updatedAt + (staleTime || 0) - Date.now(), 0);
}
function resolveStaleTime(staleTime, query) {
  return typeof staleTime === "function" ? staleTime(query) : staleTime;
}
function resolveEnabled(enabled, query) {
  return typeof enabled === "function" ? enabled(query) : enabled;
}
function matchQuery(filters, query) {
  const {
    type = "all",
    exact,
    fetchStatus,
    predicate,
    queryKey,
    stale
  } = filters;
  if (queryKey) {
    if (exact) {
      if (query.queryHash !== hashQueryKeyByOptions(queryKey, query.options)) {
        return false;
      }
    } else if (!partialMatchKey(query.queryKey, queryKey)) {
      return false;
    }
  }
  if (type !== "all") {
    const isActive = query.isActive();
    if (type === "active" && !isActive) {
      return false;
    }
    if (type === "inactive" && isActive) {
      return false;
    }
  }
  if (typeof stale === "boolean" && query.isStale() !== stale) {
    return false;
  }
  if (fetchStatus && fetchStatus !== query.state.fetchStatus) {
    return false;
  }
  if (predicate && !predicate(query)) {
    return false;
  }
  return true;
}
function matchMutation(filters, mutation) {
  const { exact, status, predicate, mutationKey } = filters;
  if (mutationKey) {
    if (!mutation.options.mutationKey) {
      return false;
    }
    if (exact) {
      if (hashKey(mutation.options.mutationKey) !== hashKey(mutationKey)) {
        return false;
      }
    } else if (!partialMatchKey(mutation.options.mutationKey, mutationKey)) {
      return false;
    }
  }
  if (status && mutation.state.status !== status) {
    return false;
  }
  if (predicate && !predicate(mutation)) {
    return false;
  }
  return true;
}
function hashQueryKeyByOptions(queryKey, options) {
  const hashFn = options?.queryKeyHashFn || hashKey;
  return hashFn(queryKey);
}
function hashKey(queryKey) {
  return JSON.stringify(
    queryKey,
    (_3, val) => isPlainObject(val) ? Object.keys(val).sort().reduce((result, key) => {
      result[key] = val[key];
      return result;
    }, {}) : val
  );
}
function partialMatchKey(a3, b3) {
  if (a3 === b3) {
    return true;
  }
  if (typeof a3 !== typeof b3) {
    return false;
  }
  if (a3 && b3 && typeof a3 === "object" && typeof b3 === "object") {
    return Object.keys(b3).every((key) => partialMatchKey(a3[key], b3[key]));
  }
  return false;
}
var hasOwn = Object.prototype.hasOwnProperty;
function replaceEqualDeep(a3, b3) {
  if (a3 === b3) {
    return a3;
  }
  const array = isPlainArray(a3) && isPlainArray(b3);
  if (!array && !(isPlainObject(a3) && isPlainObject(b3))) return b3;
  const aItems = array ? a3 : Object.keys(a3);
  const aSize = aItems.length;
  const bItems = array ? b3 : Object.keys(b3);
  const bSize = bItems.length;
  const copy = array ? new Array(bSize) : {};
  let equalItems = 0;
  for (let i3 = 0; i3 < bSize; i3++) {
    const key = array ? i3 : bItems[i3];
    const aItem = a3[key];
    const bItem = b3[key];
    if (aItem === bItem) {
      copy[key] = aItem;
      if (array ? i3 < aSize : hasOwn.call(a3, key)) equalItems++;
      continue;
    }
    if (aItem === null || bItem === null || typeof aItem !== "object" || typeof bItem !== "object") {
      copy[key] = bItem;
      continue;
    }
    const v3 = replaceEqualDeep(aItem, bItem);
    copy[key] = v3;
    if (v3 === aItem) equalItems++;
  }
  return aSize === bSize && equalItems === aSize ? a3 : copy;
}
function shallowEqualObjects(a3, b3) {
  if (!b3 || Object.keys(a3).length !== Object.keys(b3).length) {
    return false;
  }
  for (const key in a3) {
    if (a3[key] !== b3[key]) {
      return false;
    }
  }
  return true;
}
function isPlainArray(value) {
  return Array.isArray(value) && value.length === Object.keys(value).length;
}
function isPlainObject(o3) {
  if (!hasObjectPrototype(o3)) {
    return false;
  }
  const ctor = o3.constructor;
  if (ctor === void 0) {
    return true;
  }
  const prot = ctor.prototype;
  if (!hasObjectPrototype(prot)) {
    return false;
  }
  if (!prot.hasOwnProperty("isPrototypeOf")) {
    return false;
  }
  if (Object.getPrototypeOf(o3) !== Object.prototype) {
    return false;
  }
  return true;
}
function hasObjectPrototype(o3) {
  return Object.prototype.toString.call(o3) === "[object Object]";
}
function sleep(timeout) {
  return new Promise((resolve) => {
    timeoutManager.setTimeout(resolve, timeout);
  });
}
function replaceData(prevData, data, options) {
  if (typeof options.structuralSharing === "function") {
    return options.structuralSharing(prevData, data);
  } else if (options.structuralSharing !== false) {
    return replaceEqualDeep(prevData, data);
  }
  return data;
}
function addToEnd(items, item, max2 = 0) {
  const newItems = [...items, item];
  return max2 && newItems.length > max2 ? newItems.slice(1) : newItems;
}
function addToStart(items, item, max2 = 0) {
  const newItems = [item, ...items];
  return max2 && newItems.length > max2 ? newItems.slice(0, -1) : newItems;
}
var skipToken = Symbol();
function ensureQueryFn(options, fetchOptions) {
  if (!options.queryFn && fetchOptions?.initialPromise) {
    return () => fetchOptions.initialPromise;
  }
  if (!options.queryFn || options.queryFn === skipToken) {
    return () => Promise.reject(new Error(`Missing queryFn: '${options.queryHash}'`));
  }
  return options.queryFn;
}
function shouldThrowError(throwOnError, params) {
  if (typeof throwOnError === "function") {
    return throwOnError(...params);
  }
  return !!throwOnError;
}
var FocusManager = class extends Subscribable {
  #focused;
  #cleanup;
  #setup;
  constructor() {
    super();
    this.#setup = (onFocus) => {
      if (!isServer && window.addEventListener) {
        const listener = () => onFocus();
        window.addEventListener("visibilitychange", listener, false);
        return () => {
          window.removeEventListener("visibilitychange", listener);
        };
      }
      return;
    };
  }
  onSubscribe() {
    if (!this.#cleanup) {
      this.setEventListener(this.#setup);
    }
  }
  onUnsubscribe() {
    if (!this.hasListeners()) {
      this.#cleanup?.();
      this.#cleanup = void 0;
    }
  }
  setEventListener(setup) {
    this.#setup = setup;
    this.#cleanup?.();
    this.#cleanup = setup((focused) => {
      if (typeof focused === "boolean") {
        this.setFocused(focused);
      } else {
        this.onFocus();
      }
    });
  }
  setFocused(focused) {
    const changed = this.#focused !== focused;
    if (changed) {
      this.#focused = focused;
      this.onFocus();
    }
  }
  onFocus() {
    const isFocused = this.isFocused();
    this.listeners.forEach((listener) => {
      listener(isFocused);
    });
  }
  isFocused() {
    if (typeof this.#focused === "boolean") {
      return this.#focused;
    }
    return globalThis.document?.visibilityState !== "hidden";
  }
};
var focusManager = new FocusManager();
function pendingThenable() {
  let resolve;
  let reject;
  const thenable = new Promise((_resolve, _reject) => {
    resolve = _resolve;
    reject = _reject;
  });
  thenable.status = "pending";
  thenable.catch(() => {
  });
  function finalize(data) {
    Object.assign(thenable, data);
    delete thenable.resolve;
    delete thenable.reject;
  }
  thenable.resolve = (value) => {
    finalize({
      status: "fulfilled",
      value
    });
    resolve(value);
  };
  thenable.reject = (reason) => {
    finalize({
      status: "rejected",
      reason
    });
    reject(reason);
  };
  return thenable;
}
var defaultScheduler = systemSetTimeoutZero;
function createNotifyManager() {
  let queue = [];
  let transactions = 0;
  let notifyFn = (callback) => {
    callback();
  };
  let batchNotifyFn = (callback) => {
    callback();
  };
  let scheduleFn = defaultScheduler;
  const schedule = (callback) => {
    if (transactions) {
      queue.push(callback);
    } else {
      scheduleFn(() => {
        notifyFn(callback);
      });
    }
  };
  const flush = () => {
    const originalQueue = queue;
    queue = [];
    if (originalQueue.length) {
      scheduleFn(() => {
        batchNotifyFn(() => {
          originalQueue.forEach((callback) => {
            notifyFn(callback);
          });
        });
      });
    }
  };
  return {
    batch: (callback) => {
      let result;
      transactions++;
      try {
        result = callback();
      } finally {
        transactions--;
        if (!transactions) {
          flush();
        }
      }
      return result;
    },
    /**
     * All calls to the wrapped function will be batched.
     */
    batchCalls: (callback) => {
      return (...args) => {
        schedule(() => {
          callback(...args);
        });
      };
    },
    schedule,
    /**
     * Use this method to set a custom notify function.
     * This can be used to for example wrap notifications with `React.act` while running tests.
     */
    setNotifyFunction: (fn2) => {
      notifyFn = fn2;
    },
    /**
     * Use this method to set a custom function to batch notifications together into a single tick.
     * By default React Query will use the batch function provided by ReactDOM or React Native.
     */
    setBatchNotifyFunction: (fn2) => {
      batchNotifyFn = fn2;
    },
    setScheduler: (fn2) => {
      scheduleFn = fn2;
    }
  };
}
var notifyManager = createNotifyManager();
var OnlineManager = class extends Subscribable {
  #online = true;
  #cleanup;
  #setup;
  constructor() {
    super();
    this.#setup = (onOnline) => {
      if (!isServer && window.addEventListener) {
        const onlineListener = () => onOnline(true);
        const offlineListener = () => onOnline(false);
        window.addEventListener("online", onlineListener, false);
        window.addEventListener("offline", offlineListener, false);
        return () => {
          window.removeEventListener("online", onlineListener);
          window.removeEventListener("offline", offlineListener);
        };
      }
      return;
    };
  }
  onSubscribe() {
    if (!this.#cleanup) {
      this.setEventListener(this.#setup);
    }
  }
  onUnsubscribe() {
    if (!this.hasListeners()) {
      this.#cleanup?.();
      this.#cleanup = void 0;
    }
  }
  setEventListener(setup) {
    this.#setup = setup;
    this.#cleanup?.();
    this.#cleanup = setup(this.setOnline.bind(this));
  }
  setOnline(online) {
    const changed = this.#online !== online;
    if (changed) {
      this.#online = online;
      this.listeners.forEach((listener) => {
        listener(online);
      });
    }
  }
  isOnline() {
    return this.#online;
  }
};
var onlineManager = new OnlineManager();
function defaultRetryDelay(failureCount) {
  return Math.min(1e3 * 2 ** failureCount, 3e4);
}
function canFetch(networkMode) {
  return (networkMode ?? "online") === "online" ? onlineManager.isOnline() : true;
}
var CancelledError = class extends Error {
  constructor(options) {
    super("CancelledError");
    this.revert = options?.revert;
    this.silent = options?.silent;
  }
};
function createRetryer(config) {
  let isRetryCancelled = false;
  let failureCount = 0;
  let continueFn;
  const thenable = pendingThenable();
  const isResolved = () => thenable.status !== "pending";
  const cancel = (cancelOptions) => {
    if (!isResolved()) {
      const error = new CancelledError(cancelOptions);
      reject(error);
      config.onCancel?.(error);
    }
  };
  const cancelRetry = () => {
    isRetryCancelled = true;
  };
  const continueRetry = () => {
    isRetryCancelled = false;
  };
  const canContinue = () => focusManager.isFocused() && (config.networkMode === "always" || onlineManager.isOnline()) && config.canRun();
  const canStart = () => canFetch(config.networkMode) && config.canRun();
  const resolve = (value) => {
    if (!isResolved()) {
      continueFn?.();
      thenable.resolve(value);
    }
  };
  const reject = (value) => {
    if (!isResolved()) {
      continueFn?.();
      thenable.reject(value);
    }
  };
  const pause = () => {
    return new Promise((continueResolve) => {
      continueFn = (value) => {
        if (isResolved() || canContinue()) {
          continueResolve(value);
        }
      };
      config.onPause?.();
    }).then(() => {
      continueFn = void 0;
      if (!isResolved()) {
        config.onContinue?.();
      }
    });
  };
  const run = () => {
    if (isResolved()) {
      return;
    }
    let promiseOrValue;
    const initialPromise = failureCount === 0 ? config.initialPromise : void 0;
    try {
      promiseOrValue = initialPromise ?? config.fn();
    } catch (error) {
      promiseOrValue = Promise.reject(error);
    }
    Promise.resolve(promiseOrValue).then(resolve).catch((error) => {
      if (isResolved()) {
        return;
      }
      const retry = config.retry ?? (isServer ? 0 : 3);
      const retryDelay = config.retryDelay ?? defaultRetryDelay;
      const delay = typeof retryDelay === "function" ? retryDelay(failureCount, error) : retryDelay;
      const shouldRetry = retry === true || typeof retry === "number" && failureCount < retry || typeof retry === "function" && retry(failureCount, error);
      if (isRetryCancelled || !shouldRetry) {
        reject(error);
        return;
      }
      failureCount++;
      config.onFail?.(failureCount, error);
      sleep(delay).then(() => {
        return canContinue() ? void 0 : pause();
      }).then(() => {
        if (isRetryCancelled) {
          reject(error);
        } else {
          run();
        }
      });
    });
  };
  return {
    promise: thenable,
    status: () => thenable.status,
    cancel,
    continue: () => {
      continueFn?.();
      return thenable;
    },
    cancelRetry,
    continueRetry,
    canStart,
    start: () => {
      if (canStart()) {
        run();
      } else {
        pause().then(run);
      }
      return thenable;
    }
  };
}
var Removable = class {
  #gcTimeout;
  destroy() {
    this.clearGcTimeout();
  }
  scheduleGc() {
    this.clearGcTimeout();
    if (isValidTimeout(this.gcTime)) {
      this.#gcTimeout = timeoutManager.setTimeout(() => {
        this.optionalRemove();
      }, this.gcTime);
    }
  }
  updateGcTime(newGcTime) {
    this.gcTime = Math.max(
      this.gcTime || 0,
      newGcTime ?? (isServer ? Infinity : 5 * 60 * 1e3)
    );
  }
  clearGcTimeout() {
    if (this.#gcTimeout) {
      timeoutManager.clearTimeout(this.#gcTimeout);
      this.#gcTimeout = void 0;
    }
  }
};
var Query = class extends Removable {
  #initialState;
  #revertState;
  #cache;
  #client;
  #retryer;
  #defaultOptions;
  #abortSignalConsumed;
  constructor(config) {
    super();
    this.#abortSignalConsumed = false;
    this.#defaultOptions = config.defaultOptions;
    this.setOptions(config.options);
    this.observers = [];
    this.#client = config.client;
    this.#cache = this.#client.getQueryCache();
    this.queryKey = config.queryKey;
    this.queryHash = config.queryHash;
    this.#initialState = getDefaultState$1(this.options);
    this.state = config.state ?? this.#initialState;
    this.scheduleGc();
  }
  get meta() {
    return this.options.meta;
  }
  get promise() {
    return this.#retryer?.promise;
  }
  setOptions(options) {
    this.options = { ...this.#defaultOptions, ...options };
    this.updateGcTime(this.options.gcTime);
    if (this.state && this.state.data === void 0) {
      const defaultState = getDefaultState$1(this.options);
      if (defaultState.data !== void 0) {
        this.setState(
          successState(defaultState.data, defaultState.dataUpdatedAt)
        );
        this.#initialState = defaultState;
      }
    }
  }
  optionalRemove() {
    if (!this.observers.length && this.state.fetchStatus === "idle") {
      this.#cache.remove(this);
    }
  }
  setData(newData, options) {
    const data = replaceData(this.state.data, newData, this.options);
    this.#dispatch({
      data,
      type: "success",
      dataUpdatedAt: options?.updatedAt,
      manual: options?.manual
    });
    return data;
  }
  setState(state, setStateOptions) {
    this.#dispatch({ type: "setState", state, setStateOptions });
  }
  cancel(options) {
    const promise = this.#retryer?.promise;
    this.#retryer?.cancel(options);
    return promise ? promise.then(noop$1).catch(noop$1) : Promise.resolve();
  }
  destroy() {
    super.destroy();
    this.cancel({ silent: true });
  }
  reset() {
    this.destroy();
    this.setState(this.#initialState);
  }
  isActive() {
    return this.observers.some(
      (observer) => resolveEnabled(observer.options.enabled, this) !== false
    );
  }
  isDisabled() {
    if (this.getObserversCount() > 0) {
      return !this.isActive();
    }
    return this.options.queryFn === skipToken || this.state.dataUpdateCount + this.state.errorUpdateCount === 0;
  }
  isStatic() {
    if (this.getObserversCount() > 0) {
      return this.observers.some(
        (observer) => resolveStaleTime(observer.options.staleTime, this) === "static"
      );
    }
    return false;
  }
  isStale() {
    if (this.getObserversCount() > 0) {
      return this.observers.some(
        (observer) => observer.getCurrentResult().isStale
      );
    }
    return this.state.data === void 0 || this.state.isInvalidated;
  }
  isStaleByTime(staleTime = 0) {
    if (this.state.data === void 0) {
      return true;
    }
    if (staleTime === "static") {
      return false;
    }
    if (this.state.isInvalidated) {
      return true;
    }
    return !timeUntilStale(this.state.dataUpdatedAt, staleTime);
  }
  onFocus() {
    const observer = this.observers.find((x3) => x3.shouldFetchOnWindowFocus());
    observer?.refetch({ cancelRefetch: false });
    this.#retryer?.continue();
  }
  onOnline() {
    const observer = this.observers.find((x3) => x3.shouldFetchOnReconnect());
    observer?.refetch({ cancelRefetch: false });
    this.#retryer?.continue();
  }
  addObserver(observer) {
    if (!this.observers.includes(observer)) {
      this.observers.push(observer);
      this.clearGcTimeout();
      this.#cache.notify({ type: "observerAdded", query: this, observer });
    }
  }
  removeObserver(observer) {
    if (this.observers.includes(observer)) {
      this.observers = this.observers.filter((x3) => x3 !== observer);
      if (!this.observers.length) {
        if (this.#retryer) {
          if (this.#abortSignalConsumed) {
            this.#retryer.cancel({ revert: true });
          } else {
            this.#retryer.cancelRetry();
          }
        }
        this.scheduleGc();
      }
      this.#cache.notify({ type: "observerRemoved", query: this, observer });
    }
  }
  getObserversCount() {
    return this.observers.length;
  }
  invalidate() {
    if (!this.state.isInvalidated) {
      this.#dispatch({ type: "invalidate" });
    }
  }
  async fetch(options, fetchOptions) {
    if (this.state.fetchStatus !== "idle" && // If the promise in the retyer is already rejected, we have to definitely
    // re-start the fetch; there is a chance that the query is still in a
    // pending state when that happens
    this.#retryer?.status() !== "rejected") {
      if (this.state.data !== void 0 && fetchOptions?.cancelRefetch) {
        this.cancel({ silent: true });
      } else if (this.#retryer) {
        this.#retryer.continueRetry();
        return this.#retryer.promise;
      }
    }
    if (options) {
      this.setOptions(options);
    }
    if (!this.options.queryFn) {
      const observer = this.observers.find((x3) => x3.options.queryFn);
      if (observer) {
        this.setOptions(observer.options);
      }
    }
    const abortController = new AbortController();
    const addSignalProperty = (object) => {
      Object.defineProperty(object, "signal", {
        enumerable: true,
        get: () => {
          this.#abortSignalConsumed = true;
          return abortController.signal;
        }
      });
    };
    const fetchFn = () => {
      const queryFn = ensureQueryFn(this.options, fetchOptions);
      const createQueryFnContext = () => {
        const queryFnContext2 = {
          client: this.#client,
          queryKey: this.queryKey,
          meta: this.meta
        };
        addSignalProperty(queryFnContext2);
        return queryFnContext2;
      };
      const queryFnContext = createQueryFnContext();
      this.#abortSignalConsumed = false;
      if (this.options.persister) {
        return this.options.persister(
          queryFn,
          queryFnContext,
          this
        );
      }
      return queryFn(queryFnContext);
    };
    const createFetchContext = () => {
      const context2 = {
        fetchOptions,
        options: this.options,
        queryKey: this.queryKey,
        client: this.#client,
        state: this.state,
        fetchFn
      };
      addSignalProperty(context2);
      return context2;
    };
    const context = createFetchContext();
    this.options.behavior?.onFetch(context, this);
    this.#revertState = this.state;
    if (this.state.fetchStatus === "idle" || this.state.fetchMeta !== context.fetchOptions?.meta) {
      this.#dispatch({ type: "fetch", meta: context.fetchOptions?.meta });
    }
    this.#retryer = createRetryer({
      initialPromise: fetchOptions?.initialPromise,
      fn: context.fetchFn,
      onCancel: (error) => {
        if (error instanceof CancelledError && error.revert) {
          this.setState({
            ...this.#revertState,
            fetchStatus: "idle"
          });
        }
        abortController.abort();
      },
      onFail: (failureCount, error) => {
        this.#dispatch({ type: "failed", failureCount, error });
      },
      onPause: () => {
        this.#dispatch({ type: "pause" });
      },
      onContinue: () => {
        this.#dispatch({ type: "continue" });
      },
      retry: context.options.retry,
      retryDelay: context.options.retryDelay,
      networkMode: context.options.networkMode,
      canRun: () => true
    });
    try {
      const data = await this.#retryer.start();
      if (data === void 0) {
        if (false) ;
        throw new Error(`${this.queryHash} data is undefined`);
      }
      this.setData(data);
      this.#cache.config.onSuccess?.(data, this);
      this.#cache.config.onSettled?.(
        data,
        this.state.error,
        this
      );
      return data;
    } catch (error) {
      if (error instanceof CancelledError) {
        if (error.silent) {
          return this.#retryer.promise;
        } else if (error.revert) {
          if (this.state.data === void 0) {
            throw error;
          }
          return this.state.data;
        }
      }
      this.#dispatch({
        type: "error",
        error
      });
      this.#cache.config.onError?.(
        error,
        this
      );
      this.#cache.config.onSettled?.(
        this.state.data,
        error,
        this
      );
      throw error;
    } finally {
      this.scheduleGc();
    }
  }
  #dispatch(action) {
    const reducer = (state) => {
      switch (action.type) {
        case "failed":
          return {
            ...state,
            fetchFailureCount: action.failureCount,
            fetchFailureReason: action.error
          };
        case "pause":
          return {
            ...state,
            fetchStatus: "paused"
          };
        case "continue":
          return {
            ...state,
            fetchStatus: "fetching"
          };
        case "fetch":
          return {
            ...state,
            ...fetchState(state.data, this.options),
            fetchMeta: action.meta ?? null
          };
        case "success":
          const newState = {
            ...state,
            ...successState(action.data, action.dataUpdatedAt),
            dataUpdateCount: state.dataUpdateCount + 1,
            ...!action.manual && {
              fetchStatus: "idle",
              fetchFailureCount: 0,
              fetchFailureReason: null
            }
          };
          this.#revertState = action.manual ? newState : void 0;
          return newState;
        case "error":
          const error = action.error;
          return {
            ...state,
            error,
            errorUpdateCount: state.errorUpdateCount + 1,
            errorUpdatedAt: Date.now(),
            fetchFailureCount: state.fetchFailureCount + 1,
            fetchFailureReason: error,
            fetchStatus: "idle",
            status: "error"
          };
        case "invalidate":
          return {
            ...state,
            isInvalidated: true
          };
        case "setState":
          return {
            ...state,
            ...action.state
          };
      }
    };
    this.state = reducer(this.state);
    notifyManager.batch(() => {
      this.observers.forEach((observer) => {
        observer.onQueryUpdate();
      });
      this.#cache.notify({ query: this, type: "updated", action });
    });
  }
};
function fetchState(data, options) {
  return {
    fetchFailureCount: 0,
    fetchFailureReason: null,
    fetchStatus: canFetch(options.networkMode) ? "fetching" : "paused",
    ...data === void 0 && {
      error: null,
      status: "pending"
    }
  };
}
function successState(data, dataUpdatedAt) {
  return {
    data,
    dataUpdatedAt: dataUpdatedAt ?? Date.now(),
    error: null,
    isInvalidated: false,
    status: "success"
  };
}
function getDefaultState$1(options) {
  const data = typeof options.initialData === "function" ? options.initialData() : options.initialData;
  const hasData = data !== void 0;
  const initialDataUpdatedAt = hasData ? typeof options.initialDataUpdatedAt === "function" ? options.initialDataUpdatedAt() : options.initialDataUpdatedAt : 0;
  return {
    data,
    dataUpdateCount: 0,
    dataUpdatedAt: hasData ? initialDataUpdatedAt ?? Date.now() : 0,
    error: null,
    errorUpdateCount: 0,
    errorUpdatedAt: 0,
    fetchFailureCount: 0,
    fetchFailureReason: null,
    fetchMeta: null,
    isInvalidated: false,
    status: hasData ? "success" : "pending",
    fetchStatus: "idle"
  };
}
var QueryObserver = class extends Subscribable {
  constructor(client2, options) {
    super();
    this.options = options;
    this.#client = client2;
    this.#selectError = null;
    this.#currentThenable = pendingThenable();
    this.bindMethods();
    this.setOptions(options);
  }
  #client;
  #currentQuery = void 0;
  #currentQueryInitialState = void 0;
  #currentResult = void 0;
  #currentResultState;
  #currentResultOptions;
  #currentThenable;
  #selectError;
  #selectFn;
  #selectResult;
  // This property keeps track of the last query with defined data.
  // It will be used to pass the previous data and query to the placeholder function between renders.
  #lastQueryWithDefinedData;
  #staleTimeoutId;
  #refetchIntervalId;
  #currentRefetchInterval;
  #trackedProps = /* @__PURE__ */ new Set();
  bindMethods() {
    this.refetch = this.refetch.bind(this);
  }
  onSubscribe() {
    if (this.listeners.size === 1) {
      this.#currentQuery.addObserver(this);
      if (shouldFetchOnMount(this.#currentQuery, this.options)) {
        this.#executeFetch();
      } else {
        this.updateResult();
      }
      this.#updateTimers();
    }
  }
  onUnsubscribe() {
    if (!this.hasListeners()) {
      this.destroy();
    }
  }
  shouldFetchOnReconnect() {
    return shouldFetchOn(
      this.#currentQuery,
      this.options,
      this.options.refetchOnReconnect
    );
  }
  shouldFetchOnWindowFocus() {
    return shouldFetchOn(
      this.#currentQuery,
      this.options,
      this.options.refetchOnWindowFocus
    );
  }
  destroy() {
    this.listeners = /* @__PURE__ */ new Set();
    this.#clearStaleTimeout();
    this.#clearRefetchInterval();
    this.#currentQuery.removeObserver(this);
  }
  setOptions(options) {
    const prevOptions = this.options;
    const prevQuery = this.#currentQuery;
    this.options = this.#client.defaultQueryOptions(options);
    if (this.options.enabled !== void 0 && typeof this.options.enabled !== "boolean" && typeof this.options.enabled !== "function" && typeof resolveEnabled(this.options.enabled, this.#currentQuery) !== "boolean") {
      throw new Error(
        "Expected enabled to be a boolean or a callback that returns a boolean"
      );
    }
    this.#updateQuery();
    this.#currentQuery.setOptions(this.options);
    if (prevOptions._defaulted && !shallowEqualObjects(this.options, prevOptions)) {
      this.#client.getQueryCache().notify({
        type: "observerOptionsUpdated",
        query: this.#currentQuery,
        observer: this
      });
    }
    const mounted = this.hasListeners();
    if (mounted && shouldFetchOptionally(
      this.#currentQuery,
      prevQuery,
      this.options,
      prevOptions
    )) {
      this.#executeFetch();
    }
    this.updateResult();
    if (mounted && (this.#currentQuery !== prevQuery || resolveEnabled(this.options.enabled, this.#currentQuery) !== resolveEnabled(prevOptions.enabled, this.#currentQuery) || resolveStaleTime(this.options.staleTime, this.#currentQuery) !== resolveStaleTime(prevOptions.staleTime, this.#currentQuery))) {
      this.#updateStaleTimeout();
    }
    const nextRefetchInterval = this.#computeRefetchInterval();
    if (mounted && (this.#currentQuery !== prevQuery || resolveEnabled(this.options.enabled, this.#currentQuery) !== resolveEnabled(prevOptions.enabled, this.#currentQuery) || nextRefetchInterval !== this.#currentRefetchInterval)) {
      this.#updateRefetchInterval(nextRefetchInterval);
    }
  }
  getOptimisticResult(options) {
    const query = this.#client.getQueryCache().build(this.#client, options);
    const result = this.createResult(query, options);
    if (shouldAssignObserverCurrentProperties(this, result)) {
      this.#currentResult = result;
      this.#currentResultOptions = this.options;
      this.#currentResultState = this.#currentQuery.state;
    }
    return result;
  }
  getCurrentResult() {
    return this.#currentResult;
  }
  trackResult(result, onPropTracked) {
    return new Proxy(result, {
      get: (target, key) => {
        this.trackProp(key);
        onPropTracked?.(key);
        if (key === "promise") {
          this.trackProp("data");
          if (!this.options.experimental_prefetchInRender && this.#currentThenable.status === "pending") {
            this.#currentThenable.reject(
              new Error(
                "experimental_prefetchInRender feature flag is not enabled"
              )
            );
          }
        }
        return Reflect.get(target, key);
      }
    });
  }
  trackProp(key) {
    this.#trackedProps.add(key);
  }
  getCurrentQuery() {
    return this.#currentQuery;
  }
  refetch({ ...options } = {}) {
    return this.fetch({
      ...options
    });
  }
  fetchOptimistic(options) {
    const defaultedOptions = this.#client.defaultQueryOptions(options);
    const query = this.#client.getQueryCache().build(this.#client, defaultedOptions);
    return query.fetch().then(() => this.createResult(query, defaultedOptions));
  }
  fetch(fetchOptions) {
    return this.#executeFetch({
      ...fetchOptions,
      cancelRefetch: fetchOptions.cancelRefetch ?? true
    }).then(() => {
      this.updateResult();
      return this.#currentResult;
    });
  }
  #executeFetch(fetchOptions) {
    this.#updateQuery();
    let promise = this.#currentQuery.fetch(
      this.options,
      fetchOptions
    );
    if (!fetchOptions?.throwOnError) {
      promise = promise.catch(noop$1);
    }
    return promise;
  }
  #updateStaleTimeout() {
    this.#clearStaleTimeout();
    const staleTime = resolveStaleTime(
      this.options.staleTime,
      this.#currentQuery
    );
    if (isServer || this.#currentResult.isStale || !isValidTimeout(staleTime)) {
      return;
    }
    const time = timeUntilStale(this.#currentResult.dataUpdatedAt, staleTime);
    const timeout = time + 1;
    this.#staleTimeoutId = timeoutManager.setTimeout(() => {
      if (!this.#currentResult.isStale) {
        this.updateResult();
      }
    }, timeout);
  }
  #computeRefetchInterval() {
    return (typeof this.options.refetchInterval === "function" ? this.options.refetchInterval(this.#currentQuery) : this.options.refetchInterval) ?? false;
  }
  #updateRefetchInterval(nextInterval) {
    this.#clearRefetchInterval();
    this.#currentRefetchInterval = nextInterval;
    if (isServer || resolveEnabled(this.options.enabled, this.#currentQuery) === false || !isValidTimeout(this.#currentRefetchInterval) || this.#currentRefetchInterval === 0) {
      return;
    }
    this.#refetchIntervalId = timeoutManager.setInterval(() => {
      if (this.options.refetchIntervalInBackground || focusManager.isFocused()) {
        this.#executeFetch();
      }
    }, this.#currentRefetchInterval);
  }
  #updateTimers() {
    this.#updateStaleTimeout();
    this.#updateRefetchInterval(this.#computeRefetchInterval());
  }
  #clearStaleTimeout() {
    if (this.#staleTimeoutId) {
      timeoutManager.clearTimeout(this.#staleTimeoutId);
      this.#staleTimeoutId = void 0;
    }
  }
  #clearRefetchInterval() {
    if (this.#refetchIntervalId) {
      timeoutManager.clearInterval(this.#refetchIntervalId);
      this.#refetchIntervalId = void 0;
    }
  }
  createResult(query, options) {
    const prevQuery = this.#currentQuery;
    const prevOptions = this.options;
    const prevResult = this.#currentResult;
    const prevResultState = this.#currentResultState;
    const prevResultOptions = this.#currentResultOptions;
    const queryChange = query !== prevQuery;
    const queryInitialState = queryChange ? query.state : this.#currentQueryInitialState;
    const { state } = query;
    let newState = { ...state };
    let isPlaceholderData = false;
    let data;
    if (options._optimisticResults) {
      const mounted = this.hasListeners();
      const fetchOnMount = !mounted && shouldFetchOnMount(query, options);
      const fetchOptionally = mounted && shouldFetchOptionally(query, prevQuery, options, prevOptions);
      if (fetchOnMount || fetchOptionally) {
        newState = {
          ...newState,
          ...fetchState(state.data, query.options)
        };
      }
      if (options._optimisticResults === "isRestoring") {
        newState.fetchStatus = "idle";
      }
    }
    let { error, errorUpdatedAt, status } = newState;
    data = newState.data;
    let skipSelect = false;
    if (options.placeholderData !== void 0 && data === void 0 && status === "pending") {
      let placeholderData;
      if (prevResult?.isPlaceholderData && options.placeholderData === prevResultOptions?.placeholderData) {
        placeholderData = prevResult.data;
        skipSelect = true;
      } else {
        placeholderData = typeof options.placeholderData === "function" ? options.placeholderData(
          this.#lastQueryWithDefinedData?.state.data,
          this.#lastQueryWithDefinedData
        ) : options.placeholderData;
      }
      if (placeholderData !== void 0) {
        status = "success";
        data = replaceData(
          prevResult?.data,
          placeholderData,
          options
        );
        isPlaceholderData = true;
      }
    }
    if (options.select && data !== void 0 && !skipSelect) {
      if (prevResult && data === prevResultState?.data && options.select === this.#selectFn) {
        data = this.#selectResult;
      } else {
        try {
          this.#selectFn = options.select;
          data = options.select(data);
          data = replaceData(prevResult?.data, data, options);
          this.#selectResult = data;
          this.#selectError = null;
        } catch (selectError) {
          this.#selectError = selectError;
        }
      }
    }
    if (this.#selectError) {
      error = this.#selectError;
      data = this.#selectResult;
      errorUpdatedAt = Date.now();
      status = "error";
    }
    const isFetching = newState.fetchStatus === "fetching";
    const isPending = status === "pending";
    const isError = status === "error";
    const isLoading = isPending && isFetching;
    const hasData = data !== void 0;
    const result = {
      status,
      fetchStatus: newState.fetchStatus,
      isPending,
      isSuccess: status === "success",
      isError,
      isInitialLoading: isLoading,
      isLoading,
      data,
      dataUpdatedAt: newState.dataUpdatedAt,
      error,
      errorUpdatedAt,
      failureCount: newState.fetchFailureCount,
      failureReason: newState.fetchFailureReason,
      errorUpdateCount: newState.errorUpdateCount,
      isFetched: newState.dataUpdateCount > 0 || newState.errorUpdateCount > 0,
      isFetchedAfterMount: newState.dataUpdateCount > queryInitialState.dataUpdateCount || newState.errorUpdateCount > queryInitialState.errorUpdateCount,
      isFetching,
      isRefetching: isFetching && !isPending,
      isLoadingError: isError && !hasData,
      isPaused: newState.fetchStatus === "paused",
      isPlaceholderData,
      isRefetchError: isError && hasData,
      isStale: isStale(query, options),
      refetch: this.refetch,
      promise: this.#currentThenable,
      isEnabled: resolveEnabled(options.enabled, query) !== false
    };
    const nextResult = result;
    if (this.options.experimental_prefetchInRender) {
      const finalizeThenableIfPossible = (thenable) => {
        if (nextResult.status === "error") {
          thenable.reject(nextResult.error);
        } else if (nextResult.data !== void 0) {
          thenable.resolve(nextResult.data);
        }
      };
      const recreateThenable = () => {
        const pending = this.#currentThenable = nextResult.promise = pendingThenable();
        finalizeThenableIfPossible(pending);
      };
      const prevThenable = this.#currentThenable;
      switch (prevThenable.status) {
        case "pending":
          if (query.queryHash === prevQuery.queryHash) {
            finalizeThenableIfPossible(prevThenable);
          }
          break;
        case "fulfilled":
          if (nextResult.status === "error" || nextResult.data !== prevThenable.value) {
            recreateThenable();
          }
          break;
        case "rejected":
          if (nextResult.status !== "error" || nextResult.error !== prevThenable.reason) {
            recreateThenable();
          }
          break;
      }
    }
    return nextResult;
  }
  updateResult() {
    const prevResult = this.#currentResult;
    const nextResult = this.createResult(this.#currentQuery, this.options);
    this.#currentResultState = this.#currentQuery.state;
    this.#currentResultOptions = this.options;
    if (this.#currentResultState.data !== void 0) {
      this.#lastQueryWithDefinedData = this.#currentQuery;
    }
    if (shallowEqualObjects(nextResult, prevResult)) {
      return;
    }
    this.#currentResult = nextResult;
    const shouldNotifyListeners = () => {
      if (!prevResult) {
        return true;
      }
      const { notifyOnChangeProps } = this.options;
      const notifyOnChangePropsValue = typeof notifyOnChangeProps === "function" ? notifyOnChangeProps() : notifyOnChangeProps;
      if (notifyOnChangePropsValue === "all" || !notifyOnChangePropsValue && !this.#trackedProps.size) {
        return true;
      }
      const includedProps = new Set(
        notifyOnChangePropsValue ?? this.#trackedProps
      );
      if (this.options.throwOnError) {
        includedProps.add("error");
      }
      return Object.keys(this.#currentResult).some((key) => {
        const typedKey = key;
        const changed = this.#currentResult[typedKey] !== prevResult[typedKey];
        return changed && includedProps.has(typedKey);
      });
    };
    this.#notify({ listeners: shouldNotifyListeners() });
  }
  #updateQuery() {
    const query = this.#client.getQueryCache().build(this.#client, this.options);
    if (query === this.#currentQuery) {
      return;
    }
    const prevQuery = this.#currentQuery;
    this.#currentQuery = query;
    this.#currentQueryInitialState = query.state;
    if (this.hasListeners()) {
      prevQuery?.removeObserver(this);
      query.addObserver(this);
    }
  }
  onQueryUpdate() {
    this.updateResult();
    if (this.hasListeners()) {
      this.#updateTimers();
    }
  }
  #notify(notifyOptions) {
    notifyManager.batch(() => {
      if (notifyOptions.listeners) {
        this.listeners.forEach((listener) => {
          listener(this.#currentResult);
        });
      }
      this.#client.getQueryCache().notify({
        query: this.#currentQuery,
        type: "observerResultsUpdated"
      });
    });
  }
};
function shouldLoadOnMount(query, options) {
  return resolveEnabled(options.enabled, query) !== false && query.state.data === void 0 && !(query.state.status === "error" && options.retryOnMount === false);
}
function shouldFetchOnMount(query, options) {
  return shouldLoadOnMount(query, options) || query.state.data !== void 0 && shouldFetchOn(query, options, options.refetchOnMount);
}
function shouldFetchOn(query, options, field) {
  if (resolveEnabled(options.enabled, query) !== false && resolveStaleTime(options.staleTime, query) !== "static") {
    const value = typeof field === "function" ? field(query) : field;
    return value === "always" || value !== false && isStale(query, options);
  }
  return false;
}
function shouldFetchOptionally(query, prevQuery, options, prevOptions) {
  return (query !== prevQuery || resolveEnabled(prevOptions.enabled, query) === false) && (!options.suspense || query.state.status !== "error") && isStale(query, options);
}
function isStale(query, options) {
  return resolveEnabled(options.enabled, query) !== false && query.isStaleByTime(resolveStaleTime(options.staleTime, query));
}
function shouldAssignObserverCurrentProperties(observer, optimisticResult) {
  if (!shallowEqualObjects(observer.getCurrentResult(), optimisticResult)) {
    return true;
  }
  return false;
}
function infiniteQueryBehavior(pages) {
  return {
    onFetch: (context, query) => {
      const options = context.options;
      const direction = context.fetchOptions?.meta?.fetchMore?.direction;
      const oldPages = context.state.data?.pages || [];
      const oldPageParams = context.state.data?.pageParams || [];
      let result = { pages: [], pageParams: [] };
      let currentPage = 0;
      const fetchFn = async () => {
        let cancelled = false;
        const addSignalProperty = (object) => {
          Object.defineProperty(object, "signal", {
            enumerable: true,
            get: () => {
              if (context.signal.aborted) {
                cancelled = true;
              } else {
                context.signal.addEventListener("abort", () => {
                  cancelled = true;
                });
              }
              return context.signal;
            }
          });
        };
        const queryFn = ensureQueryFn(context.options, context.fetchOptions);
        const fetchPage = async (data, param, previous) => {
          if (cancelled) {
            return Promise.reject();
          }
          if (param == null && data.pages.length) {
            return Promise.resolve(data);
          }
          const createQueryFnContext = () => {
            const queryFnContext2 = {
              client: context.client,
              queryKey: context.queryKey,
              pageParam: param,
              direction: previous ? "backward" : "forward",
              meta: context.options.meta
            };
            addSignalProperty(queryFnContext2);
            return queryFnContext2;
          };
          const queryFnContext = createQueryFnContext();
          const page = await queryFn(queryFnContext);
          const { maxPages } = context.options;
          const addTo = previous ? addToStart : addToEnd;
          return {
            pages: addTo(data.pages, page, maxPages),
            pageParams: addTo(data.pageParams, param, maxPages)
          };
        };
        if (direction && oldPages.length) {
          const previous = direction === "backward";
          const pageParamFn = previous ? getPreviousPageParam : getNextPageParam;
          const oldData = {
            pages: oldPages,
            pageParams: oldPageParams
          };
          const param = pageParamFn(options, oldData);
          result = await fetchPage(oldData, param, previous);
        } else {
          const remainingPages = pages ?? oldPages.length;
          do {
            const param = currentPage === 0 ? oldPageParams[0] ?? options.initialPageParam : getNextPageParam(options, result);
            if (currentPage > 0 && param == null) {
              break;
            }
            result = await fetchPage(result, param);
            currentPage++;
          } while (currentPage < remainingPages);
        }
        return result;
      };
      if (context.options.persister) {
        context.fetchFn = () => {
          return context.options.persister?.(
            fetchFn,
            {
              client: context.client,
              queryKey: context.queryKey,
              meta: context.options.meta,
              signal: context.signal
            },
            query
          );
        };
      } else {
        context.fetchFn = fetchFn;
      }
    }
  };
}
function getNextPageParam(options, { pages, pageParams }) {
  const lastIndex = pages.length - 1;
  return pages.length > 0 ? options.getNextPageParam(
    pages[lastIndex],
    pages,
    pageParams[lastIndex],
    pageParams
  ) : void 0;
}
function getPreviousPageParam(options, { pages, pageParams }) {
  return pages.length > 0 ? options.getPreviousPageParam?.(pages[0], pages, pageParams[0], pageParams) : void 0;
}
var Mutation = class extends Removable {
  #client;
  #observers;
  #mutationCache;
  #retryer;
  constructor(config) {
    super();
    this.#client = config.client;
    this.mutationId = config.mutationId;
    this.#mutationCache = config.mutationCache;
    this.#observers = [];
    this.state = config.state || getDefaultState();
    this.setOptions(config.options);
    this.scheduleGc();
  }
  setOptions(options) {
    this.options = options;
    this.updateGcTime(this.options.gcTime);
  }
  get meta() {
    return this.options.meta;
  }
  addObserver(observer) {
    if (!this.#observers.includes(observer)) {
      this.#observers.push(observer);
      this.clearGcTimeout();
      this.#mutationCache.notify({
        type: "observerAdded",
        mutation: this,
        observer
      });
    }
  }
  removeObserver(observer) {
    this.#observers = this.#observers.filter((x3) => x3 !== observer);
    this.scheduleGc();
    this.#mutationCache.notify({
      type: "observerRemoved",
      mutation: this,
      observer
    });
  }
  optionalRemove() {
    if (!this.#observers.length) {
      if (this.state.status === "pending") {
        this.scheduleGc();
      } else {
        this.#mutationCache.remove(this);
      }
    }
  }
  continue() {
    return this.#retryer?.continue() ?? // continuing a mutation assumes that variables are set, mutation must have been dehydrated before
    this.execute(this.state.variables);
  }
  async execute(variables) {
    const onContinue = () => {
      this.#dispatch({ type: "continue" });
    };
    const mutationFnContext = {
      client: this.#client,
      meta: this.options.meta,
      mutationKey: this.options.mutationKey
    };
    this.#retryer = createRetryer({
      fn: () => {
        if (!this.options.mutationFn) {
          return Promise.reject(new Error("No mutationFn found"));
        }
        return this.options.mutationFn(variables, mutationFnContext);
      },
      onFail: (failureCount, error) => {
        this.#dispatch({ type: "failed", failureCount, error });
      },
      onPause: () => {
        this.#dispatch({ type: "pause" });
      },
      onContinue,
      retry: this.options.retry ?? 0,
      retryDelay: this.options.retryDelay,
      networkMode: this.options.networkMode,
      canRun: () => this.#mutationCache.canRun(this)
    });
    const restored = this.state.status === "pending";
    const isPaused = !this.#retryer.canStart();
    try {
      if (restored) {
        onContinue();
      } else {
        this.#dispatch({ type: "pending", variables, isPaused });
        await this.#mutationCache.config.onMutate?.(
          variables,
          this,
          mutationFnContext
        );
        const context = await this.options.onMutate?.(
          variables,
          mutationFnContext
        );
        if (context !== this.state.context) {
          this.#dispatch({
            type: "pending",
            context,
            variables,
            isPaused
          });
        }
      }
      const data = await this.#retryer.start();
      await this.#mutationCache.config.onSuccess?.(
        data,
        variables,
        this.state.context,
        this,
        mutationFnContext
      );
      await this.options.onSuccess?.(
        data,
        variables,
        this.state.context,
        mutationFnContext
      );
      await this.#mutationCache.config.onSettled?.(
        data,
        null,
        this.state.variables,
        this.state.context,
        this,
        mutationFnContext
      );
      await this.options.onSettled?.(
        data,
        null,
        variables,
        this.state.context,
        mutationFnContext
      );
      this.#dispatch({ type: "success", data });
      return data;
    } catch (error) {
      try {
        await this.#mutationCache.config.onError?.(
          error,
          variables,
          this.state.context,
          this,
          mutationFnContext
        );
        await this.options.onError?.(
          error,
          variables,
          this.state.context,
          mutationFnContext
        );
        await this.#mutationCache.config.onSettled?.(
          void 0,
          error,
          this.state.variables,
          this.state.context,
          this,
          mutationFnContext
        );
        await this.options.onSettled?.(
          void 0,
          error,
          variables,
          this.state.context,
          mutationFnContext
        );
        throw error;
      } finally {
        this.#dispatch({ type: "error", error });
      }
    } finally {
      this.#mutationCache.runNext(this);
    }
  }
  #dispatch(action) {
    const reducer = (state) => {
      switch (action.type) {
        case "failed":
          return {
            ...state,
            failureCount: action.failureCount,
            failureReason: action.error
          };
        case "pause":
          return {
            ...state,
            isPaused: true
          };
        case "continue":
          return {
            ...state,
            isPaused: false
          };
        case "pending":
          return {
            ...state,
            context: action.context,
            data: void 0,
            failureCount: 0,
            failureReason: null,
            error: null,
            isPaused: action.isPaused,
            status: "pending",
            variables: action.variables,
            submittedAt: Date.now()
          };
        case "success":
          return {
            ...state,
            data: action.data,
            failureCount: 0,
            failureReason: null,
            error: null,
            status: "success",
            isPaused: false
          };
        case "error":
          return {
            ...state,
            data: void 0,
            error: action.error,
            failureCount: state.failureCount + 1,
            failureReason: action.error,
            isPaused: false,
            status: "error"
          };
      }
    };
    this.state = reducer(this.state);
    notifyManager.batch(() => {
      this.#observers.forEach((observer) => {
        observer.onMutationUpdate(action);
      });
      this.#mutationCache.notify({
        mutation: this,
        type: "updated",
        action
      });
    });
  }
};
function getDefaultState() {
  return {
    context: void 0,
    data: void 0,
    error: null,
    failureCount: 0,
    failureReason: null,
    isPaused: false,
    status: "idle",
    variables: void 0,
    submittedAt: 0
  };
}
var MutationCache = class extends Subscribable {
  constructor(config = {}) {
    super();
    this.config = config;
    this.#mutations = /* @__PURE__ */ new Set();
    this.#scopes = /* @__PURE__ */ new Map();
    this.#mutationId = 0;
  }
  #mutations;
  #scopes;
  #mutationId;
  build(client2, options, state) {
    const mutation = new Mutation({
      client: client2,
      mutationCache: this,
      mutationId: ++this.#mutationId,
      options: client2.defaultMutationOptions(options),
      state
    });
    this.add(mutation);
    return mutation;
  }
  add(mutation) {
    this.#mutations.add(mutation);
    const scope = scopeFor(mutation);
    if (typeof scope === "string") {
      const scopedMutations = this.#scopes.get(scope);
      if (scopedMutations) {
        scopedMutations.push(mutation);
      } else {
        this.#scopes.set(scope, [mutation]);
      }
    }
    this.notify({ type: "added", mutation });
  }
  remove(mutation) {
    if (this.#mutations.delete(mutation)) {
      const scope = scopeFor(mutation);
      if (typeof scope === "string") {
        const scopedMutations = this.#scopes.get(scope);
        if (scopedMutations) {
          if (scopedMutations.length > 1) {
            const index2 = scopedMutations.indexOf(mutation);
            if (index2 !== -1) {
              scopedMutations.splice(index2, 1);
            }
          } else if (scopedMutations[0] === mutation) {
            this.#scopes.delete(scope);
          }
        }
      }
    }
    this.notify({ type: "removed", mutation });
  }
  canRun(mutation) {
    const scope = scopeFor(mutation);
    if (typeof scope === "string") {
      const mutationsWithSameScope = this.#scopes.get(scope);
      const firstPendingMutation = mutationsWithSameScope?.find(
        (m3) => m3.state.status === "pending"
      );
      return !firstPendingMutation || firstPendingMutation === mutation;
    } else {
      return true;
    }
  }
  runNext(mutation) {
    const scope = scopeFor(mutation);
    if (typeof scope === "string") {
      const foundMutation = this.#scopes.get(scope)?.find((m3) => m3 !== mutation && m3.state.isPaused);
      return foundMutation?.continue() ?? Promise.resolve();
    } else {
      return Promise.resolve();
    }
  }
  clear() {
    notifyManager.batch(() => {
      this.#mutations.forEach((mutation) => {
        this.notify({ type: "removed", mutation });
      });
      this.#mutations.clear();
      this.#scopes.clear();
    });
  }
  getAll() {
    return Array.from(this.#mutations);
  }
  find(filters) {
    const defaultedFilters = { exact: true, ...filters };
    return this.getAll().find(
      (mutation) => matchMutation(defaultedFilters, mutation)
    );
  }
  findAll(filters = {}) {
    return this.getAll().filter((mutation) => matchMutation(filters, mutation));
  }
  notify(event) {
    notifyManager.batch(() => {
      this.listeners.forEach((listener) => {
        listener(event);
      });
    });
  }
  resumePausedMutations() {
    const pausedMutations = this.getAll().filter((x3) => x3.state.isPaused);
    return notifyManager.batch(
      () => Promise.all(
        pausedMutations.map((mutation) => mutation.continue().catch(noop$1))
      )
    );
  }
};
function scopeFor(mutation) {
  return mutation.options.scope?.id;
}
var MutationObserver$1 = class MutationObserver2 extends Subscribable {
  #client;
  #currentResult = void 0;
  #currentMutation;
  #mutateOptions;
  constructor(client2, options) {
    super();
    this.#client = client2;
    this.setOptions(options);
    this.bindMethods();
    this.#updateResult();
  }
  bindMethods() {
    this.mutate = this.mutate.bind(this);
    this.reset = this.reset.bind(this);
  }
  setOptions(options) {
    const prevOptions = this.options;
    this.options = this.#client.defaultMutationOptions(options);
    if (!shallowEqualObjects(this.options, prevOptions)) {
      this.#client.getMutationCache().notify({
        type: "observerOptionsUpdated",
        mutation: this.#currentMutation,
        observer: this
      });
    }
    if (prevOptions?.mutationKey && this.options.mutationKey && hashKey(prevOptions.mutationKey) !== hashKey(this.options.mutationKey)) {
      this.reset();
    } else if (this.#currentMutation?.state.status === "pending") {
      this.#currentMutation.setOptions(this.options);
    }
  }
  onUnsubscribe() {
    if (!this.hasListeners()) {
      this.#currentMutation?.removeObserver(this);
    }
  }
  onMutationUpdate(action) {
    this.#updateResult();
    this.#notify(action);
  }
  getCurrentResult() {
    return this.#currentResult;
  }
  reset() {
    this.#currentMutation?.removeObserver(this);
    this.#currentMutation = void 0;
    this.#updateResult();
    this.#notify();
  }
  mutate(variables, options) {
    this.#mutateOptions = options;
    this.#currentMutation?.removeObserver(this);
    this.#currentMutation = this.#client.getMutationCache().build(this.#client, this.options);
    this.#currentMutation.addObserver(this);
    return this.#currentMutation.execute(variables);
  }
  #updateResult() {
    const state = this.#currentMutation?.state ?? getDefaultState();
    this.#currentResult = {
      ...state,
      isPending: state.status === "pending",
      isSuccess: state.status === "success",
      isError: state.status === "error",
      isIdle: state.status === "idle",
      mutate: this.mutate,
      reset: this.reset
    };
  }
  #notify(action) {
    notifyManager.batch(() => {
      if (this.#mutateOptions && this.hasListeners()) {
        const variables = this.#currentResult.variables;
        const onMutateResult = this.#currentResult.context;
        const context = {
          client: this.#client,
          meta: this.options.meta,
          mutationKey: this.options.mutationKey
        };
        if (action?.type === "success") {
          this.#mutateOptions.onSuccess?.(
            action.data,
            variables,
            onMutateResult,
            context
          );
          this.#mutateOptions.onSettled?.(
            action.data,
            null,
            variables,
            onMutateResult,
            context
          );
        } else if (action?.type === "error") {
          this.#mutateOptions.onError?.(
            action.error,
            variables,
            onMutateResult,
            context
          );
          this.#mutateOptions.onSettled?.(
            void 0,
            action.error,
            variables,
            onMutateResult,
            context
          );
        }
      }
      this.listeners.forEach((listener) => {
        listener(this.#currentResult);
      });
    });
  }
};
var QueryCache = class extends Subscribable {
  constructor(config = {}) {
    super();
    this.config = config;
    this.#queries = /* @__PURE__ */ new Map();
  }
  #queries;
  build(client2, options, state) {
    const queryKey = options.queryKey;
    const queryHash = options.queryHash ?? hashQueryKeyByOptions(queryKey, options);
    let query = this.get(queryHash);
    if (!query) {
      query = new Query({
        client: client2,
        queryKey,
        queryHash,
        options: client2.defaultQueryOptions(options),
        state,
        defaultOptions: client2.getQueryDefaults(queryKey)
      });
      this.add(query);
    }
    return query;
  }
  add(query) {
    if (!this.#queries.has(query.queryHash)) {
      this.#queries.set(query.queryHash, query);
      this.notify({
        type: "added",
        query
      });
    }
  }
  remove(query) {
    const queryInMap = this.#queries.get(query.queryHash);
    if (queryInMap) {
      query.destroy();
      if (queryInMap === query) {
        this.#queries.delete(query.queryHash);
      }
      this.notify({ type: "removed", query });
    }
  }
  clear() {
    notifyManager.batch(() => {
      this.getAll().forEach((query) => {
        this.remove(query);
      });
    });
  }
  get(queryHash) {
    return this.#queries.get(queryHash);
  }
  getAll() {
    return [...this.#queries.values()];
  }
  find(filters) {
    const defaultedFilters = { exact: true, ...filters };
    return this.getAll().find(
      (query) => matchQuery(defaultedFilters, query)
    );
  }
  findAll(filters = {}) {
    const queries = this.getAll();
    return Object.keys(filters).length > 0 ? queries.filter((query) => matchQuery(filters, query)) : queries;
  }
  notify(event) {
    notifyManager.batch(() => {
      this.listeners.forEach((listener) => {
        listener(event);
      });
    });
  }
  onFocus() {
    notifyManager.batch(() => {
      this.getAll().forEach((query) => {
        query.onFocus();
      });
    });
  }
  onOnline() {
    notifyManager.batch(() => {
      this.getAll().forEach((query) => {
        query.onOnline();
      });
    });
  }
};
var QueryClient = class {
  #queryCache;
  #mutationCache;
  #defaultOptions;
  #queryDefaults;
  #mutationDefaults;
  #mountCount;
  #unsubscribeFocus;
  #unsubscribeOnline;
  constructor(config = {}) {
    this.#queryCache = config.queryCache || new QueryCache();
    this.#mutationCache = config.mutationCache || new MutationCache();
    this.#defaultOptions = config.defaultOptions || {};
    this.#queryDefaults = /* @__PURE__ */ new Map();
    this.#mutationDefaults = /* @__PURE__ */ new Map();
    this.#mountCount = 0;
  }
  mount() {
    this.#mountCount++;
    if (this.#mountCount !== 1) return;
    this.#unsubscribeFocus = focusManager.subscribe(async (focused) => {
      if (focused) {
        await this.resumePausedMutations();
        this.#queryCache.onFocus();
      }
    });
    this.#unsubscribeOnline = onlineManager.subscribe(async (online) => {
      if (online) {
        await this.resumePausedMutations();
        this.#queryCache.onOnline();
      }
    });
  }
  unmount() {
    this.#mountCount--;
    if (this.#mountCount !== 0) return;
    this.#unsubscribeFocus?.();
    this.#unsubscribeFocus = void 0;
    this.#unsubscribeOnline?.();
    this.#unsubscribeOnline = void 0;
  }
  isFetching(filters) {
    return this.#queryCache.findAll({ ...filters, fetchStatus: "fetching" }).length;
  }
  isMutating(filters) {
    return this.#mutationCache.findAll({ ...filters, status: "pending" }).length;
  }
  /**
   * Imperative (non-reactive) way to retrieve data for a QueryKey.
   * Should only be used in callbacks or functions where reading the latest data is necessary, e.g. for optimistic updates.
   *
   * Hint: Do not use this function inside a component, because it won't receive updates.
   * Use `useQuery` to create a `QueryObserver` that subscribes to changes.
   */
  getQueryData(queryKey) {
    const options = this.defaultQueryOptions({ queryKey });
    return this.#queryCache.get(options.queryHash)?.state.data;
  }
  ensureQueryData(options) {
    const defaultedOptions = this.defaultQueryOptions(options);
    const query = this.#queryCache.build(this, defaultedOptions);
    const cachedData = query.state.data;
    if (cachedData === void 0) {
      return this.fetchQuery(options);
    }
    if (options.revalidateIfStale && query.isStaleByTime(resolveStaleTime(defaultedOptions.staleTime, query))) {
      void this.prefetchQuery(defaultedOptions);
    }
    return Promise.resolve(cachedData);
  }
  getQueriesData(filters) {
    return this.#queryCache.findAll(filters).map(({ queryKey, state }) => {
      const data = state.data;
      return [queryKey, data];
    });
  }
  setQueryData(queryKey, updater, options) {
    const defaultedOptions = this.defaultQueryOptions({ queryKey });
    const query = this.#queryCache.get(
      defaultedOptions.queryHash
    );
    const prevData = query?.state.data;
    const data = functionalUpdate(updater, prevData);
    if (data === void 0) {
      return void 0;
    }
    return this.#queryCache.build(this, defaultedOptions).setData(data, { ...options, manual: true });
  }
  setQueriesData(filters, updater, options) {
    return notifyManager.batch(
      () => this.#queryCache.findAll(filters).map(({ queryKey }) => [
        queryKey,
        this.setQueryData(queryKey, updater, options)
      ])
    );
  }
  getQueryState(queryKey) {
    const options = this.defaultQueryOptions({ queryKey });
    return this.#queryCache.get(
      options.queryHash
    )?.state;
  }
  removeQueries(filters) {
    const queryCache = this.#queryCache;
    notifyManager.batch(() => {
      queryCache.findAll(filters).forEach((query) => {
        queryCache.remove(query);
      });
    });
  }
  resetQueries(filters, options) {
    const queryCache = this.#queryCache;
    return notifyManager.batch(() => {
      queryCache.findAll(filters).forEach((query) => {
        query.reset();
      });
      return this.refetchQueries(
        {
          type: "active",
          ...filters
        },
        options
      );
    });
  }
  cancelQueries(filters, cancelOptions = {}) {
    const defaultedCancelOptions = { revert: true, ...cancelOptions };
    const promises = notifyManager.batch(
      () => this.#queryCache.findAll(filters).map((query) => query.cancel(defaultedCancelOptions))
    );
    return Promise.all(promises).then(noop$1).catch(noop$1);
  }
  invalidateQueries(filters, options = {}) {
    return notifyManager.batch(() => {
      this.#queryCache.findAll(filters).forEach((query) => {
        query.invalidate();
      });
      if (filters?.refetchType === "none") {
        return Promise.resolve();
      }
      return this.refetchQueries(
        {
          ...filters,
          type: filters?.refetchType ?? filters?.type ?? "active"
        },
        options
      );
    });
  }
  refetchQueries(filters, options = {}) {
    const fetchOptions = {
      ...options,
      cancelRefetch: options.cancelRefetch ?? true
    };
    const promises = notifyManager.batch(
      () => this.#queryCache.findAll(filters).filter((query) => !query.isDisabled() && !query.isStatic()).map((query) => {
        let promise = query.fetch(void 0, fetchOptions);
        if (!fetchOptions.throwOnError) {
          promise = promise.catch(noop$1);
        }
        return query.state.fetchStatus === "paused" ? Promise.resolve() : promise;
      })
    );
    return Promise.all(promises).then(noop$1);
  }
  fetchQuery(options) {
    const defaultedOptions = this.defaultQueryOptions(options);
    if (defaultedOptions.retry === void 0) {
      defaultedOptions.retry = false;
    }
    const query = this.#queryCache.build(this, defaultedOptions);
    return query.isStaleByTime(
      resolveStaleTime(defaultedOptions.staleTime, query)
    ) ? query.fetch(defaultedOptions) : Promise.resolve(query.state.data);
  }
  prefetchQuery(options) {
    return this.fetchQuery(options).then(noop$1).catch(noop$1);
  }
  fetchInfiniteQuery(options) {
    options.behavior = infiniteQueryBehavior(options.pages);
    return this.fetchQuery(options);
  }
  prefetchInfiniteQuery(options) {
    return this.fetchInfiniteQuery(options).then(noop$1).catch(noop$1);
  }
  ensureInfiniteQueryData(options) {
    options.behavior = infiniteQueryBehavior(options.pages);
    return this.ensureQueryData(options);
  }
  resumePausedMutations() {
    if (onlineManager.isOnline()) {
      return this.#mutationCache.resumePausedMutations();
    }
    return Promise.resolve();
  }
  getQueryCache() {
    return this.#queryCache;
  }
  getMutationCache() {
    return this.#mutationCache;
  }
  getDefaultOptions() {
    return this.#defaultOptions;
  }
  setDefaultOptions(options) {
    this.#defaultOptions = options;
  }
  setQueryDefaults(queryKey, options) {
    this.#queryDefaults.set(hashKey(queryKey), {
      queryKey,
      defaultOptions: options
    });
  }
  getQueryDefaults(queryKey) {
    const defaults = [...this.#queryDefaults.values()];
    const result = {};
    defaults.forEach((queryDefault) => {
      if (partialMatchKey(queryKey, queryDefault.queryKey)) {
        Object.assign(result, queryDefault.defaultOptions);
      }
    });
    return result;
  }
  setMutationDefaults(mutationKey, options) {
    this.#mutationDefaults.set(hashKey(mutationKey), {
      mutationKey,
      defaultOptions: options
    });
  }
  getMutationDefaults(mutationKey) {
    const defaults = [...this.#mutationDefaults.values()];
    const result = {};
    defaults.forEach((queryDefault) => {
      if (partialMatchKey(mutationKey, queryDefault.mutationKey)) {
        Object.assign(result, queryDefault.defaultOptions);
      }
    });
    return result;
  }
  defaultQueryOptions(options) {
    if (options._defaulted) {
      return options;
    }
    const defaultedOptions = {
      ...this.#defaultOptions.queries,
      ...this.getQueryDefaults(options.queryKey),
      ...options,
      _defaulted: true
    };
    if (!defaultedOptions.queryHash) {
      defaultedOptions.queryHash = hashQueryKeyByOptions(
        defaultedOptions.queryKey,
        defaultedOptions
      );
    }
    if (defaultedOptions.refetchOnReconnect === void 0) {
      defaultedOptions.refetchOnReconnect = defaultedOptions.networkMode !== "always";
    }
    if (defaultedOptions.throwOnError === void 0) {
      defaultedOptions.throwOnError = !!defaultedOptions.suspense;
    }
    if (!defaultedOptions.networkMode && defaultedOptions.persister) {
      defaultedOptions.networkMode = "offlineFirst";
    }
    if (defaultedOptions.queryFn === skipToken) {
      defaultedOptions.enabled = false;
    }
    return defaultedOptions;
  }
  defaultMutationOptions(options) {
    if (options?._defaulted) {
      return options;
    }
    return {
      ...this.#defaultOptions.mutations,
      ...options?.mutationKey && this.getMutationDefaults(options.mutationKey),
      ...options,
      _defaulted: true
    };
  }
  clear() {
    this.#queryCache.clear();
    this.#mutationCache.clear();
  }
};
var QueryClientContext = reactExports.createContext(
  void 0
);
var useQueryClient = (queryClient2) => {
  const client2 = reactExports.useContext(QueryClientContext);
  if (!client2) {
    throw new Error("No QueryClient set, use QueryClientProvider to set one");
  }
  return client2;
};
var QueryClientProvider = ({
  client: client2,
  children
}) => {
  reactExports.useEffect(() => {
    client2.mount();
    return () => {
      client2.unmount();
    };
  }, [client2]);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(QueryClientContext.Provider, { value: client2, children });
};
var IsRestoringContext = reactExports.createContext(false);
var useIsRestoring = () => reactExports.useContext(IsRestoringContext);
IsRestoringContext.Provider;
function createValue() {
  let isReset = false;
  return {
    clearReset: () => {
      isReset = false;
    },
    reset: () => {
      isReset = true;
    },
    isReset: () => {
      return isReset;
    }
  };
}
var QueryErrorResetBoundaryContext = reactExports.createContext(createValue());
var useQueryErrorResetBoundary = () => reactExports.useContext(QueryErrorResetBoundaryContext);
var ensurePreventErrorBoundaryRetry = (options, errorResetBoundary) => {
  if (options.suspense || options.throwOnError || options.experimental_prefetchInRender) {
    if (!errorResetBoundary.isReset()) {
      options.retryOnMount = false;
    }
  }
};
var useClearResetErrorBoundary = (errorResetBoundary) => {
  reactExports.useEffect(() => {
    errorResetBoundary.clearReset();
  }, [errorResetBoundary]);
};
var getHasError = ({
  result,
  errorResetBoundary,
  throwOnError,
  query,
  suspense
}) => {
  return result.isError && !errorResetBoundary.isReset() && !result.isFetching && query && (suspense && result.data === void 0 || shouldThrowError(throwOnError, [result.error, query]));
};
var ensureSuspenseTimers = (defaultedOptions) => {
  if (defaultedOptions.suspense) {
    const MIN_SUSPENSE_TIME_MS = 1e3;
    const clamp2 = (value) => value === "static" ? value : Math.max(value ?? MIN_SUSPENSE_TIME_MS, MIN_SUSPENSE_TIME_MS);
    const originalStaleTime = defaultedOptions.staleTime;
    defaultedOptions.staleTime = typeof originalStaleTime === "function" ? (...args) => clamp2(originalStaleTime(...args)) : clamp2(originalStaleTime);
    if (typeof defaultedOptions.gcTime === "number") {
      defaultedOptions.gcTime = Math.max(
        defaultedOptions.gcTime,
        MIN_SUSPENSE_TIME_MS
      );
    }
  }
};
var willFetch = (result, isRestoring) => result.isLoading && result.isFetching && !isRestoring;
var shouldSuspend = (defaultedOptions, result) => defaultedOptions?.suspense && result.isPending;
var fetchOptimistic = (defaultedOptions, observer, errorResetBoundary) => observer.fetchOptimistic(defaultedOptions).catch(() => {
  errorResetBoundary.clearReset();
});
function useBaseQuery(options, Observer, queryClient2) {
  const isRestoring = useIsRestoring();
  const errorResetBoundary = useQueryErrorResetBoundary();
  const client2 = useQueryClient();
  const defaultedOptions = client2.defaultQueryOptions(options);
  client2.getDefaultOptions().queries?._experimental_beforeQuery?.(
    defaultedOptions
  );
  defaultedOptions._optimisticResults = isRestoring ? "isRestoring" : "optimistic";
  ensureSuspenseTimers(defaultedOptions);
  ensurePreventErrorBoundaryRetry(defaultedOptions, errorResetBoundary);
  useClearResetErrorBoundary(errorResetBoundary);
  const isNewCacheEntry = !client2.getQueryCache().get(defaultedOptions.queryHash);
  const [observer] = reactExports.useState(
    () => new Observer(
      client2,
      defaultedOptions
    )
  );
  const result = observer.getOptimisticResult(defaultedOptions);
  const shouldSubscribe = !isRestoring && options.subscribed !== false;
  reactExports.useSyncExternalStore(
    reactExports.useCallback(
      (onStoreChange) => {
        const unsubscribe = shouldSubscribe ? observer.subscribe(notifyManager.batchCalls(onStoreChange)) : noop$1;
        observer.updateResult();
        return unsubscribe;
      },
      [observer, shouldSubscribe]
    ),
    () => observer.getCurrentResult(),
    () => observer.getCurrentResult()
  );
  reactExports.useEffect(() => {
    observer.setOptions(defaultedOptions);
  }, [defaultedOptions, observer]);
  if (shouldSuspend(defaultedOptions, result)) {
    throw fetchOptimistic(defaultedOptions, observer, errorResetBoundary);
  }
  if (getHasError({
    result,
    errorResetBoundary,
    throwOnError: defaultedOptions.throwOnError,
    query: client2.getQueryCache().get(defaultedOptions.queryHash),
    suspense: defaultedOptions.suspense
  })) {
    throw result.error;
  }
  client2.getDefaultOptions().queries?._experimental_afterQuery?.(
    defaultedOptions,
    result
  );
  if (defaultedOptions.experimental_prefetchInRender && !isServer && willFetch(result, isRestoring)) {
    const promise = isNewCacheEntry ? (
      // Fetch immediately on render in order to ensure `.promise` is resolved even if the component is unmounted
      fetchOptimistic(defaultedOptions, observer, errorResetBoundary)
    ) : (
      // subscribe to the "cache promise" so that we can finalize the currentThenable once data comes in
      client2.getQueryCache().get(defaultedOptions.queryHash)?.promise
    );
    promise?.catch(noop$1).finally(() => {
      observer.updateResult();
    });
  }
  return !defaultedOptions.notifyOnChangeProps ? observer.trackResult(result) : result;
}
function useQuery(options, queryClient2) {
  return useBaseQuery(options, QueryObserver);
}
function useMutation(options, queryClient2) {
  const client2 = useQueryClient();
  const [observer] = reactExports.useState(
    () => new MutationObserver$1(
      client2,
      options
    )
  );
  reactExports.useEffect(() => {
    observer.setOptions(options);
  }, [observer, options]);
  const result = reactExports.useSyncExternalStore(
    reactExports.useCallback(
      (onStoreChange) => observer.subscribe(notifyManager.batchCalls(onStoreChange)),
      [observer]
    ),
    () => observer.getCurrentResult(),
    () => observer.getCurrentResult()
  );
  const mutate = reactExports.useCallback(
    (variables, mutateOptions) => {
      observer.mutate(variables, mutateOptions).catch(noop$1);
    },
    [observer]
  );
  if (result.error && shouldThrowError(observer.options.throwOnError, [result.error])) {
    throw result.error;
  }
  return { ...result, mutate, mutateAsync: result.mutate };
}
const scriptRel = /* @__PURE__ */ (function detectScriptRel() {
  const relList = typeof document !== "undefined" && document.createElement("link").relList;
  return relList && relList.supports && relList.supports("modulepreload") ? "modulepreload" : "preload";
})();
const assetsURL = function(dep, importerUrl) {
  return new URL(dep, importerUrl).href;
};
const seen = {};
const __vitePreload = function preload(baseModule, deps, importerUrl) {
  let promise = Promise.resolve();
  if (deps && deps.length > 0) {
    let allSettled = function(promises$2) {
      return Promise.all(promises$2.map((p3) => Promise.resolve(p3).then((value$1) => ({
        status: "fulfilled",
        value: value$1
      }), (reason) => ({
        status: "rejected",
        reason
      }))));
    };
    const links = document.getElementsByTagName("link");
    const cspNonceMeta = document.querySelector("meta[property=csp-nonce]");
    const cspNonce = cspNonceMeta?.nonce || cspNonceMeta?.getAttribute("nonce");
    promise = allSettled(deps.map((dep) => {
      dep = assetsURL(dep, importerUrl);
      if (dep in seen) return;
      seen[dep] = true;
      const isCss = dep.endsWith(".css");
      const cssSelector = isCss ? '[rel="stylesheet"]' : "";
      if (!!importerUrl) for (let i$12 = links.length - 1; i$12 >= 0; i$12--) {
        const link$1 = links[i$12];
        if (link$1.href === dep && (!isCss || link$1.rel === "stylesheet")) return;
      }
      else if (document.querySelector(`link[href="${dep}"]${cssSelector}`)) return;
      const link = document.createElement("link");
      link.rel = isCss ? "stylesheet" : scriptRel;
      if (!isCss) link.as = "script";
      link.crossOrigin = "";
      link.href = dep;
      if (cspNonce) link.setAttribute("nonce", cspNonce);
      document.head.appendChild(link);
      if (isCss) return new Promise((res, rej) => {
        link.addEventListener("load", res);
        link.addEventListener("error", () => rej(/* @__PURE__ */ new Error(`Unable to preload CSS for ${dep}`)));
      });
    }));
  }
  function handlePreloadError(err$2) {
    const e$12 = new Event("vite:preloadError", { cancelable: true });
    e$12.payload = err$2;
    window.dispatchEvent(e$12);
    if (!e$12.defaultPrevented) throw err$2;
  }
  return promise.then((res) => {
    for (const item of res || []) {
      if (item.status !== "rejected") continue;
      handlePreloadError(item.reason);
    }
    return baseModule().catch(handlePreloadError);
  });
};
var c$1 = { VITE_APP_BACKEND_V2_GET_URL: "https://json.excalidraw.com/api/v2/", VITE_APP_BACKEND_V2_POST_URL: "https://json.excalidraw.com/api/v2/post/", VITE_APP_LIBRARY_URL: "https://libraries.excalidraw.com", VITE_APP_LIBRARY_BACKEND: "https://us-central1-excalidraw-room-persistence.cloudfunctions.net/libraries", VITE_APP_PLUS_LP: "https://plus.excalidraw.com", VITE_APP_PLUS_APP: "https://app.excalidraw.com", VITE_APP_AI_BACKEND: "https://oss-ai.excalidraw.com", VITE_APP_WS_SERVER_URL: "https://oss-collab.excalidraw.com", VITE_APP_FIREBASE_CONFIG: '{"apiKey":"AIzaSyAd15pYlMci_xIp9ko6wkEsDzAAA0Dn0RU","authDomain":"excalidraw-room-persistence.firebaseapp.com","databaseURL":"https://excalidraw-room-persistence.firebaseio.com","projectId":"excalidraw-room-persistence","storageBucket":"excalidraw-room-persistence.appspot.com","messagingSenderId":"654800341332","appId":"1:654800341332:web:4a692de832b55bd57ce0c1"}', VITE_APP_ENABLE_TRACKING: "false", VITE_APP_PLUS_EXPORT_PUBLIC_KEY: `MIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEApQ0jM9Qz8TdFLzcuAZZX
/WvuKSOJxiw6AR/ZcE3eFQWM/mbFdhQgyK8eHGkKQifKzH1xUZjCxyXcxW6ZO02t
kPOPxhz+nxUrIoWCD/V4NGmUA1lxwHuO21HN1gzKrN3xHg5EGjyouR9vibT9VDGF
gq6+4Ic/kJX+AD2MM7Yre2+FsOdysrmuW2Fu3ahuC1uQE7pOe1j0k7auNP0y1q53
PrB8Ts2LUpepWC1l7zIXFm4ViDULuyWXTEpUcHSsEH8vpd1tckjypxCwkipfZsXx
iPszy0o0Dx2iArPfWMXlFAI9mvyFCyFC3+nSvfyAUb2C4uZgCwAuyFh/ydPF4DEE
PQIDAQAB`, VITE_APP_DEBUG_ENABLE_TEXT_CONTAINER_BOUNDING_BOX: "false", VITE_APP_COLLAPSE_OVERLAY: "false", VITE_APP_ENABLE_ESLINT: "false", PKG_NAME: "@excalidraw/excalidraw", PKG_VERSION: "0.18.0", PROD: true };
var d$1 = Object.defineProperty;
var e$1 = (b3, a3, c3) => a3 in b3 ? d$1(b3, a3, { enumerable: true, configurable: true, writable: true, value: c3 }) : b3[a3] = c3;
var f$1 = ((b3) => typeof require < "u" ? require : typeof Proxy < "u" ? new Proxy(b3, { get: (a3, c3) => (typeof require < "u" ? require : a3)[c3] }) : b3)(function(b3) {
  if (typeof require < "u") return require.apply(this, arguments);
  throw Error('Dynamic require of "' + b3 + '" is not supported');
}), g$2 = (b3) => (a3) => {
  var c3 = b3[a3];
  if (c3) return c3();
  throw new Error("Module not found in bundle: " + a3);
};
var h$1 = (b3, a3) => {
  for (var c3 in a3) d$1(b3, c3, { get: a3[c3], enumerable: true });
};
var i$1 = (b3, a3, c3) => (e$1(b3, typeof a3 != "symbol" ? a3 + "" : a3, c3), c3);
var crc32$1 = {};
var hasRequiredCrc32;
function requireCrc32() {
  if (hasRequiredCrc32) return crc32$1;
  hasRequiredCrc32 = 1;
  (function(exports$1) {
    (function(factory) {
      if (typeof DO_NOT_EXPORT_CRC === "undefined") {
        {
          factory(exports$1);
        }
      } else {
        factory({});
      }
    })(function(CRC32) {
      CRC32.version = "0.3.0";
      function signed_crc_table() {
        var c3 = 0, table2 = new Array(256);
        for (var n3 = 0; n3 != 256; ++n3) {
          c3 = n3;
          c3 = c3 & 1 ? -306674912 ^ c3 >>> 1 : c3 >>> 1;
          c3 = c3 & 1 ? -306674912 ^ c3 >>> 1 : c3 >>> 1;
          c3 = c3 & 1 ? -306674912 ^ c3 >>> 1 : c3 >>> 1;
          c3 = c3 & 1 ? -306674912 ^ c3 >>> 1 : c3 >>> 1;
          c3 = c3 & 1 ? -306674912 ^ c3 >>> 1 : c3 >>> 1;
          c3 = c3 & 1 ? -306674912 ^ c3 >>> 1 : c3 >>> 1;
          c3 = c3 & 1 ? -306674912 ^ c3 >>> 1 : c3 >>> 1;
          c3 = c3 & 1 ? -306674912 ^ c3 >>> 1 : c3 >>> 1;
          table2[n3] = c3;
        }
        return typeof Int32Array !== "undefined" ? new Int32Array(table2) : table2;
      }
      var table = signed_crc_table();
      var use_buffer = typeof Buffer !== "undefined";
      function crc32_bstr(bstr) {
        if (bstr.length > 32768) {
          if (use_buffer) return crc32_buf_8(new Buffer(bstr));
        }
        var crc = -1, L3 = bstr.length - 1;
        for (var i3 = 0; i3 < L3; ) {
          crc = table[(crc ^ bstr.charCodeAt(i3++)) & 255] ^ crc >>> 8;
          crc = table[(crc ^ bstr.charCodeAt(i3++)) & 255] ^ crc >>> 8;
        }
        if (i3 === L3) crc = crc >>> 8 ^ table[(crc ^ bstr.charCodeAt(i3)) & 255];
        return crc ^ -1;
      }
      function crc32_buf(buf) {
        if (buf.length > 1e4) return crc32_buf_8(buf);
        for (var crc = -1, i3 = 0, L3 = buf.length - 3; i3 < L3; ) {
          crc = crc >>> 8 ^ table[(crc ^ buf[i3++]) & 255];
          crc = crc >>> 8 ^ table[(crc ^ buf[i3++]) & 255];
          crc = crc >>> 8 ^ table[(crc ^ buf[i3++]) & 255];
          crc = crc >>> 8 ^ table[(crc ^ buf[i3++]) & 255];
        }
        while (i3 < L3 + 3) crc = crc >>> 8 ^ table[(crc ^ buf[i3++]) & 255];
        return crc ^ -1;
      }
      function crc32_buf_8(buf) {
        for (var crc = -1, i3 = 0, L3 = buf.length - 7; i3 < L3; ) {
          crc = crc >>> 8 ^ table[(crc ^ buf[i3++]) & 255];
          crc = crc >>> 8 ^ table[(crc ^ buf[i3++]) & 255];
          crc = crc >>> 8 ^ table[(crc ^ buf[i3++]) & 255];
          crc = crc >>> 8 ^ table[(crc ^ buf[i3++]) & 255];
          crc = crc >>> 8 ^ table[(crc ^ buf[i3++]) & 255];
          crc = crc >>> 8 ^ table[(crc ^ buf[i3++]) & 255];
          crc = crc >>> 8 ^ table[(crc ^ buf[i3++]) & 255];
          crc = crc >>> 8 ^ table[(crc ^ buf[i3++]) & 255];
        }
        while (i3 < L3 + 7) crc = crc >>> 8 ^ table[(crc ^ buf[i3++]) & 255];
        return crc ^ -1;
      }
      function crc32_str(str) {
        for (var crc = -1, i3 = 0, L3 = str.length, c3, d3; i3 < L3; ) {
          c3 = str.charCodeAt(i3++);
          if (c3 < 128) {
            crc = crc >>> 8 ^ table[(crc ^ c3) & 255];
          } else if (c3 < 2048) {
            crc = crc >>> 8 ^ table[(crc ^ (192 | c3 >> 6 & 31)) & 255];
            crc = crc >>> 8 ^ table[(crc ^ (128 | c3 & 63)) & 255];
          } else if (c3 >= 55296 && c3 < 57344) {
            c3 = (c3 & 1023) + 64;
            d3 = str.charCodeAt(i3++) & 1023;
            crc = crc >>> 8 ^ table[(crc ^ (240 | c3 >> 8 & 7)) & 255];
            crc = crc >>> 8 ^ table[(crc ^ (128 | c3 >> 2 & 63)) & 255];
            crc = crc >>> 8 ^ table[(crc ^ (128 | d3 >> 6 & 15 | c3 & 3)) & 255];
            crc = crc >>> 8 ^ table[(crc ^ (128 | d3 & 63)) & 255];
          } else {
            crc = crc >>> 8 ^ table[(crc ^ (224 | c3 >> 12 & 15)) & 255];
            crc = crc >>> 8 ^ table[(crc ^ (128 | c3 >> 6 & 63)) & 255];
            crc = crc >>> 8 ^ table[(crc ^ (128 | c3 & 63)) & 255];
          }
        }
        return crc ^ -1;
      }
      CRC32.table = table;
      CRC32.bstr = crc32_bstr;
      CRC32.buf = crc32_buf;
      CRC32.str = crc32_str;
    });
  })(crc32$1);
  return crc32$1;
}
var pngChunksExtract;
var hasRequiredPngChunksExtract;
function requirePngChunksExtract() {
  if (hasRequiredPngChunksExtract) return pngChunksExtract;
  hasRequiredPngChunksExtract = 1;
  var crc322 = requireCrc32();
  pngChunksExtract = extractChunks;
  var uint8 = new Uint8Array(4);
  var int32 = new Int32Array(uint8.buffer);
  var uint32 = new Uint32Array(uint8.buffer);
  function extractChunks(data) {
    if (data[0] !== 137) throw new Error("Invalid .png file header");
    if (data[1] !== 80) throw new Error("Invalid .png file header");
    if (data[2] !== 78) throw new Error("Invalid .png file header");
    if (data[3] !== 71) throw new Error("Invalid .png file header");
    if (data[4] !== 13) throw new Error("Invalid .png file header: possibly caused by DOS-Unix line ending conversion?");
    if (data[5] !== 10) throw new Error("Invalid .png file header: possibly caused by DOS-Unix line ending conversion?");
    if (data[6] !== 26) throw new Error("Invalid .png file header");
    if (data[7] !== 10) throw new Error("Invalid .png file header: possibly caused by DOS-Unix line ending conversion?");
    var ended = false;
    var chunks = [];
    var idx = 8;
    while (idx < data.length) {
      uint8[3] = data[idx++];
      uint8[2] = data[idx++];
      uint8[1] = data[idx++];
      uint8[0] = data[idx++];
      var length = uint32[0] + 4;
      var chunk = new Uint8Array(length);
      chunk[0] = data[idx++];
      chunk[1] = data[idx++];
      chunk[2] = data[idx++];
      chunk[3] = data[idx++];
      var name = String.fromCharCode(chunk[0]) + String.fromCharCode(chunk[1]) + String.fromCharCode(chunk[2]) + String.fromCharCode(chunk[3]);
      if (!chunks.length && name !== "IHDR") {
        throw new Error("IHDR header missing");
      }
      if (name === "IEND") {
        ended = true;
        chunks.push({
          name,
          data: new Uint8Array(0)
        });
        break;
      }
      for (var i3 = 4; i3 < length; i3++) {
        chunk[i3] = data[idx++];
      }
      uint8[3] = data[idx++];
      uint8[2] = data[idx++];
      uint8[1] = data[idx++];
      uint8[0] = data[idx++];
      var crcActual = int32[0];
      var crcExpect = crc322.buf(chunk);
      if (crcExpect !== crcActual) {
        throw new Error(
          "CRC values for " + name + " header do not match, PNG file is likely corrupted"
        );
      }
      var chunkData = new Uint8Array(chunk.buffer.slice(4));
      chunks.push({
        name,
        data: chunkData
      });
    }
    if (!ended) {
      throw new Error(".png file ended prematurely: no IEND header was found");
    }
    return chunks;
  }
  return pngChunksExtract;
}
var pngChunksExtractExports = requirePngChunksExtract();
const l6 = /* @__PURE__ */ getDefaultExportFromCjs(pngChunksExtractExports);
var pngChunkText = {};
var encode_1;
var hasRequiredEncode;
function requireEncode() {
  if (hasRequiredEncode) return encode_1;
  hasRequiredEncode = 1;
  encode_1 = encode;
  function encode(keyword, content) {
    keyword = String(keyword);
    content = String(content);
    if (!/^[\x00-\xFF]+$/.test(keyword) || !/^[\x00-\xFF]+$/.test(content)) {
      throw new Error("Only Latin-1 characters are permitted in PNG tEXt chunks. You might want to consider base64 encoding and/or zEXt compression");
    }
    if (keyword.length >= 80) {
      throw new Error('Keyword "' + keyword + '" is longer than the 79-character limit imposed by the PNG specification');
    }
    var totalSize = keyword.length + content.length + 1;
    var output = new Uint8Array(totalSize);
    var idx = 0;
    var code;
    for (var i3 = 0; i3 < keyword.length; i3++) {
      if (!(code = keyword.charCodeAt(i3))) {
        throw new Error("0x00 character is not permitted in tEXt keywords");
      }
      output[idx++] = code;
    }
    output[idx++] = 0;
    for (var j = 0; j < content.length; j++) {
      if (!(code = content.charCodeAt(j))) {
        throw new Error("0x00 character is not permitted in tEXt content");
      }
      output[idx++] = code;
    }
    return {
      name: "tEXt",
      data: output
    };
  }
  return encode_1;
}
var decode_1;
var hasRequiredDecode;
function requireDecode() {
  if (hasRequiredDecode) return decode_1;
  hasRequiredDecode = 1;
  decode_1 = decode;
  function decode(data) {
    if (data.data && data.name) {
      data = data.data;
    }
    var naming = true;
    var text = "";
    var name = "";
    for (var i3 = 0; i3 < data.length; i3++) {
      var code = data[i3];
      if (naming) {
        if (code) {
          name += String.fromCharCode(code);
        } else {
          naming = false;
        }
      } else {
        if (code) {
          text += String.fromCharCode(code);
        } else {
          throw new Error("Invalid NULL character found. 0x00 character is not permitted in tEXt content");
        }
      }
    }
    return {
      keyword: name,
      text
    };
  }
  return decode_1;
}
var hasRequiredPngChunkText;
function requirePngChunkText() {
  if (hasRequiredPngChunkText) return pngChunkText;
  hasRequiredPngChunkText = 1;
  pngChunkText.encode = requireEncode();
  pngChunkText.decode = requireDecode();
  return pngChunkText;
}
var pngChunkTextExports = requirePngChunkText();
const U6 = /* @__PURE__ */ getDefaultExportFromCjs(pngChunkTextExports);
var sliced;
var hasRequiredSliced;
function requireSliced() {
  if (hasRequiredSliced) return sliced;
  hasRequiredSliced = 1;
  sliced = function(args, slice, sliceEnd) {
    var ret = [];
    var len = args.length;
    if (0 === len) return ret;
    var start = slice < 0 ? Math.max(0, slice + len) : slice || 0;
    if (sliceEnd !== void 0) {
      len = sliceEnd < 0 ? sliceEnd + len : sliceEnd;
    }
    while (len-- > start) {
      ret[len - start] = args[len];
    }
    return ret;
  };
  return sliced;
}
var pngChunksEncode;
var hasRequiredPngChunksEncode;
function requirePngChunksEncode() {
  if (hasRequiredPngChunksEncode) return pngChunksEncode;
  hasRequiredPngChunksEncode = 1;
  var sliced2 = requireSliced();
  var crc322 = requireCrc32();
  pngChunksEncode = encodeChunks;
  var uint8 = new Uint8Array(4);
  var int32 = new Int32Array(uint8.buffer);
  var uint32 = new Uint32Array(uint8.buffer);
  function encodeChunks(chunks) {
    var totalSize = 8;
    var idx = totalSize;
    var i3;
    for (i3 = 0; i3 < chunks.length; i3++) {
      totalSize += chunks[i3].data.length;
      totalSize += 12;
    }
    var output = new Uint8Array(totalSize);
    output[0] = 137;
    output[1] = 80;
    output[2] = 78;
    output[3] = 71;
    output[4] = 13;
    output[5] = 10;
    output[6] = 26;
    output[7] = 10;
    for (i3 = 0; i3 < chunks.length; i3++) {
      var chunk = chunks[i3];
      var name = chunk.name;
      var data = chunk.data;
      var size2 = data.length;
      var nameChars = [
        name.charCodeAt(0),
        name.charCodeAt(1),
        name.charCodeAt(2),
        name.charCodeAt(3)
      ];
      uint32[0] = size2;
      output[idx++] = uint8[3];
      output[idx++] = uint8[2];
      output[idx++] = uint8[1];
      output[idx++] = uint8[0];
      output[idx++] = nameChars[0];
      output[idx++] = nameChars[1];
      output[idx++] = nameChars[2];
      output[idx++] = nameChars[3];
      for (var j = 0; j < size2; ) {
        output[idx++] = data[j++];
      }
      var crcCheck = nameChars.concat(sliced2(data));
      var crc = crc322.buf(crcCheck);
      int32[0] = crc;
      output[idx++] = uint8[3];
      output[idx++] = uint8[2];
      output[idx++] = uint8[1];
      output[idx++] = uint8[0];
    }
    return output;
  }
  return pngChunksEncode;
}
var pngChunksEncodeExports = requirePngChunksEncode();
const q9 = /* @__PURE__ */ getDefaultExportFromCjs(pngChunksEncodeExports);
const Z_FIXED = 4;
const Z_BINARY = 0;
const Z_TEXT = 1;
const Z_UNKNOWN = 2;
function zero(buf) {
  let len = buf.length;
  while (--len >= 0) {
    buf[len] = 0;
  }
}
const STORED_BLOCK = 0;
const STATIC_TREES = 1;
const DYN_TREES = 2;
const MIN_MATCH = 3;
const MAX_MATCH = 258;
const LENGTH_CODES = 29;
const LITERALS = 256;
const L_CODES = LITERALS + 1 + LENGTH_CODES;
const D_CODES = 30;
const BL_CODES = 19;
const HEAP_SIZE = 2 * L_CODES + 1;
const MAX_BITS = 15;
const Buf_size = 16;
const MAX_BL_BITS = 7;
const END_BLOCK = 256;
const REP_3_6 = 16;
const REPZ_3_10 = 17;
const REPZ_11_138 = 18;
const extra_lbits = (
  /* extra bits for each length code */
  new Uint8Array([0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 0])
);
const extra_dbits = (
  /* extra bits for each distance code */
  new Uint8Array([0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10, 10, 11, 11, 12, 12, 13, 13])
);
const extra_blbits = (
  /* extra bits for each bit length code */
  new Uint8Array([0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 3, 7])
);
const bl_order = new Uint8Array([16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15]);
const DIST_CODE_LEN = 512;
const static_ltree = new Array((L_CODES + 2) * 2);
zero(static_ltree);
const static_dtree = new Array(D_CODES * 2);
zero(static_dtree);
const _dist_code = new Array(DIST_CODE_LEN);
zero(_dist_code);
const _length_code = new Array(MAX_MATCH - MIN_MATCH + 1);
zero(_length_code);
const base_length = new Array(LENGTH_CODES);
zero(base_length);
const base_dist = new Array(D_CODES);
zero(base_dist);
function StaticTreeDesc(static_tree, extra_bits, extra_base, elems, max_length) {
  this.static_tree = static_tree;
  this.extra_bits = extra_bits;
  this.extra_base = extra_base;
  this.elems = elems;
  this.max_length = max_length;
  this.has_stree = static_tree && static_tree.length;
}
let static_l_desc;
let static_d_desc;
let static_bl_desc;
function TreeDesc(dyn_tree, stat_desc) {
  this.dyn_tree = dyn_tree;
  this.max_code = 0;
  this.stat_desc = stat_desc;
}
const d_code = (dist2) => {
  return dist2 < 256 ? _dist_code[dist2] : _dist_code[256 + (dist2 >>> 7)];
};
const put_short = (s3, w3) => {
  s3.pending_buf[s3.pending++] = w3 & 255;
  s3.pending_buf[s3.pending++] = w3 >>> 8 & 255;
};
const send_bits = (s3, value, length) => {
  if (s3.bi_valid > Buf_size - length) {
    s3.bi_buf |= value << s3.bi_valid & 65535;
    put_short(s3, s3.bi_buf);
    s3.bi_buf = value >> Buf_size - s3.bi_valid;
    s3.bi_valid += length - Buf_size;
  } else {
    s3.bi_buf |= value << s3.bi_valid & 65535;
    s3.bi_valid += length;
  }
};
const send_code = (s3, c3, tree) => {
  send_bits(
    s3,
    tree[c3 * 2],
    tree[c3 * 2 + 1]
    /*.Len*/
  );
};
const bi_reverse = (code, len) => {
  let res = 0;
  do {
    res |= code & 1;
    code >>>= 1;
    res <<= 1;
  } while (--len > 0);
  return res >>> 1;
};
const bi_flush = (s3) => {
  if (s3.bi_valid === 16) {
    put_short(s3, s3.bi_buf);
    s3.bi_buf = 0;
    s3.bi_valid = 0;
  } else if (s3.bi_valid >= 8) {
    s3.pending_buf[s3.pending++] = s3.bi_buf & 255;
    s3.bi_buf >>= 8;
    s3.bi_valid -= 8;
  }
};
const gen_bitlen = (s3, desc) => {
  const tree = desc.dyn_tree;
  const max_code = desc.max_code;
  const stree = desc.stat_desc.static_tree;
  const has_stree = desc.stat_desc.has_stree;
  const extra = desc.stat_desc.extra_bits;
  const base = desc.stat_desc.extra_base;
  const max_length = desc.stat_desc.max_length;
  let h3;
  let n3, m3;
  let bits;
  let xbits;
  let f3;
  let overflow = 0;
  for (bits = 0; bits <= MAX_BITS; bits++) {
    s3.bl_count[bits] = 0;
  }
  tree[s3.heap[s3.heap_max] * 2 + 1] = 0;
  for (h3 = s3.heap_max + 1; h3 < HEAP_SIZE; h3++) {
    n3 = s3.heap[h3];
    bits = tree[tree[n3 * 2 + 1] * 2 + 1] + 1;
    if (bits > max_length) {
      bits = max_length;
      overflow++;
    }
    tree[n3 * 2 + 1] = bits;
    if (n3 > max_code) {
      continue;
    }
    s3.bl_count[bits]++;
    xbits = 0;
    if (n3 >= base) {
      xbits = extra[n3 - base];
    }
    f3 = tree[n3 * 2];
    s3.opt_len += f3 * (bits + xbits);
    if (has_stree) {
      s3.static_len += f3 * (stree[n3 * 2 + 1] + xbits);
    }
  }
  if (overflow === 0) {
    return;
  }
  do {
    bits = max_length - 1;
    while (s3.bl_count[bits] === 0) {
      bits--;
    }
    s3.bl_count[bits]--;
    s3.bl_count[bits + 1] += 2;
    s3.bl_count[max_length]--;
    overflow -= 2;
  } while (overflow > 0);
  for (bits = max_length; bits !== 0; bits--) {
    n3 = s3.bl_count[bits];
    while (n3 !== 0) {
      m3 = s3.heap[--h3];
      if (m3 > max_code) {
        continue;
      }
      if (tree[m3 * 2 + 1] !== bits) {
        s3.opt_len += (bits - tree[m3 * 2 + 1]) * tree[m3 * 2];
        tree[m3 * 2 + 1] = bits;
      }
      n3--;
    }
  }
};
const gen_codes = (tree, max_code, bl_count) => {
  const next_code = new Array(MAX_BITS + 1);
  let code = 0;
  let bits;
  let n3;
  for (bits = 1; bits <= MAX_BITS; bits++) {
    next_code[bits] = code = code + bl_count[bits - 1] << 1;
  }
  for (n3 = 0; n3 <= max_code; n3++) {
    let len = tree[n3 * 2 + 1];
    if (len === 0) {
      continue;
    }
    tree[n3 * 2] = bi_reverse(next_code[len]++, len);
  }
};
const tr_static_init = () => {
  let n3;
  let bits;
  let length;
  let code;
  let dist2;
  const bl_count = new Array(MAX_BITS + 1);
  length = 0;
  for (code = 0; code < LENGTH_CODES - 1; code++) {
    base_length[code] = length;
    for (n3 = 0; n3 < 1 << extra_lbits[code]; n3++) {
      _length_code[length++] = code;
    }
  }
  _length_code[length - 1] = code;
  dist2 = 0;
  for (code = 0; code < 16; code++) {
    base_dist[code] = dist2;
    for (n3 = 0; n3 < 1 << extra_dbits[code]; n3++) {
      _dist_code[dist2++] = code;
    }
  }
  dist2 >>= 7;
  for (; code < D_CODES; code++) {
    base_dist[code] = dist2 << 7;
    for (n3 = 0; n3 < 1 << extra_dbits[code] - 7; n3++) {
      _dist_code[256 + dist2++] = code;
    }
  }
  for (bits = 0; bits <= MAX_BITS; bits++) {
    bl_count[bits] = 0;
  }
  n3 = 0;
  while (n3 <= 143) {
    static_ltree[n3 * 2 + 1] = 8;
    n3++;
    bl_count[8]++;
  }
  while (n3 <= 255) {
    static_ltree[n3 * 2 + 1] = 9;
    n3++;
    bl_count[9]++;
  }
  while (n3 <= 279) {
    static_ltree[n3 * 2 + 1] = 7;
    n3++;
    bl_count[7]++;
  }
  while (n3 <= 287) {
    static_ltree[n3 * 2 + 1] = 8;
    n3++;
    bl_count[8]++;
  }
  gen_codes(static_ltree, L_CODES + 1, bl_count);
  for (n3 = 0; n3 < D_CODES; n3++) {
    static_dtree[n3 * 2 + 1] = 5;
    static_dtree[n3 * 2] = bi_reverse(n3, 5);
  }
  static_l_desc = new StaticTreeDesc(static_ltree, extra_lbits, LITERALS + 1, L_CODES, MAX_BITS);
  static_d_desc = new StaticTreeDesc(static_dtree, extra_dbits, 0, D_CODES, MAX_BITS);
  static_bl_desc = new StaticTreeDesc(new Array(0), extra_blbits, 0, BL_CODES, MAX_BL_BITS);
};
const init_block = (s3) => {
  let n3;
  for (n3 = 0; n3 < L_CODES; n3++) {
    s3.dyn_ltree[n3 * 2] = 0;
  }
  for (n3 = 0; n3 < D_CODES; n3++) {
    s3.dyn_dtree[n3 * 2] = 0;
  }
  for (n3 = 0; n3 < BL_CODES; n3++) {
    s3.bl_tree[n3 * 2] = 0;
  }
  s3.dyn_ltree[END_BLOCK * 2] = 1;
  s3.opt_len = s3.static_len = 0;
  s3.last_lit = s3.matches = 0;
};
const bi_windup = (s3) => {
  if (s3.bi_valid > 8) {
    put_short(s3, s3.bi_buf);
  } else if (s3.bi_valid > 0) {
    s3.pending_buf[s3.pending++] = s3.bi_buf;
  }
  s3.bi_buf = 0;
  s3.bi_valid = 0;
};
const copy_block = (s3, buf, len, header) => {
  bi_windup(s3);
  {
    put_short(s3, len);
    put_short(s3, ~len);
  }
  s3.pending_buf.set(s3.window.subarray(buf, buf + len), s3.pending);
  s3.pending += len;
};
const smaller = (tree, n3, m3, depth) => {
  const _n2 = n3 * 2;
  const _m2 = m3 * 2;
  return tree[_n2] < tree[_m2] || tree[_n2] === tree[_m2] && depth[n3] <= depth[m3];
};
const pqdownheap = (s3, tree, k2) => {
  const v3 = s3.heap[k2];
  let j = k2 << 1;
  while (j <= s3.heap_len) {
    if (j < s3.heap_len && smaller(tree, s3.heap[j + 1], s3.heap[j], s3.depth)) {
      j++;
    }
    if (smaller(tree, v3, s3.heap[j], s3.depth)) {
      break;
    }
    s3.heap[k2] = s3.heap[j];
    k2 = j;
    j <<= 1;
  }
  s3.heap[k2] = v3;
};
const compress_block = (s3, ltree, dtree) => {
  let dist2;
  let lc2;
  let lx = 0;
  let code;
  let extra;
  if (s3.last_lit !== 0) {
    do {
      dist2 = s3.pending_buf[s3.d_buf + lx * 2] << 8 | s3.pending_buf[s3.d_buf + lx * 2 + 1];
      lc2 = s3.pending_buf[s3.l_buf + lx];
      lx++;
      if (dist2 === 0) {
        send_code(s3, lc2, ltree);
      } else {
        code = _length_code[lc2];
        send_code(s3, code + LITERALS + 1, ltree);
        extra = extra_lbits[code];
        if (extra !== 0) {
          lc2 -= base_length[code];
          send_bits(s3, lc2, extra);
        }
        dist2--;
        code = d_code(dist2);
        send_code(s3, code, dtree);
        extra = extra_dbits[code];
        if (extra !== 0) {
          dist2 -= base_dist[code];
          send_bits(s3, dist2, extra);
        }
      }
    } while (lx < s3.last_lit);
  }
  send_code(s3, END_BLOCK, ltree);
};
const build_tree = (s3, desc) => {
  const tree = desc.dyn_tree;
  const stree = desc.stat_desc.static_tree;
  const has_stree = desc.stat_desc.has_stree;
  const elems = desc.stat_desc.elems;
  let n3, m3;
  let max_code = -1;
  let node;
  s3.heap_len = 0;
  s3.heap_max = HEAP_SIZE;
  for (n3 = 0; n3 < elems; n3++) {
    if (tree[n3 * 2] !== 0) {
      s3.heap[++s3.heap_len] = max_code = n3;
      s3.depth[n3] = 0;
    } else {
      tree[n3 * 2 + 1] = 0;
    }
  }
  while (s3.heap_len < 2) {
    node = s3.heap[++s3.heap_len] = max_code < 2 ? ++max_code : 0;
    tree[node * 2] = 1;
    s3.depth[node] = 0;
    s3.opt_len--;
    if (has_stree) {
      s3.static_len -= stree[node * 2 + 1];
    }
  }
  desc.max_code = max_code;
  for (n3 = s3.heap_len >> 1; n3 >= 1; n3--) {
    pqdownheap(s3, tree, n3);
  }
  node = elems;
  do {
    n3 = s3.heap[
      1
      /*SMALLEST*/
    ];
    s3.heap[
      1
      /*SMALLEST*/
    ] = s3.heap[s3.heap_len--];
    pqdownheap(
      s3,
      tree,
      1
      /*SMALLEST*/
    );
    m3 = s3.heap[
      1
      /*SMALLEST*/
    ];
    s3.heap[--s3.heap_max] = n3;
    s3.heap[--s3.heap_max] = m3;
    tree[node * 2] = tree[n3 * 2] + tree[m3 * 2];
    s3.depth[node] = (s3.depth[n3] >= s3.depth[m3] ? s3.depth[n3] : s3.depth[m3]) + 1;
    tree[n3 * 2 + 1] = tree[m3 * 2 + 1] = node;
    s3.heap[
      1
      /*SMALLEST*/
    ] = node++;
    pqdownheap(
      s3,
      tree,
      1
      /*SMALLEST*/
    );
  } while (s3.heap_len >= 2);
  s3.heap[--s3.heap_max] = s3.heap[
    1
    /*SMALLEST*/
  ];
  gen_bitlen(s3, desc);
  gen_codes(tree, max_code, s3.bl_count);
};
const scan_tree = (s3, tree, max_code) => {
  let n3;
  let prevlen = -1;
  let curlen;
  let nextlen = tree[0 * 2 + 1];
  let count2 = 0;
  let max_count = 7;
  let min_count = 4;
  if (nextlen === 0) {
    max_count = 138;
    min_count = 3;
  }
  tree[(max_code + 1) * 2 + 1] = 65535;
  for (n3 = 0; n3 <= max_code; n3++) {
    curlen = nextlen;
    nextlen = tree[(n3 + 1) * 2 + 1];
    if (++count2 < max_count && curlen === nextlen) {
      continue;
    } else if (count2 < min_count) {
      s3.bl_tree[curlen * 2] += count2;
    } else if (curlen !== 0) {
      if (curlen !== prevlen) {
        s3.bl_tree[curlen * 2]++;
      }
      s3.bl_tree[REP_3_6 * 2]++;
    } else if (count2 <= 10) {
      s3.bl_tree[REPZ_3_10 * 2]++;
    } else {
      s3.bl_tree[REPZ_11_138 * 2]++;
    }
    count2 = 0;
    prevlen = curlen;
    if (nextlen === 0) {
      max_count = 138;
      min_count = 3;
    } else if (curlen === nextlen) {
      max_count = 6;
      min_count = 3;
    } else {
      max_count = 7;
      min_count = 4;
    }
  }
};
const send_tree = (s3, tree, max_code) => {
  let n3;
  let prevlen = -1;
  let curlen;
  let nextlen = tree[0 * 2 + 1];
  let count2 = 0;
  let max_count = 7;
  let min_count = 4;
  if (nextlen === 0) {
    max_count = 138;
    min_count = 3;
  }
  for (n3 = 0; n3 <= max_code; n3++) {
    curlen = nextlen;
    nextlen = tree[(n3 + 1) * 2 + 1];
    if (++count2 < max_count && curlen === nextlen) {
      continue;
    } else if (count2 < min_count) {
      do {
        send_code(s3, curlen, s3.bl_tree);
      } while (--count2 !== 0);
    } else if (curlen !== 0) {
      if (curlen !== prevlen) {
        send_code(s3, curlen, s3.bl_tree);
        count2--;
      }
      send_code(s3, REP_3_6, s3.bl_tree);
      send_bits(s3, count2 - 3, 2);
    } else if (count2 <= 10) {
      send_code(s3, REPZ_3_10, s3.bl_tree);
      send_bits(s3, count2 - 3, 3);
    } else {
      send_code(s3, REPZ_11_138, s3.bl_tree);
      send_bits(s3, count2 - 11, 7);
    }
    count2 = 0;
    prevlen = curlen;
    if (nextlen === 0) {
      max_count = 138;
      min_count = 3;
    } else if (curlen === nextlen) {
      max_count = 6;
      min_count = 3;
    } else {
      max_count = 7;
      min_count = 4;
    }
  }
};
const build_bl_tree = (s3) => {
  let max_blindex;
  scan_tree(s3, s3.dyn_ltree, s3.l_desc.max_code);
  scan_tree(s3, s3.dyn_dtree, s3.d_desc.max_code);
  build_tree(s3, s3.bl_desc);
  for (max_blindex = BL_CODES - 1; max_blindex >= 3; max_blindex--) {
    if (s3.bl_tree[bl_order[max_blindex] * 2 + 1] !== 0) {
      break;
    }
  }
  s3.opt_len += 3 * (max_blindex + 1) + 5 + 5 + 4;
  return max_blindex;
};
const send_all_trees = (s3, lcodes, dcodes, blcodes) => {
  let rank2;
  send_bits(s3, lcodes - 257, 5);
  send_bits(s3, dcodes - 1, 5);
  send_bits(s3, blcodes - 4, 4);
  for (rank2 = 0; rank2 < blcodes; rank2++) {
    send_bits(s3, s3.bl_tree[bl_order[rank2] * 2 + 1], 3);
  }
  send_tree(s3, s3.dyn_ltree, lcodes - 1);
  send_tree(s3, s3.dyn_dtree, dcodes - 1);
};
const detect_data_type = (s3) => {
  let black_mask = 4093624447;
  let n3;
  for (n3 = 0; n3 <= 31; n3++, black_mask >>>= 1) {
    if (black_mask & 1 && s3.dyn_ltree[n3 * 2] !== 0) {
      return Z_BINARY;
    }
  }
  if (s3.dyn_ltree[9 * 2] !== 0 || s3.dyn_ltree[10 * 2] !== 0 || s3.dyn_ltree[13 * 2] !== 0) {
    return Z_TEXT;
  }
  for (n3 = 32; n3 < LITERALS; n3++) {
    if (s3.dyn_ltree[n3 * 2] !== 0) {
      return Z_TEXT;
    }
  }
  return Z_BINARY;
};
let static_init_done = false;
const _tr_init = (s3) => {
  if (!static_init_done) {
    tr_static_init();
    static_init_done = true;
  }
  s3.l_desc = new TreeDesc(s3.dyn_ltree, static_l_desc);
  s3.d_desc = new TreeDesc(s3.dyn_dtree, static_d_desc);
  s3.bl_desc = new TreeDesc(s3.bl_tree, static_bl_desc);
  s3.bi_buf = 0;
  s3.bi_valid = 0;
  init_block(s3);
};
const _tr_stored_block = (s3, buf, stored_len, last) => {
  send_bits(s3, (STORED_BLOCK << 1) + (last ? 1 : 0), 3);
  copy_block(s3, buf, stored_len);
};
const _tr_align = (s3) => {
  send_bits(s3, STATIC_TREES << 1, 3);
  send_code(s3, END_BLOCK, static_ltree);
  bi_flush(s3);
};
const _tr_flush_block = (s3, buf, stored_len, last) => {
  let opt_lenb, static_lenb;
  let max_blindex = 0;
  if (s3.level > 0) {
    if (s3.strm.data_type === Z_UNKNOWN) {
      s3.strm.data_type = detect_data_type(s3);
    }
    build_tree(s3, s3.l_desc);
    build_tree(s3, s3.d_desc);
    max_blindex = build_bl_tree(s3);
    opt_lenb = s3.opt_len + 3 + 7 >>> 3;
    static_lenb = s3.static_len + 3 + 7 >>> 3;
    if (static_lenb <= opt_lenb) {
      opt_lenb = static_lenb;
    }
  } else {
    opt_lenb = static_lenb = stored_len + 5;
  }
  if (stored_len + 4 <= opt_lenb && buf !== -1) {
    _tr_stored_block(s3, buf, stored_len, last);
  } else if (s3.strategy === Z_FIXED || static_lenb === opt_lenb) {
    send_bits(s3, (STATIC_TREES << 1) + (last ? 1 : 0), 3);
    compress_block(s3, static_ltree, static_dtree);
  } else {
    send_bits(s3, (DYN_TREES << 1) + (last ? 1 : 0), 3);
    send_all_trees(s3, s3.l_desc.max_code + 1, s3.d_desc.max_code + 1, max_blindex + 1);
    compress_block(s3, s3.dyn_ltree, s3.dyn_dtree);
  }
  init_block(s3);
  if (last) {
    bi_windup(s3);
  }
};
const _tr_tally = (s3, dist2, lc2) => {
  s3.pending_buf[s3.d_buf + s3.last_lit * 2] = dist2 >>> 8 & 255;
  s3.pending_buf[s3.d_buf + s3.last_lit * 2 + 1] = dist2 & 255;
  s3.pending_buf[s3.l_buf + s3.last_lit] = lc2 & 255;
  s3.last_lit++;
  if (dist2 === 0) {
    s3.dyn_ltree[lc2 * 2]++;
  } else {
    s3.matches++;
    dist2--;
    s3.dyn_ltree[(_length_code[lc2] + LITERALS + 1) * 2]++;
    s3.dyn_dtree[d_code(dist2) * 2]++;
  }
  return s3.last_lit === s3.lit_bufsize - 1;
};
var _tr_init_1 = _tr_init;
var _tr_stored_block_1 = _tr_stored_block;
var _tr_flush_block_1 = _tr_flush_block;
var _tr_tally_1 = _tr_tally;
var _tr_align_1 = _tr_align;
var trees = {
  _tr_init: _tr_init_1,
  _tr_stored_block: _tr_stored_block_1,
  _tr_flush_block: _tr_flush_block_1,
  _tr_tally: _tr_tally_1,
  _tr_align: _tr_align_1
};
const adler32 = (adler, buf, len, pos) => {
  let s12 = adler & 65535 | 0, s22 = adler >>> 16 & 65535 | 0, n3 = 0;
  while (len !== 0) {
    n3 = len > 2e3 ? 2e3 : len;
    len -= n3;
    do {
      s12 = s12 + buf[pos++] | 0;
      s22 = s22 + s12 | 0;
    } while (--n3);
    s12 %= 65521;
    s22 %= 65521;
  }
  return s12 | s22 << 16 | 0;
};
var adler32_1 = adler32;
const makeTable = () => {
  let c3, table = [];
  for (var n3 = 0; n3 < 256; n3++) {
    c3 = n3;
    for (var k2 = 0; k2 < 8; k2++) {
      c3 = c3 & 1 ? 3988292384 ^ c3 >>> 1 : c3 >>> 1;
    }
    table[n3] = c3;
  }
  return table;
};
const crcTable = new Uint32Array(makeTable());
const crc32 = (crc, buf, len, pos) => {
  const t3 = crcTable;
  const end = pos + len;
  crc ^= -1;
  for (let i3 = pos; i3 < end; i3++) {
    crc = crc >>> 8 ^ t3[(crc ^ buf[i3]) & 255];
  }
  return crc ^ -1;
};
var crc32_1 = crc32;
var messages = {
  2: "need dictionary",
  /* Z_NEED_DICT       2  */
  1: "stream end",
  /* Z_STREAM_END      1  */
  0: "",
  /* Z_OK              0  */
  "-1": "file error",
  /* Z_ERRNO         (-1) */
  "-2": "stream error",
  /* Z_STREAM_ERROR  (-2) */
  "-3": "data error",
  /* Z_DATA_ERROR    (-3) */
  "-4": "insufficient memory",
  /* Z_MEM_ERROR     (-4) */
  "-5": "buffer error",
  /* Z_BUF_ERROR     (-5) */
  "-6": "incompatible version"
  /* Z_VERSION_ERROR (-6) */
};
var constants = {
  /* Allowed flush values; see deflate() and inflate() below for details */
  Z_NO_FLUSH: 0,
  Z_PARTIAL_FLUSH: 1,
  Z_SYNC_FLUSH: 2,
  Z_FULL_FLUSH: 3,
  Z_FINISH: 4,
  Z_BLOCK: 5,
  Z_TREES: 6,
  /* Return codes for the compression/decompression functions. Negative values
  * are errors, positive values are used for special but normal events.
  */
  Z_OK: 0,
  Z_STREAM_END: 1,
  Z_NEED_DICT: 2,
  Z_STREAM_ERROR: -2,
  Z_DATA_ERROR: -3,
  Z_MEM_ERROR: -4,
  Z_BUF_ERROR: -5,
  Z_DEFAULT_COMPRESSION: -1,
  Z_FILTERED: 1,
  Z_HUFFMAN_ONLY: 2,
  Z_RLE: 3,
  Z_FIXED: 4,
  Z_DEFAULT_STRATEGY: 0,
  //Z_ASCII:                1, // = Z_TEXT (deprecated)
  Z_UNKNOWN: 2,
  /* The deflate compression method */
  Z_DEFLATED: 8
  //Z_NULL:                 null // Use -1 or null inline, depending on var type
};
const { _tr_init: _tr_init$1, _tr_stored_block: _tr_stored_block$1, _tr_flush_block: _tr_flush_block$1, _tr_tally: _tr_tally$1, _tr_align: _tr_align$1 } = trees;
const {
  Z_NO_FLUSH,
  Z_PARTIAL_FLUSH,
  Z_FULL_FLUSH,
  Z_FINISH,
  Z_BLOCK,
  Z_OK,
  Z_STREAM_END,
  Z_STREAM_ERROR,
  Z_DATA_ERROR,
  Z_BUF_ERROR,
  Z_DEFAULT_COMPRESSION,
  Z_FILTERED,
  Z_HUFFMAN_ONLY,
  Z_RLE,
  Z_FIXED: Z_FIXED$1,
  Z_DEFAULT_STRATEGY,
  Z_UNKNOWN: Z_UNKNOWN$1,
  Z_DEFLATED
} = constants;
const MAX_MEM_LEVEL = 9;
const MAX_WBITS = 15;
const DEF_MEM_LEVEL = 8;
const LENGTH_CODES$1 = 29;
const LITERALS$1 = 256;
const L_CODES$1 = LITERALS$1 + 1 + LENGTH_CODES$1;
const D_CODES$1 = 30;
const BL_CODES$1 = 19;
const HEAP_SIZE$1 = 2 * L_CODES$1 + 1;
const MAX_BITS$1 = 15;
const MIN_MATCH$1 = 3;
const MAX_MATCH$1 = 258;
const MIN_LOOKAHEAD = MAX_MATCH$1 + MIN_MATCH$1 + 1;
const PRESET_DICT = 32;
const INIT_STATE = 42;
const EXTRA_STATE = 69;
const NAME_STATE = 73;
const COMMENT_STATE = 91;
const HCRC_STATE = 103;
const BUSY_STATE = 113;
const FINISH_STATE = 666;
const BS_NEED_MORE = 1;
const BS_BLOCK_DONE = 2;
const BS_FINISH_STARTED = 3;
const BS_FINISH_DONE = 4;
const OS_CODE = 3;
const err = (strm, errorCode) => {
  strm.msg = messages[errorCode];
  return errorCode;
};
const rank = (f3) => {
  return (f3 << 1) - (f3 > 4 ? 9 : 0);
};
const zero$1 = (buf) => {
  let len = buf.length;
  while (--len >= 0) {
    buf[len] = 0;
  }
};
let HASH_ZLIB = (s3, prev, data) => (prev << s3.hash_shift ^ data) & s3.hash_mask;
let HASH = HASH_ZLIB;
const flush_pending = (strm) => {
  const s3 = strm.state;
  let len = s3.pending;
  if (len > strm.avail_out) {
    len = strm.avail_out;
  }
  if (len === 0) {
    return;
  }
  strm.output.set(s3.pending_buf.subarray(s3.pending_out, s3.pending_out + len), strm.next_out);
  strm.next_out += len;
  s3.pending_out += len;
  strm.total_out += len;
  strm.avail_out -= len;
  s3.pending -= len;
  if (s3.pending === 0) {
    s3.pending_out = 0;
  }
};
const flush_block_only = (s3, last) => {
  _tr_flush_block$1(s3, s3.block_start >= 0 ? s3.block_start : -1, s3.strstart - s3.block_start, last);
  s3.block_start = s3.strstart;
  flush_pending(s3.strm);
};
const put_byte = (s3, b3) => {
  s3.pending_buf[s3.pending++] = b3;
};
const putShortMSB = (s3, b3) => {
  s3.pending_buf[s3.pending++] = b3 >>> 8 & 255;
  s3.pending_buf[s3.pending++] = b3 & 255;
};
const read_buf = (strm, buf, start, size2) => {
  let len = strm.avail_in;
  if (len > size2) {
    len = size2;
  }
  if (len === 0) {
    return 0;
  }
  strm.avail_in -= len;
  buf.set(strm.input.subarray(strm.next_in, strm.next_in + len), start);
  if (strm.state.wrap === 1) {
    strm.adler = adler32_1(strm.adler, buf, len, start);
  } else if (strm.state.wrap === 2) {
    strm.adler = crc32_1(strm.adler, buf, len, start);
  }
  strm.next_in += len;
  strm.total_in += len;
  return len;
};
const longest_match = (s3, cur_match) => {
  let chain_length = s3.max_chain_length;
  let scan = s3.strstart;
  let match;
  let len;
  let best_len = s3.prev_length;
  let nice_match = s3.nice_match;
  const limit = s3.strstart > s3.w_size - MIN_LOOKAHEAD ? s3.strstart - (s3.w_size - MIN_LOOKAHEAD) : 0;
  const _win = s3.window;
  const wmask = s3.w_mask;
  const prev = s3.prev;
  const strend = s3.strstart + MAX_MATCH$1;
  let scan_end1 = _win[scan + best_len - 1];
  let scan_end = _win[scan + best_len];
  if (s3.prev_length >= s3.good_match) {
    chain_length >>= 2;
  }
  if (nice_match > s3.lookahead) {
    nice_match = s3.lookahead;
  }
  do {
    match = cur_match;
    if (_win[match + best_len] !== scan_end || _win[match + best_len - 1] !== scan_end1 || _win[match] !== _win[scan] || _win[++match] !== _win[scan + 1]) {
      continue;
    }
    scan += 2;
    match++;
    do {
    } while (_win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && scan < strend);
    len = MAX_MATCH$1 - (strend - scan);
    scan = strend - MAX_MATCH$1;
    if (len > best_len) {
      s3.match_start = cur_match;
      best_len = len;
      if (len >= nice_match) {
        break;
      }
      scan_end1 = _win[scan + best_len - 1];
      scan_end = _win[scan + best_len];
    }
  } while ((cur_match = prev[cur_match & wmask]) > limit && --chain_length !== 0);
  if (best_len <= s3.lookahead) {
    return best_len;
  }
  return s3.lookahead;
};
const fill_window = (s3) => {
  const _w_size = s3.w_size;
  let p3, n3, m3, more, str;
  do {
    more = s3.window_size - s3.lookahead - s3.strstart;
    if (s3.strstart >= _w_size + (_w_size - MIN_LOOKAHEAD)) {
      s3.window.set(s3.window.subarray(_w_size, _w_size + _w_size), 0);
      s3.match_start -= _w_size;
      s3.strstart -= _w_size;
      s3.block_start -= _w_size;
      n3 = s3.hash_size;
      p3 = n3;
      do {
        m3 = s3.head[--p3];
        s3.head[p3] = m3 >= _w_size ? m3 - _w_size : 0;
      } while (--n3);
      n3 = _w_size;
      p3 = n3;
      do {
        m3 = s3.prev[--p3];
        s3.prev[p3] = m3 >= _w_size ? m3 - _w_size : 0;
      } while (--n3);
      more += _w_size;
    }
    if (s3.strm.avail_in === 0) {
      break;
    }
    n3 = read_buf(s3.strm, s3.window, s3.strstart + s3.lookahead, more);
    s3.lookahead += n3;
    if (s3.lookahead + s3.insert >= MIN_MATCH$1) {
      str = s3.strstart - s3.insert;
      s3.ins_h = s3.window[str];
      s3.ins_h = HASH(s3, s3.ins_h, s3.window[str + 1]);
      while (s3.insert) {
        s3.ins_h = HASH(s3, s3.ins_h, s3.window[str + MIN_MATCH$1 - 1]);
        s3.prev[str & s3.w_mask] = s3.head[s3.ins_h];
        s3.head[s3.ins_h] = str;
        str++;
        s3.insert--;
        if (s3.lookahead + s3.insert < MIN_MATCH$1) {
          break;
        }
      }
    }
  } while (s3.lookahead < MIN_LOOKAHEAD && s3.strm.avail_in !== 0);
};
const deflate_stored = (s3, flush) => {
  let max_block_size = 65535;
  if (max_block_size > s3.pending_buf_size - 5) {
    max_block_size = s3.pending_buf_size - 5;
  }
  for (; ; ) {
    if (s3.lookahead <= 1) {
      fill_window(s3);
      if (s3.lookahead === 0 && flush === Z_NO_FLUSH) {
        return BS_NEED_MORE;
      }
      if (s3.lookahead === 0) {
        break;
      }
    }
    s3.strstart += s3.lookahead;
    s3.lookahead = 0;
    const max_start = s3.block_start + max_block_size;
    if (s3.strstart === 0 || s3.strstart >= max_start) {
      s3.lookahead = s3.strstart - max_start;
      s3.strstart = max_start;
      flush_block_only(s3, false);
      if (s3.strm.avail_out === 0) {
        return BS_NEED_MORE;
      }
    }
    if (s3.strstart - s3.block_start >= s3.w_size - MIN_LOOKAHEAD) {
      flush_block_only(s3, false);
      if (s3.strm.avail_out === 0) {
        return BS_NEED_MORE;
      }
    }
  }
  s3.insert = 0;
  if (flush === Z_FINISH) {
    flush_block_only(s3, true);
    if (s3.strm.avail_out === 0) {
      return BS_FINISH_STARTED;
    }
    return BS_FINISH_DONE;
  }
  if (s3.strstart > s3.block_start) {
    flush_block_only(s3, false);
    if (s3.strm.avail_out === 0) {
      return BS_NEED_MORE;
    }
  }
  return BS_NEED_MORE;
};
const deflate_fast = (s3, flush) => {
  let hash_head;
  let bflush;
  for (; ; ) {
    if (s3.lookahead < MIN_LOOKAHEAD) {
      fill_window(s3);
      if (s3.lookahead < MIN_LOOKAHEAD && flush === Z_NO_FLUSH) {
        return BS_NEED_MORE;
      }
      if (s3.lookahead === 0) {
        break;
      }
    }
    hash_head = 0;
    if (s3.lookahead >= MIN_MATCH$1) {
      s3.ins_h = HASH(s3, s3.ins_h, s3.window[s3.strstart + MIN_MATCH$1 - 1]);
      hash_head = s3.prev[s3.strstart & s3.w_mask] = s3.head[s3.ins_h];
      s3.head[s3.ins_h] = s3.strstart;
    }
    if (hash_head !== 0 && s3.strstart - hash_head <= s3.w_size - MIN_LOOKAHEAD) {
      s3.match_length = longest_match(s3, hash_head);
    }
    if (s3.match_length >= MIN_MATCH$1) {
      bflush = _tr_tally$1(s3, s3.strstart - s3.match_start, s3.match_length - MIN_MATCH$1);
      s3.lookahead -= s3.match_length;
      if (s3.match_length <= s3.max_lazy_match && s3.lookahead >= MIN_MATCH$1) {
        s3.match_length--;
        do {
          s3.strstart++;
          s3.ins_h = HASH(s3, s3.ins_h, s3.window[s3.strstart + MIN_MATCH$1 - 1]);
          hash_head = s3.prev[s3.strstart & s3.w_mask] = s3.head[s3.ins_h];
          s3.head[s3.ins_h] = s3.strstart;
        } while (--s3.match_length !== 0);
        s3.strstart++;
      } else {
        s3.strstart += s3.match_length;
        s3.match_length = 0;
        s3.ins_h = s3.window[s3.strstart];
        s3.ins_h = HASH(s3, s3.ins_h, s3.window[s3.strstart + 1]);
      }
    } else {
      bflush = _tr_tally$1(s3, 0, s3.window[s3.strstart]);
      s3.lookahead--;
      s3.strstart++;
    }
    if (bflush) {
      flush_block_only(s3, false);
      if (s3.strm.avail_out === 0) {
        return BS_NEED_MORE;
      }
    }
  }
  s3.insert = s3.strstart < MIN_MATCH$1 - 1 ? s3.strstart : MIN_MATCH$1 - 1;
  if (flush === Z_FINISH) {
    flush_block_only(s3, true);
    if (s3.strm.avail_out === 0) {
      return BS_FINISH_STARTED;
    }
    return BS_FINISH_DONE;
  }
  if (s3.last_lit) {
    flush_block_only(s3, false);
    if (s3.strm.avail_out === 0) {
      return BS_NEED_MORE;
    }
  }
  return BS_BLOCK_DONE;
};
const deflate_slow = (s3, flush) => {
  let hash_head;
  let bflush;
  let max_insert;
  for (; ; ) {
    if (s3.lookahead < MIN_LOOKAHEAD) {
      fill_window(s3);
      if (s3.lookahead < MIN_LOOKAHEAD && flush === Z_NO_FLUSH) {
        return BS_NEED_MORE;
      }
      if (s3.lookahead === 0) {
        break;
      }
    }
    hash_head = 0;
    if (s3.lookahead >= MIN_MATCH$1) {
      s3.ins_h = HASH(s3, s3.ins_h, s3.window[s3.strstart + MIN_MATCH$1 - 1]);
      hash_head = s3.prev[s3.strstart & s3.w_mask] = s3.head[s3.ins_h];
      s3.head[s3.ins_h] = s3.strstart;
    }
    s3.prev_length = s3.match_length;
    s3.prev_match = s3.match_start;
    s3.match_length = MIN_MATCH$1 - 1;
    if (hash_head !== 0 && s3.prev_length < s3.max_lazy_match && s3.strstart - hash_head <= s3.w_size - MIN_LOOKAHEAD) {
      s3.match_length = longest_match(s3, hash_head);
      if (s3.match_length <= 5 && (s3.strategy === Z_FILTERED || s3.match_length === MIN_MATCH$1 && s3.strstart - s3.match_start > 4096)) {
        s3.match_length = MIN_MATCH$1 - 1;
      }
    }
    if (s3.prev_length >= MIN_MATCH$1 && s3.match_length <= s3.prev_length) {
      max_insert = s3.strstart + s3.lookahead - MIN_MATCH$1;
      bflush = _tr_tally$1(s3, s3.strstart - 1 - s3.prev_match, s3.prev_length - MIN_MATCH$1);
      s3.lookahead -= s3.prev_length - 1;
      s3.prev_length -= 2;
      do {
        if (++s3.strstart <= max_insert) {
          s3.ins_h = HASH(s3, s3.ins_h, s3.window[s3.strstart + MIN_MATCH$1 - 1]);
          hash_head = s3.prev[s3.strstart & s3.w_mask] = s3.head[s3.ins_h];
          s3.head[s3.ins_h] = s3.strstart;
        }
      } while (--s3.prev_length !== 0);
      s3.match_available = 0;
      s3.match_length = MIN_MATCH$1 - 1;
      s3.strstart++;
      if (bflush) {
        flush_block_only(s3, false);
        if (s3.strm.avail_out === 0) {
          return BS_NEED_MORE;
        }
      }
    } else if (s3.match_available) {
      bflush = _tr_tally$1(s3, 0, s3.window[s3.strstart - 1]);
      if (bflush) {
        flush_block_only(s3, false);
      }
      s3.strstart++;
      s3.lookahead--;
      if (s3.strm.avail_out === 0) {
        return BS_NEED_MORE;
      }
    } else {
      s3.match_available = 1;
      s3.strstart++;
      s3.lookahead--;
    }
  }
  if (s3.match_available) {
    bflush = _tr_tally$1(s3, 0, s3.window[s3.strstart - 1]);
    s3.match_available = 0;
  }
  s3.insert = s3.strstart < MIN_MATCH$1 - 1 ? s3.strstart : MIN_MATCH$1 - 1;
  if (flush === Z_FINISH) {
    flush_block_only(s3, true);
    if (s3.strm.avail_out === 0) {
      return BS_FINISH_STARTED;
    }
    return BS_FINISH_DONE;
  }
  if (s3.last_lit) {
    flush_block_only(s3, false);
    if (s3.strm.avail_out === 0) {
      return BS_NEED_MORE;
    }
  }
  return BS_BLOCK_DONE;
};
const deflate_rle = (s3, flush) => {
  let bflush;
  let prev;
  let scan, strend;
  const _win = s3.window;
  for (; ; ) {
    if (s3.lookahead <= MAX_MATCH$1) {
      fill_window(s3);
      if (s3.lookahead <= MAX_MATCH$1 && flush === Z_NO_FLUSH) {
        return BS_NEED_MORE;
      }
      if (s3.lookahead === 0) {
        break;
      }
    }
    s3.match_length = 0;
    if (s3.lookahead >= MIN_MATCH$1 && s3.strstart > 0) {
      scan = s3.strstart - 1;
      prev = _win[scan];
      if (prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan]) {
        strend = s3.strstart + MAX_MATCH$1;
        do {
        } while (prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && scan < strend);
        s3.match_length = MAX_MATCH$1 - (strend - scan);
        if (s3.match_length > s3.lookahead) {
          s3.match_length = s3.lookahead;
        }
      }
    }
    if (s3.match_length >= MIN_MATCH$1) {
      bflush = _tr_tally$1(s3, 1, s3.match_length - MIN_MATCH$1);
      s3.lookahead -= s3.match_length;
      s3.strstart += s3.match_length;
      s3.match_length = 0;
    } else {
      bflush = _tr_tally$1(s3, 0, s3.window[s3.strstart]);
      s3.lookahead--;
      s3.strstart++;
    }
    if (bflush) {
      flush_block_only(s3, false);
      if (s3.strm.avail_out === 0) {
        return BS_NEED_MORE;
      }
    }
  }
  s3.insert = 0;
  if (flush === Z_FINISH) {
    flush_block_only(s3, true);
    if (s3.strm.avail_out === 0) {
      return BS_FINISH_STARTED;
    }
    return BS_FINISH_DONE;
  }
  if (s3.last_lit) {
    flush_block_only(s3, false);
    if (s3.strm.avail_out === 0) {
      return BS_NEED_MORE;
    }
  }
  return BS_BLOCK_DONE;
};
const deflate_huff = (s3, flush) => {
  let bflush;
  for (; ; ) {
    if (s3.lookahead === 0) {
      fill_window(s3);
      if (s3.lookahead === 0) {
        if (flush === Z_NO_FLUSH) {
          return BS_NEED_MORE;
        }
        break;
      }
    }
    s3.match_length = 0;
    bflush = _tr_tally$1(s3, 0, s3.window[s3.strstart]);
    s3.lookahead--;
    s3.strstart++;
    if (bflush) {
      flush_block_only(s3, false);
      if (s3.strm.avail_out === 0) {
        return BS_NEED_MORE;
      }
    }
  }
  s3.insert = 0;
  if (flush === Z_FINISH) {
    flush_block_only(s3, true);
    if (s3.strm.avail_out === 0) {
      return BS_FINISH_STARTED;
    }
    return BS_FINISH_DONE;
  }
  if (s3.last_lit) {
    flush_block_only(s3, false);
    if (s3.strm.avail_out === 0) {
      return BS_NEED_MORE;
    }
  }
  return BS_BLOCK_DONE;
};
function Config(good_length, max_lazy, nice_length, max_chain, func) {
  this.good_length = good_length;
  this.max_lazy = max_lazy;
  this.nice_length = nice_length;
  this.max_chain = max_chain;
  this.func = func;
}
const configuration_table = [
  /*      good lazy nice chain */
  new Config(0, 0, 0, 0, deflate_stored),
  /* 0 store only */
  new Config(4, 4, 8, 4, deflate_fast),
  /* 1 max speed, no lazy matches */
  new Config(4, 5, 16, 8, deflate_fast),
  /* 2 */
  new Config(4, 6, 32, 32, deflate_fast),
  /* 3 */
  new Config(4, 4, 16, 16, deflate_slow),
  /* 4 lazy matches */
  new Config(8, 16, 32, 32, deflate_slow),
  /* 5 */
  new Config(8, 16, 128, 128, deflate_slow),
  /* 6 */
  new Config(8, 32, 128, 256, deflate_slow),
  /* 7 */
  new Config(32, 128, 258, 1024, deflate_slow),
  /* 8 */
  new Config(32, 258, 258, 4096, deflate_slow)
  /* 9 max compression */
];
const lm_init = (s3) => {
  s3.window_size = 2 * s3.w_size;
  zero$1(s3.head);
  s3.max_lazy_match = configuration_table[s3.level].max_lazy;
  s3.good_match = configuration_table[s3.level].good_length;
  s3.nice_match = configuration_table[s3.level].nice_length;
  s3.max_chain_length = configuration_table[s3.level].max_chain;
  s3.strstart = 0;
  s3.block_start = 0;
  s3.lookahead = 0;
  s3.insert = 0;
  s3.match_length = s3.prev_length = MIN_MATCH$1 - 1;
  s3.match_available = 0;
  s3.ins_h = 0;
};
function DeflateState() {
  this.strm = null;
  this.status = 0;
  this.pending_buf = null;
  this.pending_buf_size = 0;
  this.pending_out = 0;
  this.pending = 0;
  this.wrap = 0;
  this.gzhead = null;
  this.gzindex = 0;
  this.method = Z_DEFLATED;
  this.last_flush = -1;
  this.w_size = 0;
  this.w_bits = 0;
  this.w_mask = 0;
  this.window = null;
  this.window_size = 0;
  this.prev = null;
  this.head = null;
  this.ins_h = 0;
  this.hash_size = 0;
  this.hash_bits = 0;
  this.hash_mask = 0;
  this.hash_shift = 0;
  this.block_start = 0;
  this.match_length = 0;
  this.prev_match = 0;
  this.match_available = 0;
  this.strstart = 0;
  this.match_start = 0;
  this.lookahead = 0;
  this.prev_length = 0;
  this.max_chain_length = 0;
  this.max_lazy_match = 0;
  this.level = 0;
  this.strategy = 0;
  this.good_match = 0;
  this.nice_match = 0;
  this.dyn_ltree = new Uint16Array(HEAP_SIZE$1 * 2);
  this.dyn_dtree = new Uint16Array((2 * D_CODES$1 + 1) * 2);
  this.bl_tree = new Uint16Array((2 * BL_CODES$1 + 1) * 2);
  zero$1(this.dyn_ltree);
  zero$1(this.dyn_dtree);
  zero$1(this.bl_tree);
  this.l_desc = null;
  this.d_desc = null;
  this.bl_desc = null;
  this.bl_count = new Uint16Array(MAX_BITS$1 + 1);
  this.heap = new Uint16Array(2 * L_CODES$1 + 1);
  zero$1(this.heap);
  this.heap_len = 0;
  this.heap_max = 0;
  this.depth = new Uint16Array(2 * L_CODES$1 + 1);
  zero$1(this.depth);
  this.l_buf = 0;
  this.lit_bufsize = 0;
  this.last_lit = 0;
  this.d_buf = 0;
  this.opt_len = 0;
  this.static_len = 0;
  this.matches = 0;
  this.insert = 0;
  this.bi_buf = 0;
  this.bi_valid = 0;
}
const deflateResetKeep = (strm) => {
  if (!strm || !strm.state) {
    return err(strm, Z_STREAM_ERROR);
  }
  strm.total_in = strm.total_out = 0;
  strm.data_type = Z_UNKNOWN$1;
  const s3 = strm.state;
  s3.pending = 0;
  s3.pending_out = 0;
  if (s3.wrap < 0) {
    s3.wrap = -s3.wrap;
  }
  s3.status = s3.wrap ? INIT_STATE : BUSY_STATE;
  strm.adler = s3.wrap === 2 ? 0 : 1;
  s3.last_flush = Z_NO_FLUSH;
  _tr_init$1(s3);
  return Z_OK;
};
const deflateReset = (strm) => {
  const ret = deflateResetKeep(strm);
  if (ret === Z_OK) {
    lm_init(strm.state);
  }
  return ret;
};
const deflateSetHeader = (strm, head) => {
  if (!strm || !strm.state) {
    return Z_STREAM_ERROR;
  }
  if (strm.state.wrap !== 2) {
    return Z_STREAM_ERROR;
  }
  strm.state.gzhead = head;
  return Z_OK;
};
const deflateInit2 = (strm, level, method, windowBits, memLevel, strategy) => {
  if (!strm) {
    return Z_STREAM_ERROR;
  }
  let wrap = 1;
  if (level === Z_DEFAULT_COMPRESSION) {
    level = 6;
  }
  if (windowBits < 0) {
    wrap = 0;
    windowBits = -windowBits;
  } else if (windowBits > 15) {
    wrap = 2;
    windowBits -= 16;
  }
  if (memLevel < 1 || memLevel > MAX_MEM_LEVEL || method !== Z_DEFLATED || windowBits < 8 || windowBits > 15 || level < 0 || level > 9 || strategy < 0 || strategy > Z_FIXED$1) {
    return err(strm, Z_STREAM_ERROR);
  }
  if (windowBits === 8) {
    windowBits = 9;
  }
  const s3 = new DeflateState();
  strm.state = s3;
  s3.strm = strm;
  s3.wrap = wrap;
  s3.gzhead = null;
  s3.w_bits = windowBits;
  s3.w_size = 1 << s3.w_bits;
  s3.w_mask = s3.w_size - 1;
  s3.hash_bits = memLevel + 7;
  s3.hash_size = 1 << s3.hash_bits;
  s3.hash_mask = s3.hash_size - 1;
  s3.hash_shift = ~~((s3.hash_bits + MIN_MATCH$1 - 1) / MIN_MATCH$1);
  s3.window = new Uint8Array(s3.w_size * 2);
  s3.head = new Uint16Array(s3.hash_size);
  s3.prev = new Uint16Array(s3.w_size);
  s3.lit_bufsize = 1 << memLevel + 6;
  s3.pending_buf_size = s3.lit_bufsize * 4;
  s3.pending_buf = new Uint8Array(s3.pending_buf_size);
  s3.d_buf = 1 * s3.lit_bufsize;
  s3.l_buf = (1 + 2) * s3.lit_bufsize;
  s3.level = level;
  s3.strategy = strategy;
  s3.method = method;
  return deflateReset(strm);
};
const deflateInit = (strm, level) => {
  return deflateInit2(strm, level, Z_DEFLATED, MAX_WBITS, DEF_MEM_LEVEL, Z_DEFAULT_STRATEGY);
};
const deflate = (strm, flush) => {
  let beg, val;
  if (!strm || !strm.state || flush > Z_BLOCK || flush < 0) {
    return strm ? err(strm, Z_STREAM_ERROR) : Z_STREAM_ERROR;
  }
  const s3 = strm.state;
  if (!strm.output || !strm.input && strm.avail_in !== 0 || s3.status === FINISH_STATE && flush !== Z_FINISH) {
    return err(strm, strm.avail_out === 0 ? Z_BUF_ERROR : Z_STREAM_ERROR);
  }
  s3.strm = strm;
  const old_flush = s3.last_flush;
  s3.last_flush = flush;
  if (s3.status === INIT_STATE) {
    if (s3.wrap === 2) {
      strm.adler = 0;
      put_byte(s3, 31);
      put_byte(s3, 139);
      put_byte(s3, 8);
      if (!s3.gzhead) {
        put_byte(s3, 0);
        put_byte(s3, 0);
        put_byte(s3, 0);
        put_byte(s3, 0);
        put_byte(s3, 0);
        put_byte(s3, s3.level === 9 ? 2 : s3.strategy >= Z_HUFFMAN_ONLY || s3.level < 2 ? 4 : 0);
        put_byte(s3, OS_CODE);
        s3.status = BUSY_STATE;
      } else {
        put_byte(
          s3,
          (s3.gzhead.text ? 1 : 0) + (s3.gzhead.hcrc ? 2 : 0) + (!s3.gzhead.extra ? 0 : 4) + (!s3.gzhead.name ? 0 : 8) + (!s3.gzhead.comment ? 0 : 16)
        );
        put_byte(s3, s3.gzhead.time & 255);
        put_byte(s3, s3.gzhead.time >> 8 & 255);
        put_byte(s3, s3.gzhead.time >> 16 & 255);
        put_byte(s3, s3.gzhead.time >> 24 & 255);
        put_byte(s3, s3.level === 9 ? 2 : s3.strategy >= Z_HUFFMAN_ONLY || s3.level < 2 ? 4 : 0);
        put_byte(s3, s3.gzhead.os & 255);
        if (s3.gzhead.extra && s3.gzhead.extra.length) {
          put_byte(s3, s3.gzhead.extra.length & 255);
          put_byte(s3, s3.gzhead.extra.length >> 8 & 255);
        }
        if (s3.gzhead.hcrc) {
          strm.adler = crc32_1(strm.adler, s3.pending_buf, s3.pending, 0);
        }
        s3.gzindex = 0;
        s3.status = EXTRA_STATE;
      }
    } else {
      let header = Z_DEFLATED + (s3.w_bits - 8 << 4) << 8;
      let level_flags = -1;
      if (s3.strategy >= Z_HUFFMAN_ONLY || s3.level < 2) {
        level_flags = 0;
      } else if (s3.level < 6) {
        level_flags = 1;
      } else if (s3.level === 6) {
        level_flags = 2;
      } else {
        level_flags = 3;
      }
      header |= level_flags << 6;
      if (s3.strstart !== 0) {
        header |= PRESET_DICT;
      }
      header += 31 - header % 31;
      s3.status = BUSY_STATE;
      putShortMSB(s3, header);
      if (s3.strstart !== 0) {
        putShortMSB(s3, strm.adler >>> 16);
        putShortMSB(s3, strm.adler & 65535);
      }
      strm.adler = 1;
    }
  }
  if (s3.status === EXTRA_STATE) {
    if (s3.gzhead.extra) {
      beg = s3.pending;
      while (s3.gzindex < (s3.gzhead.extra.length & 65535)) {
        if (s3.pending === s3.pending_buf_size) {
          if (s3.gzhead.hcrc && s3.pending > beg) {
            strm.adler = crc32_1(strm.adler, s3.pending_buf, s3.pending - beg, beg);
          }
          flush_pending(strm);
          beg = s3.pending;
          if (s3.pending === s3.pending_buf_size) {
            break;
          }
        }
        put_byte(s3, s3.gzhead.extra[s3.gzindex] & 255);
        s3.gzindex++;
      }
      if (s3.gzhead.hcrc && s3.pending > beg) {
        strm.adler = crc32_1(strm.adler, s3.pending_buf, s3.pending - beg, beg);
      }
      if (s3.gzindex === s3.gzhead.extra.length) {
        s3.gzindex = 0;
        s3.status = NAME_STATE;
      }
    } else {
      s3.status = NAME_STATE;
    }
  }
  if (s3.status === NAME_STATE) {
    if (s3.gzhead.name) {
      beg = s3.pending;
      do {
        if (s3.pending === s3.pending_buf_size) {
          if (s3.gzhead.hcrc && s3.pending > beg) {
            strm.adler = crc32_1(strm.adler, s3.pending_buf, s3.pending - beg, beg);
          }
          flush_pending(strm);
          beg = s3.pending;
          if (s3.pending === s3.pending_buf_size) {
            val = 1;
            break;
          }
        }
        if (s3.gzindex < s3.gzhead.name.length) {
          val = s3.gzhead.name.charCodeAt(s3.gzindex++) & 255;
        } else {
          val = 0;
        }
        put_byte(s3, val);
      } while (val !== 0);
      if (s3.gzhead.hcrc && s3.pending > beg) {
        strm.adler = crc32_1(strm.adler, s3.pending_buf, s3.pending - beg, beg);
      }
      if (val === 0) {
        s3.gzindex = 0;
        s3.status = COMMENT_STATE;
      }
    } else {
      s3.status = COMMENT_STATE;
    }
  }
  if (s3.status === COMMENT_STATE) {
    if (s3.gzhead.comment) {
      beg = s3.pending;
      do {
        if (s3.pending === s3.pending_buf_size) {
          if (s3.gzhead.hcrc && s3.pending > beg) {
            strm.adler = crc32_1(strm.adler, s3.pending_buf, s3.pending - beg, beg);
          }
          flush_pending(strm);
          beg = s3.pending;
          if (s3.pending === s3.pending_buf_size) {
            val = 1;
            break;
          }
        }
        if (s3.gzindex < s3.gzhead.comment.length) {
          val = s3.gzhead.comment.charCodeAt(s3.gzindex++) & 255;
        } else {
          val = 0;
        }
        put_byte(s3, val);
      } while (val !== 0);
      if (s3.gzhead.hcrc && s3.pending > beg) {
        strm.adler = crc32_1(strm.adler, s3.pending_buf, s3.pending - beg, beg);
      }
      if (val === 0) {
        s3.status = HCRC_STATE;
      }
    } else {
      s3.status = HCRC_STATE;
    }
  }
  if (s3.status === HCRC_STATE) {
    if (s3.gzhead.hcrc) {
      if (s3.pending + 2 > s3.pending_buf_size) {
        flush_pending(strm);
      }
      if (s3.pending + 2 <= s3.pending_buf_size) {
        put_byte(s3, strm.adler & 255);
        put_byte(s3, strm.adler >> 8 & 255);
        strm.adler = 0;
        s3.status = BUSY_STATE;
      }
    } else {
      s3.status = BUSY_STATE;
    }
  }
  if (s3.pending !== 0) {
    flush_pending(strm);
    if (strm.avail_out === 0) {
      s3.last_flush = -1;
      return Z_OK;
    }
  } else if (strm.avail_in === 0 && rank(flush) <= rank(old_flush) && flush !== Z_FINISH) {
    return err(strm, Z_BUF_ERROR);
  }
  if (s3.status === FINISH_STATE && strm.avail_in !== 0) {
    return err(strm, Z_BUF_ERROR);
  }
  if (strm.avail_in !== 0 || s3.lookahead !== 0 || flush !== Z_NO_FLUSH && s3.status !== FINISH_STATE) {
    let bstate = s3.strategy === Z_HUFFMAN_ONLY ? deflate_huff(s3, flush) : s3.strategy === Z_RLE ? deflate_rle(s3, flush) : configuration_table[s3.level].func(s3, flush);
    if (bstate === BS_FINISH_STARTED || bstate === BS_FINISH_DONE) {
      s3.status = FINISH_STATE;
    }
    if (bstate === BS_NEED_MORE || bstate === BS_FINISH_STARTED) {
      if (strm.avail_out === 0) {
        s3.last_flush = -1;
      }
      return Z_OK;
    }
    if (bstate === BS_BLOCK_DONE) {
      if (flush === Z_PARTIAL_FLUSH) {
        _tr_align$1(s3);
      } else if (flush !== Z_BLOCK) {
        _tr_stored_block$1(s3, 0, 0, false);
        if (flush === Z_FULL_FLUSH) {
          zero$1(s3.head);
          if (s3.lookahead === 0) {
            s3.strstart = 0;
            s3.block_start = 0;
            s3.insert = 0;
          }
        }
      }
      flush_pending(strm);
      if (strm.avail_out === 0) {
        s3.last_flush = -1;
        return Z_OK;
      }
    }
  }
  if (flush !== Z_FINISH) {
    return Z_OK;
  }
  if (s3.wrap <= 0) {
    return Z_STREAM_END;
  }
  if (s3.wrap === 2) {
    put_byte(s3, strm.adler & 255);
    put_byte(s3, strm.adler >> 8 & 255);
    put_byte(s3, strm.adler >> 16 & 255);
    put_byte(s3, strm.adler >> 24 & 255);
    put_byte(s3, strm.total_in & 255);
    put_byte(s3, strm.total_in >> 8 & 255);
    put_byte(s3, strm.total_in >> 16 & 255);
    put_byte(s3, strm.total_in >> 24 & 255);
  } else {
    putShortMSB(s3, strm.adler >>> 16);
    putShortMSB(s3, strm.adler & 65535);
  }
  flush_pending(strm);
  if (s3.wrap > 0) {
    s3.wrap = -s3.wrap;
  }
  return s3.pending !== 0 ? Z_OK : Z_STREAM_END;
};
const deflateEnd = (strm) => {
  if (!strm || !strm.state) {
    return Z_STREAM_ERROR;
  }
  const status = strm.state.status;
  if (status !== INIT_STATE && status !== EXTRA_STATE && status !== NAME_STATE && status !== COMMENT_STATE && status !== HCRC_STATE && status !== BUSY_STATE && status !== FINISH_STATE) {
    return err(strm, Z_STREAM_ERROR);
  }
  strm.state = null;
  return status === BUSY_STATE ? err(strm, Z_DATA_ERROR) : Z_OK;
};
const deflateSetDictionary = (strm, dictionary) => {
  let dictLength = dictionary.length;
  if (!strm || !strm.state) {
    return Z_STREAM_ERROR;
  }
  const s3 = strm.state;
  const wrap = s3.wrap;
  if (wrap === 2 || wrap === 1 && s3.status !== INIT_STATE || s3.lookahead) {
    return Z_STREAM_ERROR;
  }
  if (wrap === 1) {
    strm.adler = adler32_1(strm.adler, dictionary, dictLength, 0);
  }
  s3.wrap = 0;
  if (dictLength >= s3.w_size) {
    if (wrap === 0) {
      zero$1(s3.head);
      s3.strstart = 0;
      s3.block_start = 0;
      s3.insert = 0;
    }
    let tmpDict = new Uint8Array(s3.w_size);
    tmpDict.set(dictionary.subarray(dictLength - s3.w_size, dictLength), 0);
    dictionary = tmpDict;
    dictLength = s3.w_size;
  }
  const avail = strm.avail_in;
  const next = strm.next_in;
  const input = strm.input;
  strm.avail_in = dictLength;
  strm.next_in = 0;
  strm.input = dictionary;
  fill_window(s3);
  while (s3.lookahead >= MIN_MATCH$1) {
    let str = s3.strstart;
    let n3 = s3.lookahead - (MIN_MATCH$1 - 1);
    do {
      s3.ins_h = HASH(s3, s3.ins_h, s3.window[str + MIN_MATCH$1 - 1]);
      s3.prev[str & s3.w_mask] = s3.head[s3.ins_h];
      s3.head[s3.ins_h] = str;
      str++;
    } while (--n3);
    s3.strstart = str;
    s3.lookahead = MIN_MATCH$1 - 1;
    fill_window(s3);
  }
  s3.strstart += s3.lookahead;
  s3.block_start = s3.strstart;
  s3.insert = s3.lookahead;
  s3.lookahead = 0;
  s3.match_length = s3.prev_length = MIN_MATCH$1 - 1;
  s3.match_available = 0;
  strm.next_in = next;
  strm.input = input;
  strm.avail_in = avail;
  s3.wrap = wrap;
  return Z_OK;
};
var deflateInit_1 = deflateInit;
var deflateInit2_1 = deflateInit2;
var deflateReset_1 = deflateReset;
var deflateResetKeep_1 = deflateResetKeep;
var deflateSetHeader_1 = deflateSetHeader;
var deflate_2 = deflate;
var deflateEnd_1 = deflateEnd;
var deflateSetDictionary_1 = deflateSetDictionary;
var deflateInfo = "pako deflate (from Nodeca project)";
var deflate_1 = {
  deflateInit: deflateInit_1,
  deflateInit2: deflateInit2_1,
  deflateReset: deflateReset_1,
  deflateResetKeep: deflateResetKeep_1,
  deflateSetHeader: deflateSetHeader_1,
  deflate: deflate_2,
  deflateEnd: deflateEnd_1,
  deflateSetDictionary: deflateSetDictionary_1,
  deflateInfo
};
const _has = (obj, key) => {
  return Object.prototype.hasOwnProperty.call(obj, key);
};
var assign = function(obj) {
  const sources = Array.prototype.slice.call(arguments, 1);
  while (sources.length) {
    const source = sources.shift();
    if (!source) {
      continue;
    }
    if (typeof source !== "object") {
      throw new TypeError(source + "must be non-object");
    }
    for (const p3 in source) {
      if (_has(source, p3)) {
        obj[p3] = source[p3];
      }
    }
  }
  return obj;
};
var flattenChunks = (chunks) => {
  let len = 0;
  for (let i3 = 0, l3 = chunks.length; i3 < l3; i3++) {
    len += chunks[i3].length;
  }
  const result = new Uint8Array(len);
  for (let i3 = 0, pos = 0, l3 = chunks.length; i3 < l3; i3++) {
    let chunk = chunks[i3];
    result.set(chunk, pos);
    pos += chunk.length;
  }
  return result;
};
var common = {
  assign,
  flattenChunks
};
let STR_APPLY_UIA_OK = true;
try {
  String.fromCharCode.apply(null, new Uint8Array(1));
} catch (__2) {
  STR_APPLY_UIA_OK = false;
}
const _utf8len = new Uint8Array(256);
for (let q3 = 0; q3 < 256; q3++) {
  _utf8len[q3] = q3 >= 252 ? 6 : q3 >= 248 ? 5 : q3 >= 240 ? 4 : q3 >= 224 ? 3 : q3 >= 192 ? 2 : 1;
}
_utf8len[254] = _utf8len[254] = 1;
var string2buf = (str) => {
  let buf, c3, c22, m_pos, i3, str_len = str.length, buf_len = 0;
  for (m_pos = 0; m_pos < str_len; m_pos++) {
    c3 = str.charCodeAt(m_pos);
    if ((c3 & 64512) === 55296 && m_pos + 1 < str_len) {
      c22 = str.charCodeAt(m_pos + 1);
      if ((c22 & 64512) === 56320) {
        c3 = 65536 + (c3 - 55296 << 10) + (c22 - 56320);
        m_pos++;
      }
    }
    buf_len += c3 < 128 ? 1 : c3 < 2048 ? 2 : c3 < 65536 ? 3 : 4;
  }
  buf = new Uint8Array(buf_len);
  for (i3 = 0, m_pos = 0; i3 < buf_len; m_pos++) {
    c3 = str.charCodeAt(m_pos);
    if ((c3 & 64512) === 55296 && m_pos + 1 < str_len) {
      c22 = str.charCodeAt(m_pos + 1);
      if ((c22 & 64512) === 56320) {
        c3 = 65536 + (c3 - 55296 << 10) + (c22 - 56320);
        m_pos++;
      }
    }
    if (c3 < 128) {
      buf[i3++] = c3;
    } else if (c3 < 2048) {
      buf[i3++] = 192 | c3 >>> 6;
      buf[i3++] = 128 | c3 & 63;
    } else if (c3 < 65536) {
      buf[i3++] = 224 | c3 >>> 12;
      buf[i3++] = 128 | c3 >>> 6 & 63;
      buf[i3++] = 128 | c3 & 63;
    } else {
      buf[i3++] = 240 | c3 >>> 18;
      buf[i3++] = 128 | c3 >>> 12 & 63;
      buf[i3++] = 128 | c3 >>> 6 & 63;
      buf[i3++] = 128 | c3 & 63;
    }
  }
  return buf;
};
const buf2binstring = (buf, len) => {
  if (len < 65534) {
    if (buf.subarray && STR_APPLY_UIA_OK) {
      return String.fromCharCode.apply(null, buf.length === len ? buf : buf.subarray(0, len));
    }
  }
  let result = "";
  for (let i3 = 0; i3 < len; i3++) {
    result += String.fromCharCode(buf[i3]);
  }
  return result;
};
var buf2string = (buf, max2) => {
  let i3, out;
  const len = max2 || buf.length;
  const utf16buf = new Array(len * 2);
  for (out = 0, i3 = 0; i3 < len; ) {
    let c3 = buf[i3++];
    if (c3 < 128) {
      utf16buf[out++] = c3;
      continue;
    }
    let c_len = _utf8len[c3];
    if (c_len > 4) {
      utf16buf[out++] = 65533;
      i3 += c_len - 1;
      continue;
    }
    c3 &= c_len === 2 ? 31 : c_len === 3 ? 15 : 7;
    while (c_len > 1 && i3 < len) {
      c3 = c3 << 6 | buf[i3++] & 63;
      c_len--;
    }
    if (c_len > 1) {
      utf16buf[out++] = 65533;
      continue;
    }
    if (c3 < 65536) {
      utf16buf[out++] = c3;
    } else {
      c3 -= 65536;
      utf16buf[out++] = 55296 | c3 >> 10 & 1023;
      utf16buf[out++] = 56320 | c3 & 1023;
    }
  }
  return buf2binstring(utf16buf, out);
};
var utf8border = (buf, max2) => {
  max2 = max2 || buf.length;
  if (max2 > buf.length) {
    max2 = buf.length;
  }
  let pos = max2 - 1;
  while (pos >= 0 && (buf[pos] & 192) === 128) {
    pos--;
  }
  if (pos < 0) {
    return max2;
  }
  if (pos === 0) {
    return max2;
  }
  return pos + _utf8len[buf[pos]] > max2 ? pos : max2;
};
var strings = {
  string2buf,
  buf2string,
  utf8border
};
function ZStream() {
  this.input = null;
  this.next_in = 0;
  this.avail_in = 0;
  this.total_in = 0;
  this.output = null;
  this.next_out = 0;
  this.avail_out = 0;
  this.total_out = 0;
  this.msg = "";
  this.state = null;
  this.data_type = 2;
  this.adler = 0;
}
var zstream = ZStream;
const toString = Object.prototype.toString;
const {
  Z_NO_FLUSH: Z_NO_FLUSH$1,
  Z_SYNC_FLUSH,
  Z_FULL_FLUSH: Z_FULL_FLUSH$1,
  Z_FINISH: Z_FINISH$1,
  Z_OK: Z_OK$1,
  Z_STREAM_END: Z_STREAM_END$1,
  Z_DEFAULT_COMPRESSION: Z_DEFAULT_COMPRESSION$1,
  Z_DEFAULT_STRATEGY: Z_DEFAULT_STRATEGY$1,
  Z_DEFLATED: Z_DEFLATED$1
} = constants;
function Deflate(options) {
  this.options = common.assign({
    level: Z_DEFAULT_COMPRESSION$1,
    method: Z_DEFLATED$1,
    chunkSize: 16384,
    windowBits: 15,
    memLevel: 8,
    strategy: Z_DEFAULT_STRATEGY$1
  }, options || {});
  let opt = this.options;
  if (opt.raw && opt.windowBits > 0) {
    opt.windowBits = -opt.windowBits;
  } else if (opt.gzip && opt.windowBits > 0 && opt.windowBits < 16) {
    opt.windowBits += 16;
  }
  this.err = 0;
  this.msg = "";
  this.ended = false;
  this.chunks = [];
  this.strm = new zstream();
  this.strm.avail_out = 0;
  let status = deflate_1.deflateInit2(
    this.strm,
    opt.level,
    opt.method,
    opt.windowBits,
    opt.memLevel,
    opt.strategy
  );
  if (status !== Z_OK$1) {
    throw new Error(messages[status]);
  }
  if (opt.header) {
    deflate_1.deflateSetHeader(this.strm, opt.header);
  }
  if (opt.dictionary) {
    let dict;
    if (typeof opt.dictionary === "string") {
      dict = strings.string2buf(opt.dictionary);
    } else if (toString.call(opt.dictionary) === "[object ArrayBuffer]") {
      dict = new Uint8Array(opt.dictionary);
    } else {
      dict = opt.dictionary;
    }
    status = deflate_1.deflateSetDictionary(this.strm, dict);
    if (status !== Z_OK$1) {
      throw new Error(messages[status]);
    }
    this._dict_set = true;
  }
}
Deflate.prototype.push = function(data, flush_mode) {
  const strm = this.strm;
  const chunkSize = this.options.chunkSize;
  let status, _flush_mode;
  if (this.ended) {
    return false;
  }
  if (flush_mode === ~~flush_mode) _flush_mode = flush_mode;
  else _flush_mode = flush_mode === true ? Z_FINISH$1 : Z_NO_FLUSH$1;
  if (typeof data === "string") {
    strm.input = strings.string2buf(data);
  } else if (toString.call(data) === "[object ArrayBuffer]") {
    strm.input = new Uint8Array(data);
  } else {
    strm.input = data;
  }
  strm.next_in = 0;
  strm.avail_in = strm.input.length;
  for (; ; ) {
    if (strm.avail_out === 0) {
      strm.output = new Uint8Array(chunkSize);
      strm.next_out = 0;
      strm.avail_out = chunkSize;
    }
    if ((_flush_mode === Z_SYNC_FLUSH || _flush_mode === Z_FULL_FLUSH$1) && strm.avail_out <= 6) {
      this.onData(strm.output.subarray(0, strm.next_out));
      strm.avail_out = 0;
      continue;
    }
    status = deflate_1.deflate(strm, _flush_mode);
    if (status === Z_STREAM_END$1) {
      if (strm.next_out > 0) {
        this.onData(strm.output.subarray(0, strm.next_out));
      }
      status = deflate_1.deflateEnd(this.strm);
      this.onEnd(status);
      this.ended = true;
      return status === Z_OK$1;
    }
    if (strm.avail_out === 0) {
      this.onData(strm.output);
      continue;
    }
    if (_flush_mode > 0 && strm.next_out > 0) {
      this.onData(strm.output.subarray(0, strm.next_out));
      strm.avail_out = 0;
      continue;
    }
    if (strm.avail_in === 0) break;
  }
  return true;
};
Deflate.prototype.onData = function(chunk) {
  this.chunks.push(chunk);
};
Deflate.prototype.onEnd = function(status) {
  if (status === Z_OK$1) {
    this.result = common.flattenChunks(this.chunks);
  }
  this.chunks = [];
  this.err = status;
  this.msg = this.strm.msg;
};
function deflate$1(input, options) {
  const deflator = new Deflate(options);
  deflator.push(input, true);
  if (deflator.err) {
    throw deflator.msg || messages[deflator.err];
  }
  return deflator.result;
}
var deflate_2$1 = deflate$1;
var deflate_1$1 = {
  deflate: deflate_2$1
};
const BAD = 30;
const TYPE = 12;
var inffast = function inflate_fast(strm, start) {
  let _in;
  let last;
  let _out;
  let beg;
  let end;
  let dmax;
  let wsize;
  let whave;
  let wnext;
  let s_window;
  let hold;
  let bits;
  let lcode;
  let dcode;
  let lmask;
  let dmask;
  let here;
  let op2;
  let len;
  let dist2;
  let from;
  let from_source;
  let input, output;
  const state = strm.state;
  _in = strm.next_in;
  input = strm.input;
  last = _in + (strm.avail_in - 5);
  _out = strm.next_out;
  output = strm.output;
  beg = _out - (start - strm.avail_out);
  end = _out + (strm.avail_out - 257);
  dmax = state.dmax;
  wsize = state.wsize;
  whave = state.whave;
  wnext = state.wnext;
  s_window = state.window;
  hold = state.hold;
  bits = state.bits;
  lcode = state.lencode;
  dcode = state.distcode;
  lmask = (1 << state.lenbits) - 1;
  dmask = (1 << state.distbits) - 1;
  top:
    do {
      if (bits < 15) {
        hold += input[_in++] << bits;
        bits += 8;
        hold += input[_in++] << bits;
        bits += 8;
      }
      here = lcode[hold & lmask];
      dolen:
        for (; ; ) {
          op2 = here >>> 24;
          hold >>>= op2;
          bits -= op2;
          op2 = here >>> 16 & 255;
          if (op2 === 0) {
            output[_out++] = here & 65535;
          } else if (op2 & 16) {
            len = here & 65535;
            op2 &= 15;
            if (op2) {
              if (bits < op2) {
                hold += input[_in++] << bits;
                bits += 8;
              }
              len += hold & (1 << op2) - 1;
              hold >>>= op2;
              bits -= op2;
            }
            if (bits < 15) {
              hold += input[_in++] << bits;
              bits += 8;
              hold += input[_in++] << bits;
              bits += 8;
            }
            here = dcode[hold & dmask];
            dodist:
              for (; ; ) {
                op2 = here >>> 24;
                hold >>>= op2;
                bits -= op2;
                op2 = here >>> 16 & 255;
                if (op2 & 16) {
                  dist2 = here & 65535;
                  op2 &= 15;
                  if (bits < op2) {
                    hold += input[_in++] << bits;
                    bits += 8;
                    if (bits < op2) {
                      hold += input[_in++] << bits;
                      bits += 8;
                    }
                  }
                  dist2 += hold & (1 << op2) - 1;
                  if (dist2 > dmax) {
                    strm.msg = "invalid distance too far back";
                    state.mode = BAD;
                    break top;
                  }
                  hold >>>= op2;
                  bits -= op2;
                  op2 = _out - beg;
                  if (dist2 > op2) {
                    op2 = dist2 - op2;
                    if (op2 > whave) {
                      if (state.sane) {
                        strm.msg = "invalid distance too far back";
                        state.mode = BAD;
                        break top;
                      }
                    }
                    from = 0;
                    from_source = s_window;
                    if (wnext === 0) {
                      from += wsize - op2;
                      if (op2 < len) {
                        len -= op2;
                        do {
                          output[_out++] = s_window[from++];
                        } while (--op2);
                        from = _out - dist2;
                        from_source = output;
                      }
                    } else if (wnext < op2) {
                      from += wsize + wnext - op2;
                      op2 -= wnext;
                      if (op2 < len) {
                        len -= op2;
                        do {
                          output[_out++] = s_window[from++];
                        } while (--op2);
                        from = 0;
                        if (wnext < len) {
                          op2 = wnext;
                          len -= op2;
                          do {
                            output[_out++] = s_window[from++];
                          } while (--op2);
                          from = _out - dist2;
                          from_source = output;
                        }
                      }
                    } else {
                      from += wnext - op2;
                      if (op2 < len) {
                        len -= op2;
                        do {
                          output[_out++] = s_window[from++];
                        } while (--op2);
                        from = _out - dist2;
                        from_source = output;
                      }
                    }
                    while (len > 2) {
                      output[_out++] = from_source[from++];
                      output[_out++] = from_source[from++];
                      output[_out++] = from_source[from++];
                      len -= 3;
                    }
                    if (len) {
                      output[_out++] = from_source[from++];
                      if (len > 1) {
                        output[_out++] = from_source[from++];
                      }
                    }
                  } else {
                    from = _out - dist2;
                    do {
                      output[_out++] = output[from++];
                      output[_out++] = output[from++];
                      output[_out++] = output[from++];
                      len -= 3;
                    } while (len > 2);
                    if (len) {
                      output[_out++] = output[from++];
                      if (len > 1) {
                        output[_out++] = output[from++];
                      }
                    }
                  }
                } else if ((op2 & 64) === 0) {
                  here = dcode[(here & 65535) + (hold & (1 << op2) - 1)];
                  continue dodist;
                } else {
                  strm.msg = "invalid distance code";
                  state.mode = BAD;
                  break top;
                }
                break;
              }
          } else if ((op2 & 64) === 0) {
            here = lcode[(here & 65535) + (hold & (1 << op2) - 1)];
            continue dolen;
          } else if (op2 & 32) {
            state.mode = TYPE;
            break top;
          } else {
            strm.msg = "invalid literal/length code";
            state.mode = BAD;
            break top;
          }
          break;
        }
    } while (_in < last && _out < end);
  len = bits >> 3;
  _in -= len;
  bits -= len << 3;
  hold &= (1 << bits) - 1;
  strm.next_in = _in;
  strm.next_out = _out;
  strm.avail_in = _in < last ? 5 + (last - _in) : 5 - (_in - last);
  strm.avail_out = _out < end ? 257 + (end - _out) : 257 - (_out - end);
  state.hold = hold;
  state.bits = bits;
  return;
};
const MAXBITS = 15;
const ENOUGH_LENS = 852;
const ENOUGH_DISTS = 592;
const CODES = 0;
const LENS = 1;
const DISTS = 2;
const lbase = new Uint16Array([
  /* Length codes 257..285 base */
  3,
  4,
  5,
  6,
  7,
  8,
  9,
  10,
  11,
  13,
  15,
  17,
  19,
  23,
  27,
  31,
  35,
  43,
  51,
  59,
  67,
  83,
  99,
  115,
  131,
  163,
  195,
  227,
  258,
  0,
  0
]);
const lext = new Uint8Array([
  /* Length codes 257..285 extra */
  16,
  16,
  16,
  16,
  16,
  16,
  16,
  16,
  17,
  17,
  17,
  17,
  18,
  18,
  18,
  18,
  19,
  19,
  19,
  19,
  20,
  20,
  20,
  20,
  21,
  21,
  21,
  21,
  16,
  72,
  78
]);
const dbase = new Uint16Array([
  /* Distance codes 0..29 base */
  1,
  2,
  3,
  4,
  5,
  7,
  9,
  13,
  17,
  25,
  33,
  49,
  65,
  97,
  129,
  193,
  257,
  385,
  513,
  769,
  1025,
  1537,
  2049,
  3073,
  4097,
  6145,
  8193,
  12289,
  16385,
  24577,
  0,
  0
]);
const dext = new Uint8Array([
  /* Distance codes 0..29 extra */
  16,
  16,
  16,
  16,
  17,
  17,
  18,
  18,
  19,
  19,
  20,
  20,
  21,
  21,
  22,
  22,
  23,
  23,
  24,
  24,
  25,
  25,
  26,
  26,
  27,
  27,
  28,
  28,
  29,
  29,
  64,
  64
]);
const inflate_table = (type, lens, lens_index, codes, table, table_index, work, opts) => {
  const bits = opts.bits;
  let len = 0;
  let sym = 0;
  let min2 = 0, max2 = 0;
  let root = 0;
  let curr = 0;
  let drop = 0;
  let left = 0;
  let used = 0;
  let huff = 0;
  let incr;
  let fill;
  let low;
  let mask;
  let next;
  let base = null;
  let base_index = 0;
  let end;
  const count2 = new Uint16Array(MAXBITS + 1);
  const offs = new Uint16Array(MAXBITS + 1);
  let extra = null;
  let extra_index = 0;
  let here_bits, here_op, here_val;
  for (len = 0; len <= MAXBITS; len++) {
    count2[len] = 0;
  }
  for (sym = 0; sym < codes; sym++) {
    count2[lens[lens_index + sym]]++;
  }
  root = bits;
  for (max2 = MAXBITS; max2 >= 1; max2--) {
    if (count2[max2] !== 0) {
      break;
    }
  }
  if (root > max2) {
    root = max2;
  }
  if (max2 === 0) {
    table[table_index++] = 1 << 24 | 64 << 16 | 0;
    table[table_index++] = 1 << 24 | 64 << 16 | 0;
    opts.bits = 1;
    return 0;
  }
  for (min2 = 1; min2 < max2; min2++) {
    if (count2[min2] !== 0) {
      break;
    }
  }
  if (root < min2) {
    root = min2;
  }
  left = 1;
  for (len = 1; len <= MAXBITS; len++) {
    left <<= 1;
    left -= count2[len];
    if (left < 0) {
      return -1;
    }
  }
  if (left > 0 && (type === CODES || max2 !== 1)) {
    return -1;
  }
  offs[1] = 0;
  for (len = 1; len < MAXBITS; len++) {
    offs[len + 1] = offs[len] + count2[len];
  }
  for (sym = 0; sym < codes; sym++) {
    if (lens[lens_index + sym] !== 0) {
      work[offs[lens[lens_index + sym]]++] = sym;
    }
  }
  if (type === CODES) {
    base = extra = work;
    end = 19;
  } else if (type === LENS) {
    base = lbase;
    base_index -= 257;
    extra = lext;
    extra_index -= 257;
    end = 256;
  } else {
    base = dbase;
    extra = dext;
    end = -1;
  }
  huff = 0;
  sym = 0;
  len = min2;
  next = table_index;
  curr = root;
  drop = 0;
  low = -1;
  used = 1 << root;
  mask = used - 1;
  if (type === LENS && used > ENOUGH_LENS || type === DISTS && used > ENOUGH_DISTS) {
    return 1;
  }
  for (; ; ) {
    here_bits = len - drop;
    if (work[sym] < end) {
      here_op = 0;
      here_val = work[sym];
    } else if (work[sym] > end) {
      here_op = extra[extra_index + work[sym]];
      here_val = base[base_index + work[sym]];
    } else {
      here_op = 32 + 64;
      here_val = 0;
    }
    incr = 1 << len - drop;
    fill = 1 << curr;
    min2 = fill;
    do {
      fill -= incr;
      table[next + (huff >> drop) + fill] = here_bits << 24 | here_op << 16 | here_val | 0;
    } while (fill !== 0);
    incr = 1 << len - 1;
    while (huff & incr) {
      incr >>= 1;
    }
    if (incr !== 0) {
      huff &= incr - 1;
      huff += incr;
    } else {
      huff = 0;
    }
    sym++;
    if (--count2[len] === 0) {
      if (len === max2) {
        break;
      }
      len = lens[lens_index + work[sym]];
    }
    if (len > root && (huff & mask) !== low) {
      if (drop === 0) {
        drop = root;
      }
      next += min2;
      curr = len - drop;
      left = 1 << curr;
      while (curr + drop < max2) {
        left -= count2[curr + drop];
        if (left <= 0) {
          break;
        }
        curr++;
        left <<= 1;
      }
      used += 1 << curr;
      if (type === LENS && used > ENOUGH_LENS || type === DISTS && used > ENOUGH_DISTS) {
        return 1;
      }
      low = huff & mask;
      table[low] = root << 24 | curr << 16 | next - table_index | 0;
    }
  }
  if (huff !== 0) {
    table[next + huff] = len - drop << 24 | 64 << 16 | 0;
  }
  opts.bits = root;
  return 0;
};
var inftrees = inflate_table;
const CODES$1 = 0;
const LENS$1 = 1;
const DISTS$1 = 2;
const {
  Z_FINISH: Z_FINISH$2,
  Z_BLOCK: Z_BLOCK$1,
  Z_TREES,
  Z_OK: Z_OK$2,
  Z_STREAM_END: Z_STREAM_END$2,
  Z_NEED_DICT,
  Z_STREAM_ERROR: Z_STREAM_ERROR$1,
  Z_DATA_ERROR: Z_DATA_ERROR$1,
  Z_MEM_ERROR,
  Z_BUF_ERROR: Z_BUF_ERROR$1,
  Z_DEFLATED: Z_DEFLATED$2
} = constants;
const HEAD = 1;
const FLAGS = 2;
const TIME = 3;
const OS = 4;
const EXLEN = 5;
const EXTRA = 6;
const NAME$1 = 7;
const COMMENT = 8;
const HCRC = 9;
const DICTID = 10;
const DICT = 11;
const TYPE$1 = 12;
const TYPEDO = 13;
const STORED = 14;
const COPY_ = 15;
const COPY = 16;
const TABLE = 17;
const LENLENS = 18;
const CODELENS = 19;
const LEN_ = 20;
const LEN = 21;
const LENEXT = 22;
const DIST = 23;
const DISTEXT = 24;
const MATCH = 25;
const LIT = 26;
const CHECK = 27;
const LENGTH = 28;
const DONE = 29;
const BAD$1 = 30;
const MEM = 31;
const SYNC = 32;
const ENOUGH_LENS$1 = 852;
const ENOUGH_DISTS$1 = 592;
const MAX_WBITS$1 = 15;
const DEF_WBITS = MAX_WBITS$1;
const zswap32 = (q3) => {
  return (q3 >>> 24 & 255) + (q3 >>> 8 & 65280) + ((q3 & 65280) << 8) + ((q3 & 255) << 24);
};
function InflateState() {
  this.mode = 0;
  this.last = false;
  this.wrap = 0;
  this.havedict = false;
  this.flags = 0;
  this.dmax = 0;
  this.check = 0;
  this.total = 0;
  this.head = null;
  this.wbits = 0;
  this.wsize = 0;
  this.whave = 0;
  this.wnext = 0;
  this.window = null;
  this.hold = 0;
  this.bits = 0;
  this.length = 0;
  this.offset = 0;
  this.extra = 0;
  this.lencode = null;
  this.distcode = null;
  this.lenbits = 0;
  this.distbits = 0;
  this.ncode = 0;
  this.nlen = 0;
  this.ndist = 0;
  this.have = 0;
  this.next = null;
  this.lens = new Uint16Array(320);
  this.work = new Uint16Array(288);
  this.lendyn = null;
  this.distdyn = null;
  this.sane = 0;
  this.back = 0;
  this.was = 0;
}
const inflateResetKeep = (strm) => {
  if (!strm || !strm.state) {
    return Z_STREAM_ERROR$1;
  }
  const state = strm.state;
  strm.total_in = strm.total_out = state.total = 0;
  strm.msg = "";
  if (state.wrap) {
    strm.adler = state.wrap & 1;
  }
  state.mode = HEAD;
  state.last = 0;
  state.havedict = 0;
  state.dmax = 32768;
  state.head = null;
  state.hold = 0;
  state.bits = 0;
  state.lencode = state.lendyn = new Int32Array(ENOUGH_LENS$1);
  state.distcode = state.distdyn = new Int32Array(ENOUGH_DISTS$1);
  state.sane = 1;
  state.back = -1;
  return Z_OK$2;
};
const inflateReset = (strm) => {
  if (!strm || !strm.state) {
    return Z_STREAM_ERROR$1;
  }
  const state = strm.state;
  state.wsize = 0;
  state.whave = 0;
  state.wnext = 0;
  return inflateResetKeep(strm);
};
const inflateReset2 = (strm, windowBits) => {
  let wrap;
  if (!strm || !strm.state) {
    return Z_STREAM_ERROR$1;
  }
  const state = strm.state;
  if (windowBits < 0) {
    wrap = 0;
    windowBits = -windowBits;
  } else {
    wrap = (windowBits >> 4) + 1;
    if (windowBits < 48) {
      windowBits &= 15;
    }
  }
  if (windowBits && (windowBits < 8 || windowBits > 15)) {
    return Z_STREAM_ERROR$1;
  }
  if (state.window !== null && state.wbits !== windowBits) {
    state.window = null;
  }
  state.wrap = wrap;
  state.wbits = windowBits;
  return inflateReset(strm);
};
const inflateInit2 = (strm, windowBits) => {
  if (!strm) {
    return Z_STREAM_ERROR$1;
  }
  const state = new InflateState();
  strm.state = state;
  state.window = null;
  const ret = inflateReset2(strm, windowBits);
  if (ret !== Z_OK$2) {
    strm.state = null;
  }
  return ret;
};
const inflateInit = (strm) => {
  return inflateInit2(strm, DEF_WBITS);
};
let virgin = true;
let lenfix, distfix;
const fixedtables = (state) => {
  if (virgin) {
    lenfix = new Int32Array(512);
    distfix = new Int32Array(32);
    let sym = 0;
    while (sym < 144) {
      state.lens[sym++] = 8;
    }
    while (sym < 256) {
      state.lens[sym++] = 9;
    }
    while (sym < 280) {
      state.lens[sym++] = 7;
    }
    while (sym < 288) {
      state.lens[sym++] = 8;
    }
    inftrees(LENS$1, state.lens, 0, 288, lenfix, 0, state.work, { bits: 9 });
    sym = 0;
    while (sym < 32) {
      state.lens[sym++] = 5;
    }
    inftrees(DISTS$1, state.lens, 0, 32, distfix, 0, state.work, { bits: 5 });
    virgin = false;
  }
  state.lencode = lenfix;
  state.lenbits = 9;
  state.distcode = distfix;
  state.distbits = 5;
};
const updatewindow = (strm, src, end, copy) => {
  let dist2;
  const state = strm.state;
  if (state.window === null) {
    state.wsize = 1 << state.wbits;
    state.wnext = 0;
    state.whave = 0;
    state.window = new Uint8Array(state.wsize);
  }
  if (copy >= state.wsize) {
    state.window.set(src.subarray(end - state.wsize, end), 0);
    state.wnext = 0;
    state.whave = state.wsize;
  } else {
    dist2 = state.wsize - state.wnext;
    if (dist2 > copy) {
      dist2 = copy;
    }
    state.window.set(src.subarray(end - copy, end - copy + dist2), state.wnext);
    copy -= dist2;
    if (copy) {
      state.window.set(src.subarray(end - copy, end), 0);
      state.wnext = copy;
      state.whave = state.wsize;
    } else {
      state.wnext += dist2;
      if (state.wnext === state.wsize) {
        state.wnext = 0;
      }
      if (state.whave < state.wsize) {
        state.whave += dist2;
      }
    }
  }
  return 0;
};
const inflate = (strm, flush) => {
  let state;
  let input, output;
  let next;
  let put;
  let have, left;
  let hold;
  let bits;
  let _in, _out;
  let copy;
  let from;
  let from_source;
  let here = 0;
  let here_bits, here_op, here_val;
  let last_bits, last_op, last_val;
  let len;
  let ret;
  const hbuf = new Uint8Array(4);
  let opts;
  let n3;
  const order = (
    /* permutation of code lengths */
    new Uint8Array([16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15])
  );
  if (!strm || !strm.state || !strm.output || !strm.input && strm.avail_in !== 0) {
    return Z_STREAM_ERROR$1;
  }
  state = strm.state;
  if (state.mode === TYPE$1) {
    state.mode = TYPEDO;
  }
  put = strm.next_out;
  output = strm.output;
  left = strm.avail_out;
  next = strm.next_in;
  input = strm.input;
  have = strm.avail_in;
  hold = state.hold;
  bits = state.bits;
  _in = have;
  _out = left;
  ret = Z_OK$2;
  inf_leave:
    for (; ; ) {
      switch (state.mode) {
        case HEAD:
          if (state.wrap === 0) {
            state.mode = TYPEDO;
            break;
          }
          while (bits < 16) {
            if (have === 0) {
              break inf_leave;
            }
            have--;
            hold += input[next++] << bits;
            bits += 8;
          }
          if (state.wrap & 2 && hold === 35615) {
            state.check = 0;
            hbuf[0] = hold & 255;
            hbuf[1] = hold >>> 8 & 255;
            state.check = crc32_1(state.check, hbuf, 2, 0);
            hold = 0;
            bits = 0;
            state.mode = FLAGS;
            break;
          }
          state.flags = 0;
          if (state.head) {
            state.head.done = false;
          }
          if (!(state.wrap & 1) || /* check if zlib header allowed */
          (((hold & 255) << 8) + (hold >> 8)) % 31) {
            strm.msg = "incorrect header check";
            state.mode = BAD$1;
            break;
          }
          if ((hold & 15) !== Z_DEFLATED$2) {
            strm.msg = "unknown compression method";
            state.mode = BAD$1;
            break;
          }
          hold >>>= 4;
          bits -= 4;
          len = (hold & 15) + 8;
          if (state.wbits === 0) {
            state.wbits = len;
          } else if (len > state.wbits) {
            strm.msg = "invalid window size";
            state.mode = BAD$1;
            break;
          }
          state.dmax = 1 << state.wbits;
          strm.adler = state.check = 1;
          state.mode = hold & 512 ? DICTID : TYPE$1;
          hold = 0;
          bits = 0;
          break;
        case FLAGS:
          while (bits < 16) {
            if (have === 0) {
              break inf_leave;
            }
            have--;
            hold += input[next++] << bits;
            bits += 8;
          }
          state.flags = hold;
          if ((state.flags & 255) !== Z_DEFLATED$2) {
            strm.msg = "unknown compression method";
            state.mode = BAD$1;
            break;
          }
          if (state.flags & 57344) {
            strm.msg = "unknown header flags set";
            state.mode = BAD$1;
            break;
          }
          if (state.head) {
            state.head.text = hold >> 8 & 1;
          }
          if (state.flags & 512) {
            hbuf[0] = hold & 255;
            hbuf[1] = hold >>> 8 & 255;
            state.check = crc32_1(state.check, hbuf, 2, 0);
          }
          hold = 0;
          bits = 0;
          state.mode = TIME;
        /* falls through */
        case TIME:
          while (bits < 32) {
            if (have === 0) {
              break inf_leave;
            }
            have--;
            hold += input[next++] << bits;
            bits += 8;
          }
          if (state.head) {
            state.head.time = hold;
          }
          if (state.flags & 512) {
            hbuf[0] = hold & 255;
            hbuf[1] = hold >>> 8 & 255;
            hbuf[2] = hold >>> 16 & 255;
            hbuf[3] = hold >>> 24 & 255;
            state.check = crc32_1(state.check, hbuf, 4, 0);
          }
          hold = 0;
          bits = 0;
          state.mode = OS;
        /* falls through */
        case OS:
          while (bits < 16) {
            if (have === 0) {
              break inf_leave;
            }
            have--;
            hold += input[next++] << bits;
            bits += 8;
          }
          if (state.head) {
            state.head.xflags = hold & 255;
            state.head.os = hold >> 8;
          }
          if (state.flags & 512) {
            hbuf[0] = hold & 255;
            hbuf[1] = hold >>> 8 & 255;
            state.check = crc32_1(state.check, hbuf, 2, 0);
          }
          hold = 0;
          bits = 0;
          state.mode = EXLEN;
        /* falls through */
        case EXLEN:
          if (state.flags & 1024) {
            while (bits < 16) {
              if (have === 0) {
                break inf_leave;
              }
              have--;
              hold += input[next++] << bits;
              bits += 8;
            }
            state.length = hold;
            if (state.head) {
              state.head.extra_len = hold;
            }
            if (state.flags & 512) {
              hbuf[0] = hold & 255;
              hbuf[1] = hold >>> 8 & 255;
              state.check = crc32_1(state.check, hbuf, 2, 0);
            }
            hold = 0;
            bits = 0;
          } else if (state.head) {
            state.head.extra = null;
          }
          state.mode = EXTRA;
        /* falls through */
        case EXTRA:
          if (state.flags & 1024) {
            copy = state.length;
            if (copy > have) {
              copy = have;
            }
            if (copy) {
              if (state.head) {
                len = state.head.extra_len - state.length;
                if (!state.head.extra) {
                  state.head.extra = new Uint8Array(state.head.extra_len);
                }
                state.head.extra.set(
                  input.subarray(
                    next,
                    // extra field is limited to 65536 bytes
                    // - no need for additional size check
                    next + copy
                  ),
                  /*len + copy > state.head.extra_max - len ? state.head.extra_max : copy,*/
                  len
                );
              }
              if (state.flags & 512) {
                state.check = crc32_1(state.check, input, copy, next);
              }
              have -= copy;
              next += copy;
              state.length -= copy;
            }
            if (state.length) {
              break inf_leave;
            }
          }
          state.length = 0;
          state.mode = NAME$1;
        /* falls through */
        case NAME$1:
          if (state.flags & 2048) {
            if (have === 0) {
              break inf_leave;
            }
            copy = 0;
            do {
              len = input[next + copy++];
              if (state.head && len && state.length < 65536) {
                state.head.name += String.fromCharCode(len);
              }
            } while (len && copy < have);
            if (state.flags & 512) {
              state.check = crc32_1(state.check, input, copy, next);
            }
            have -= copy;
            next += copy;
            if (len) {
              break inf_leave;
            }
          } else if (state.head) {
            state.head.name = null;
          }
          state.length = 0;
          state.mode = COMMENT;
        /* falls through */
        case COMMENT:
          if (state.flags & 4096) {
            if (have === 0) {
              break inf_leave;
            }
            copy = 0;
            do {
              len = input[next + copy++];
              if (state.head && len && state.length < 65536) {
                state.head.comment += String.fromCharCode(len);
              }
            } while (len && copy < have);
            if (state.flags & 512) {
              state.check = crc32_1(state.check, input, copy, next);
            }
            have -= copy;
            next += copy;
            if (len) {
              break inf_leave;
            }
          } else if (state.head) {
            state.head.comment = null;
          }
          state.mode = HCRC;
        /* falls through */
        case HCRC:
          if (state.flags & 512) {
            while (bits < 16) {
              if (have === 0) {
                break inf_leave;
              }
              have--;
              hold += input[next++] << bits;
              bits += 8;
            }
            if (hold !== (state.check & 65535)) {
              strm.msg = "header crc mismatch";
              state.mode = BAD$1;
              break;
            }
            hold = 0;
            bits = 0;
          }
          if (state.head) {
            state.head.hcrc = state.flags >> 9 & 1;
            state.head.done = true;
          }
          strm.adler = state.check = 0;
          state.mode = TYPE$1;
          break;
        case DICTID:
          while (bits < 32) {
            if (have === 0) {
              break inf_leave;
            }
            have--;
            hold += input[next++] << bits;
            bits += 8;
          }
          strm.adler = state.check = zswap32(hold);
          hold = 0;
          bits = 0;
          state.mode = DICT;
        /* falls through */
        case DICT:
          if (state.havedict === 0) {
            strm.next_out = put;
            strm.avail_out = left;
            strm.next_in = next;
            strm.avail_in = have;
            state.hold = hold;
            state.bits = bits;
            return Z_NEED_DICT;
          }
          strm.adler = state.check = 1;
          state.mode = TYPE$1;
        /* falls through */
        case TYPE$1:
          if (flush === Z_BLOCK$1 || flush === Z_TREES) {
            break inf_leave;
          }
        /* falls through */
        case TYPEDO:
          if (state.last) {
            hold >>>= bits & 7;
            bits -= bits & 7;
            state.mode = CHECK;
            break;
          }
          while (bits < 3) {
            if (have === 0) {
              break inf_leave;
            }
            have--;
            hold += input[next++] << bits;
            bits += 8;
          }
          state.last = hold & 1;
          hold >>>= 1;
          bits -= 1;
          switch (hold & 3) {
            case 0:
              state.mode = STORED;
              break;
            case 1:
              fixedtables(state);
              state.mode = LEN_;
              if (flush === Z_TREES) {
                hold >>>= 2;
                bits -= 2;
                break inf_leave;
              }
              break;
            case 2:
              state.mode = TABLE;
              break;
            case 3:
              strm.msg = "invalid block type";
              state.mode = BAD$1;
          }
          hold >>>= 2;
          bits -= 2;
          break;
        case STORED:
          hold >>>= bits & 7;
          bits -= bits & 7;
          while (bits < 32) {
            if (have === 0) {
              break inf_leave;
            }
            have--;
            hold += input[next++] << bits;
            bits += 8;
          }
          if ((hold & 65535) !== (hold >>> 16 ^ 65535)) {
            strm.msg = "invalid stored block lengths";
            state.mode = BAD$1;
            break;
          }
          state.length = hold & 65535;
          hold = 0;
          bits = 0;
          state.mode = COPY_;
          if (flush === Z_TREES) {
            break inf_leave;
          }
        /* falls through */
        case COPY_:
          state.mode = COPY;
        /* falls through */
        case COPY:
          copy = state.length;
          if (copy) {
            if (copy > have) {
              copy = have;
            }
            if (copy > left) {
              copy = left;
            }
            if (copy === 0) {
              break inf_leave;
            }
            output.set(input.subarray(next, next + copy), put);
            have -= copy;
            next += copy;
            left -= copy;
            put += copy;
            state.length -= copy;
            break;
          }
          state.mode = TYPE$1;
          break;
        case TABLE:
          while (bits < 14) {
            if (have === 0) {
              break inf_leave;
            }
            have--;
            hold += input[next++] << bits;
            bits += 8;
          }
          state.nlen = (hold & 31) + 257;
          hold >>>= 5;
          bits -= 5;
          state.ndist = (hold & 31) + 1;
          hold >>>= 5;
          bits -= 5;
          state.ncode = (hold & 15) + 4;
          hold >>>= 4;
          bits -= 4;
          if (state.nlen > 286 || state.ndist > 30) {
            strm.msg = "too many length or distance symbols";
            state.mode = BAD$1;
            break;
          }
          state.have = 0;
          state.mode = LENLENS;
        /* falls through */
        case LENLENS:
          while (state.have < state.ncode) {
            while (bits < 3) {
              if (have === 0) {
                break inf_leave;
              }
              have--;
              hold += input[next++] << bits;
              bits += 8;
            }
            state.lens[order[state.have++]] = hold & 7;
            hold >>>= 3;
            bits -= 3;
          }
          while (state.have < 19) {
            state.lens[order[state.have++]] = 0;
          }
          state.lencode = state.lendyn;
          state.lenbits = 7;
          opts = { bits: state.lenbits };
          ret = inftrees(CODES$1, state.lens, 0, 19, state.lencode, 0, state.work, opts);
          state.lenbits = opts.bits;
          if (ret) {
            strm.msg = "invalid code lengths set";
            state.mode = BAD$1;
            break;
          }
          state.have = 0;
          state.mode = CODELENS;
        /* falls through */
        case CODELENS:
          while (state.have < state.nlen + state.ndist) {
            for (; ; ) {
              here = state.lencode[hold & (1 << state.lenbits) - 1];
              here_bits = here >>> 24;
              here_op = here >>> 16 & 255;
              here_val = here & 65535;
              if (here_bits <= bits) {
                break;
              }
              if (have === 0) {
                break inf_leave;
              }
              have--;
              hold += input[next++] << bits;
              bits += 8;
            }
            if (here_val < 16) {
              hold >>>= here_bits;
              bits -= here_bits;
              state.lens[state.have++] = here_val;
            } else {
              if (here_val === 16) {
                n3 = here_bits + 2;
                while (bits < n3) {
                  if (have === 0) {
                    break inf_leave;
                  }
                  have--;
                  hold += input[next++] << bits;
                  bits += 8;
                }
                hold >>>= here_bits;
                bits -= here_bits;
                if (state.have === 0) {
                  strm.msg = "invalid bit length repeat";
                  state.mode = BAD$1;
                  break;
                }
                len = state.lens[state.have - 1];
                copy = 3 + (hold & 3);
                hold >>>= 2;
                bits -= 2;
              } else if (here_val === 17) {
                n3 = here_bits + 3;
                while (bits < n3) {
                  if (have === 0) {
                    break inf_leave;
                  }
                  have--;
                  hold += input[next++] << bits;
                  bits += 8;
                }
                hold >>>= here_bits;
                bits -= here_bits;
                len = 0;
                copy = 3 + (hold & 7);
                hold >>>= 3;
                bits -= 3;
              } else {
                n3 = here_bits + 7;
                while (bits < n3) {
                  if (have === 0) {
                    break inf_leave;
                  }
                  have--;
                  hold += input[next++] << bits;
                  bits += 8;
                }
                hold >>>= here_bits;
                bits -= here_bits;
                len = 0;
                copy = 11 + (hold & 127);
                hold >>>= 7;
                bits -= 7;
              }
              if (state.have + copy > state.nlen + state.ndist) {
                strm.msg = "invalid bit length repeat";
                state.mode = BAD$1;
                break;
              }
              while (copy--) {
                state.lens[state.have++] = len;
              }
            }
          }
          if (state.mode === BAD$1) {
            break;
          }
          if (state.lens[256] === 0) {
            strm.msg = "invalid code -- missing end-of-block";
            state.mode = BAD$1;
            break;
          }
          state.lenbits = 9;
          opts = { bits: state.lenbits };
          ret = inftrees(LENS$1, state.lens, 0, state.nlen, state.lencode, 0, state.work, opts);
          state.lenbits = opts.bits;
          if (ret) {
            strm.msg = "invalid literal/lengths set";
            state.mode = BAD$1;
            break;
          }
          state.distbits = 6;
          state.distcode = state.distdyn;
          opts = { bits: state.distbits };
          ret = inftrees(DISTS$1, state.lens, state.nlen, state.ndist, state.distcode, 0, state.work, opts);
          state.distbits = opts.bits;
          if (ret) {
            strm.msg = "invalid distances set";
            state.mode = BAD$1;
            break;
          }
          state.mode = LEN_;
          if (flush === Z_TREES) {
            break inf_leave;
          }
        /* falls through */
        case LEN_:
          state.mode = LEN;
        /* falls through */
        case LEN:
          if (have >= 6 && left >= 258) {
            strm.next_out = put;
            strm.avail_out = left;
            strm.next_in = next;
            strm.avail_in = have;
            state.hold = hold;
            state.bits = bits;
            inffast(strm, _out);
            put = strm.next_out;
            output = strm.output;
            left = strm.avail_out;
            next = strm.next_in;
            input = strm.input;
            have = strm.avail_in;
            hold = state.hold;
            bits = state.bits;
            if (state.mode === TYPE$1) {
              state.back = -1;
            }
            break;
          }
          state.back = 0;
          for (; ; ) {
            here = state.lencode[hold & (1 << state.lenbits) - 1];
            here_bits = here >>> 24;
            here_op = here >>> 16 & 255;
            here_val = here & 65535;
            if (here_bits <= bits) {
              break;
            }
            if (have === 0) {
              break inf_leave;
            }
            have--;
            hold += input[next++] << bits;
            bits += 8;
          }
          if (here_op && (here_op & 240) === 0) {
            last_bits = here_bits;
            last_op = here_op;
            last_val = here_val;
            for (; ; ) {
              here = state.lencode[last_val + ((hold & (1 << last_bits + last_op) - 1) >> last_bits)];
              here_bits = here >>> 24;
              here_op = here >>> 16 & 255;
              here_val = here & 65535;
              if (last_bits + here_bits <= bits) {
                break;
              }
              if (have === 0) {
                break inf_leave;
              }
              have--;
              hold += input[next++] << bits;
              bits += 8;
            }
            hold >>>= last_bits;
            bits -= last_bits;
            state.back += last_bits;
          }
          hold >>>= here_bits;
          bits -= here_bits;
          state.back += here_bits;
          state.length = here_val;
          if (here_op === 0) {
            state.mode = LIT;
            break;
          }
          if (here_op & 32) {
            state.back = -1;
            state.mode = TYPE$1;
            break;
          }
          if (here_op & 64) {
            strm.msg = "invalid literal/length code";
            state.mode = BAD$1;
            break;
          }
          state.extra = here_op & 15;
          state.mode = LENEXT;
        /* falls through */
        case LENEXT:
          if (state.extra) {
            n3 = state.extra;
            while (bits < n3) {
              if (have === 0) {
                break inf_leave;
              }
              have--;
              hold += input[next++] << bits;
              bits += 8;
            }
            state.length += hold & (1 << state.extra) - 1;
            hold >>>= state.extra;
            bits -= state.extra;
            state.back += state.extra;
          }
          state.was = state.length;
          state.mode = DIST;
        /* falls through */
        case DIST:
          for (; ; ) {
            here = state.distcode[hold & (1 << state.distbits) - 1];
            here_bits = here >>> 24;
            here_op = here >>> 16 & 255;
            here_val = here & 65535;
            if (here_bits <= bits) {
              break;
            }
            if (have === 0) {
              break inf_leave;
            }
            have--;
            hold += input[next++] << bits;
            bits += 8;
          }
          if ((here_op & 240) === 0) {
            last_bits = here_bits;
            last_op = here_op;
            last_val = here_val;
            for (; ; ) {
              here = state.distcode[last_val + ((hold & (1 << last_bits + last_op) - 1) >> last_bits)];
              here_bits = here >>> 24;
              here_op = here >>> 16 & 255;
              here_val = here & 65535;
              if (last_bits + here_bits <= bits) {
                break;
              }
              if (have === 0) {
                break inf_leave;
              }
              have--;
              hold += input[next++] << bits;
              bits += 8;
            }
            hold >>>= last_bits;
            bits -= last_bits;
            state.back += last_bits;
          }
          hold >>>= here_bits;
          bits -= here_bits;
          state.back += here_bits;
          if (here_op & 64) {
            strm.msg = "invalid distance code";
            state.mode = BAD$1;
            break;
          }
          state.offset = here_val;
          state.extra = here_op & 15;
          state.mode = DISTEXT;
        /* falls through */
        case DISTEXT:
          if (state.extra) {
            n3 = state.extra;
            while (bits < n3) {
              if (have === 0) {
                break inf_leave;
              }
              have--;
              hold += input[next++] << bits;
              bits += 8;
            }
            state.offset += hold & (1 << state.extra) - 1;
            hold >>>= state.extra;
            bits -= state.extra;
            state.back += state.extra;
          }
          if (state.offset > state.dmax) {
            strm.msg = "invalid distance too far back";
            state.mode = BAD$1;
            break;
          }
          state.mode = MATCH;
        /* falls through */
        case MATCH:
          if (left === 0) {
            break inf_leave;
          }
          copy = _out - left;
          if (state.offset > copy) {
            copy = state.offset - copy;
            if (copy > state.whave) {
              if (state.sane) {
                strm.msg = "invalid distance too far back";
                state.mode = BAD$1;
                break;
              }
            }
            if (copy > state.wnext) {
              copy -= state.wnext;
              from = state.wsize - copy;
            } else {
              from = state.wnext - copy;
            }
            if (copy > state.length) {
              copy = state.length;
            }
            from_source = state.window;
          } else {
            from_source = output;
            from = put - state.offset;
            copy = state.length;
          }
          if (copy > left) {
            copy = left;
          }
          left -= copy;
          state.length -= copy;
          do {
            output[put++] = from_source[from++];
          } while (--copy);
          if (state.length === 0) {
            state.mode = LEN;
          }
          break;
        case LIT:
          if (left === 0) {
            break inf_leave;
          }
          output[put++] = state.length;
          left--;
          state.mode = LEN;
          break;
        case CHECK:
          if (state.wrap) {
            while (bits < 32) {
              if (have === 0) {
                break inf_leave;
              }
              have--;
              hold |= input[next++] << bits;
              bits += 8;
            }
            _out -= left;
            strm.total_out += _out;
            state.total += _out;
            if (_out) {
              strm.adler = state.check = /*UPDATE(state.check, put - _out, _out);*/
              state.flags ? crc32_1(state.check, output, _out, put - _out) : adler32_1(state.check, output, _out, put - _out);
            }
            _out = left;
            if ((state.flags ? hold : zswap32(hold)) !== state.check) {
              strm.msg = "incorrect data check";
              state.mode = BAD$1;
              break;
            }
            hold = 0;
            bits = 0;
          }
          state.mode = LENGTH;
        /* falls through */
        case LENGTH:
          if (state.wrap && state.flags) {
            while (bits < 32) {
              if (have === 0) {
                break inf_leave;
              }
              have--;
              hold += input[next++] << bits;
              bits += 8;
            }
            if (hold !== (state.total & 4294967295)) {
              strm.msg = "incorrect length check";
              state.mode = BAD$1;
              break;
            }
            hold = 0;
            bits = 0;
          }
          state.mode = DONE;
        /* falls through */
        case DONE:
          ret = Z_STREAM_END$2;
          break inf_leave;
        case BAD$1:
          ret = Z_DATA_ERROR$1;
          break inf_leave;
        case MEM:
          return Z_MEM_ERROR;
        case SYNC:
        /* falls through */
        default:
          return Z_STREAM_ERROR$1;
      }
    }
  strm.next_out = put;
  strm.avail_out = left;
  strm.next_in = next;
  strm.avail_in = have;
  state.hold = hold;
  state.bits = bits;
  if (state.wsize || _out !== strm.avail_out && state.mode < BAD$1 && (state.mode < CHECK || flush !== Z_FINISH$2)) {
    if (updatewindow(strm, strm.output, strm.next_out, _out - strm.avail_out)) ;
  }
  _in -= strm.avail_in;
  _out -= strm.avail_out;
  strm.total_in += _in;
  strm.total_out += _out;
  state.total += _out;
  if (state.wrap && _out) {
    strm.adler = state.check = /*UPDATE(state.check, strm.next_out - _out, _out);*/
    state.flags ? crc32_1(state.check, output, _out, strm.next_out - _out) : adler32_1(state.check, output, _out, strm.next_out - _out);
  }
  strm.data_type = state.bits + (state.last ? 64 : 0) + (state.mode === TYPE$1 ? 128 : 0) + (state.mode === LEN_ || state.mode === COPY_ ? 256 : 0);
  if ((_in === 0 && _out === 0 || flush === Z_FINISH$2) && ret === Z_OK$2) {
    ret = Z_BUF_ERROR$1;
  }
  return ret;
};
const inflateEnd = (strm) => {
  if (!strm || !strm.state) {
    return Z_STREAM_ERROR$1;
  }
  let state = strm.state;
  if (state.window) {
    state.window = null;
  }
  strm.state = null;
  return Z_OK$2;
};
const inflateGetHeader = (strm, head) => {
  if (!strm || !strm.state) {
    return Z_STREAM_ERROR$1;
  }
  const state = strm.state;
  if ((state.wrap & 2) === 0) {
    return Z_STREAM_ERROR$1;
  }
  state.head = head;
  head.done = false;
  return Z_OK$2;
};
const inflateSetDictionary = (strm, dictionary) => {
  const dictLength = dictionary.length;
  let state;
  let dictid;
  let ret;
  if (!strm || !strm.state) {
    return Z_STREAM_ERROR$1;
  }
  state = strm.state;
  if (state.wrap !== 0 && state.mode !== DICT) {
    return Z_STREAM_ERROR$1;
  }
  if (state.mode === DICT) {
    dictid = 1;
    dictid = adler32_1(dictid, dictionary, dictLength, 0);
    if (dictid !== state.check) {
      return Z_DATA_ERROR$1;
    }
  }
  ret = updatewindow(strm, dictionary, dictLength, dictLength);
  if (ret) {
    state.mode = MEM;
    return Z_MEM_ERROR;
  }
  state.havedict = 1;
  return Z_OK$2;
};
var inflateReset_1 = inflateReset;
var inflateReset2_1 = inflateReset2;
var inflateResetKeep_1 = inflateResetKeep;
var inflateInit_1 = inflateInit;
var inflateInit2_1 = inflateInit2;
var inflate_2 = inflate;
var inflateEnd_1 = inflateEnd;
var inflateGetHeader_1 = inflateGetHeader;
var inflateSetDictionary_1 = inflateSetDictionary;
var inflateInfo = "pako inflate (from Nodeca project)";
var inflate_1 = {
  inflateReset: inflateReset_1,
  inflateReset2: inflateReset2_1,
  inflateResetKeep: inflateResetKeep_1,
  inflateInit: inflateInit_1,
  inflateInit2: inflateInit2_1,
  inflate: inflate_2,
  inflateEnd: inflateEnd_1,
  inflateGetHeader: inflateGetHeader_1,
  inflateSetDictionary: inflateSetDictionary_1,
  inflateInfo
};
function GZheader() {
  this.text = 0;
  this.time = 0;
  this.xflags = 0;
  this.os = 0;
  this.extra = null;
  this.extra_len = 0;
  this.name = "";
  this.comment = "";
  this.hcrc = 0;
  this.done = false;
}
var gzheader = GZheader;
const toString$1 = Object.prototype.toString;
const {
  Z_NO_FLUSH: Z_NO_FLUSH$2,
  Z_FINISH: Z_FINISH$3,
  Z_OK: Z_OK$3,
  Z_STREAM_END: Z_STREAM_END$3,
  Z_NEED_DICT: Z_NEED_DICT$1,
  Z_STREAM_ERROR: Z_STREAM_ERROR$2,
  Z_DATA_ERROR: Z_DATA_ERROR$2,
  Z_MEM_ERROR: Z_MEM_ERROR$1
} = constants;
function Inflate(options) {
  this.options = common.assign({
    chunkSize: 1024 * 64,
    windowBits: 15,
    to: ""
  }, options || {});
  const opt = this.options;
  if (opt.raw && opt.windowBits >= 0 && opt.windowBits < 16) {
    opt.windowBits = -opt.windowBits;
    if (opt.windowBits === 0) {
      opt.windowBits = -15;
    }
  }
  if (opt.windowBits >= 0 && opt.windowBits < 16 && !(options && options.windowBits)) {
    opt.windowBits += 32;
  }
  if (opt.windowBits > 15 && opt.windowBits < 48) {
    if ((opt.windowBits & 15) === 0) {
      opt.windowBits |= 15;
    }
  }
  this.err = 0;
  this.msg = "";
  this.ended = false;
  this.chunks = [];
  this.strm = new zstream();
  this.strm.avail_out = 0;
  let status = inflate_1.inflateInit2(
    this.strm,
    opt.windowBits
  );
  if (status !== Z_OK$3) {
    throw new Error(messages[status]);
  }
  this.header = new gzheader();
  inflate_1.inflateGetHeader(this.strm, this.header);
  if (opt.dictionary) {
    if (typeof opt.dictionary === "string") {
      opt.dictionary = strings.string2buf(opt.dictionary);
    } else if (toString$1.call(opt.dictionary) === "[object ArrayBuffer]") {
      opt.dictionary = new Uint8Array(opt.dictionary);
    }
    if (opt.raw) {
      status = inflate_1.inflateSetDictionary(this.strm, opt.dictionary);
      if (status !== Z_OK$3) {
        throw new Error(messages[status]);
      }
    }
  }
}
Inflate.prototype.push = function(data, flush_mode) {
  const strm = this.strm;
  const chunkSize = this.options.chunkSize;
  const dictionary = this.options.dictionary;
  let status, _flush_mode, last_avail_out;
  if (this.ended) return false;
  if (flush_mode === ~~flush_mode) _flush_mode = flush_mode;
  else _flush_mode = flush_mode === true ? Z_FINISH$3 : Z_NO_FLUSH$2;
  if (toString$1.call(data) === "[object ArrayBuffer]") {
    strm.input = new Uint8Array(data);
  } else {
    strm.input = data;
  }
  strm.next_in = 0;
  strm.avail_in = strm.input.length;
  for (; ; ) {
    if (strm.avail_out === 0) {
      strm.output = new Uint8Array(chunkSize);
      strm.next_out = 0;
      strm.avail_out = chunkSize;
    }
    status = inflate_1.inflate(strm, _flush_mode);
    if (status === Z_NEED_DICT$1 && dictionary) {
      status = inflate_1.inflateSetDictionary(strm, dictionary);
      if (status === Z_OK$3) {
        status = inflate_1.inflate(strm, _flush_mode);
      } else if (status === Z_DATA_ERROR$2) {
        status = Z_NEED_DICT$1;
      }
    }
    while (strm.avail_in > 0 && status === Z_STREAM_END$3 && strm.state.wrap > 0 && data[strm.next_in] !== 0) {
      inflate_1.inflateReset(strm);
      status = inflate_1.inflate(strm, _flush_mode);
    }
    switch (status) {
      case Z_STREAM_ERROR$2:
      case Z_DATA_ERROR$2:
      case Z_NEED_DICT$1:
      case Z_MEM_ERROR$1:
        this.onEnd(status);
        this.ended = true;
        return false;
    }
    last_avail_out = strm.avail_out;
    if (strm.next_out) {
      if (strm.avail_out === 0 || status === Z_STREAM_END$3) {
        if (this.options.to === "string") {
          let next_out_utf8 = strings.utf8border(strm.output, strm.next_out);
          let tail = strm.next_out - next_out_utf8;
          let utf8str = strings.buf2string(strm.output, next_out_utf8);
          strm.next_out = tail;
          strm.avail_out = chunkSize - tail;
          if (tail) strm.output.set(strm.output.subarray(next_out_utf8, next_out_utf8 + tail), 0);
          this.onData(utf8str);
        } else {
          this.onData(strm.output.length === strm.next_out ? strm.output : strm.output.subarray(0, strm.next_out));
        }
      }
    }
    if (status === Z_OK$3 && last_avail_out === 0) continue;
    if (status === Z_STREAM_END$3) {
      status = inflate_1.inflateEnd(this.strm);
      this.onEnd(status);
      this.ended = true;
      return true;
    }
    if (strm.avail_in === 0) break;
  }
  return true;
};
Inflate.prototype.onData = function(chunk) {
  this.chunks.push(chunk);
};
Inflate.prototype.onEnd = function(status) {
  if (status === Z_OK$3) {
    if (this.options.to === "string") {
      this.result = this.chunks.join("");
    } else {
      this.result = common.flattenChunks(this.chunks);
    }
  }
  this.chunks = [];
  this.err = status;
  this.msg = this.strm.msg;
};
function inflate$1(input, options) {
  const inflator = new Inflate(options);
  inflator.push(input);
  if (inflator.err) throw inflator.msg || messages[inflator.err];
  return inflator.result;
}
var inflate_2$1 = inflate$1;
var inflate_1$1 = {
  inflate: inflate_2$1
};
const { deflate: deflate$2 } = deflate_1$1;
const { inflate: inflate$2 } = inflate_1$1;
var deflate_1$2 = deflate$2;
var inflate_1$2 = inflate$2;
const white = "#ffffff";
const black = "#000000";
const gray = ["#f8f9fa", "#f1f3f5", "#e9ecef", "#dee2e6", "#ced4da", "#adb5bd", "#868e96", "#495057", "#343a40", "#212529"];
const red = ["#fff5f5", "#ffe3e3", "#ffc9c9", "#ffa8a8", "#ff8787", "#ff6b6b", "#fa5252", "#f03e3e", "#e03131", "#c92a2a"];
const pink = ["#fff0f6", "#ffdeeb", "#fcc2d7", "#faa2c1", "#f783ac", "#f06595", "#e64980", "#d6336c", "#c2255c", "#a61e4d"];
const grape = ["#f8f0fc", "#f3d9fa", "#eebefa", "#e599f7", "#da77f2", "#cc5de8", "#be4bdb", "#ae3ec9", "#9c36b5", "#862e9c"];
const violet = ["#f3f0ff", "#e5dbff", "#d0bfff", "#b197fc", "#9775fa", "#845ef7", "#7950f2", "#7048e8", "#6741d9", "#5f3dc4"];
const indigo = ["#edf2ff", "#dbe4ff", "#bac8ff", "#91a7ff", "#748ffc", "#5c7cfa", "#4c6ef5", "#4263eb", "#3b5bdb", "#364fc7"];
const blue = ["#e7f5ff", "#d0ebff", "#a5d8ff", "#74c0fc", "#4dabf7", "#339af0", "#228be6", "#1c7ed6", "#1971c2", "#1864ab"];
const cyan = ["#e3fafc", "#c5f6fa", "#99e9f2", "#66d9e8", "#3bc9db", "#22b8cf", "#15aabf", "#1098ad", "#0c8599", "#0b7285"];
const teal = ["#e6fcf5", "#c3fae8", "#96f2d7", "#63e6be", "#38d9a9", "#20c997", "#12b886", "#0ca678", "#099268", "#087f5b"];
const green = ["#ebfbee", "#d3f9d8", "#b2f2bb", "#8ce99a", "#69db7c", "#51cf66", "#40c057", "#37b24d", "#2f9e44", "#2b8a3e"];
const lime = ["#f4fce3", "#e9fac8", "#d8f5a2", "#c0eb75", "#a9e34b", "#94d82d", "#82c91e", "#74b816", "#66a80f", "#5c940d"];
const yellow = ["#fff9db", "#fff3bf", "#ffec99", "#ffe066", "#ffd43b", "#fcc419", "#fab005", "#f59f00", "#f08c00", "#e67700"];
const orange = ["#fff4e6", "#ffe8cc", "#ffd8a8", "#ffc078", "#ffa94d", "#ff922b", "#fd7e14", "#f76707", "#e8590c", "#d9480f"];
const _d$1 = {
  white,
  black,
  gray,
  red,
  pink,
  grape,
  violet,
  indigo,
  blue,
  cyan,
  teal,
  green,
  lime,
  yellow,
  orange
};
let nanoid = (size2 = 21) => crypto.getRandomValues(new Uint8Array(size2)).reduce((id2, byte) => {
  byte &= 63;
  if (byte < 36) {
    id2 += byte.toString(36);
  } else if (byte < 62) {
    id2 += (byte - 26).toString(36).toUpperCase();
  } else if (byte > 62) {
    id2 += "-";
  } else {
    id2 += "_";
  }
  return id2;
}, "");
var lodash_throttle;
var hasRequiredLodash_throttle;
function requireLodash_throttle() {
  if (hasRequiredLodash_throttle) return lodash_throttle;
  hasRequiredLodash_throttle = 1;
  var FUNC_ERROR_TEXT = "Expected a function";
  var NAN = 0 / 0;
  var symbolTag = "[object Symbol]";
  var reTrim = /^\s+|\s+$/g;
  var reIsBadHex = /^[-+]0x[0-9a-f]+$/i;
  var reIsBinary = /^0b[01]+$/i;
  var reIsOctal = /^0o[0-7]+$/i;
  var freeParseInt = parseInt;
  var freeGlobal = typeof commonjsGlobal == "object" && commonjsGlobal && commonjsGlobal.Object === Object && commonjsGlobal;
  var freeSelf = typeof self == "object" && self && self.Object === Object && self;
  var root = freeGlobal || freeSelf || Function("return this")();
  var objectProto = Object.prototype;
  var objectToString = objectProto.toString;
  var nativeMax = Math.max, nativeMin = Math.min;
  var now = function() {
    return root.Date.now();
  };
  function debounce(func, wait, options) {
    var lastArgs, lastThis, maxWait, result, timerId, lastCallTime, lastInvokeTime = 0, leading = false, maxing = false, trailing = true;
    if (typeof func != "function") {
      throw new TypeError(FUNC_ERROR_TEXT);
    }
    wait = toNumber(wait) || 0;
    if (isObject(options)) {
      leading = !!options.leading;
      maxing = "maxWait" in options;
      maxWait = maxing ? nativeMax(toNumber(options.maxWait) || 0, wait) : maxWait;
      trailing = "trailing" in options ? !!options.trailing : trailing;
    }
    function invokeFunc(time) {
      var args = lastArgs, thisArg = lastThis;
      lastArgs = lastThis = void 0;
      lastInvokeTime = time;
      result = func.apply(thisArg, args);
      return result;
    }
    function leadingEdge(time) {
      lastInvokeTime = time;
      timerId = setTimeout(timerExpired, wait);
      return leading ? invokeFunc(time) : result;
    }
    function remainingWait(time) {
      var timeSinceLastCall = time - lastCallTime, timeSinceLastInvoke = time - lastInvokeTime, result2 = wait - timeSinceLastCall;
      return maxing ? nativeMin(result2, maxWait - timeSinceLastInvoke) : result2;
    }
    function shouldInvoke(time) {
      var timeSinceLastCall = time - lastCallTime, timeSinceLastInvoke = time - lastInvokeTime;
      return lastCallTime === void 0 || timeSinceLastCall >= wait || timeSinceLastCall < 0 || maxing && timeSinceLastInvoke >= maxWait;
    }
    function timerExpired() {
      var time = now();
      if (shouldInvoke(time)) {
        return trailingEdge(time);
      }
      timerId = setTimeout(timerExpired, remainingWait(time));
    }
    function trailingEdge(time) {
      timerId = void 0;
      if (trailing && lastArgs) {
        return invokeFunc(time);
      }
      lastArgs = lastThis = void 0;
      return result;
    }
    function cancel() {
      if (timerId !== void 0) {
        clearTimeout(timerId);
      }
      lastInvokeTime = 0;
      lastArgs = lastCallTime = lastThis = timerId = void 0;
    }
    function flush() {
      return timerId === void 0 ? result : trailingEdge(now());
    }
    function debounced() {
      var time = now(), isInvoking = shouldInvoke(time);
      lastArgs = arguments;
      lastThis = this;
      lastCallTime = time;
      if (isInvoking) {
        if (timerId === void 0) {
          return leadingEdge(lastCallTime);
        }
        if (maxing) {
          timerId = setTimeout(timerExpired, wait);
          return invokeFunc(lastCallTime);
        }
      }
      if (timerId === void 0) {
        timerId = setTimeout(timerExpired, wait);
      }
      return result;
    }
    debounced.cancel = cancel;
    debounced.flush = flush;
    return debounced;
  }
  function throttle(func, wait, options) {
    var leading = true, trailing = true;
    if (typeof func != "function") {
      throw new TypeError(FUNC_ERROR_TEXT);
    }
    if (isObject(options)) {
      leading = "leading" in options ? !!options.leading : leading;
      trailing = "trailing" in options ? !!options.trailing : trailing;
    }
    return debounce(func, wait, {
      "leading": leading,
      "maxWait": wait,
      "trailing": trailing
    });
  }
  function isObject(value) {
    var type = typeof value;
    return !!value && (type == "object" || type == "function");
  }
  function isObjectLike(value) {
    return !!value && typeof value == "object";
  }
  function isSymbol(value) {
    return typeof value == "symbol" || isObjectLike(value) && objectToString.call(value) == symbolTag;
  }
  function toNumber(value) {
    if (typeof value == "number") {
      return value;
    }
    if (isSymbol(value)) {
      return NAN;
    }
    if (isObject(value)) {
      var other = typeof value.valueOf == "function" ? value.valueOf() : value;
      value = isObject(other) ? other + "" : other;
    }
    if (typeof value != "string") {
      return value === 0 ? value : +value;
    }
    value = value.replace(reTrim, "");
    var isBinary = reIsBinary.test(value);
    return isBinary || reIsOctal.test(value) ? freeParseInt(value.slice(2), isBinary ? 2 : 8) : reIsBadHex.test(value) ? NAN : +value;
  }
  lodash_throttle = throttle;
  return lodash_throttle;
}
var lodash_throttleExports = requireLodash_throttle();
const gM = /* @__PURE__ */ getDefaultExportFromCjs(lodash_throttleExports);
var es6PromisePool$1 = { exports: {} };
var es6PromisePool = es6PromisePool$1.exports;
var hasRequiredEs6PromisePool;
function requireEs6PromisePool() {
  if (hasRequiredEs6PromisePool) return es6PromisePool$1.exports;
  hasRequiredEs6PromisePool = 1;
  (function(module, exports$1) {
    (function(root, factory) {
      {
        module.exports = factory();
      }
    })(es6PromisePool, function() {
      var EventTarget = function() {
        this._listeners = {};
      };
      EventTarget.prototype.addEventListener = function(type, listener) {
        this._listeners[type] = this._listeners[type] || [];
        if (this._listeners[type].indexOf(listener) < 0) {
          this._listeners[type].push(listener);
        }
      };
      EventTarget.prototype.removeEventListener = function(type, listener) {
        if (this._listeners[type]) {
          var p3 = this._listeners[type].indexOf(listener);
          if (p3 >= 0) {
            this._listeners[type].splice(p3, 1);
          }
        }
      };
      EventTarget.prototype.dispatchEvent = function(evt) {
        if (this._listeners[evt.type] && this._listeners[evt.type].length) {
          var listeners = this._listeners[evt.type].slice();
          for (var i3 = 0, l3 = listeners.length; i3 < l3; ++i3) {
            listeners[i3].call(this, evt);
          }
        }
      };
      var isGenerator = function(func) {
        return typeof func.constructor === "function" && func.constructor.name === "GeneratorFunction";
      };
      var functionToIterator = function(func) {
        return {
          next: function() {
            var promise = func();
            return promise ? { value: promise } : { done: true };
          }
        };
      };
      var promiseToIterator = function(promise) {
        var called = false;
        return {
          next: function() {
            if (called) {
              return { done: true };
            }
            called = true;
            return { value: promise };
          }
        };
      };
      var toIterator = function(obj, Promise2) {
        var type = typeof obj;
        if (type === "object") {
          if (typeof obj.next === "function") {
            return obj;
          }
          if (typeof obj.then === "function") {
            return promiseToIterator(obj);
          }
        }
        if (type === "function") {
          return isGenerator(obj) ? obj() : functionToIterator(obj);
        }
        return promiseToIterator(Promise2.resolve(obj));
      };
      var PromisePoolEvent = function(target, type, data) {
        this.target = target;
        this.type = type;
        this.data = data;
      };
      var PromisePool = function(source, concurrency, options) {
        EventTarget.call(this);
        if (typeof concurrency !== "number" || Math.floor(concurrency) !== concurrency || concurrency < 1) {
          throw new Error("Invalid concurrency");
        }
        this._concurrency = concurrency;
        this._options = options || {};
        this._options.promise = this._options.promise || Promise;
        this._iterator = toIterator(source, this._options.promise);
        this._done = false;
        this._size = 0;
        this._promise = null;
        this._callbacks = null;
      };
      PromisePool.prototype = new EventTarget();
      PromisePool.prototype.constructor = PromisePool;
      PromisePool.prototype.concurrency = function(value) {
        if (typeof value !== "undefined") {
          this._concurrency = value;
          if (this.active()) {
            this._proceed();
          }
        }
        return this._concurrency;
      };
      PromisePool.prototype.size = function() {
        return this._size;
      };
      PromisePool.prototype.active = function() {
        return !!this._promise;
      };
      PromisePool.prototype.promise = function() {
        return this._promise;
      };
      PromisePool.prototype.start = function() {
        var that = this;
        var Promise2 = this._options.promise;
        this._promise = new Promise2(function(resolve, reject) {
          that._callbacks = {
            reject,
            resolve
          };
          that._proceed();
        });
        return this._promise;
      };
      PromisePool.prototype._fireEvent = function(type, data) {
        this.dispatchEvent(new PromisePoolEvent(this, type, data));
      };
      PromisePool.prototype._settle = function(error) {
        if (error) {
          this._callbacks.reject(error);
        } else {
          this._callbacks.resolve();
        }
        this._promise = null;
        this._callbacks = null;
      };
      PromisePool.prototype._onPooledPromiseFulfilled = function(promise, result) {
        this._size--;
        if (this.active()) {
          this._fireEvent("fulfilled", {
            promise,
            result
          });
          this._proceed();
        }
      };
      PromisePool.prototype._onPooledPromiseRejected = function(promise, error) {
        this._size--;
        if (this.active()) {
          this._fireEvent("rejected", {
            promise,
            error
          });
          this._settle(error || new Error("Unknown error"));
        }
      };
      PromisePool.prototype._trackPromise = function(promise) {
        var that = this;
        promise.then(function(result) {
          that._onPooledPromiseFulfilled(promise, result);
        }, function(error) {
          that._onPooledPromiseRejected(promise, error);
        })["catch"](function(err2) {
          that._settle(new Error("Promise processing failed: " + err2));
        });
      };
      PromisePool.prototype._proceed = function() {
        if (!this._done) {
          var result = { done: false };
          while (this._size < this._concurrency && !(result = this._iterator.next()).done) {
            this._size++;
            this._trackPromise(result.value);
          }
          this._done = result === null || !!result.done;
        }
        if (this._done && this._size === 0) {
          this._settle();
        }
      };
      PromisePool.PromisePoolEvent = PromisePoolEvent;
      PromisePool.PromisePool = PromisePool;
      return PromisePool;
    });
  })(es6PromisePool$1);
  return es6PromisePool$1.exports;
}
var es6PromisePoolExports = requireEs6PromisePool();
const L6 = /* @__PURE__ */ getDefaultExportFromCjs(es6PromisePoolExports);
function rotatePoints(points, center, degrees) {
  if (points && points.length) {
    const [cx, cy2] = center;
    const angle = Math.PI / 180 * degrees;
    const cos = Math.cos(angle);
    const sin = Math.sin(angle);
    for (const p3 of points) {
      const [x3, y3] = p3;
      p3[0] = (x3 - cx) * cos - (y3 - cy2) * sin + cx;
      p3[1] = (x3 - cx) * sin + (y3 - cy2) * cos + cy2;
    }
  }
}
function rotateLines(lines, center, degrees) {
  const points = [];
  lines.forEach((line2) => points.push(...line2));
  rotatePoints(points, center, degrees);
}
function areSamePoints(p12, p22) {
  return p12[0] === p22[0] && p12[1] === p22[1];
}
function hachureLines(polygons, hachureGap, hachureAngle, hachureStepOffset = 1) {
  const angle = hachureAngle;
  const gap = Math.max(hachureGap, 0.1);
  const polygonList = polygons[0] && polygons[0][0] && typeof polygons[0][0] === "number" ? [polygons] : polygons;
  const rotationCenter = [0, 0];
  if (angle) {
    for (const polygon2 of polygonList) {
      rotatePoints(polygon2, rotationCenter, angle);
    }
  }
  const lines = straightHachureLines(polygonList, gap, hachureStepOffset);
  if (angle) {
    for (const polygon2 of polygonList) {
      rotatePoints(polygon2, rotationCenter, -angle);
    }
    rotateLines(lines, rotationCenter, -angle);
  }
  return lines;
}
function straightHachureLines(polygons, gap, hachureStepOffset) {
  const vertexArray = [];
  for (const polygon2 of polygons) {
    const vertices = [...polygon2];
    if (!areSamePoints(vertices[0], vertices[vertices.length - 1])) {
      vertices.push([vertices[0][0], vertices[0][1]]);
    }
    if (vertices.length > 2) {
      vertexArray.push(vertices);
    }
  }
  const lines = [];
  gap = Math.max(gap, 0.1);
  const edges = [];
  for (const vertices of vertexArray) {
    for (let i3 = 0; i3 < vertices.length - 1; i3++) {
      const p12 = vertices[i3];
      const p22 = vertices[i3 + 1];
      if (p12[1] !== p22[1]) {
        const ymin = Math.min(p12[1], p22[1]);
        edges.push({
          ymin,
          ymax: Math.max(p12[1], p22[1]),
          x: ymin === p12[1] ? p12[0] : p22[0],
          islope: (p22[0] - p12[0]) / (p22[1] - p12[1])
        });
      }
    }
  }
  edges.sort((e12, e23) => {
    if (e12.ymin < e23.ymin) {
      return -1;
    }
    if (e12.ymin > e23.ymin) {
      return 1;
    }
    if (e12.x < e23.x) {
      return -1;
    }
    if (e12.x > e23.x) {
      return 1;
    }
    if (e12.ymax === e23.ymax) {
      return 0;
    }
    return (e12.ymax - e23.ymax) / Math.abs(e12.ymax - e23.ymax);
  });
  if (!edges.length) {
    return lines;
  }
  let activeEdges = [];
  let y3 = edges[0].ymin;
  let iteration = 0;
  while (activeEdges.length || edges.length) {
    if (edges.length) {
      let ix = -1;
      for (let i3 = 0; i3 < edges.length; i3++) {
        if (edges[i3].ymin > y3) {
          break;
        }
        ix = i3;
      }
      const removed = edges.splice(0, ix + 1);
      removed.forEach((edge) => {
        activeEdges.push({ s: y3, edge });
      });
    }
    activeEdges = activeEdges.filter((ae2) => {
      if (ae2.edge.ymax <= y3) {
        return false;
      }
      return true;
    });
    activeEdges.sort((ae1, ae2) => {
      if (ae1.edge.x === ae2.edge.x) {
        return 0;
      }
      return (ae1.edge.x - ae2.edge.x) / Math.abs(ae1.edge.x - ae2.edge.x);
    });
    if (hachureStepOffset !== 1 || iteration % gap === 0) {
      if (activeEdges.length > 1) {
        for (let i3 = 0; i3 < activeEdges.length; i3 = i3 + 2) {
          const nexti = i3 + 1;
          if (nexti >= activeEdges.length) {
            break;
          }
          const ce2 = activeEdges[i3].edge;
          const ne3 = activeEdges[nexti].edge;
          lines.push([
            [Math.round(ce2.x), y3],
            [Math.round(ne3.x), y3]
          ]);
        }
      }
    }
    y3 += hachureStepOffset;
    activeEdges.forEach((ae2) => {
      ae2.edge.x = ae2.edge.x + hachureStepOffset * ae2.edge.islope;
    });
    iteration++;
  }
  return lines;
}
function polygonHachureLines(polygonList, o3) {
  var _a2;
  const angle = o3.hachureAngle + 90;
  let gap = o3.hachureGap;
  if (gap < 0) {
    gap = o3.strokeWidth * 4;
  }
  gap = Math.max(gap, 0.1);
  let skipOffset = 1;
  if (o3.roughness >= 1) {
    if ((((_a2 = o3.randomizer) === null || _a2 === void 0 ? void 0 : _a2.next()) || Math.random()) > 0.7) {
      skipOffset = gap;
    }
  }
  return hachureLines(polygonList, gap, angle, skipOffset || 1);
}
class HachureFiller {
  constructor(helper2) {
    this.helper = helper2;
  }
  fillPolygons(polygonList, o3) {
    return this._fillPolygons(polygonList, o3);
  }
  _fillPolygons(polygonList, o3) {
    const lines = polygonHachureLines(polygonList, o3);
    const ops = this.renderLines(lines, o3);
    return { type: "fillSketch", ops };
  }
  renderLines(lines, o3) {
    const ops = [];
    for (const line2 of lines) {
      ops.push(...this.helper.doubleLineOps(line2[0][0], line2[0][1], line2[1][0], line2[1][1], o3));
    }
    return ops;
  }
}
function lineLength(line2) {
  const p12 = line2[0];
  const p22 = line2[1];
  return Math.sqrt(Math.pow(p12[0] - p22[0], 2) + Math.pow(p12[1] - p22[1], 2));
}
class ZigZagFiller extends HachureFiller {
  fillPolygons(polygonList, o3) {
    let gap = o3.hachureGap;
    if (gap < 0) {
      gap = o3.strokeWidth * 4;
    }
    gap = Math.max(gap, 0.1);
    const o22 = Object.assign({}, o3, { hachureGap: gap });
    const lines = polygonHachureLines(polygonList, o22);
    const zigZagAngle = Math.PI / 180 * o3.hachureAngle;
    const zigzagLines = [];
    const dgx = gap * 0.5 * Math.cos(zigZagAngle);
    const dgy = gap * 0.5 * Math.sin(zigZagAngle);
    for (const [p12, p22] of lines) {
      if (lineLength([p12, p22])) {
        zigzagLines.push([
          [p12[0] - dgx, p12[1] + dgy],
          [...p22]
        ], [
          [p12[0] + dgx, p12[1] - dgy],
          [...p22]
        ]);
      }
    }
    const ops = this.renderLines(zigzagLines, o3);
    return { type: "fillSketch", ops };
  }
}
class HatchFiller extends HachureFiller {
  fillPolygons(polygonList, o3) {
    const set = this._fillPolygons(polygonList, o3);
    const o22 = Object.assign({}, o3, { hachureAngle: o3.hachureAngle + 90 });
    const set2 = this._fillPolygons(polygonList, o22);
    set.ops = set.ops.concat(set2.ops);
    return set;
  }
}
class DotFiller {
  constructor(helper2) {
    this.helper = helper2;
  }
  fillPolygons(polygonList, o3) {
    o3 = Object.assign({}, o3, { hachureAngle: 0 });
    const lines = polygonHachureLines(polygonList, o3);
    return this.dotsOnLines(lines, o3);
  }
  dotsOnLines(lines, o3) {
    const ops = [];
    let gap = o3.hachureGap;
    if (gap < 0) {
      gap = o3.strokeWidth * 4;
    }
    gap = Math.max(gap, 0.1);
    let fweight = o3.fillWeight;
    if (fweight < 0) {
      fweight = o3.strokeWidth / 2;
    }
    const ro3 = gap / 4;
    for (const line2 of lines) {
      const length = lineLength(line2);
      const dl2 = length / gap;
      const count2 = Math.ceil(dl2) - 1;
      const offset2 = length - count2 * gap;
      const x3 = (line2[0][0] + line2[1][0]) / 2 - gap / 4;
      const minY = Math.min(line2[0][1], line2[1][1]);
      for (let i3 = 0; i3 < count2; i3++) {
        const y3 = minY + offset2 + i3 * gap;
        const cx = x3 - ro3 + Math.random() * 2 * ro3;
        const cy2 = y3 - ro3 + Math.random() * 2 * ro3;
        const el2 = this.helper.ellipse(cx, cy2, fweight, fweight, o3);
        ops.push(...el2.ops);
      }
    }
    return { type: "fillSketch", ops };
  }
}
class DashedFiller {
  constructor(helper2) {
    this.helper = helper2;
  }
  fillPolygons(polygonList, o3) {
    const lines = polygonHachureLines(polygonList, o3);
    return { type: "fillSketch", ops: this.dashedLine(lines, o3) };
  }
  dashedLine(lines, o3) {
    const offset2 = o3.dashOffset < 0 ? o3.hachureGap < 0 ? o3.strokeWidth * 4 : o3.hachureGap : o3.dashOffset;
    const gap = o3.dashGap < 0 ? o3.hachureGap < 0 ? o3.strokeWidth * 4 : o3.hachureGap : o3.dashGap;
    const ops = [];
    lines.forEach((line2) => {
      const length = lineLength(line2);
      const count2 = Math.floor(length / (offset2 + gap));
      const startOffset = (length + gap - count2 * (offset2 + gap)) / 2;
      let p12 = line2[0];
      let p22 = line2[1];
      if (p12[0] > p22[0]) {
        p12 = line2[1];
        p22 = line2[0];
      }
      const alpha = Math.atan((p22[1] - p12[1]) / (p22[0] - p12[0]));
      for (let i3 = 0; i3 < count2; i3++) {
        const lstart = i3 * (offset2 + gap);
        const lend = lstart + offset2;
        const start = [p12[0] + lstart * Math.cos(alpha) + startOffset * Math.cos(alpha), p12[1] + lstart * Math.sin(alpha) + startOffset * Math.sin(alpha)];
        const end = [p12[0] + lend * Math.cos(alpha) + startOffset * Math.cos(alpha), p12[1] + lend * Math.sin(alpha) + startOffset * Math.sin(alpha)];
        ops.push(...this.helper.doubleLineOps(start[0], start[1], end[0], end[1], o3));
      }
    });
    return ops;
  }
}
class ZigZagLineFiller {
  constructor(helper2) {
    this.helper = helper2;
  }
  fillPolygons(polygonList, o3) {
    const gap = o3.hachureGap < 0 ? o3.strokeWidth * 4 : o3.hachureGap;
    const zo2 = o3.zigzagOffset < 0 ? gap : o3.zigzagOffset;
    o3 = Object.assign({}, o3, { hachureGap: gap + zo2 });
    const lines = polygonHachureLines(polygonList, o3);
    return { type: "fillSketch", ops: this.zigzagLines(lines, zo2, o3) };
  }
  zigzagLines(lines, zo2, o3) {
    const ops = [];
    lines.forEach((line2) => {
      const length = lineLength(line2);
      const count2 = Math.round(length / (2 * zo2));
      let p12 = line2[0];
      let p22 = line2[1];
      if (p12[0] > p22[0]) {
        p12 = line2[1];
        p22 = line2[0];
      }
      const alpha = Math.atan((p22[1] - p12[1]) / (p22[0] - p12[0]));
      for (let i3 = 0; i3 < count2; i3++) {
        const lstart = i3 * 2 * zo2;
        const lend = (i3 + 1) * 2 * zo2;
        const dz = Math.sqrt(2 * Math.pow(zo2, 2));
        const start = [p12[0] + lstart * Math.cos(alpha), p12[1] + lstart * Math.sin(alpha)];
        const end = [p12[0] + lend * Math.cos(alpha), p12[1] + lend * Math.sin(alpha)];
        const middle = [start[0] + dz * Math.cos(alpha + Math.PI / 4), start[1] + dz * Math.sin(alpha + Math.PI / 4)];
        ops.push(...this.helper.doubleLineOps(start[0], start[1], middle[0], middle[1], o3), ...this.helper.doubleLineOps(middle[0], middle[1], end[0], end[1], o3));
      }
    });
    return ops;
  }
}
const fillers = {};
function getFiller(o3, helper2) {
  let fillerName = o3.fillStyle || "hachure";
  if (!fillers[fillerName]) {
    switch (fillerName) {
      case "zigzag":
        if (!fillers[fillerName]) {
          fillers[fillerName] = new ZigZagFiller(helper2);
        }
        break;
      case "cross-hatch":
        if (!fillers[fillerName]) {
          fillers[fillerName] = new HatchFiller(helper2);
        }
        break;
      case "dots":
        if (!fillers[fillerName]) {
          fillers[fillerName] = new DotFiller(helper2);
        }
        break;
      case "dashed":
        if (!fillers[fillerName]) {
          fillers[fillerName] = new DashedFiller(helper2);
        }
        break;
      case "zigzag-line":
        if (!fillers[fillerName]) {
          fillers[fillerName] = new ZigZagLineFiller(helper2);
        }
        break;
      case "hachure":
      default:
        fillerName = "hachure";
        if (!fillers[fillerName]) {
          fillers[fillerName] = new HachureFiller(helper2);
        }
        break;
    }
  }
  return fillers[fillerName];
}
function randomSeed() {
  return Math.floor(Math.random() * 2 ** 31);
}
class Random {
  constructor(seed) {
    this.seed = seed;
  }
  next() {
    if (this.seed) {
      return (2 ** 31 - 1 & (this.seed = Math.imul(48271, this.seed))) / 2 ** 31;
    } else {
      return Math.random();
    }
  }
}
const COMMAND = 0;
const NUMBER = 1;
const EOD = 2;
const PARAMS = { A: 7, a: 7, C: 6, c: 6, H: 1, h: 1, L: 2, l: 2, M: 2, m: 2, Q: 4, q: 4, S: 4, s: 4, T: 2, t: 2, V: 1, v: 1, Z: 0, z: 0 };
function tokenize(d3) {
  const tokens = new Array();
  while (d3 !== "") {
    if (d3.match(/^([ \t\r\n,]+)/)) {
      d3 = d3.substr(RegExp.$1.length);
    } else if (d3.match(/^([aAcChHlLmMqQsStTvVzZ])/)) {
      tokens[tokens.length] = { type: COMMAND, text: RegExp.$1 };
      d3 = d3.substr(RegExp.$1.length);
    } else if (d3.match(/^(([-+]?[0-9]+(\.[0-9]*)?|[-+]?\.[0-9]+)([eE][-+]?[0-9]+)?)/)) {
      tokens[tokens.length] = { type: NUMBER, text: `${parseFloat(RegExp.$1)}` };
      d3 = d3.substr(RegExp.$1.length);
    } else {
      return [];
    }
  }
  tokens[tokens.length] = { type: EOD, text: "" };
  return tokens;
}
function isType(token, type) {
  return token.type === type;
}
function parsePath(d3) {
  const segments = [];
  const tokens = tokenize(d3);
  let mode = "BOD";
  let index2 = 0;
  let token = tokens[index2];
  while (!isType(token, EOD)) {
    let paramsCount = 0;
    const params = [];
    if (mode === "BOD") {
      if (token.text === "M" || token.text === "m") {
        index2++;
        paramsCount = PARAMS[token.text];
        mode = token.text;
      } else {
        return parsePath("M0,0" + d3);
      }
    } else if (isType(token, NUMBER)) {
      paramsCount = PARAMS[mode];
    } else {
      index2++;
      paramsCount = PARAMS[token.text];
      mode = token.text;
    }
    if (index2 + paramsCount < tokens.length) {
      for (let i3 = index2; i3 < index2 + paramsCount; i3++) {
        const numbeToken = tokens[i3];
        if (isType(numbeToken, NUMBER)) {
          params[params.length] = +numbeToken.text;
        } else {
          throw new Error("Param not a number: " + mode + "," + numbeToken.text);
        }
      }
      if (typeof PARAMS[mode] === "number") {
        const segment = { key: mode, data: params };
        segments.push(segment);
        index2 += paramsCount;
        token = tokens[index2];
        if (mode === "M")
          mode = "L";
        if (mode === "m")
          mode = "l";
      } else {
        throw new Error("Bad segment: " + mode);
      }
    } else {
      throw new Error("Path data ended short");
    }
  }
  return segments;
}
function absolutize(segments) {
  let cx = 0, cy2 = 0;
  let subx = 0, suby = 0;
  const out = [];
  for (const { key, data } of segments) {
    switch (key) {
      case "M":
        out.push({ key: "M", data: [...data] });
        [cx, cy2] = data;
        [subx, suby] = data;
        break;
      case "m":
        cx += data[0];
        cy2 += data[1];
        out.push({ key: "M", data: [cx, cy2] });
        subx = cx;
        suby = cy2;
        break;
      case "L":
        out.push({ key: "L", data: [...data] });
        [cx, cy2] = data;
        break;
      case "l":
        cx += data[0];
        cy2 += data[1];
        out.push({ key: "L", data: [cx, cy2] });
        break;
      case "C":
        out.push({ key: "C", data: [...data] });
        cx = data[4];
        cy2 = data[5];
        break;
      case "c": {
        const newdata = data.map((d3, i3) => i3 % 2 ? d3 + cy2 : d3 + cx);
        out.push({ key: "C", data: newdata });
        cx = newdata[4];
        cy2 = newdata[5];
        break;
      }
      case "Q":
        out.push({ key: "Q", data: [...data] });
        cx = data[2];
        cy2 = data[3];
        break;
      case "q": {
        const newdata = data.map((d3, i3) => i3 % 2 ? d3 + cy2 : d3 + cx);
        out.push({ key: "Q", data: newdata });
        cx = newdata[2];
        cy2 = newdata[3];
        break;
      }
      case "A":
        out.push({ key: "A", data: [...data] });
        cx = data[5];
        cy2 = data[6];
        break;
      case "a":
        cx += data[5];
        cy2 += data[6];
        out.push({ key: "A", data: [data[0], data[1], data[2], data[3], data[4], cx, cy2] });
        break;
      case "H":
        out.push({ key: "H", data: [...data] });
        cx = data[0];
        break;
      case "h":
        cx += data[0];
        out.push({ key: "H", data: [cx] });
        break;
      case "V":
        out.push({ key: "V", data: [...data] });
        cy2 = data[0];
        break;
      case "v":
        cy2 += data[0];
        out.push({ key: "V", data: [cy2] });
        break;
      case "S":
        out.push({ key: "S", data: [...data] });
        cx = data[2];
        cy2 = data[3];
        break;
      case "s": {
        const newdata = data.map((d3, i3) => i3 % 2 ? d3 + cy2 : d3 + cx);
        out.push({ key: "S", data: newdata });
        cx = newdata[2];
        cy2 = newdata[3];
        break;
      }
      case "T":
        out.push({ key: "T", data: [...data] });
        cx = data[0];
        cy2 = data[1];
        break;
      case "t":
        cx += data[0];
        cy2 += data[1];
        out.push({ key: "T", data: [cx, cy2] });
        break;
      case "Z":
      case "z":
        out.push({ key: "Z", data: [] });
        cx = subx;
        cy2 = suby;
        break;
    }
  }
  return out;
}
function normalize(segments) {
  const out = [];
  let lastType = "";
  let cx = 0, cy2 = 0;
  let subx = 0, suby = 0;
  let lcx = 0, lcy = 0;
  for (const { key, data } of segments) {
    switch (key) {
      case "M":
        out.push({ key: "M", data: [...data] });
        [cx, cy2] = data;
        [subx, suby] = data;
        break;
      case "C":
        out.push({ key: "C", data: [...data] });
        cx = data[4];
        cy2 = data[5];
        lcx = data[2];
        lcy = data[3];
        break;
      case "L":
        out.push({ key: "L", data: [...data] });
        [cx, cy2] = data;
        break;
      case "H":
        cx = data[0];
        out.push({ key: "L", data: [cx, cy2] });
        break;
      case "V":
        cy2 = data[0];
        out.push({ key: "L", data: [cx, cy2] });
        break;
      case "S": {
        let cx1 = 0, cy1 = 0;
        if (lastType === "C" || lastType === "S") {
          cx1 = cx + (cx - lcx);
          cy1 = cy2 + (cy2 - lcy);
        } else {
          cx1 = cx;
          cy1 = cy2;
        }
        out.push({ key: "C", data: [cx1, cy1, ...data] });
        lcx = data[0];
        lcy = data[1];
        cx = data[2];
        cy2 = data[3];
        break;
      }
      case "T": {
        const [x3, y3] = data;
        let x12 = 0, y12 = 0;
        if (lastType === "Q" || lastType === "T") {
          x12 = cx + (cx - lcx);
          y12 = cy2 + (cy2 - lcy);
        } else {
          x12 = cx;
          y12 = cy2;
        }
        const cx1 = cx + 2 * (x12 - cx) / 3;
        const cy1 = cy2 + 2 * (y12 - cy2) / 3;
        const cx2 = x3 + 2 * (x12 - x3) / 3;
        const cy22 = y3 + 2 * (y12 - y3) / 3;
        out.push({ key: "C", data: [cx1, cy1, cx2, cy22, x3, y3] });
        lcx = x12;
        lcy = y12;
        cx = x3;
        cy2 = y3;
        break;
      }
      case "Q": {
        const [x12, y12, x3, y3] = data;
        const cx1 = cx + 2 * (x12 - cx) / 3;
        const cy1 = cy2 + 2 * (y12 - cy2) / 3;
        const cx2 = x3 + 2 * (x12 - x3) / 3;
        const cy22 = y3 + 2 * (y12 - y3) / 3;
        out.push({ key: "C", data: [cx1, cy1, cx2, cy22, x3, y3] });
        lcx = x12;
        lcy = y12;
        cx = x3;
        cy2 = y3;
        break;
      }
      case "A": {
        const r12 = Math.abs(data[0]);
        const r22 = Math.abs(data[1]);
        const angle = data[2];
        const largeArcFlag = data[3];
        const sweepFlag = data[4];
        const x3 = data[5];
        const y3 = data[6];
        if (r12 === 0 || r22 === 0) {
          out.push({ key: "C", data: [cx, cy2, x3, y3, x3, y3] });
          cx = x3;
          cy2 = y3;
        } else {
          if (cx !== x3 || cy2 !== y3) {
            const curves = arcToCubicCurves(cx, cy2, x3, y3, r12, r22, angle, largeArcFlag, sweepFlag);
            curves.forEach(function(curve2) {
              out.push({ key: "C", data: curve2 });
            });
            cx = x3;
            cy2 = y3;
          }
        }
        break;
      }
      case "Z":
        out.push({ key: "Z", data: [] });
        cx = subx;
        cy2 = suby;
        break;
    }
    lastType = key;
  }
  return out;
}
function degToRad(degrees) {
  return Math.PI * degrees / 180;
}
function rotate(x3, y3, angleRad) {
  const X3 = x3 * Math.cos(angleRad) - y3 * Math.sin(angleRad);
  const Y3 = x3 * Math.sin(angleRad) + y3 * Math.cos(angleRad);
  return [X3, Y3];
}
function arcToCubicCurves(x12, y12, x22, y22, r12, r22, angle, largeArcFlag, sweepFlag, recursive) {
  const angleRad = degToRad(angle);
  let params = [];
  let f12 = 0, f22 = 0, cx = 0, cy2 = 0;
  if (recursive) {
    [f12, f22, cx, cy2] = recursive;
  } else {
    [x12, y12] = rotate(x12, y12, -angleRad);
    [x22, y22] = rotate(x22, y22, -angleRad);
    const x3 = (x12 - x22) / 2;
    const y3 = (y12 - y22) / 2;
    let h3 = x3 * x3 / (r12 * r12) + y3 * y3 / (r22 * r22);
    if (h3 > 1) {
      h3 = Math.sqrt(h3);
      r12 = h3 * r12;
      r22 = h3 * r22;
    }
    const sign = largeArcFlag === sweepFlag ? -1 : 1;
    const r1Pow = r12 * r12;
    const r2Pow = r22 * r22;
    const left = r1Pow * r2Pow - r1Pow * y3 * y3 - r2Pow * x3 * x3;
    const right = r1Pow * y3 * y3 + r2Pow * x3 * x3;
    const k2 = sign * Math.sqrt(Math.abs(left / right));
    cx = k2 * r12 * y3 / r22 + (x12 + x22) / 2;
    cy2 = k2 * -r22 * x3 / r12 + (y12 + y22) / 2;
    f12 = Math.asin(parseFloat(((y12 - cy2) / r22).toFixed(9)));
    f22 = Math.asin(parseFloat(((y22 - cy2) / r22).toFixed(9)));
    if (x12 < cx) {
      f12 = Math.PI - f12;
    }
    if (x22 < cx) {
      f22 = Math.PI - f22;
    }
    if (f12 < 0) {
      f12 = Math.PI * 2 + f12;
    }
    if (f22 < 0) {
      f22 = Math.PI * 2 + f22;
    }
    if (sweepFlag && f12 > f22) {
      f12 = f12 - Math.PI * 2;
    }
    if (!sweepFlag && f22 > f12) {
      f22 = f22 - Math.PI * 2;
    }
  }
  let df2 = f22 - f12;
  if (Math.abs(df2) > Math.PI * 120 / 180) {
    const f2old = f22;
    const x2old = x22;
    const y2old = y22;
    if (sweepFlag && f22 > f12) {
      f22 = f12 + Math.PI * 120 / 180 * 1;
    } else {
      f22 = f12 + Math.PI * 120 / 180 * -1;
    }
    x22 = cx + r12 * Math.cos(f22);
    y22 = cy2 + r22 * Math.sin(f22);
    params = arcToCubicCurves(x22, y22, x2old, y2old, r12, r22, angle, 0, sweepFlag, [f22, f2old, cx, cy2]);
  }
  df2 = f22 - f12;
  const c12 = Math.cos(f12);
  const s12 = Math.sin(f12);
  const c22 = Math.cos(f22);
  const s22 = Math.sin(f22);
  const t3 = Math.tan(df2 / 4);
  const hx = 4 / 3 * r12 * t3;
  const hy2 = 4 / 3 * r22 * t3;
  const m12 = [x12, y12];
  const m22 = [x12 + hx * s12, y12 - hy2 * c12];
  const m3 = [x22 + hx * s22, y22 - hy2 * c22];
  const m42 = [x22, y22];
  m22[0] = 2 * m12[0] - m22[0];
  m22[1] = 2 * m12[1] - m22[1];
  if (recursive) {
    return [m22, m3, m42].concat(params);
  } else {
    params = [m22, m3, m42].concat(params);
    const curves = [];
    for (let i3 = 0; i3 < params.length; i3 += 3) {
      const r13 = rotate(params[i3][0], params[i3][1], angleRad);
      const r23 = rotate(params[i3 + 1][0], params[i3 + 1][1], angleRad);
      const r3 = rotate(params[i3 + 2][0], params[i3 + 2][1], angleRad);
      curves.push([r13[0], r13[1], r23[0], r23[1], r3[0], r3[1]]);
    }
    return curves;
  }
}
const helper = {
  randOffset,
  randOffsetWithRange,
  ellipse,
  doubleLineOps: doubleLineFillOps
};
function line(x12, y12, x22, y22, o3) {
  return { type: "path", ops: _doubleLine(x12, y12, x22, y22, o3) };
}
function linearPath(points, close, o3) {
  const len = (points || []).length;
  if (len > 2) {
    const ops = [];
    for (let i3 = 0; i3 < len - 1; i3++) {
      ops.push(..._doubleLine(points[i3][0], points[i3][1], points[i3 + 1][0], points[i3 + 1][1], o3));
    }
    if (close) {
      ops.push(..._doubleLine(points[len - 1][0], points[len - 1][1], points[0][0], points[0][1], o3));
    }
    return { type: "path", ops };
  } else if (len === 2) {
    return line(points[0][0], points[0][1], points[1][0], points[1][1], o3);
  }
  return { type: "path", ops: [] };
}
function polygon(points, o3) {
  return linearPath(points, true, o3);
}
function rectangle(x3, y3, width, height, o3) {
  const points = [
    [x3, y3],
    [x3 + width, y3],
    [x3 + width, y3 + height],
    [x3, y3 + height]
  ];
  return polygon(points, o3);
}
function curve(points, o3) {
  let o12 = _curveWithOffset(points, 1 * (1 + o3.roughness * 0.2), o3);
  if (!o3.disableMultiStroke) {
    const o22 = _curveWithOffset(points, 1.5 * (1 + o3.roughness * 0.22), cloneOptionsAlterSeed(o3));
    o12 = o12.concat(o22);
  }
  return { type: "path", ops: o12 };
}
function ellipse(x3, y3, width, height, o3) {
  const params = generateEllipseParams(width, height, o3);
  return ellipseWithParams(x3, y3, o3, params).opset;
}
function generateEllipseParams(width, height, o3) {
  const psq = Math.sqrt(Math.PI * 2 * Math.sqrt((Math.pow(width / 2, 2) + Math.pow(height / 2, 2)) / 2));
  const stepCount = Math.ceil(Math.max(o3.curveStepCount, o3.curveStepCount / Math.sqrt(200) * psq));
  const increment = Math.PI * 2 / stepCount;
  let rx = Math.abs(width / 2);
  let ry2 = Math.abs(height / 2);
  const curveFitRandomness = 1 - o3.curveFitting;
  rx += _offsetOpt(rx * curveFitRandomness, o3);
  ry2 += _offsetOpt(ry2 * curveFitRandomness, o3);
  return { increment, rx, ry: ry2 };
}
function ellipseWithParams(x3, y3, o3, ellipseParams) {
  const [ap1, cp1] = _computeEllipsePoints(ellipseParams.increment, x3, y3, ellipseParams.rx, ellipseParams.ry, 1, ellipseParams.increment * _offset(0.1, _offset(0.4, 1, o3), o3), o3);
  let o12 = _curve(ap1, null, o3);
  if (!o3.disableMultiStroke && o3.roughness !== 0) {
    const [ap2] = _computeEllipsePoints(ellipseParams.increment, x3, y3, ellipseParams.rx, ellipseParams.ry, 1.5, 0, o3);
    const o22 = _curve(ap2, null, o3);
    o12 = o12.concat(o22);
  }
  return {
    estimatedPoints: cp1,
    opset: { type: "path", ops: o12 }
  };
}
function arc(x3, y3, width, height, start, stop, closed, roughClosure, o3) {
  const cx = x3;
  const cy2 = y3;
  let rx = Math.abs(width / 2);
  let ry2 = Math.abs(height / 2);
  rx += _offsetOpt(rx * 0.01, o3);
  ry2 += _offsetOpt(ry2 * 0.01, o3);
  let strt = start;
  let stp = stop;
  while (strt < 0) {
    strt += Math.PI * 2;
    stp += Math.PI * 2;
  }
  if (stp - strt > Math.PI * 2) {
    strt = 0;
    stp = Math.PI * 2;
  }
  const ellipseInc = Math.PI * 2 / o3.curveStepCount;
  const arcInc = Math.min(ellipseInc / 2, (stp - strt) / 2);
  const ops = _arc(arcInc, cx, cy2, rx, ry2, strt, stp, 1, o3);
  if (!o3.disableMultiStroke) {
    const o22 = _arc(arcInc, cx, cy2, rx, ry2, strt, stp, 1.5, o3);
    ops.push(...o22);
  }
  if (closed) {
    if (roughClosure) {
      ops.push(..._doubleLine(cx, cy2, cx + rx * Math.cos(strt), cy2 + ry2 * Math.sin(strt), o3), ..._doubleLine(cx, cy2, cx + rx * Math.cos(stp), cy2 + ry2 * Math.sin(stp), o3));
    } else {
      ops.push({ op: "lineTo", data: [cx, cy2] }, { op: "lineTo", data: [cx + rx * Math.cos(strt), cy2 + ry2 * Math.sin(strt)] });
    }
  }
  return { type: "path", ops };
}
function svgPath(path, o3) {
  const segments = normalize(absolutize(parsePath(path)));
  const ops = [];
  let first = [0, 0];
  let current = [0, 0];
  for (const { key, data } of segments) {
    switch (key) {
      case "M": {
        current = [data[0], data[1]];
        first = [data[0], data[1]];
        break;
      }
      case "L":
        ops.push(..._doubleLine(current[0], current[1], data[0], data[1], o3));
        current = [data[0], data[1]];
        break;
      case "C": {
        const [x12, y12, x22, y22, x3, y3] = data;
        ops.push(..._bezierTo(x12, y12, x22, y22, x3, y3, current, o3));
        current = [x3, y3];
        break;
      }
      case "Z":
        ops.push(..._doubleLine(current[0], current[1], first[0], first[1], o3));
        current = [first[0], first[1]];
        break;
    }
  }
  return { type: "path", ops };
}
function solidFillPolygon(polygonList, o3) {
  const ops = [];
  for (const points of polygonList) {
    if (points.length) {
      const offset2 = o3.maxRandomnessOffset || 0;
      const len = points.length;
      if (len > 2) {
        ops.push({ op: "move", data: [points[0][0] + _offsetOpt(offset2, o3), points[0][1] + _offsetOpt(offset2, o3)] });
        for (let i3 = 1; i3 < len; i3++) {
          ops.push({ op: "lineTo", data: [points[i3][0] + _offsetOpt(offset2, o3), points[i3][1] + _offsetOpt(offset2, o3)] });
        }
      }
    }
  }
  return { type: "fillPath", ops };
}
function patternFillPolygons(polygonList, o3) {
  return getFiller(o3, helper).fillPolygons(polygonList, o3);
}
function patternFillArc(x3, y3, width, height, start, stop, o3) {
  const cx = x3;
  const cy2 = y3;
  let rx = Math.abs(width / 2);
  let ry2 = Math.abs(height / 2);
  rx += _offsetOpt(rx * 0.01, o3);
  ry2 += _offsetOpt(ry2 * 0.01, o3);
  let strt = start;
  let stp = stop;
  while (strt < 0) {
    strt += Math.PI * 2;
    stp += Math.PI * 2;
  }
  if (stp - strt > Math.PI * 2) {
    strt = 0;
    stp = Math.PI * 2;
  }
  const increment = (stp - strt) / o3.curveStepCount;
  const points = [];
  for (let angle = strt; angle <= stp; angle = angle + increment) {
    points.push([cx + rx * Math.cos(angle), cy2 + ry2 * Math.sin(angle)]);
  }
  points.push([cx + rx * Math.cos(stp), cy2 + ry2 * Math.sin(stp)]);
  points.push([cx, cy2]);
  return patternFillPolygons([points], o3);
}
function randOffset(x3, o3) {
  return _offsetOpt(x3, o3);
}
function randOffsetWithRange(min2, max2, o3) {
  return _offset(min2, max2, o3);
}
function doubleLineFillOps(x12, y12, x22, y22, o3) {
  return _doubleLine(x12, y12, x22, y22, o3, true);
}
function cloneOptionsAlterSeed(ops) {
  const result = Object.assign({}, ops);
  result.randomizer = void 0;
  if (ops.seed) {
    result.seed = ops.seed + 1;
  }
  return result;
}
function random(ops) {
  if (!ops.randomizer) {
    ops.randomizer = new Random(ops.seed || 0);
  }
  return ops.randomizer.next();
}
function _offset(min2, max2, ops, roughnessGain = 1) {
  return ops.roughness * roughnessGain * (random(ops) * (max2 - min2) + min2);
}
function _offsetOpt(x3, ops, roughnessGain = 1) {
  return _offset(-x3, x3, ops, roughnessGain);
}
function _doubleLine(x12, y12, x22, y22, o3, filling = false) {
  const singleStroke = filling ? o3.disableMultiStrokeFill : o3.disableMultiStroke;
  const o12 = _line(x12, y12, x22, y22, o3, true, false);
  if (singleStroke) {
    return o12;
  }
  const o22 = _line(x12, y12, x22, y22, o3, true, true);
  return o12.concat(o22);
}
function _line(x12, y12, x22, y22, o3, move, overlay) {
  const lengthSq = Math.pow(x12 - x22, 2) + Math.pow(y12 - y22, 2);
  const length = Math.sqrt(lengthSq);
  let roughnessGain = 1;
  if (length < 200) {
    roughnessGain = 1;
  } else if (length > 500) {
    roughnessGain = 0.4;
  } else {
    roughnessGain = -16668e-7 * length + 1.233334;
  }
  let offset2 = o3.maxRandomnessOffset || 0;
  if (offset2 * offset2 * 100 > lengthSq) {
    offset2 = length / 10;
  }
  const halfOffset = offset2 / 2;
  const divergePoint = 0.2 + random(o3) * 0.2;
  let midDispX = o3.bowing * o3.maxRandomnessOffset * (y22 - y12) / 200;
  let midDispY = o3.bowing * o3.maxRandomnessOffset * (x12 - x22) / 200;
  midDispX = _offsetOpt(midDispX, o3, roughnessGain);
  midDispY = _offsetOpt(midDispY, o3, roughnessGain);
  const ops = [];
  const randomHalf = () => _offsetOpt(halfOffset, o3, roughnessGain);
  const randomFull = () => _offsetOpt(offset2, o3, roughnessGain);
  const preserveVertices = o3.preserveVertices;
  {
    if (overlay) {
      ops.push({
        op: "move",
        data: [
          x12 + (preserveVertices ? 0 : randomHalf()),
          y12 + (preserveVertices ? 0 : randomHalf())
        ]
      });
    } else {
      ops.push({
        op: "move",
        data: [
          x12 + (preserveVertices ? 0 : _offsetOpt(offset2, o3, roughnessGain)),
          y12 + (preserveVertices ? 0 : _offsetOpt(offset2, o3, roughnessGain))
        ]
      });
    }
  }
  if (overlay) {
    ops.push({
      op: "bcurveTo",
      data: [
        midDispX + x12 + (x22 - x12) * divergePoint + randomHalf(),
        midDispY + y12 + (y22 - y12) * divergePoint + randomHalf(),
        midDispX + x12 + 2 * (x22 - x12) * divergePoint + randomHalf(),
        midDispY + y12 + 2 * (y22 - y12) * divergePoint + randomHalf(),
        x22 + (preserveVertices ? 0 : randomHalf()),
        y22 + (preserveVertices ? 0 : randomHalf())
      ]
    });
  } else {
    ops.push({
      op: "bcurveTo",
      data: [
        midDispX + x12 + (x22 - x12) * divergePoint + randomFull(),
        midDispY + y12 + (y22 - y12) * divergePoint + randomFull(),
        midDispX + x12 + 2 * (x22 - x12) * divergePoint + randomFull(),
        midDispY + y12 + 2 * (y22 - y12) * divergePoint + randomFull(),
        x22 + (preserveVertices ? 0 : randomFull()),
        y22 + (preserveVertices ? 0 : randomFull())
      ]
    });
  }
  return ops;
}
function _curveWithOffset(points, offset2, o3) {
  const ps2 = [];
  ps2.push([
    points[0][0] + _offsetOpt(offset2, o3),
    points[0][1] + _offsetOpt(offset2, o3)
  ]);
  ps2.push([
    points[0][0] + _offsetOpt(offset2, o3),
    points[0][1] + _offsetOpt(offset2, o3)
  ]);
  for (let i3 = 1; i3 < points.length; i3++) {
    ps2.push([
      points[i3][0] + _offsetOpt(offset2, o3),
      points[i3][1] + _offsetOpt(offset2, o3)
    ]);
    if (i3 === points.length - 1) {
      ps2.push([
        points[i3][0] + _offsetOpt(offset2, o3),
        points[i3][1] + _offsetOpt(offset2, o3)
      ]);
    }
  }
  return _curve(ps2, null, o3);
}
function _curve(points, closePoint, o3) {
  const len = points.length;
  const ops = [];
  if (len > 3) {
    const b3 = [];
    const s3 = 1 - o3.curveTightness;
    ops.push({ op: "move", data: [points[1][0], points[1][1]] });
    for (let i3 = 1; i3 + 2 < len; i3++) {
      const cachedVertArray = points[i3];
      b3[0] = [cachedVertArray[0], cachedVertArray[1]];
      b3[1] = [cachedVertArray[0] + (s3 * points[i3 + 1][0] - s3 * points[i3 - 1][0]) / 6, cachedVertArray[1] + (s3 * points[i3 + 1][1] - s3 * points[i3 - 1][1]) / 6];
      b3[2] = [points[i3 + 1][0] + (s3 * points[i3][0] - s3 * points[i3 + 2][0]) / 6, points[i3 + 1][1] + (s3 * points[i3][1] - s3 * points[i3 + 2][1]) / 6];
      b3[3] = [points[i3 + 1][0], points[i3 + 1][1]];
      ops.push({ op: "bcurveTo", data: [b3[1][0], b3[1][1], b3[2][0], b3[2][1], b3[3][0], b3[3][1]] });
    }
  } else if (len === 3) {
    ops.push({ op: "move", data: [points[1][0], points[1][1]] });
    ops.push({
      op: "bcurveTo",
      data: [
        points[1][0],
        points[1][1],
        points[2][0],
        points[2][1],
        points[2][0],
        points[2][1]
      ]
    });
  } else if (len === 2) {
    ops.push(..._doubleLine(points[0][0], points[0][1], points[1][0], points[1][1], o3));
  }
  return ops;
}
function _computeEllipsePoints(increment, cx, cy2, rx, ry2, offset2, overlap, o3) {
  const coreOnly = o3.roughness === 0;
  const corePoints = [];
  const allPoints = [];
  if (coreOnly) {
    increment = increment / 4;
    allPoints.push([
      cx + rx * Math.cos(-increment),
      cy2 + ry2 * Math.sin(-increment)
    ]);
    for (let angle = 0; angle <= Math.PI * 2; angle = angle + increment) {
      const p3 = [
        cx + rx * Math.cos(angle),
        cy2 + ry2 * Math.sin(angle)
      ];
      corePoints.push(p3);
      allPoints.push(p3);
    }
    allPoints.push([
      cx + rx * Math.cos(0),
      cy2 + ry2 * Math.sin(0)
    ]);
    allPoints.push([
      cx + rx * Math.cos(increment),
      cy2 + ry2 * Math.sin(increment)
    ]);
  } else {
    const radOffset = _offsetOpt(0.5, o3) - Math.PI / 2;
    allPoints.push([
      _offsetOpt(offset2, o3) + cx + 0.9 * rx * Math.cos(radOffset - increment),
      _offsetOpt(offset2, o3) + cy2 + 0.9 * ry2 * Math.sin(radOffset - increment)
    ]);
    const endAngle = Math.PI * 2 + radOffset - 0.01;
    for (let angle = radOffset; angle < endAngle; angle = angle + increment) {
      const p3 = [
        _offsetOpt(offset2, o3) + cx + rx * Math.cos(angle),
        _offsetOpt(offset2, o3) + cy2 + ry2 * Math.sin(angle)
      ];
      corePoints.push(p3);
      allPoints.push(p3);
    }
    allPoints.push([
      _offsetOpt(offset2, o3) + cx + rx * Math.cos(radOffset + Math.PI * 2 + overlap * 0.5),
      _offsetOpt(offset2, o3) + cy2 + ry2 * Math.sin(radOffset + Math.PI * 2 + overlap * 0.5)
    ]);
    allPoints.push([
      _offsetOpt(offset2, o3) + cx + 0.98 * rx * Math.cos(radOffset + overlap),
      _offsetOpt(offset2, o3) + cy2 + 0.98 * ry2 * Math.sin(radOffset + overlap)
    ]);
    allPoints.push([
      _offsetOpt(offset2, o3) + cx + 0.9 * rx * Math.cos(radOffset + overlap * 0.5),
      _offsetOpt(offset2, o3) + cy2 + 0.9 * ry2 * Math.sin(radOffset + overlap * 0.5)
    ]);
  }
  return [allPoints, corePoints];
}
function _arc(increment, cx, cy2, rx, ry2, strt, stp, offset2, o3) {
  const radOffset = strt + _offsetOpt(0.1, o3);
  const points = [];
  points.push([
    _offsetOpt(offset2, o3) + cx + 0.9 * rx * Math.cos(radOffset - increment),
    _offsetOpt(offset2, o3) + cy2 + 0.9 * ry2 * Math.sin(radOffset - increment)
  ]);
  for (let angle = radOffset; angle <= stp; angle = angle + increment) {
    points.push([
      _offsetOpt(offset2, o3) + cx + rx * Math.cos(angle),
      _offsetOpt(offset2, o3) + cy2 + ry2 * Math.sin(angle)
    ]);
  }
  points.push([
    cx + rx * Math.cos(stp),
    cy2 + ry2 * Math.sin(stp)
  ]);
  points.push([
    cx + rx * Math.cos(stp),
    cy2 + ry2 * Math.sin(stp)
  ]);
  return _curve(points, null, o3);
}
function _bezierTo(x12, y12, x22, y22, x3, y3, current, o3) {
  const ops = [];
  const ros = [o3.maxRandomnessOffset || 1, (o3.maxRandomnessOffset || 1) + 0.3];
  let f3 = [0, 0];
  const iterations = o3.disableMultiStroke ? 1 : 2;
  const preserveVertices = o3.preserveVertices;
  for (let i3 = 0; i3 < iterations; i3++) {
    if (i3 === 0) {
      ops.push({ op: "move", data: [current[0], current[1]] });
    } else {
      ops.push({ op: "move", data: [current[0] + (preserveVertices ? 0 : _offsetOpt(ros[0], o3)), current[1] + (preserveVertices ? 0 : _offsetOpt(ros[0], o3))] });
    }
    f3 = preserveVertices ? [x3, y3] : [x3 + _offsetOpt(ros[i3], o3), y3 + _offsetOpt(ros[i3], o3)];
    ops.push({
      op: "bcurveTo",
      data: [
        x12 + _offsetOpt(ros[i3], o3),
        y12 + _offsetOpt(ros[i3], o3),
        x22 + _offsetOpt(ros[i3], o3),
        y22 + _offsetOpt(ros[i3], o3),
        f3[0],
        f3[1]
      ]
    });
  }
  return ops;
}
function clone(p3) {
  return [...p3];
}
function curveToBezier(pointsIn, curveTightness = 0) {
  const len = pointsIn.length;
  if (len < 3) {
    throw new Error("A curve must have at least three points.");
  }
  const out = [];
  if (len === 3) {
    out.push(clone(pointsIn[0]), clone(pointsIn[1]), clone(pointsIn[2]), clone(pointsIn[2]));
  } else {
    const points = [];
    points.push(pointsIn[0], pointsIn[0]);
    for (let i3 = 1; i3 < pointsIn.length; i3++) {
      points.push(pointsIn[i3]);
      if (i3 === pointsIn.length - 1) {
        points.push(pointsIn[i3]);
      }
    }
    const b3 = [];
    const s3 = 1 - curveTightness;
    out.push(clone(points[0]));
    for (let i3 = 1; i3 + 2 < points.length; i3++) {
      const cachedVertArray = points[i3];
      b3[0] = [cachedVertArray[0], cachedVertArray[1]];
      b3[1] = [cachedVertArray[0] + (s3 * points[i3 + 1][0] - s3 * points[i3 - 1][0]) / 6, cachedVertArray[1] + (s3 * points[i3 + 1][1] - s3 * points[i3 - 1][1]) / 6];
      b3[2] = [points[i3 + 1][0] + (s3 * points[i3][0] - s3 * points[i3 + 2][0]) / 6, points[i3 + 1][1] + (s3 * points[i3][1] - s3 * points[i3 + 2][1]) / 6];
      b3[3] = [points[i3 + 1][0], points[i3 + 1][1]];
      out.push(b3[1], b3[2], b3[3]);
    }
  }
  return out;
}
function distance$2(p12, p22) {
  return Math.sqrt(distanceSq$2(p12, p22));
}
function distanceSq$2(p12, p22) {
  return Math.pow(p12[0] - p22[0], 2) + Math.pow(p12[1] - p22[1], 2);
}
function distanceToSegmentSq$2(p3, v3, w3) {
  const l22 = distanceSq$2(v3, w3);
  if (l22 === 0) {
    return distanceSq$2(p3, v3);
  }
  let t3 = ((p3[0] - v3[0]) * (w3[0] - v3[0]) + (p3[1] - v3[1]) * (w3[1] - v3[1])) / l22;
  t3 = Math.max(0, Math.min(1, t3));
  return distanceSq$2(p3, lerp$2(v3, w3, t3));
}
function lerp$2(a3, b3, t3) {
  return [
    a3[0] + (b3[0] - a3[0]) * t3,
    a3[1] + (b3[1] - a3[1]) * t3
  ];
}
function flatness$2(points, offset2) {
  const p12 = points[offset2 + 0];
  const p22 = points[offset2 + 1];
  const p3 = points[offset2 + 2];
  const p42 = points[offset2 + 3];
  let ux2 = 3 * p22[0] - 2 * p12[0] - p42[0];
  ux2 *= ux2;
  let uy2 = 3 * p22[1] - 2 * p12[1] - p42[1];
  uy2 *= uy2;
  let vx2 = 3 * p3[0] - 2 * p42[0] - p12[0];
  vx2 *= vx2;
  let vy = 3 * p3[1] - 2 * p42[1] - p12[1];
  vy *= vy;
  if (ux2 < vx2) {
    ux2 = vx2;
  }
  if (uy2 < vy) {
    uy2 = vy;
  }
  return ux2 + uy2;
}
function getPointsOnBezierCurveWithSplitting$2(points, offset2, tolerance, newPoints) {
  const outPoints = newPoints || [];
  if (flatness$2(points, offset2) < tolerance) {
    const p0 = points[offset2 + 0];
    if (outPoints.length) {
      const d3 = distance$2(outPoints[outPoints.length - 1], p0);
      if (d3 > 1) {
        outPoints.push(p0);
      }
    } else {
      outPoints.push(p0);
    }
    outPoints.push(points[offset2 + 3]);
  } else {
    const t3 = 0.5;
    const p12 = points[offset2 + 0];
    const p22 = points[offset2 + 1];
    const p3 = points[offset2 + 2];
    const p42 = points[offset2 + 3];
    const q12 = lerp$2(p12, p22, t3);
    const q22 = lerp$2(p22, p3, t3);
    const q3 = lerp$2(p3, p42, t3);
    const r12 = lerp$2(q12, q22, t3);
    const r22 = lerp$2(q22, q3, t3);
    const red2 = lerp$2(r12, r22, t3);
    getPointsOnBezierCurveWithSplitting$2([p12, q12, r12, red2], 0, tolerance, outPoints);
    getPointsOnBezierCurveWithSplitting$2([red2, r22, q3, p42], 0, tolerance, outPoints);
  }
  return outPoints;
}
function simplifyPoints$2(points, start, end, epsilon, newPoints) {
  const outPoints = newPoints || [];
  const s3 = points[start];
  const e12 = points[end - 1];
  let maxDistSq = 0;
  let maxNdx = 1;
  for (let i3 = start + 1; i3 < end - 1; ++i3) {
    const distSq = distanceToSegmentSq$2(points[i3], s3, e12);
    if (distSq > maxDistSq) {
      maxDistSq = distSq;
      maxNdx = i3;
    }
  }
  if (Math.sqrt(maxDistSq) > epsilon) {
    simplifyPoints$2(points, start, maxNdx + 1, epsilon, outPoints);
    simplifyPoints$2(points, maxNdx, end, epsilon, outPoints);
  } else {
    if (!outPoints.length) {
      outPoints.push(s3);
    }
    outPoints.push(e12);
  }
  return outPoints;
}
function pointsOnBezierCurves$2(points, tolerance = 0.15, distance2) {
  const newPoints = [];
  const numSegments = (points.length - 1) / 3;
  for (let i3 = 0; i3 < numSegments; i3++) {
    const offset2 = i3 * 3;
    getPointsOnBezierCurveWithSplitting$2(points, offset2, tolerance, newPoints);
  }
  if (distance2 && distance2 > 0) {
    return simplifyPoints$2(newPoints, 0, newPoints.length, distance2);
  }
  return newPoints;
}
function distance$1(p12, p22) {
  return Math.sqrt(distanceSq$1(p12, p22));
}
function distanceSq$1(p12, p22) {
  return Math.pow(p12[0] - p22[0], 2) + Math.pow(p12[1] - p22[1], 2);
}
function distanceToSegmentSq$1(p3, v3, w3) {
  const l22 = distanceSq$1(v3, w3);
  if (l22 === 0) {
    return distanceSq$1(p3, v3);
  }
  let t3 = ((p3[0] - v3[0]) * (w3[0] - v3[0]) + (p3[1] - v3[1]) * (w3[1] - v3[1])) / l22;
  t3 = Math.max(0, Math.min(1, t3));
  return distanceSq$1(p3, lerp$1(v3, w3, t3));
}
function lerp$1(a3, b3, t3) {
  return [
    a3[0] + (b3[0] - a3[0]) * t3,
    a3[1] + (b3[1] - a3[1]) * t3
  ];
}
function flatness$1(points, offset2) {
  const p12 = points[offset2 + 0];
  const p22 = points[offset2 + 1];
  const p3 = points[offset2 + 2];
  const p42 = points[offset2 + 3];
  let ux2 = 3 * p22[0] - 2 * p12[0] - p42[0];
  ux2 *= ux2;
  let uy2 = 3 * p22[1] - 2 * p12[1] - p42[1];
  uy2 *= uy2;
  let vx2 = 3 * p3[0] - 2 * p42[0] - p12[0];
  vx2 *= vx2;
  let vy = 3 * p3[1] - 2 * p42[1] - p12[1];
  vy *= vy;
  if (ux2 < vx2) {
    ux2 = vx2;
  }
  if (uy2 < vy) {
    uy2 = vy;
  }
  return ux2 + uy2;
}
function getPointsOnBezierCurveWithSplitting$1(points, offset2, tolerance, newPoints) {
  const outPoints = newPoints || [];
  if (flatness$1(points, offset2) < tolerance) {
    const p0 = points[offset2 + 0];
    if (outPoints.length) {
      const d3 = distance$1(outPoints[outPoints.length - 1], p0);
      if (d3 > 1) {
        outPoints.push(p0);
      }
    } else {
      outPoints.push(p0);
    }
    outPoints.push(points[offset2 + 3]);
  } else {
    const t3 = 0.5;
    const p12 = points[offset2 + 0];
    const p22 = points[offset2 + 1];
    const p3 = points[offset2 + 2];
    const p42 = points[offset2 + 3];
    const q12 = lerp$1(p12, p22, t3);
    const q22 = lerp$1(p22, p3, t3);
    const q3 = lerp$1(p3, p42, t3);
    const r12 = lerp$1(q12, q22, t3);
    const r22 = lerp$1(q22, q3, t3);
    const red2 = lerp$1(r12, r22, t3);
    getPointsOnBezierCurveWithSplitting$1([p12, q12, r12, red2], 0, tolerance, outPoints);
    getPointsOnBezierCurveWithSplitting$1([red2, r22, q3, p42], 0, tolerance, outPoints);
  }
  return outPoints;
}
function simplify$1(points, distance2) {
  return simplifyPoints$1(points, 0, points.length, distance2);
}
function simplifyPoints$1(points, start, end, epsilon, newPoints) {
  const outPoints = newPoints || [];
  const s3 = points[start];
  const e12 = points[end - 1];
  let maxDistSq = 0;
  let maxNdx = 1;
  for (let i3 = start + 1; i3 < end - 1; ++i3) {
    const distSq = distanceToSegmentSq$1(points[i3], s3, e12);
    if (distSq > maxDistSq) {
      maxDistSq = distSq;
      maxNdx = i3;
    }
  }
  if (Math.sqrt(maxDistSq) > epsilon) {
    simplifyPoints$1(points, start, maxNdx + 1, epsilon, outPoints);
    simplifyPoints$1(points, maxNdx, end, epsilon, outPoints);
  } else {
    if (!outPoints.length) {
      outPoints.push(s3);
    }
    outPoints.push(e12);
  }
  return outPoints;
}
function pointsOnBezierCurves$1(points, tolerance = 0.15, distance2) {
  const newPoints = [];
  const numSegments = (points.length - 1) / 3;
  for (let i3 = 0; i3 < numSegments; i3++) {
    const offset2 = i3 * 3;
    getPointsOnBezierCurveWithSplitting$1(points, offset2, tolerance, newPoints);
  }
  return newPoints;
}
function pointsOnPath(path, tolerance, distance2) {
  const segments = parsePath(path);
  const normalized = normalize(absolutize(segments));
  const sets = [];
  let currentPoints = [];
  let start = [0, 0];
  let pendingCurve = [];
  const appendPendingCurve = () => {
    if (pendingCurve.length >= 4) {
      currentPoints.push(...pointsOnBezierCurves$1(pendingCurve, tolerance));
    }
    pendingCurve = [];
  };
  const appendPendingPoints = () => {
    appendPendingCurve();
    if (currentPoints.length) {
      sets.push(currentPoints);
      currentPoints = [];
    }
  };
  for (const { key, data } of normalized) {
    switch (key) {
      case "M":
        appendPendingPoints();
        start = [data[0], data[1]];
        currentPoints.push(start);
        break;
      case "L":
        appendPendingCurve();
        currentPoints.push([data[0], data[1]]);
        break;
      case "C":
        if (!pendingCurve.length) {
          const lastPoint = currentPoints.length ? currentPoints[currentPoints.length - 1] : start;
          pendingCurve.push([lastPoint[0], lastPoint[1]]);
        }
        pendingCurve.push([data[0], data[1]]);
        pendingCurve.push([data[2], data[3]]);
        pendingCurve.push([data[4], data[5]]);
        break;
      case "Z":
        appendPendingCurve();
        currentPoints.push([start[0], start[1]]);
        break;
    }
  }
  appendPendingPoints();
  if (!distance2) {
    return sets;
  }
  const out = [];
  for (const set of sets) {
    const simplifiedSet = simplify$1(set, distance2);
    if (simplifiedSet.length) {
      out.push(simplifiedSet);
    }
  }
  return out;
}
const NOS = "none";
class RoughGenerator {
  constructor(config) {
    this.defaultOptions = {
      maxRandomnessOffset: 2,
      roughness: 1,
      bowing: 1,
      stroke: "#000",
      strokeWidth: 1,
      curveTightness: 0,
      curveFitting: 0.95,
      curveStepCount: 9,
      fillStyle: "hachure",
      fillWeight: -1,
      hachureAngle: -41,
      hachureGap: -1,
      dashOffset: -1,
      dashGap: -1,
      zigzagOffset: -1,
      seed: 0,
      disableMultiStroke: false,
      disableMultiStrokeFill: false,
      preserveVertices: false,
      fillShapeRoughnessGain: 0.8
    };
    this.config = config || {};
    if (this.config.options) {
      this.defaultOptions = this._o(this.config.options);
    }
  }
  static newSeed() {
    return randomSeed();
  }
  _o(options) {
    return options ? Object.assign({}, this.defaultOptions, options) : this.defaultOptions;
  }
  _d(shape, sets, options) {
    return { shape, sets: sets || [], options: options || this.defaultOptions };
  }
  line(x12, y12, x22, y22, options) {
    const o3 = this._o(options);
    return this._d("line", [line(x12, y12, x22, y22, o3)], o3);
  }
  rectangle(x3, y3, width, height, options) {
    const o3 = this._o(options);
    const paths = [];
    const outline = rectangle(x3, y3, width, height, o3);
    if (o3.fill) {
      const points = [[x3, y3], [x3 + width, y3], [x3 + width, y3 + height], [x3, y3 + height]];
      if (o3.fillStyle === "solid") {
        paths.push(solidFillPolygon([points], o3));
      } else {
        paths.push(patternFillPolygons([points], o3));
      }
    }
    if (o3.stroke !== NOS) {
      paths.push(outline);
    }
    return this._d("rectangle", paths, o3);
  }
  ellipse(x3, y3, width, height, options) {
    const o3 = this._o(options);
    const paths = [];
    const ellipseParams = generateEllipseParams(width, height, o3);
    const ellipseResponse = ellipseWithParams(x3, y3, o3, ellipseParams);
    if (o3.fill) {
      if (o3.fillStyle === "solid") {
        const shape = ellipseWithParams(x3, y3, o3, ellipseParams).opset;
        shape.type = "fillPath";
        paths.push(shape);
      } else {
        paths.push(patternFillPolygons([ellipseResponse.estimatedPoints], o3));
      }
    }
    if (o3.stroke !== NOS) {
      paths.push(ellipseResponse.opset);
    }
    return this._d("ellipse", paths, o3);
  }
  circle(x3, y3, diameter, options) {
    const ret = this.ellipse(x3, y3, diameter, diameter, options);
    ret.shape = "circle";
    return ret;
  }
  linearPath(points, options) {
    const o3 = this._o(options);
    return this._d("linearPath", [linearPath(points, false, o3)], o3);
  }
  arc(x3, y3, width, height, start, stop, closed = false, options) {
    const o3 = this._o(options);
    const paths = [];
    const outline = arc(x3, y3, width, height, start, stop, closed, true, o3);
    if (closed && o3.fill) {
      if (o3.fillStyle === "solid") {
        const fillOptions = Object.assign({}, o3);
        fillOptions.disableMultiStroke = true;
        const shape = arc(x3, y3, width, height, start, stop, true, false, fillOptions);
        shape.type = "fillPath";
        paths.push(shape);
      } else {
        paths.push(patternFillArc(x3, y3, width, height, start, stop, o3));
      }
    }
    if (o3.stroke !== NOS) {
      paths.push(outline);
    }
    return this._d("arc", paths, o3);
  }
  curve(points, options) {
    const o3 = this._o(options);
    const paths = [];
    const outline = curve(points, o3);
    if (o3.fill && o3.fill !== NOS && points.length >= 3) {
      if (o3.fillStyle === "solid") {
        const fillShape = curve(points, Object.assign(Object.assign({}, o3), { disableMultiStroke: true, roughness: o3.roughness ? o3.roughness + o3.fillShapeRoughnessGain : 0 }));
        paths.push({
          type: "fillPath",
          ops: this._mergedShape(fillShape.ops)
        });
      } else {
        const bcurve = curveToBezier(points);
        const polyPoints = pointsOnBezierCurves$2(bcurve, 10, (1 + o3.roughness) / 2);
        paths.push(patternFillPolygons([polyPoints], o3));
      }
    }
    if (o3.stroke !== NOS) {
      paths.push(outline);
    }
    return this._d("curve", paths, o3);
  }
  polygon(points, options) {
    const o3 = this._o(options);
    const paths = [];
    const outline = linearPath(points, true, o3);
    if (o3.fill) {
      if (o3.fillStyle === "solid") {
        paths.push(solidFillPolygon([points], o3));
      } else {
        paths.push(patternFillPolygons([points], o3));
      }
    }
    if (o3.stroke !== NOS) {
      paths.push(outline);
    }
    return this._d("polygon", paths, o3);
  }
  path(d3, options) {
    const o3 = this._o(options);
    const paths = [];
    if (!d3) {
      return this._d("path", paths, o3);
    }
    d3 = (d3 || "").replace(/\n/g, " ").replace(/(-\s)/g, "-").replace("/(ss)/g", " ");
    const hasFill = o3.fill && o3.fill !== "transparent" && o3.fill !== NOS;
    const hasStroke = o3.stroke !== NOS;
    const simplified = !!(o3.simplification && o3.simplification < 1);
    const distance2 = simplified ? 4 - 4 * (o3.simplification || 1) : (1 + o3.roughness) / 2;
    const sets = pointsOnPath(d3, 1, distance2);
    const shape = svgPath(d3, o3);
    if (hasFill) {
      if (o3.fillStyle === "solid") {
        if (sets.length === 1) {
          const fillShape = svgPath(d3, Object.assign(Object.assign({}, o3), { disableMultiStroke: true, roughness: o3.roughness ? o3.roughness + o3.fillShapeRoughnessGain : 0 }));
          paths.push({
            type: "fillPath",
            ops: this._mergedShape(fillShape.ops)
          });
        } else {
          paths.push(solidFillPolygon(sets, o3));
        }
      } else {
        paths.push(patternFillPolygons(sets, o3));
      }
    }
    if (hasStroke) {
      if (simplified) {
        sets.forEach((set) => {
          paths.push(linearPath(set, false, o3));
        });
      } else {
        paths.push(shape);
      }
    }
    return this._d("path", paths, o3);
  }
  opsToPath(drawing, fixedDecimals) {
    let path = "";
    for (const item of drawing.ops) {
      const data = typeof fixedDecimals === "number" && fixedDecimals >= 0 ? item.data.map((d3) => +d3.toFixed(fixedDecimals)) : item.data;
      switch (item.op) {
        case "move":
          path += `M${data[0]} ${data[1]} `;
          break;
        case "bcurveTo":
          path += `C${data[0]} ${data[1]}, ${data[2]} ${data[3]}, ${data[4]} ${data[5]} `;
          break;
        case "lineTo":
          path += `L${data[0]} ${data[1]} `;
          break;
      }
    }
    return path.trim();
  }
  toPaths(drawable) {
    const sets = drawable.sets || [];
    const o3 = drawable.options || this.defaultOptions;
    const paths = [];
    for (const drawing of sets) {
      let path = null;
      switch (drawing.type) {
        case "path":
          path = {
            d: this.opsToPath(drawing),
            stroke: o3.stroke,
            strokeWidth: o3.strokeWidth,
            fill: NOS
          };
          break;
        case "fillPath":
          path = {
            d: this.opsToPath(drawing),
            stroke: NOS,
            strokeWidth: 0,
            fill: o3.fill || NOS
          };
          break;
        case "fillSketch":
          path = this.fillSketch(drawing, o3);
          break;
      }
      if (path) {
        paths.push(path);
      }
    }
    return paths;
  }
  fillSketch(drawing, o3) {
    let fweight = o3.fillWeight;
    if (fweight < 0) {
      fweight = o3.strokeWidth / 2;
    }
    return {
      d: this.opsToPath(drawing),
      stroke: o3.fill || NOS,
      strokeWidth: fweight,
      fill: NOS
    };
  }
  _mergedShape(input) {
    return input.filter((d3, i3) => {
      if (i3 === 0) {
        return true;
      }
      if (d3.op === "move") {
        return false;
      }
      return true;
    });
  }
}
class RoughCanvas {
  constructor(canvas, config) {
    this.canvas = canvas;
    this.ctx = this.canvas.getContext("2d");
    this.gen = new RoughGenerator(config);
  }
  draw(drawable) {
    const sets = drawable.sets || [];
    const o3 = drawable.options || this.getDefaultOptions();
    const ctx = this.ctx;
    const precision = drawable.options.fixedDecimalPlaceDigits;
    for (const drawing of sets) {
      switch (drawing.type) {
        case "path":
          ctx.save();
          ctx.strokeStyle = o3.stroke === "none" ? "transparent" : o3.stroke;
          ctx.lineWidth = o3.strokeWidth;
          if (o3.strokeLineDash) {
            ctx.setLineDash(o3.strokeLineDash);
          }
          if (o3.strokeLineDashOffset) {
            ctx.lineDashOffset = o3.strokeLineDashOffset;
          }
          this._drawToContext(ctx, drawing, precision);
          ctx.restore();
          break;
        case "fillPath": {
          ctx.save();
          ctx.fillStyle = o3.fill || "";
          const fillRule = drawable.shape === "curve" || drawable.shape === "polygon" || drawable.shape === "path" ? "evenodd" : "nonzero";
          this._drawToContext(ctx, drawing, precision, fillRule);
          ctx.restore();
          break;
        }
        case "fillSketch":
          this.fillSketch(ctx, drawing, o3);
          break;
      }
    }
  }
  fillSketch(ctx, drawing, o3) {
    let fweight = o3.fillWeight;
    if (fweight < 0) {
      fweight = o3.strokeWidth / 2;
    }
    ctx.save();
    if (o3.fillLineDash) {
      ctx.setLineDash(o3.fillLineDash);
    }
    if (o3.fillLineDashOffset) {
      ctx.lineDashOffset = o3.fillLineDashOffset;
    }
    ctx.strokeStyle = o3.fill || "";
    ctx.lineWidth = fweight;
    this._drawToContext(ctx, drawing, o3.fixedDecimalPlaceDigits);
    ctx.restore();
  }
  _drawToContext(ctx, drawing, fixedDecimals, rule = "nonzero") {
    ctx.beginPath();
    for (const item of drawing.ops) {
      const data = typeof fixedDecimals === "number" && fixedDecimals >= 0 ? item.data.map((d3) => +d3.toFixed(fixedDecimals)) : item.data;
      switch (item.op) {
        case "move":
          ctx.moveTo(data[0], data[1]);
          break;
        case "bcurveTo":
          ctx.bezierCurveTo(data[0], data[1], data[2], data[3], data[4], data[5]);
          break;
        case "lineTo":
          ctx.lineTo(data[0], data[1]);
          break;
      }
    }
    if (drawing.type === "fillPath") {
      ctx.fill(rule);
    } else {
      ctx.stroke();
    }
  }
  get generator() {
    return this.gen;
  }
  getDefaultOptions() {
    return this.gen.defaultOptions;
  }
  line(x12, y12, x22, y22, options) {
    const d3 = this.gen.line(x12, y12, x22, y22, options);
    this.draw(d3);
    return d3;
  }
  rectangle(x3, y3, width, height, options) {
    const d3 = this.gen.rectangle(x3, y3, width, height, options);
    this.draw(d3);
    return d3;
  }
  ellipse(x3, y3, width, height, options) {
    const d3 = this.gen.ellipse(x3, y3, width, height, options);
    this.draw(d3);
    return d3;
  }
  circle(x3, y3, diameter, options) {
    const d3 = this.gen.circle(x3, y3, diameter, options);
    this.draw(d3);
    return d3;
  }
  linearPath(points, options) {
    const d3 = this.gen.linearPath(points, options);
    this.draw(d3);
    return d3;
  }
  polygon(points, options) {
    const d3 = this.gen.polygon(points, options);
    this.draw(d3);
    return d3;
  }
  arc(x3, y3, width, height, start, stop, closed = false, options) {
    const d3 = this.gen.arc(x3, y3, width, height, start, stop, closed, options);
    this.draw(d3);
    return d3;
  }
  curve(points, options) {
    const d3 = this.gen.curve(points, options);
    this.draw(d3);
    return d3;
  }
  path(d3, options) {
    const drawing = this.gen.path(d3, options);
    this.draw(drawing);
    return drawing;
  }
}
const SVGNS = "http://www.w3.org/2000/svg";
class RoughSVG {
  constructor(svg, config) {
    this.svg = svg;
    this.gen = new RoughGenerator(config);
  }
  draw(drawable) {
    const sets = drawable.sets || [];
    const o3 = drawable.options || this.getDefaultOptions();
    const doc = this.svg.ownerDocument || window.document;
    const g3 = doc.createElementNS(SVGNS, "g");
    const precision = drawable.options.fixedDecimalPlaceDigits;
    for (const drawing of sets) {
      let path = null;
      switch (drawing.type) {
        case "path": {
          path = doc.createElementNS(SVGNS, "path");
          path.setAttribute("d", this.opsToPath(drawing, precision));
          path.setAttribute("stroke", o3.stroke);
          path.setAttribute("stroke-width", o3.strokeWidth + "");
          path.setAttribute("fill", "none");
          if (o3.strokeLineDash) {
            path.setAttribute("stroke-dasharray", o3.strokeLineDash.join(" ").trim());
          }
          if (o3.strokeLineDashOffset) {
            path.setAttribute("stroke-dashoffset", `${o3.strokeLineDashOffset}`);
          }
          break;
        }
        case "fillPath": {
          path = doc.createElementNS(SVGNS, "path");
          path.setAttribute("d", this.opsToPath(drawing, precision));
          path.setAttribute("stroke", "none");
          path.setAttribute("stroke-width", "0");
          path.setAttribute("fill", o3.fill || "");
          if (drawable.shape === "curve" || drawable.shape === "polygon") {
            path.setAttribute("fill-rule", "evenodd");
          }
          break;
        }
        case "fillSketch": {
          path = this.fillSketch(doc, drawing, o3);
          break;
        }
      }
      if (path) {
        g3.appendChild(path);
      }
    }
    return g3;
  }
  fillSketch(doc, drawing, o3) {
    let fweight = o3.fillWeight;
    if (fweight < 0) {
      fweight = o3.strokeWidth / 2;
    }
    const path = doc.createElementNS(SVGNS, "path");
    path.setAttribute("d", this.opsToPath(drawing, o3.fixedDecimalPlaceDigits));
    path.setAttribute("stroke", o3.fill || "");
    path.setAttribute("stroke-width", fweight + "");
    path.setAttribute("fill", "none");
    if (o3.fillLineDash) {
      path.setAttribute("stroke-dasharray", o3.fillLineDash.join(" ").trim());
    }
    if (o3.fillLineDashOffset) {
      path.setAttribute("stroke-dashoffset", `${o3.fillLineDashOffset}`);
    }
    return path;
  }
  get generator() {
    return this.gen;
  }
  getDefaultOptions() {
    return this.gen.defaultOptions;
  }
  opsToPath(drawing, fixedDecimalPlaceDigits) {
    return this.gen.opsToPath(drawing, fixedDecimalPlaceDigits);
  }
  line(x12, y12, x22, y22, options) {
    const d3 = this.gen.line(x12, y12, x22, y22, options);
    return this.draw(d3);
  }
  rectangle(x3, y3, width, height, options) {
    const d3 = this.gen.rectangle(x3, y3, width, height, options);
    return this.draw(d3);
  }
  ellipse(x3, y3, width, height, options) {
    const d3 = this.gen.ellipse(x3, y3, width, height, options);
    return this.draw(d3);
  }
  circle(x3, y3, diameter, options) {
    const d3 = this.gen.circle(x3, y3, diameter, options);
    return this.draw(d3);
  }
  linearPath(points, options) {
    const d3 = this.gen.linearPath(points, options);
    return this.draw(d3);
  }
  polygon(points, options) {
    const d3 = this.gen.polygon(points, options);
    return this.draw(d3);
  }
  arc(x3, y3, width, height, start, stop, closed = false, options) {
    const d3 = this.gen.arc(x3, y3, width, height, start, stop, closed, options);
    return this.draw(d3);
  }
  curve(points, options) {
    const d3 = this.gen.curve(points, options);
    return this.draw(d3);
  }
  path(d3, options) {
    const drawing = this.gen.path(d3, options);
    return this.draw(drawing);
  }
}
const q5 = {
  canvas(canvas, config) {
    return new RoughCanvas(canvas, config);
  },
  svg(svg, config) {
    return new RoughSVG(svg, config);
  },
  generator(config) {
    return new RoughGenerator(config);
  },
  newSeed() {
    return RoughGenerator.newSeed();
  }
};
function $(e12, t3, u3, x3 = (h3) => h3) {
  return e12 * x3(0.5 - t3 * (0.5 - u3));
}
function se$1(e12) {
  return [-e12[0], -e12[1]];
}
function l$1(e12, t3) {
  return [e12[0] + t3[0], e12[1] + t3[1]];
}
function a$1(e12, t3) {
  return [e12[0] - t3[0], e12[1] - t3[1]];
}
function b$1(e12, t3) {
  return [e12[0] * t3, e12[1] * t3];
}
function he$1(e12, t3) {
  return [e12[0] / t3, e12[1] / t3];
}
function R$3(e12) {
  return [e12[1], -e12[0]];
}
function B$1(e12, t3) {
  return e12[0] * t3[0] + e12[1] * t3[1];
}
function ue$1(e12, t3) {
  return e12[0] === t3[0] && e12[1] === t3[1];
}
function ge$1(e12) {
  return Math.hypot(e12[0], e12[1]);
}
function de$1(e12) {
  return e12[0] * e12[0] + e12[1] * e12[1];
}
function A$2(e12, t3) {
  return de$1(a$1(e12, t3));
}
function G$1(e12) {
  return he$1(e12, ge$1(e12));
}
function ie$1(e12, t3) {
  return Math.hypot(e12[1] - t3[1], e12[0] - t3[0]);
}
function L$1(e12, t3, u3) {
  let x3 = Math.sin(u3), h3 = Math.cos(u3), y3 = e12[0] - t3[0], n3 = e12[1] - t3[1], f3 = y3 * h3 - n3 * x3, d3 = y3 * x3 + n3 * h3;
  return [f3 + t3[0], d3 + t3[1]];
}
function K$1(e12, t3, u3) {
  return l$1(e12, b$1(a$1(t3, e12), u3));
}
function ee$1(e12, t3, u3) {
  return l$1(e12, b$1(t3, u3));
}
var { min: C$2, PI: xe$1 } = Math, pe$2 = 0.275, V = xe$1 + 1e-4;
function ce$1(e12, t3 = {}) {
  let { size: u3 = 16, smoothing: x3 = 0.5, thinning: h3 = 0.5, simulatePressure: y3 = true, easing: n3 = (r3) => r3, start: f3 = {}, end: d3 = {}, last: D3 = false } = t3, { cap: S3 = true, easing: j = (r3) => r3 * (2 - r3) } = f3, { cap: q3 = true, easing: c3 = (r3) => --r3 * r3 * r3 + 1 } = d3;
  if (e12.length === 0 || u3 <= 0) return [];
  let p3 = e12[e12.length - 1].runningLength, g3 = f3.taper === false ? 0 : f3.taper === true ? Math.max(u3, p3) : f3.taper, T3 = d3.taper === false ? 0 : d3.taper === true ? Math.max(u3, p3) : d3.taper, te2 = Math.pow(u3 * x3, 2), _3 = [], M = [], H3 = e12.slice(0, 10).reduce((r3, i3) => {
    let o3 = i3.pressure;
    if (y3) {
      let s3 = C$2(1, i3.distance / u3), W = C$2(1, 1 - s3);
      o3 = C$2(1, r3 + (W - r3) * (s3 * pe$2));
    }
    return (r3 + o3) / 2;
  }, e12[0].pressure), m3 = $(u3, h3, e12[e12.length - 1].pressure, n3), U3, X3 = e12[0].vector, z3 = e12[0].point, F3 = z3, O3 = z3, E3 = F3, J = false;
  for (let r3 = 0; r3 < e12.length; r3++) {
    let { pressure: i3 } = e12[r3], { point: o3, vector: s3, distance: W, runningLength: I3 } = e12[r3];
    if (r3 < e12.length - 1 && p3 - I3 < 3) continue;
    if (h3) {
      if (y3) {
        let v3 = C$2(1, W / u3), Z3 = C$2(1, 1 - v3);
        i3 = C$2(1, H3 + (Z3 - H3) * (v3 * pe$2));
      }
      m3 = $(u3, h3, i3, n3);
    } else m3 = u3 / 2;
    U3 === void 0 && (U3 = m3);
    let le2 = I3 < g3 ? j(I3 / g3) : 1, fe2 = p3 - I3 < T3 ? c3((p3 - I3) / T3) : 1;
    m3 = Math.max(0.01, m3 * Math.min(le2, fe2));
    let re2 = (r3 < e12.length - 1 ? e12[r3 + 1] : e12[r3]).vector, Y3 = r3 < e12.length - 1 ? B$1(s3, re2) : 1, be = B$1(s3, X3) < 0 && !J, ne3 = Y3 !== null && Y3 < 0;
    if (be || ne3) {
      let v3 = b$1(R$3(X3), m3);
      for (let Z3 = 1 / 13, w3 = 0; w3 <= 1; w3 += Z3) O3 = L$1(a$1(o3, v3), o3, V * w3), _3.push(O3), E3 = L$1(l$1(o3, v3), o3, V * -w3), M.push(E3);
      z3 = O3, F3 = E3, ne3 && (J = true);
      continue;
    }
    if (J = false, r3 === e12.length - 1) {
      let v3 = b$1(R$3(s3), m3);
      _3.push(a$1(o3, v3)), M.push(l$1(o3, v3));
      continue;
    }
    let oe2 = b$1(R$3(K$1(re2, s3, Y3)), m3);
    O3 = a$1(o3, oe2), (r3 <= 1 || A$2(z3, O3) > te2) && (_3.push(O3), z3 = O3), E3 = l$1(o3, oe2), (r3 <= 1 || A$2(F3, E3) > te2) && (M.push(E3), F3 = E3), H3 = i3, X3 = s3;
  }
  let P3 = e12[0].point.slice(0, 2), k2 = e12.length > 1 ? e12[e12.length - 1].point.slice(0, 2) : l$1(e12[0].point, [1, 1]), Q3 = [], N3 = [];
  if (e12.length === 1) {
    if (!(g3 || T3) || D3) {
      let r3 = ee$1(P3, G$1(R$3(a$1(P3, k2))), -(U3 || m3)), i3 = [];
      for (let o3 = 1 / 13, s3 = o3; s3 <= 1; s3 += o3) i3.push(L$1(r3, P3, V * 2 * s3));
      return i3;
    }
  } else {
    if (!(g3 || T3 && e12.length === 1)) if (S3) for (let i3 = 1 / 13, o3 = i3; o3 <= 1; o3 += i3) {
      let s3 = L$1(M[0], P3, V * o3);
      Q3.push(s3);
    }
    else {
      let i3 = a$1(_3[0], M[0]), o3 = b$1(i3, 0.5), s3 = b$1(i3, 0.51);
      Q3.push(a$1(P3, o3), a$1(P3, s3), l$1(P3, s3), l$1(P3, o3));
    }
    let r3 = R$3(se$1(e12[e12.length - 1].vector));
    if (T3 || g3 && e12.length === 1) N3.push(k2);
    else if (q3) {
      let i3 = ee$1(k2, r3, m3);
      for (let o3 = 1 / 29, s3 = o3; s3 < 1; s3 += o3) N3.push(L$1(i3, k2, V * 3 * s3));
    } else N3.push(l$1(k2, b$1(r3, m3)), l$1(k2, b$1(r3, m3 * 0.99)), a$1(k2, b$1(r3, m3 * 0.99)), a$1(k2, b$1(r3, m3)));
  }
  return _3.concat(N3, M.reverse(), Q3);
}
function me$2(e12, t3 = {}) {
  var q3;
  let { streamline: u3 = 0.5, size: x3 = 16, last: h3 = false } = t3;
  if (e12.length === 0) return [];
  let y3 = 0.15 + (1 - u3) * 0.85, n3 = Array.isArray(e12[0]) ? e12 : e12.map(({ x: c3, y: p3, pressure: g3 = 0.5 }) => [c3, p3, g3]);
  if (n3.length === 2) {
    let c3 = n3[1];
    n3 = n3.slice(0, -1);
    for (let p3 = 1; p3 < 5; p3++) n3.push(K$1(n3[0], c3, p3 / 4));
  }
  n3.length === 1 && (n3 = [...n3, [...l$1(n3[0], [1, 1]), ...n3[0].slice(2)]]);
  let f3 = [{ point: [n3[0][0], n3[0][1]], pressure: n3[0][2] >= 0 ? n3[0][2] : 0.25, vector: [1, 1], distance: 0, runningLength: 0 }], d3 = false, D3 = 0, S3 = f3[0], j = n3.length - 1;
  for (let c3 = 1; c3 < n3.length; c3++) {
    let p3 = h3 && c3 === j ? n3[c3].slice(0, 2) : K$1(S3.point, n3[c3], y3);
    if (ue$1(S3.point, p3)) continue;
    let g3 = ie$1(p3, S3.point);
    if (D3 += g3, c3 < j && !d3) {
      if (D3 < x3) continue;
      d3 = true;
    }
    S3 = { point: p3, pressure: n3[c3][2] >= 0 ? n3[c3][2] : 0.5, vector: G$1(a$1(S3.point, p3)), distance: g3, runningLength: D3 }, f3.push(S3);
  }
  return f3[0].vector = ((q3 = f3[1]) == null ? void 0 : q3.vector) || [0, 0], f3;
}
function ae$1(e12, t3 = {}) {
  return ce$1(me$2(e12, t3), t3);
}
function toVal(mix) {
  var k2, y3, str = "";
  if (typeof mix === "string" || typeof mix === "number") {
    str += mix;
  } else if (typeof mix === "object") {
    if (Array.isArray(mix)) {
      for (k2 = 0; k2 < mix.length; k2++) {
        if (mix[k2]) {
          if (y3 = toVal(mix[k2])) {
            str && (str += " ");
            str += y3;
          }
        }
      }
    } else {
      for (k2 in mix) {
        if (mix[k2]) {
          str && (str += " ");
          str += k2;
        }
      }
    }
  }
  return str;
}
function dM() {
  var i3 = 0, tmp, x3, str = "";
  while (i3 < arguments.length) {
    if (tmp = arguments[i3++]) {
      if (x3 = toVal(tmp)) {
        str && (str += " ");
        str += x3;
      }
    }
  }
  return str;
}
function distance(p12, p22) {
  return Math.sqrt(distanceSq(p12, p22));
}
function distanceSq(p12, p22) {
  return Math.pow(p12[0] - p22[0], 2) + Math.pow(p12[1] - p22[1], 2);
}
function distanceToSegmentSq(p3, v3, w3) {
  const l22 = distanceSq(v3, w3);
  if (l22 === 0) {
    return distanceSq(p3, v3);
  }
  let t3 = ((p3[0] - v3[0]) * (w3[0] - v3[0]) + (p3[1] - v3[1]) * (w3[1] - v3[1])) / l22;
  t3 = Math.max(0, Math.min(1, t3));
  return distanceSq(p3, lerp(v3, w3, t3));
}
function lerp(a3, b3, t3) {
  return [
    a3[0] + (b3[0] - a3[0]) * t3,
    a3[1] + (b3[1] - a3[1]) * t3
  ];
}
function flatness(points, offset2) {
  const p12 = points[offset2 + 0];
  const p22 = points[offset2 + 1];
  const p3 = points[offset2 + 2];
  const p42 = points[offset2 + 3];
  let ux2 = 3 * p22[0] - 2 * p12[0] - p42[0];
  ux2 *= ux2;
  let uy2 = 3 * p22[1] - 2 * p12[1] - p42[1];
  uy2 *= uy2;
  let vx2 = 3 * p3[0] - 2 * p42[0] - p12[0];
  vx2 *= vx2;
  let vy = 3 * p3[1] - 2 * p42[1] - p12[1];
  vy *= vy;
  if (ux2 < vx2) {
    ux2 = vx2;
  }
  if (uy2 < vy) {
    uy2 = vy;
  }
  return ux2 + uy2;
}
function getPointsOnBezierCurveWithSplitting(points, offset2, tolerance, newPoints) {
  const outPoints = newPoints || [];
  if (flatness(points, offset2) < tolerance) {
    const p0 = points[offset2 + 0];
    if (outPoints.length) {
      const d3 = distance(outPoints[outPoints.length - 1], p0);
      if (d3 > 1) {
        outPoints.push(p0);
      }
    } else {
      outPoints.push(p0);
    }
    outPoints.push(points[offset2 + 3]);
  } else {
    const t3 = 0.5;
    const p12 = points[offset2 + 0];
    const p22 = points[offset2 + 1];
    const p3 = points[offset2 + 2];
    const p42 = points[offset2 + 3];
    const q12 = lerp(p12, p22, t3);
    const q22 = lerp(p22, p3, t3);
    const q3 = lerp(p3, p42, t3);
    const r12 = lerp(q12, q22, t3);
    const r22 = lerp(q22, q3, t3);
    const red2 = lerp(r12, r22, t3);
    getPointsOnBezierCurveWithSplitting([p12, q12, r12, red2], 0, tolerance, outPoints);
    getPointsOnBezierCurveWithSplitting([red2, r22, q3, p42], 0, tolerance, outPoints);
  }
  return outPoints;
}
function simplify(points, distance2) {
  return simplifyPoints(points, 0, points.length, distance2);
}
function simplifyPoints(points, start, end, epsilon, newPoints) {
  const outPoints = newPoints || [];
  const s3 = points[start];
  const e12 = points[end - 1];
  let maxDistSq = 0;
  let maxNdx = 1;
  for (let i3 = start + 1; i3 < end - 1; ++i3) {
    const distSq = distanceToSegmentSq(points[i3], s3, e12);
    if (distSq > maxDistSq) {
      maxDistSq = distSq;
      maxNdx = i3;
    }
  }
  if (Math.sqrt(maxDistSq) > epsilon) {
    simplifyPoints(points, start, maxNdx + 1, epsilon, outPoints);
    simplifyPoints(points, maxNdx, end, epsilon, outPoints);
  } else {
    if (!outPoints.length) {
      outPoints.push(s3);
    }
    outPoints.push(e12);
  }
  return outPoints;
}
function pointsOnBezierCurves(points, tolerance = 0.15, distance2) {
  const newPoints = [];
  const numSegments = (points.length - 1) / 3;
  for (let i3 = 0; i3 < numSegments; i3++) {
    const offset2 = i3 * 3;
    getPointsOnBezierCurveWithSplitting(points, offset2, tolerance, newPoints);
  }
  {
    return simplifyPoints(newPoints, 0, newPoints.length, distance2);
  }
}
var dist = {};
var hasRequiredDist;
function requireDist() {
  if (hasRequiredDist) return dist;
  hasRequiredDist = 1;
  Object.defineProperty(dist, "__esModule", { value: true });
  dist.sanitizeUrl = void 0;
  var invalidProtocolRegex = /^([^\w]*)(javascript|data|vbscript)/im;
  var htmlEntitiesRegex = /&#(\w+)(^\w|;)?/g;
  var htmlCtrlEntityRegex = /&(newline|tab);/gi;
  var ctrlCharactersRegex = /[\u0000-\u001F\u007F-\u009F\u2000-\u200D\uFEFF]/gim;
  var urlSchemeRegex = /^.+(:|&colon;)/gim;
  var relativeFirstCharacters = [".", "/"];
  function isRelativeUrlWithoutProtocol(url) {
    return relativeFirstCharacters.indexOf(url[0]) > -1;
  }
  function decodeHtmlCharacters(str) {
    return str.replace(htmlEntitiesRegex, function(match, dec) {
      return String.fromCharCode(dec);
    });
  }
  function sanitizeUrl(url) {
    var sanitizedUrl = decodeHtmlCharacters(url || "").replace(htmlCtrlEntityRegex, "").replace(ctrlCharactersRegex, "").trim();
    if (!sanitizedUrl) {
      return "about:blank";
    }
    if (isRelativeUrlWithoutProtocol(sanitizedUrl)) {
      return sanitizedUrl;
    }
    var urlSchemeParseResults = sanitizedUrl.match(urlSchemeRegex);
    if (!urlSchemeParseResults) {
      return sanitizedUrl;
    }
    var urlScheme = urlSchemeParseResults[0];
    if (invalidProtocolRegex.test(urlScheme)) {
      return "about:blank";
    }
    return sanitizedUrl;
  }
  dist.sanitizeUrl = sanitizeUrl;
  return dist;
}
var distExports = requireDist();
const BASE_62_DIGITS = "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz";
function midpoint(a3, b3, digits) {
  const zero2 = digits[0];
  if (b3 != null && a3 >= b3) {
    throw new Error(a3 + " >= " + b3);
  }
  if (a3.slice(-1) === zero2 || b3 && b3.slice(-1) === zero2) {
    throw new Error("trailing zero");
  }
  if (b3) {
    let n3 = 0;
    while ((a3[n3] || zero2) === b3[n3]) {
      n3++;
    }
    if (n3 > 0) {
      return b3.slice(0, n3) + midpoint(a3.slice(n3), b3.slice(n3), digits);
    }
  }
  const digitA = a3 ? digits.indexOf(a3[0]) : 0;
  const digitB = b3 != null ? digits.indexOf(b3[0]) : digits.length;
  if (digitB - digitA > 1) {
    const midDigit = Math.round(0.5 * (digitA + digitB));
    return digits[midDigit];
  } else {
    if (b3 && b3.length > 1) {
      return b3.slice(0, 1);
    } else {
      return digits[digitA] + midpoint(a3.slice(1), null, digits);
    }
  }
}
function validateInteger(int) {
  if (int.length !== getIntegerLength(int[0])) {
    throw new Error("invalid integer part of order key: " + int);
  }
}
function getIntegerLength(head) {
  if (head >= "a" && head <= "z") {
    return head.charCodeAt(0) - "a".charCodeAt(0) + 2;
  } else if (head >= "A" && head <= "Z") {
    return "Z".charCodeAt(0) - head.charCodeAt(0) + 2;
  } else {
    throw new Error("invalid order key head: " + head);
  }
}
function getIntegerPart(key) {
  const integerPartLength = getIntegerLength(key[0]);
  if (integerPartLength > key.length) {
    throw new Error("invalid order key: " + key);
  }
  return key.slice(0, integerPartLength);
}
function validateOrderKey(key, digits) {
  if (key === "A" + digits[0].repeat(26)) {
    throw new Error("invalid order key: " + key);
  }
  const i3 = getIntegerPart(key);
  const f3 = key.slice(i3.length);
  if (f3.slice(-1) === digits[0]) {
    throw new Error("invalid order key: " + key);
  }
}
function incrementInteger(x3, digits) {
  validateInteger(x3);
  const [head, ...digs] = x3.split("");
  let carry = true;
  for (let i3 = digs.length - 1; carry && i3 >= 0; i3--) {
    const d3 = digits.indexOf(digs[i3]) + 1;
    if (d3 === digits.length) {
      digs[i3] = digits[0];
    } else {
      digs[i3] = digits[d3];
      carry = false;
    }
  }
  if (carry) {
    if (head === "Z") {
      return "a" + digits[0];
    }
    if (head === "z") {
      return null;
    }
    const h3 = String.fromCharCode(head.charCodeAt(0) + 1);
    if (h3 > "a") {
      digs.push(digits[0]);
    } else {
      digs.pop();
    }
    return h3 + digs.join("");
  } else {
    return head + digs.join("");
  }
}
function decrementInteger(x3, digits) {
  validateInteger(x3);
  const [head, ...digs] = x3.split("");
  let borrow = true;
  for (let i3 = digs.length - 1; borrow && i3 >= 0; i3--) {
    const d3 = digits.indexOf(digs[i3]) - 1;
    if (d3 === -1) {
      digs[i3] = digits.slice(-1);
    } else {
      digs[i3] = digits[d3];
      borrow = false;
    }
  }
  if (borrow) {
    if (head === "a") {
      return "Z" + digits.slice(-1);
    }
    if (head === "A") {
      return null;
    }
    const h3 = String.fromCharCode(head.charCodeAt(0) - 1);
    if (h3 < "Z") {
      digs.push(digits.slice(-1));
    } else {
      digs.pop();
    }
    return h3 + digs.join("");
  } else {
    return head + digs.join("");
  }
}
function generateKeyBetween(a3, b3, digits = BASE_62_DIGITS) {
  if (a3 != null) {
    validateOrderKey(a3, digits);
  }
  if (b3 != null) {
    validateOrderKey(b3, digits);
  }
  if (a3 != null && b3 != null && a3 >= b3) {
    throw new Error(a3 + " >= " + b3);
  }
  if (a3 == null) {
    if (b3 == null) {
      return "a" + digits[0];
    }
    const ib3 = getIntegerPart(b3);
    const fb3 = b3.slice(ib3.length);
    if (ib3 === "A" + digits[0].repeat(26)) {
      return ib3 + midpoint("", fb3, digits);
    }
    if (ib3 < b3) {
      return ib3;
    }
    const res = decrementInteger(ib3, digits);
    if (res == null) {
      throw new Error("cannot decrement any more");
    }
    return res;
  }
  if (b3 == null) {
    const ia3 = getIntegerPart(a3);
    const fa3 = a3.slice(ia3.length);
    const i5 = incrementInteger(ia3, digits);
    return i5 == null ? ia3 + midpoint(fa3, null, digits) : i5;
  }
  const ia2 = getIntegerPart(a3);
  const fa2 = a3.slice(ia2.length);
  const ib2 = getIntegerPart(b3);
  const fb2 = b3.slice(ib2.length);
  if (ia2 === ib2) {
    return ia2 + midpoint(fa2, fb2, digits);
  }
  const i3 = incrementInteger(ia2, digits);
  if (i3 == null) {
    throw new Error("cannot increment any more");
  }
  if (i3 < b3) {
    return i3;
  }
  return ia2 + midpoint(fa2, null, digits);
}
function generateNKeysBetween(a3, b3, n3, digits = BASE_62_DIGITS) {
  if (n3 === 0) {
    return [];
  }
  if (n3 === 1) {
    return [generateKeyBetween(a3, b3, digits)];
  }
  if (b3 == null) {
    let c8 = generateKeyBetween(a3, b3, digits);
    const result = [c8];
    for (let i3 = 0; i3 < n3 - 1; i3++) {
      c8 = generateKeyBetween(c8, b3, digits);
      result.push(c8);
    }
    return result;
  }
  if (a3 == null) {
    let c8 = generateKeyBetween(a3, b3, digits);
    const result = [c8];
    for (let i3 = 0; i3 < n3 - 1; i3++) {
      c8 = generateKeyBetween(a3, c8, digits);
      result.push(c8);
    }
    result.reverse();
    return result;
  }
  const mid = Math.floor(n3 / 2);
  const c3 = generateKeyBetween(a3, b3, digits);
  return [
    ...generateNKeysBetween(a3, c3, mid, digits),
    c3,
    ...generateNKeysBetween(c3, b3, n3 - mid - 1, digits)
  ];
}
const e = (() => {
  if ("undefined" == typeof self) return false;
  if ("top" in self && self !== top) try {
    top;
  } catch (e12) {
    return false;
  }
  else if ("showOpenFilePicker" in self) return "showOpenFilePicker";
  return false;
})(), t$1 = e ? __vitePreload(() => import("./file-open-002ab408-BNIYSKAV.js"), true ? [] : void 0, import.meta.url) : __vitePreload(() => import("./file-open-7c801643-B_l1UXdI.js"), true ? [] : void 0, import.meta.url);
async function n$1(...e12) {
  return (await t$1).default(...e12);
}
e ? __vitePreload(() => import("./directory-open-4ed118d0-BwYbu9dw.js"), true ? [] : void 0, import.meta.url) : __vitePreload(() => import("./directory-open-01563666-XowynPwH.js"), true ? [] : void 0, import.meta.url);
const o = e ? __vitePreload(() => import("./file-save-745eba88-B5-wM56X.js"), true ? [] : void 0, import.meta.url) : __vitePreload(() => import("./file-save-3189631c-vzijizFw.js"), true ? [] : void 0, import.meta.url);
async function s$1(...e12) {
  return (await o).default(...e12);
}
var p6 = (e12, t3) => t3.reduce((n3, r3) => (r3 in e12 && (n3[r3] = e12[r3]), n3), {}), k9 = 5, Z9 = 5, Ps = 4, fo = 4, po = 1, ft$1 = [0, 2, 4, 6, 8];
var pt = (e12, t3) => t3.map((n3) => _d$1[e12][n3]), Z = { transparent: "transparent", black: "#1e1e1e", white: "#ffffff", gray: pt("gray", ft$1), red: pt("red", ft$1), pink: pt("pink", ft$1), grape: pt("grape", ft$1), violet: pt("violet", ft$1), blue: pt("blue", ft$1), cyan: pt("cyan", ft$1), teal: pt("teal", ft$1), green: pt("green", ft$1), yellow: pt("yellow", ft$1), orange: pt("orange", ft$1), bronze: ["#f8f1ee", "#eaddd7", "#d2bab0", "#a18072", "#846358"] }, Ns = p6(Z, ["cyan", "blue", "violet", "grape", "pink", "green", "teal", "yellow", "orange", "red"]), W9 = [Z.black, Z.red[fo], Z.green[fo], Z.blue[fo], Z.yellow[fo]], z9 = [Z.transparent, Z.red[po], Z.green[po], Z.blue[po], Z.yellow[po]], Q9 = [Z.white, "#f8f9fa", "#f5faff", "#fffce8", "#fdf8f6"], j9 = { transparent: Z.transparent, white: Z.white, gray: Z.gray, black: Z.black, bronze: Z.bronze, ...Ns }, eE = { transparent: Z.transparent, white: Z.white, gray: Z.gray, black: Z.black, bronze: Z.bronze, ...Ns }, Fs = (e12) => [Z.cyan[e12], Z.blue[e12], Z.violet[e12], Z.grape[e12], Z.pink[e12], Z.green[e12], Z.teal[e12], Z.yellow[e12], Z.orange[e12], Z.red[e12]], tE = (e12, t3, n3) => `#${((1 << 24) + (e12 << 16) + (t3 << 8) + n3).toString(16).slice(1)}`;
var uo = /Mac|iPod|iPhone|iPad/.test(navigator.platform), iE = /^Win/.test(navigator.platform), Bs = /\b(android)\b/i.test(navigator.userAgent), aE = "netscape" in window && navigator.userAgent.indexOf("rv:") > 1 && navigator.userAgent.indexOf("Gecko") > 1, u6 = navigator.userAgent.indexOf("Chrome") !== -1, sE = !u6 && navigator.userAgent.indexOf("Safari") !== -1, _s = /iPad|iPhone/.test(navigator.platform) || navigator.userAgent.includes("Mac") && "ontouchend" in document, dE = () => navigator.brave?.isBrave?.name === "isBrave", cE = typeof window < "u" && "ResizeObserver" in window, lE = "Excalidraw", Os = 36, As = 10, Ks$1 = 8, UE = 5, fE = 1, pE = 30, Nt = Math.PI / 12, uE = "red", mo = { TEXT: "text", CROSSHAIR: "crosshair", GRABBING: "grabbing", GRAB: "grab", POINTER: "pointer", MOVE: "move", AUTO: "" }, mE = { MAIN: 0, WHEEL: 1, SECONDARY: 2, TOUCH: -1, ERASER: 5 }, bE = { enabled: "all", disabled: "none" };
var EE = { UNSTARTED: -1, ENDED: 0, PLAYING: 1, PAUSED: 2, BUFFERING: 3, CUED: 5 }, je = { TEST: "test" }, gE = { SHAPE_ACTIONS_MENU: "App-menu__left", ZOOM_ACTIONS: "zoom-actions", SEARCH_MENU_INPUT_WRAPPER: "layer-ui__search-inputWrapper" }, Mn$1 = "Xiaolai", Tn$1 = "Segoe UI Emoji", Ie = { Virgil: 1, Helvetica: 2, Cascadia: 3, Excalifont: 5, Nunito: 6, "Lilita One": 7, "Comic Shanns": 8, "Liberation Sans": 9 }, Un = { [Mn$1]: 100, [Tn$1]: 1e3 }, bo = (e12) => {
  switch (e12) {
    case Ie.Excalifont:
      return [Mn$1, Tn$1];
    default:
      return [Tn$1];
  }
}, ke = { LIGHT: "light", DARK: "dark" }, Pe$1 = { strokeColor: "#bbb", strokeWidth: 2, strokeStyle: "solid", fillStyle: "solid", roughness: 0, roundness: null, backgroundColor: "transparent", radius: 8, nameOffsetY: 3, nameColorLightTheme: "#999999", nameColorDarkTheme: "#7a7a7a", nameFontSize: 14, nameLineHeight: 1.25 }, Eo$1 = 1, ut = 20, Ft = Ie.Excalifont, Vn = "left", go = "top";
var br = 2, Er = 2 * br, m6 = 1e-5, xE = 2 * Er - m6, hE = "#ffffff", yE = "#1e1e1e", IE = "#a2f1a6";
var xo = 20, ho = 5, yo = { svg: "image/svg+xml", png: "image/png", jpg: "image/jpeg", gif: "image/gif", webp: "image/webp", bmp: "image/bmp", ico: "image/x-icon", avif: "image/avif", jfif: "image/jfif" }, H = { text: "text/plain", html: "text/html", json: "application/json", excalidraw: "application/vnd.excalidraw+json", excalidrawlib: "application/vnd.excalidrawlib+json", "excalidraw.svg": "image/svg+xml", "excalidraw.png": "image/png", binary: "application/octet-stream", ...yo }, Hs = [H.text, H.html, ...Object.values(yo)], wE = { png: "png", svg: "svg", clipboard: "clipboard" }, Ze = { excalidraw: "excalidraw", excalidrawClipboard: "excalidraw/clipboard", excalidrawLibrary: "excalidrawlib", excalidrawClipboardWithAPI: "excalidraw-api/clipboard" }, Ci$1 = window.EXCALIDRAW_EXPORT_SOURCE || window.location.origin, RE = 500, TE = 300, ME = 500;
var LE = 100, DE = 0.1, Js$1 = 0.1, Ys = 30, SE = 300;
var Io = "invert(93%) hue-rotate(180deg)", PE = { canvasActions: { changeViewBackgroundColor: true, clearCanvas: true, export: { saveFileToDisk: true }, loadScene: true, saveToActiveFile: true, toggleTheme: null, saveAsImage: true } }, NE = 730, FE = 1e3, BE = 500, _E = 1229, qn = 2, Cs = [1, 2, 3], Vi$1 = 10, OE = 1440, AE = 4 * 1024 * 1024, re = "http://www.w3.org/2000/svg";
var qi = { excalidraw: 2, excalidrawLibrary: 2 }, Se = 5, Vs = 0.7, qs$1 = 11, kt = { TOP: "top", MIDDLE: "middle", BOTTOM: "bottom" }, Xi$1 = { LEFT: "left", CENTER: "center", RIGHT: "right" }, Xs$1 = 20, wo = 0.25, Gs = 32, ot = { LEGACY: 1, PROPORTIONAL_RADIUS: 2, ADAPTIVE_RADIUS: 3 }, Gi = { artist: 1, cartoonist: 2 }, KE$1 = { thin: 1, bold: 2, extraBold: 4 }, we = { strokeColor: Z.black, backgroundColor: Z.transparent, fillStyle: "solid", strokeWidth: 2, strokeStyle: "solid", roughness: Gi.artist, opacity: 100, locked: false }, b6 = "library", HE = "search", ks = { name: "default", defaultTab: b6 }, JE$1 = /* @__PURE__ */ new Set(["iframe", "embeddable", "image"]), fn = { selection: "selection", rectangle: "rectangle", diamond: "diamond", ellipse: "ellipse", text: "text", image: "image", eraser: "eraser", frame: "frame", magicframe: "magicframe", laser: "laser" }, YE$1 = { MERMAID_TO_EXCALIDRAW: "mermaid-to-excalidraw", PUBLISH_LIBRARY: "publish-library-data" }, Zs$1 = "Untitled", ki = { generalStats: 1, elementProperties: 2 }, CE = 1, Ws$1 = { sharp: "sharp", round: "round", elbow: "elbow" }, zs = 0.3, gr = "element", Qs = Symbol.for("__test__originalId__"), E6 = ((r3) => (r3.ACTIVE = "active", r3.AWAY = "away", r3.IDLE = "idle", r3))(E6 || {});
var g6 = Cs.includes(devicePixelRatio) ? devicePixelRatio : 1, mt = () => ({ showWelcomeScreen: false, theme: ke.LIGHT, collaborators: /* @__PURE__ */ new Map(), currentChartType: "bar", currentItemBackgroundColor: we.backgroundColor, currentItemEndArrowhead: "arrow", currentItemFillStyle: we.fillStyle, currentItemFontFamily: Ft, currentItemFontSize: ut, currentItemOpacity: we.opacity, currentItemRoughness: we.roughness, currentItemStartArrowhead: null, currentItemStrokeColor: we.strokeColor, currentItemRoundness: "round", currentItemArrowType: Ws$1.round, currentItemStrokeStyle: we.strokeStyle, currentItemStrokeWidth: we.strokeWidth, currentItemTextAlign: Vn, currentHoveredFontFamily: null, cursorButton: "up", activeEmbeddable: null, newElement: null, editingTextElement: null, editingGroupId: null, editingLinearElement: null, activeTool: { type: "selection", customType: null, locked: we.locked, lastActiveTool: null }, penMode: false, penDetected: false, errorMessage: null, exportBackground: true, exportScale: g6, exportEmbedScene: false, exportWithDarkMode: false, fileHandle: null, gridSize: xo, gridStep: ho, gridModeEnabled: false, isBindingEnabled: true, defaultSidebarDockedPreference: false, isLoading: false, isResizing: false, isRotating: false, lastPointerDownWith: "mouse", multiElement: null, name: null, contextMenu: null, openMenu: null, openPopup: null, openSidebar: null, openDialog: null, pasteDialog: { shown: false, data: null }, previousSelectedElementIds: {}, resizingElement: null, scrolledOutside: false, scrollX: 0, scrollY: 0, selectedElementIds: {}, hoveredElementIds: {}, selectedGroupIds: {}, selectedElementsAreBeingDragged: false, selectionElement: null, shouldCacheIgnoreZoom: false, stats: { open: false, panels: ki.generalStats | ki.elementProperties }, startBoundElement: null, suggestedBindings: [], frameRendering: { enabled: true, clip: true, name: true, outline: true }, frameToHighlight: null, editingFrame: null, elementsToHighlight: null, toast: null, viewBackgroundColor: Z.white, zenModeEnabled: false, zoom: { value: 1 }, viewModeEnabled: false, pendingImageElementId: null, showHyperlinkPopup: false, selectedLinearElement: null, snapLines: [], originSnapOffset: { x: 0, y: 0 }, objectsSnapModeEnabled: false, userToFollow: null, followedBy: /* @__PURE__ */ new Set(), isCropping: false, croppingElementId: null, searchMatches: [] }), x6 = /* @__PURE__ */ ((e12) => e12)({ showWelcomeScreen: { browser: true, export: false, server: false }, theme: { browser: true, export: false, server: false }, collaborators: { browser: false, export: false, server: false }, currentChartType: { browser: true, export: false, server: false }, currentItemBackgroundColor: { browser: true, export: false, server: false }, currentItemEndArrowhead: { browser: true, export: false, server: false }, currentItemFillStyle: { browser: true, export: false, server: false }, currentItemFontFamily: { browser: true, export: false, server: false }, currentItemFontSize: { browser: true, export: false, server: false }, currentItemRoundness: { browser: true, export: false, server: false }, currentItemArrowType: { browser: true, export: false, server: false }, currentItemOpacity: { browser: true, export: false, server: false }, currentItemRoughness: { browser: true, export: false, server: false }, currentItemStartArrowhead: { browser: true, export: false, server: false }, currentItemStrokeColor: { browser: true, export: false, server: false }, currentItemStrokeStyle: { browser: true, export: false, server: false }, currentItemStrokeWidth: { browser: true, export: false, server: false }, currentItemTextAlign: { browser: true, export: false, server: false }, currentHoveredFontFamily: { browser: false, export: false, server: false }, cursorButton: { browser: true, export: false, server: false }, activeEmbeddable: { browser: false, export: false, server: false }, newElement: { browser: false, export: false, server: false }, editingTextElement: { browser: false, export: false, server: false }, editingGroupId: { browser: true, export: false, server: false }, editingLinearElement: { browser: false, export: false, server: false }, activeTool: { browser: true, export: false, server: false }, penMode: { browser: true, export: false, server: false }, penDetected: { browser: true, export: false, server: false }, errorMessage: { browser: false, export: false, server: false }, exportBackground: { browser: true, export: false, server: false }, exportEmbedScene: { browser: true, export: false, server: false }, exportScale: { browser: true, export: false, server: false }, exportWithDarkMode: { browser: true, export: false, server: false }, fileHandle: { browser: false, export: false, server: false }, gridSize: { browser: true, export: true, server: true }, gridStep: { browser: true, export: true, server: true }, gridModeEnabled: { browser: true, export: true, server: true }, height: { browser: false, export: false, server: false }, isBindingEnabled: { browser: false, export: false, server: false }, defaultSidebarDockedPreference: { browser: true, export: false, server: false }, isLoading: { browser: false, export: false, server: false }, isResizing: { browser: false, export: false, server: false }, isRotating: { browser: false, export: false, server: false }, lastPointerDownWith: { browser: true, export: false, server: false }, multiElement: { browser: false, export: false, server: false }, name: { browser: true, export: false, server: false }, offsetLeft: { browser: false, export: false, server: false }, offsetTop: { browser: false, export: false, server: false }, contextMenu: { browser: false, export: false, server: false }, openMenu: { browser: true, export: false, server: false }, openPopup: { browser: false, export: false, server: false }, openSidebar: { browser: true, export: false, server: false }, openDialog: { browser: false, export: false, server: false }, pasteDialog: { browser: false, export: false, server: false }, previousSelectedElementIds: { browser: true, export: false, server: false }, resizingElement: { browser: false, export: false, server: false }, scrolledOutside: { browser: true, export: false, server: false }, scrollX: { browser: true, export: false, server: false }, scrollY: { browser: true, export: false, server: false }, selectedElementIds: { browser: true, export: false, server: false }, hoveredElementIds: { browser: false, export: false, server: false }, selectedGroupIds: { browser: true, export: false, server: false }, selectedElementsAreBeingDragged: { browser: false, export: false, server: false }, selectionElement: { browser: false, export: false, server: false }, shouldCacheIgnoreZoom: { browser: true, export: false, server: false }, stats: { browser: true, export: false, server: false }, startBoundElement: { browser: false, export: false, server: false }, suggestedBindings: { browser: false, export: false, server: false }, frameRendering: { browser: false, export: false, server: false }, frameToHighlight: { browser: false, export: false, server: false }, editingFrame: { browser: false, export: false, server: false }, elementsToHighlight: { browser: false, export: false, server: false }, toast: { browser: false, export: false, server: false }, viewBackgroundColor: { browser: true, export: true, server: true }, width: { browser: false, export: false, server: false }, zenModeEnabled: { browser: true, export: false, server: false }, zoom: { browser: true, export: false, server: false }, viewModeEnabled: { browser: false, export: false, server: false }, pendingImageElementId: { browser: false, export: false, server: false }, showHyperlinkPopup: { browser: false, export: false, server: false }, selectedLinearElement: { browser: true, export: false, server: false }, snapLines: { browser: false, export: false, server: false }, originSnapOffset: { browser: false, export: false, server: false }, objectsSnapModeEnabled: { browser: true, export: false, server: false }, userToFollow: { browser: false, export: false, server: false }, followedBy: { browser: false, export: false, server: false }, isCropping: { browser: false, export: false, server: false }, croppingElementId: { browser: false, export: false, server: false }, searchMatches: { browser: false, export: false, server: false } }), js = (e12, t3) => {
  let n3 = {};
  for (let r3 of Object.keys(e12)) if (x6[r3]?.[t3]) {
    let i3 = e12[r3];
    n3[r3] = i3;
  }
  return n3;
};
var Ro = (e12) => js(e12, "export"), td$1 = ({ activeTool: e12 }) => e12.type === "eraser", nd = ({ activeTool: e12 }) => e12.type === "hand";
var se = (e12, t3, n3) => Math.min(Math.max(e12, t3), n3), To = (e12, t3, n3 = "round") => {
  let r3 = Math.pow(10, t3);
  return Math[n3]((e12 + Number.EPSILON) * r3) / r3;
}, WE$1 = (e12, t3, n3 = "round") => {
  let r3 = 1 / t3;
  return Math[n3](e12 * r3) / r3;
}, xr = (e12, t3) => (e12 + t3) / 2, Mo$1 = (e12) => typeof e12 == "number" && Number.isFinite(e12), Zi = (e12, t3, n3 = 1e-4) => Math.abs(e12 - t3) < n3;
var hr = (e12) => e12 < 0 ? e12 + 2 * Math.PI : e12 >= 2 * Math.PI ? e12 - 2 * Math.PI : e12;
function yr(e12) {
  return e12 * Math.PI / 180;
}
function rd$1(e12) {
  return e12 * 180 / Math.PI;
}
function od$1(e12) {
  return Math.abs(Math.sin(2 * e12)) < 1e-4;
}
function Be(e12, t3, n3 = 0, r3 = 0) {
  return [e12 - n3, t3 - r3];
}
function O(e12, t3 = [0, 0]) {
  return Be(e12[0] - t3[0], e12[1] - t3[1]);
}
function Me(e12, t3) {
  return e12[0] * t3[1] - t3[0] * e12[1];
}
function h6(e12, t3) {
  return e12[0] * t3[0] + e12[1] * t3[1];
}
function st$1(e12, t3) {
  return [e12[0] + t3[0], e12[1] + t3[1]];
}
function Lo(e12, t3) {
  return [e12[0] - t3[0], e12[1] - t3[1]];
}
function ue(e12, t3) {
  return Be(e12[0] * t3, e12[1] * t3);
}
function y6(e12) {
  return e12[0] * e12[0] + e12[1] * e12[1];
}
function I6(e12) {
  return Math.sqrt(y6(e12));
}
var Je = (e12) => {
  let t3 = I6(e12);
  return t3 === 0 ? Be(0, 0) : Be(e12[0] / t3, e12[1] / t3);
};
function u$1(e12, t3) {
  return [e12, t3];
}
function Ir$1(e12) {
  return e12.length === 2 ? u$1(e12[0], e12[1]) : void 0;
}
function q(e12, t3 = u$1(0, 0)) {
  return u$1(t3[0] + e12[0], t3[1] + e12[1]);
}
function Do$1(e12) {
  return Array.isArray(e12) && e12.length === 2 && typeof e12[0] == "number" && !isNaN(e12[0]) && typeof e12[1] == "number" && !isNaN(e12[1]);
}
function _e$1(e12, t3) {
  let n3 = Math.abs;
  return n3(e12[0] - t3[0]) < 1e-4 && n3(e12[1] - t3[1]) < 1e-4;
}
function T$1([e12, t3], [n3, r3], o3) {
  return u$1((e12 - n3) * Math.cos(o3) - (t3 - r3) * Math.sin(o3) + n3, (e12 - n3) * Math.sin(o3) + (t3 - r3) * Math.cos(o3) + r3);
}
function wr(e12, t3 = [0, 0]) {
  return u$1(e12[0] + t3[0], e12[1] + t3[1]);
}
function Zt(e12, t3) {
  return u$1((e12[0] + t3[0]) / 2, (e12[1] + t3[1]) / 2);
}
function ie(e12, t3) {
  return Math.hypot(t3[0] - e12[0], t3[1] - e12[1]);
}
function Xn(e12, t3) {
  let n3 = t3[0] - e12[0], r3 = t3[1] - e12[1];
  return n3 * n3 + r3 * r3;
}
var bt = (e12, t3, n3) => wr(t3, ue(O(e12, t3), n3)), So = (e12, t3, n3) => t3[0] <= Math.max(e12[0], n3[0]) && t3[0] >= Math.min(e12[0], n3[0]) && t3[1] <= Math.max(e12[1], n3[1]) && t3[1] >= Math.min(e12[1], n3[1]);
function Rr(e12, t3) {
  return [e12, t3];
}
function id(e12, t3) {
  let n3 = e12[1][1] - e12[0][1], r3 = e12[0][0] - e12[1][0], o3 = t3[1][1] - t3[0][1], i3 = t3[0][0] - t3[1][0], a3 = n3 * i3 - o3 * r3;
  if (a3 !== 0) {
    let s3 = n3 * e12[0][0] + r3 * e12[0][1], d3 = o3 * t3[0][0] + i3 * t3[0][1];
    return u$1((s3 * i3 - d3 * r3) / a3, (n3 * d3 - o3 * s3) / a3);
  }
  return null;
}
function A$1(e12, t3) {
  return [e12, t3];
}
var Bt = (e12, t3, n3 = 1e-4) => {
  let r3 = vo(e12, t3);
  return r3 === 0 ? true : r3 < n3;
}, vo = (e12, t3) => {
  let [n3, r3] = e12, [[o3, i3], [a3, s3]] = t3, d3 = n3 - o3, c3 = r3 - i3, l3 = a3 - o3, U3 = s3 - i3, p3 = d3 * l3 + c3 * U3, m3 = l3 * l3 + U3 * U3, b3 = -1;
  m3 !== 0 && (b3 = p3 / m3);
  let E3, g3;
  b3 < 0 ? (E3 = o3, g3 = i3) : b3 > 1 ? (E3 = a3, g3 = s3) : (E3 = o3 + b3 * l3, g3 = i3 + b3 * U3);
  let h3 = n3 - E3, x3 = r3 - g3;
  return Math.sqrt(h3 * h3 + x3 * x3);
};
function pn(e12, t3) {
  let n3 = id(Rr(e12[0], e12[1]), Rr(t3[0], t3[1]));
  return !n3 || !Bt(n3, t3) || !Bt(n3, e12) ? null : n3;
}
function Tr$1(e12, t3) {
  return [e12, t3];
}
function ad$1(e12, t3) {
  return [A$1(e12[0], u$1(e12[1][0], e12[0][1])), A$1(u$1(e12[1][0], e12[0][1]), e12[1]), A$1(e12[1], u$1(e12[0][0], e12[1][1])), A$1(u$1(e12[0][0], e12[1][1]), e12[0])].map((n3) => pn(t3, n3)).filter((n3) => !!n3);
}
function Et(e12, t3, n3, r3) {
  return [e12, t3, n3, r3];
}
function sd(e12, t3, n3, r3 = 1e-6) {
  return [(e12(t3 + r3, n3) - e12(t3 - r3, n3)) / (2 * r3), (e12(t3, n3 + r3) - e12(t3, n3 - r3)) / (2 * r3)];
}
function w6(e12, t3, n3, r3 = 1e-3, o3 = 10) {
  let i3 = 1 / 0, a3 = 0;
  for (; i3 >= r3; ) {
    if (a3 >= o3) return null;
    let s3 = e12(t3, n3), d3 = [sd((E3, g3) => e12(E3, g3)[0], t3, n3), sd((E3, g3) => e12(E3, g3)[1], t3, n3)], c3 = [[-s3[0]], [-s3[1]]], l3 = d3[0][0] * d3[1][1] - d3[0][1] * d3[1][0];
    if (l3 === 0) return null;
    let U3 = [[d3[1][1] / l3, -d3[0][1] / l3], [-d3[1][0] / l3, d3[0][0] / l3]], p3 = [[U3[0][0] * c3[0][0] + U3[0][1] * c3[1][0]], [U3[1][0] * c3[0][0] + U3[1][1] * c3[1][0]]];
    t3 = t3 + p3[0][0], n3 = n3 + p3[1][0];
    let [m3, b3] = e12(t3, n3);
    i3 = Math.max(Math.abs(m3), Math.abs(b3)), a3 += 1;
  }
  return [t3, n3];
}
var Mr = (e12, t3) => u$1((1 - t3) ** 3 * e12[0][0] + 3 * (1 - t3) ** 2 * t3 * e12[1][0] + 3 * (1 - t3) * t3 ** 2 * e12[2][0] + t3 ** 3 * e12[3][0], (1 - t3) ** 3 * e12[0][1] + 3 * (1 - t3) ** 2 * t3 * e12[1][1] + 3 * (1 - t3) * t3 ** 2 * e12[2][1] + t3 ** 3 * e12[3][1]);
function Wi$1(e12, t3) {
  let n3 = T6(e12);
  if (ad$1(Tr$1(u$1(n3[0], n3[1]), u$1(n3[2], n3[3])), t3).length === 0) return [];
  let r3 = (s3) => u$1(t3[0][0] + s3 * (t3[1][0] - t3[0][0]), t3[0][1] + s3 * (t3[1][1] - t3[0][1])), o3 = [[0.5, 0], [0.2, 0], [0.8, 0]], i3 = ([s3, d3]) => {
    let c3 = w6((p3, m3) => {
      let b3 = Mr(e12, p3), E3 = r3(m3);
      return [b3[0] - E3[0], b3[1] - E3[1]];
    }, s3, d3);
    if (!c3) return null;
    let [l3, U3] = c3;
    return l3 < 0 || l3 > 1 || U3 < 0 || U3 > 1 ? null : Mr(e12, l3);
  }, a3 = i3(o3[0]);
  return a3 ? [a3] : (a3 = i3(o3[1]), a3 ? [a3] : (a3 = i3(o3[2]), a3 ? [a3] : []));
}
function R6(e12, t3, n3 = 1e-3) {
  let r3 = (c3, l3, U3, p3 = n3) => {
    let m3 = c3, b3 = l3, E3;
    for (; b3 - m3 > p3; ) E3 = (b3 + m3) / 2, U3(E3 - p3) < U3(E3 + p3) ? b3 = E3 : m3 = E3;
    return E3;
  }, i3 = 0;
  for (let c3 = 1 / 0, l3 = 0; l3 < 30; l3++) {
    let U3 = ie(t3, Mr(e12, l3 / 30));
    U3 < c3 && (c3 = U3, i3 = l3);
  }
  let a3 = Math.max((i3 - 1) / 30, 0), s3 = Math.min((i3 + 1) / 30, 1), d3 = r3(a3, s3, (c3) => ie(t3, Mr(e12, c3)));
  return d3 ? Mr(e12, d3) : null;
}
function zi$1(e12, t3) {
  let n3 = R6(e12, t3);
  return n3 ? ie(t3, n3) : 0;
}
function T6(e12) {
  let [t3, n3, r3, o3] = e12, i3 = [t3[0], n3[0], r3[0], o3[0]], a3 = [t3[1], n3[1], r3[1], o3[1]];
  return [Math.min(...i3), Math.min(...a3), Math.max(...i3), Math.max(...a3)];
}
function Qi(...e12) {
  return cd$1(e12);
}
function Gn(e12) {
  return cd$1(e12);
}
var ji$1 = (e12, t3) => {
  let n3 = e12[0], r3 = e12[1], o3 = false;
  for (let i3 = 0, a3 = t3.length - 1; i3 < t3.length; a3 = i3++) {
    let s3 = t3[i3][0], d3 = t3[i3][1], c3 = t3[a3][0], l3 = t3[a3][1];
    (d3 > r3 && l3 <= r3 || d3 <= r3 && l3 > r3) && n3 < (c3 - s3) * (r3 - d3) / (l3 - d3) + s3 && (o3 = !o3);
  }
  return o3;
}, dd = (e12, t3, n3 = 1e-4) => {
  let r3 = false;
  for (let o3 = 0, i3 = t3.length - 1; o3 < i3; o3++) if (Bt(e12, A$1(t3[o3], t3[o3 + 1]), n3)) {
    r3 = true;
    break;
  }
  return r3;
};
function cd$1(e12) {
  return M6(e12) ? e12 : [...e12, e12[0]];
}
function M6(e12) {
  return _e$1(e12[0], e12[e12.length - 1]);
}
function Oe$1(e12, t3) {
  return tt([e12, t3]);
}
var Lr$1 = ([e12, t3], [n3, r3]) => e12 <= n3 ? t3 >= n3 : e12 >= n3 ? r3 >= e12 : false, Dr$1 = ([e12, t3], [n3, r3]) => {
  let o3 = Math.max(e12, n3), i3 = Math.min(t3, r3);
  return o3 <= i3 ? tt([o3, i3]) : null;
}, Sr$1 = (e12, [t3, n3]) => e12 >= t3 && e12 <= n3;
function Ln$1([e12, t3, n3], r3) {
  let o3 = (l3, U3, p3) => (l3[0] - p3[0]) * (U3[1] - p3[1]) - (U3[0] - p3[0]) * (l3[1] - p3[1]), i3 = o3(r3, e12, t3), a3 = o3(r3, t3, n3), s3 = o3(r3, n3, e12), d3 = i3 < 0 || a3 < 0 || s3 < 0, c3 = i3 > 0 || a3 > 0 || s3 > 0;
  return !(d3 && c3);
}
var ng = () => {
  let e12 = /* @__PURE__ */ new Date(), t3 = e12.getFullYear(), n3 = `${e12.getMonth() + 1}`.padStart(2, "0"), r3 = `${e12.getDate()}`.padStart(2, "0"), o3 = `${e12.getHours()}`.padStart(2, "0"), i3 = `${e12.getMinutes()}`.padStart(2, "0");
  return `${t3}-${n3}-${r3}-${o3}${i3}`;
}, rg$1 = (e12) => e12.charAt(0).toUpperCase() + e12.slice(1), og = (e12) => e12 instanceof HTMLElement && e12.className.includes("ToolIcon"), D6 = (e12) => e12 instanceof HTMLElement && e12.dataset.type === "wysiwyg" || e12 instanceof HTMLBRElement || e12 instanceof HTMLInputElement || e12 instanceof HTMLTextAreaElement || e12 instanceof HTMLSelectElement, ig$1 = (e12) => D6(e12) || e12 instanceof Element && !!e12.closest("label, button"), ag = (e12) => e12 instanceof HTMLElement && e12.dataset.type === "wysiwyg" || e12 instanceof HTMLBRElement || e12 instanceof HTMLTextAreaElement || e12 instanceof HTMLInputElement && (e12.type === "text" || e12.type === "number" || e12.type === "password"), ea = ({ fontFamily: e12 }) => {
  for (let [t3, n3] of Object.entries(Ie)) if (n3 === e12) return `${t3}${bo(n3).map((r3) => `, ${r3}`).join("")}`;
  return Tn$1;
}, Ee = ({ fontSize: e12, fontFamily: t3 }) => `${e12}px ${ea({ fontFamily: t3 })}`, $o = (e12, t3) => {
  let n3 = 0, r3 = null, o3 = (...i3) => {
    r3 = i3, clearTimeout(n3), n3 = window.setTimeout(() => {
      r3 = null, e12(...i3);
    }, t3);
  };
  return o3.flush = () => {
    if (clearTimeout(n3), r3) {
      let i3 = r3;
      r3 = null, e12(...i3);
    }
  }, o3.cancel = () => {
    r3 = null, clearTimeout(n3);
  }, o3;
}, pd$1 = (e12, t3) => {
  let n3 = null, r3 = null, o3 = null, i3 = (s3) => {
    n3 = window.requestAnimationFrame(() => {
      n3 = null, e12(...s3), r3 = null, o3 && (r3 = o3, o3 = null, i3(r3));
    });
  }, a3 = (...s3) => {
    if (c$1.MODE === "test") {
      e12(...s3);
      return;
    }
    r3 = s3, n3 === null ? i3(r3) : t3?.trailing && (o3 = s3);
  };
  return a3.flush = () => {
    n3 !== null && (cancelAnimationFrame(n3), n3 = null), r3 && (e12(...o3 || r3), r3 = o3 = null);
  }, a3.cancel = () => {
    r3 = o3 = null, n3 !== null && (cancelAnimationFrame(n3), n3 = null);
  }, a3;
}, ud$1 = (e12) => 1 - Math.pow(1 - e12, 4), Ud = (e12, t3, n3) => (t3 - e12) * ud$1(n3) + e12, sg = ({ fromValues: e12, toValues: t3, onStep: n3, duration: r3 = 250, interpolateValue: o3, onStart: i3, onEnd: a3, onCancel: s3 }) => {
  let d3 = false, c3 = 0, l3;
  function U3(p3) {
    if (d3) return;
    l3 === void 0 && (l3 = p3, i3?.());
    let m3 = Math.min(p3 - l3, r3), b3 = ud$1(m3 / r3), E3 = {};
    if (Object.keys(e12).forEach((g3) => {
      let h3 = g3, x3 = (t3[h3] - e12[h3]) * b3 + e12[h3];
      E3[h3] = x3;
    }), n3(E3), m3 < r3) {
      let g3 = m3 / r3, h3 = {};
      Object.keys(e12).forEach((x3) => {
        let y3 = x3, w3 = e12[y3], I3 = t3[y3], S3;
        S3 = o3 ? o3(w3, I3, g3, y3) : Ud(w3, I3, g3), S3 == null && (S3 = Ud(w3, I3, g3)), h3[y3] = S3;
      }), n3(h3), c3 = window.requestAnimationFrame(U3);
    } else n3(t3), a3?.();
  }
  return c3 = window.requestAnimationFrame(U3), () => {
    s3?.(), d3 = true, window.cancelAnimationFrame(c3);
  };
}, dg = (e12, t3) => {
  if (!e12.length || t3 < 1) return [];
  let n3 = 0, r3 = 0, o3 = Array(Math.ceil(e12.length / t3));
  for (; n3 < e12.length; ) o3[r3++] = e12.slice(n3, n3 += t3);
  return o3;
};
var dt = (e12, t3) => Math.abs(e12 - t3), $r = (e12, t3) => t3.type === "custom" ? { ...e12.activeTool, type: "custom", customType: t3.customType, locked: t3.locked ?? e12.activeTool.locked } : { ...e12.activeTool, lastActiveTool: t3.lastActiveToolBeforeEraser === void 0 ? e12.activeTool.lastActiveTool : t3.lastActiveToolBeforeEraser, type: t3.type, customType: null, locked: t3.locked ?? e12.activeTool.locked };
var cg$1 = (e12) => (e12 = e12.replace(/\bAlt\b/i, "Alt").replace(/\bShift\b/i, "Shift").replace(/\b(Enter|Return)\b/i, "Enter"), uo ? e12.replace(/\bCtrlOrCmd\b/gi, "Cmd").replace(/\bAlt\b/i, "Option") : e12.replace(/\bCtrlOrCmd\b/gi, "Ctrl")), Dn = ({ clientX: e12, clientY: t3 }, { zoom: n3, offsetLeft: r3, offsetTop: o3, scrollX: i3, scrollY: a3 }) => {
  let s3 = (e12 - r3) / n3.value - i3, d3 = (t3 - o3) / n3.value - a3;
  return { x: s3, y: d3 };
}, ta = ({ sceneX: e12, sceneY: t3 }, { zoom: n3, offsetLeft: r3, offsetTop: o3, scrollX: i3, scrollY: a3 }) => {
  let s3 = (e12 + i3) * n3.value + r3, d3 = (t3 + a3) * n3.value + o3;
  return { x: s3, y: d3 };
}, lg$1 = (e12) => getComputedStyle(document.documentElement).getPropertyValue(`--${e12}`), S6 = "A-Za-z--------", v6 = "---", $6 = new RegExp(`^[^${S6}]*[${v6}]`), Po = (e12) => $6.test(e12), un = (e12) => {
  let [t3, n3] = e12;
  return { x: t3, y: n3 };
}, Ug$1 = (e12) => {
  if (e12?.name === "AbortError") {
    console.warn(e12);
    return;
  }
  throw e12;
}, fg$1 = (e12, t3, n3 = 0) => {
  n3 < 0 && (n3 = e12.length + n3), n3 = Math.min(e12.length, Math.max(n3, 0));
  let r3 = n3 - 1;
  for (; ++r3 < e12.length; ) if (t3(e12[r3], r3, e12)) return r3;
  return -1;
}, pg = (e12, t3, n3 = e12.length - 1) => {
  n3 < 0 && (n3 = e12.length + n3), n3 = Math.min(e12.length - 1, Math.max(n3, 0));
  let r3 = n3 + 1;
  for (; --r3 > -1; ) if (t3(e12[r3], r3, e12)) return r3;
  return -1;
}, Wt = (e12) => {
  let t3 = e12.length === 5 && e12.substr(4, 1) === "0", n3 = e12.length === 9 && e12.substr(7, 2) === "00";
  return t3 || n3 || e12 === Z.transparent;
}, No = (e12) => e12.fillStyle !== "solid" || Wt(e12.backgroundColor), ug$1 = () => {
  let e12, t3, n3 = new Promise((r3, o3) => {
    e12 = r3, t3 = o3;
  });
  return n3.resolve = e12, n3.reject = t3, n3;
};
var mg$1 = (e12) => {
  let t3 = e12.parentElement;
  for (; t3; ) {
    if (t3 === document.body) return document;
    let { overflowY: n3 } = window.getComputedStyle(t3);
    if (t3.scrollHeight > t3.clientHeight && (n3 === "auto" || n3 === "scroll" || n3 === "overlay")) return t3;
    t3 = t3.parentElement;
  }
  return document;
}, bg$1 = (e12) => {
  let t3 = e12.parentElement;
  for (; t3; ) {
    if (t3.tabIndex > -1) {
      t3.focus();
      return;
    }
    t3 = t3.parentElement;
  }
}, md$1 = (e12) => Array.from(e12).map((t3) => `0${t3.toString(16)}`.slice(-2)).join(""), zt = () => Ot() ? 1 : Date.now(), te = (e12) => e12 instanceof Map ? e12 : e12.reduce((t3, n3) => (t3.set(typeof n3 == "string" ? n3 : n3.id, n3), t3), /* @__PURE__ */ new Map()), gg$1 = (e12) => e12.reduce((t3, n3, r3) => (t3.set(n3.id, [n3, r3]), t3), /* @__PURE__ */ new Map()), _t$1 = (e12, t3) => e12.reduce((n3, r3) => (n3[t3 ? t3(r3) : String(r3)] = r3, n3), {}), xg$1 = (e12) => e12.reduce((t3, n3, r3) => {
  let o3 = { ...n3, prev: null, next: null };
  if (r3 !== 0) {
    let i3 = t3[r3 - 1];
    if (o3.prev = i3, i3.next = o3, r3 === e12.length - 1) {
      let a3 = t3[0];
      o3.next = a3, a3.prev = o3;
    }
  }
  return t3.push(o3), t3;
}, []), Ot = () => c$1.MODE === "test", hg = () => c$1.MODE === "development", bd$1 = () => typeof process < "u" && true, yg = (e12, t3) => new CustomEvent(e12, { detail: { nativeEvent: t3 }, cancelable: true }), Ig$1 = (e12, t3) => {
  let n3 = false;
  for (let r3 in t3) {
    let o3 = t3[r3];
    if (typeof o3 < "u") {
      if (e12[r3] === o3 && (typeof o3 != "object" || o3 === null)) continue;
      n3 = true;
    }
  }
  return n3 ? { ...e12, ...t3 } : e12;
};
var wg$1 = () => {
  try {
    return window.self === window.top ? "top" : "iframe";
  } catch {
    return "iframe";
  }
};
var Fo = (e12) => !!e12 && typeof e12 == "object" && "then" in e12 && "catch" in e12 && "finally" in e12, Rg$1 = (e12) => {
  let t3 = e12?.querySelectorAll("button, a, input, select, textarea, div[tabindex], label[tabindex]");
  return t3 ? Array.from(t3).filter((n3) => n3.tabIndex > -1 && !n3.disabled) : [];
}, fd$1 = (e12, t3) => Array.isArray(e12) && Array.isArray(t3) && e12.length === 0 && t3.length === 0 ? true : e12 === t3, Qt = (e12, t3, n3, r3 = false) => {
  let o3 = Object.keys(e12), i3 = Object.keys(t3);
  if (o3.length !== i3.length) return r3 && console.warn("%cisShallowEqual: objects don't have same properties ->", "color: #8B4000", e12, t3), false;
  if (n3 && Array.isArray(n3)) {
    for (let a3 of n3) if (!(e12[a3] === t3[a3] || fd$1(e12[a3], t3[a3]))) return r3 && console.warn(`%cisShallowEqual: ${a3} not equal ->`, "color: #8B4000", e12[a3], t3[a3]), false;
    return true;
  }
  return o3.every((a3) => {
    let s3 = n3?.[a3], d3 = s3 ? s3(e12[a3], t3[a3]) : e12[a3] === t3[a3] || fd$1(e12[a3], t3[a3]);
    return !d3 && r3 && console.warn(`%cisShallowEqual: ${a3} not equal ->`, "color: #8B4000", e12[a3], t3[a3]), d3;
  });
}, Tg$1 = (e12, t3, { checkForDefaultPrevented: n3 = true } = {}) => function(o3) {
  if (e12?.(o3), !n3 || !o3?.defaultPrevented) return t3?.(o3);
}, Sn$1 = (e12, t3, n3) => {
  if (!t3) return e12;
  if (n3) return console.error(t3), e12;
  throw new Error(t3);
};
function Ae(e12, t3) {
  if (!e12) throw new Error(t3);
}
var Mg$1 = (e12) => {
  let t3, n3, r3 = function(o3) {
    let i3 = Object.entries(o3);
    if (t3) {
      let s3 = true;
      for (let [d3, c3] of i3) if (t3.get(d3) !== c3) {
        s3 = false;
        break;
      }
      if (s3) return n3;
    }
    let a3 = e12(o3);
    return t3 = new Map(i3), n3 = a3, a3;
  };
  return r3.clear = () => {
    t3 = void 0, n3 = void 0;
  }, r3;
}, Ed$1 = (e12, t3) => e12 instanceof Set || e12 instanceof Map ? e12.has(t3) : "includes" in e12 ? e12.includes(t3) : e12.hasOwnProperty(t3), Lg$1 = (e12) => JSON.parse(JSON.stringify(e12)), Dg$1 = (e12, t3) => Qt(e12, t3) ? e12 : t3;
function Sg$1(e12, t3, n3, r3) {
  return e12 ? (e12?.addEventListener?.(t3, n3, r3), () => {
    e12?.removeEventListener?.(t3, n3, r3);
  }) : () => {
  };
}
function vg(e12, t3 = true) {
  let n3 = e12.length;
  if (n3 < 4) return "";
  let r3 = e12[0], o3 = e12[1], i3 = e12[2], a3 = `M${r3[0].toFixed(2)},${r3[1].toFixed(2)} Q${o3[0].toFixed(2)},${o3[1].toFixed(2)} ${xr(o3[0], i3[0]).toFixed(2)},${xr(o3[1], i3[1]).toFixed(2)} T`;
  for (let s3 = 2, d3 = n3 - 1; s3 < d3; s3++) r3 = e12[s3], o3 = e12[s3 + 1], a3 += `${xr(r3[0], o3[0]).toFixed(2)},${xr(r3[1], o3[1]).toFixed(2)} `;
  return t3 && (a3 += "Z"), a3;
}
var gd$1 = (e12) => e12.replace(/\r?\n|\r/g, `
`), tt = (e12) => e12, mn = async (e12, ...t3) => new Promise((n3) => {
  n3(e12(...t3));
}), xd = (...e12) => Math.max(...e12.map((t3) => t3 ? 1 : 0)) > 0;
var vr = class {
  constructor(t3, n3) {
    i$1(this, "pool");
    i$1(this, "entries", {});
    this.pool = new L6(t3, n3);
  }
  all() {
    let t3 = (n3) => {
      if (n3.data.result) {
        let [r3, o3] = n3.data.result;
        this.entries[r3] = o3;
      }
    };
    return this.pool.addEventListener("fulfilled", t3), this.pool.start().then(() => (setTimeout(() => {
      this.pool.removeEventListener("fulfilled", t3);
    }), Object.values(this.entries)));
  }
}, kn$1 = (e12) => e12.replace(/"/g, "&quot;"), $g$1 = (e12) => Array.isArray(e12) ? e12 : [e12];
var At = (e12) => !!e12 && e12.type === "image" && !!e12.fileId, Ye$1 = (e12) => !!e12 && e12.type === "image", Bo = (e12) => !!e12 && e12.type === "embeddable", _o$1 = (e12) => !!e12 && e12.type === "iframe", gt$1 = (e12) => !!e12 && (e12.type === "iframe" || e12.type === "embeddable"), k$2 = (e12) => e12 != null && e12.type === "text", hd$1 = (e12) => e12 != null && e12.type === "frame", yd$1 = (e12) => e12 != null && e12.type === "magicframe", de = (e12) => e12 != null && (e12.type === "frame" || e12.type === "magicframe"), Ce$1 = (e12) => e12 != null && P6(e12.type), P6 = (e12) => e12 === "freedraw", ae = (e12) => e12 != null && na(e12.type), ee = (e12) => e12 != null && e12.type === "arrow", X$1 = (e12) => ee(e12) && e12.elbowed, na = (e12) => e12 === "arrow" || e12 === "line", Pr = (e12, t3 = true) => e12 != null && (!e12.locked || t3 === true) && N6(e12.type), N6 = (e12) => e12 === "arrow", xt = (e12, t3 = true) => e12 != null && (!e12.locked || t3 === true) && (e12.type === "rectangle" || e12.type === "diamond" || e12.type === "ellipse" || e12.type === "image" || e12.type === "iframe" || e12.type === "embeddable" || e12.type === "frame" || e12.type === "magicframe" || e12.type === "text" && !e12.containerId), Id = (e12) => e12 != null && (e12.type === "rectangle" || e12.type === "diamond" || e12.type === "image" || e12.type === "iframe" || e12.type === "embeddable" || e12.type === "frame" || e12.type === "magicframe" || e12.type === "text" && !e12.containerId);
var F6 = (e12, t3 = true) => e12 != null && (!e12.locked || t3 === true) && (e12.type === "rectangle" || e12.type === "diamond" || e12.type === "ellipse" || ee(e12)), ra = (e12) => {
  let t3 = e12?.type;
  if (!t3) return false;
  switch (t3) {
    case "text":
    case "diamond":
    case "rectangle":
    case "iframe":
    case "embeddable":
    case "ellipse":
    case "arrow":
    case "freedraw":
    case "line":
    case "frame":
    case "magicframe":
    case "image":
    case "selection":
      return true;
    default:
      return Sn$1(t3, null), false;
  }
}, Og$1 = (e12) => e12.type === "rectangle" || e12.type === "ellipse" || e12.type === "diamond", bn = (e12) => F6(e12) && !!e12.boundElements?.some(({ type: t3 }) => t3 === "text"), Ne = (e12) => e12 !== null && "containerId" in e12 && e12.containerId !== null && k$2(e12), Oo$1 = (e12) => e12 === "rectangle" || e12 === "embeddable" || e12 === "iframe" || e12 === "image", wd$1 = (e12) => e12 === "line" || e12 === "arrow" || e12 === "diamond", Ag$1 = (e12, t3) => !!((e12 === ot.ADAPTIVE_RADIUS || e12 === ot.LEGACY) && Oo$1(t3.type) || e12 === ot.PROPORTIONAL_RADIUS && wd$1(t3.type)), Kg$1 = (e12) => wd$1(e12.type) ? { type: ot.PROPORTIONAL_RADIUS } : Oo$1(e12.type) ? { type: ot.ADAPTIVE_RADIUS } : null, vn$1 = (e12) => Object.hasOwn(e12, "fixedPoint") && e12.fixedPoint != null;
var ht = (e12, t3, n3) => {
  let r3 = e12.split(`
`).map((s3) => s3 || " ").join(`
`), o3 = parseFloat(t3), i3 = B6(r3, o3, n3);
  return { width: Dd$1(r3, t3), height: i3 };
}, Rd$1 = "ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789".toLocaleUpperCase(), Td = (e12, t3) => {
  let n3 = _6(e12);
  return n3 === 0 ? ht(Rd$1.split("").join(`
`), e12, t3).width + Se * 2 : n3 + Se * 2;
}, Ko = (e12, t3) => ht("", e12, t3).width + Se * 2, Vg$1 = () => Dd$1(Rd$1, Ee({ fontSize: ut, fontFamily: Ft })) > 0, ia = (e12) => gd$1(e12).replace(/\t/g, "        "), aa = (e12) => ia(e12).split(`
`), Md$1 = (e12) => {
  let t3 = aa(e12.text).length;
  return e12.height / t3 / e12.fontSize;
}, Zn = (e12, t3) => e12 * t3, Ld$1 = (e12, t3) => Zn(e12, t3) + Se * 2, Ao, oa = class {
  constructor() {
    i$1(this, "canvas");
    this.canvas = document.createElement("canvas");
  }
  getLineWidth(t3, n3) {
    let r3 = this.canvas.getContext("2d");
    r3.font = n3;
    let i3 = r3.measureText(t3).width;
    return Ot() ? i3 * 10 : i3;
  }
}, En$1 = (e12, t3) => (Ao || (Ao = new oa()), Ao.getLineWidth(e12, t3)), Dd$1 = (e12, t3) => {
  let n3 = aa(e12), r3 = 0;
  return n3.forEach((o3) => {
    r3 = Math.max(r3, En$1(o3, t3));
  }), r3;
}, B6 = (e12, t3, n3) => {
  let r3 = aa(e12).length;
  return Zn(t3, n3) * r3;
}, $n = /* @__PURE__ */ (() => {
  let e12 = {};
  return { calculate: (o3, i3) => {
    let a3 = o3.charCodeAt(0);
    if (e12[i3] || (e12[i3] = []), !e12[i3][a3]) {
      let s3 = En$1(o3, i3);
      e12[i3][a3] = s3;
    }
    return e12[i3][a3];
  }, getCache: (o3) => e12[o3], clearCache: (o3) => {
    e12[o3] = [];
  } };
})();
var _6 = (e12) => {
  let t3 = $n.getCache(e12);
  if (!t3) return 0;
  let n3 = t3.filter((r3) => r3 !== void 0);
  return Math.max(...n3);
};
var sa, Ho, da, Sd$1 = (e12) => (sa || (sa = le$1.class(...Object.values(jt))), sa.test(e12)), O6 = () => {
  if (!Ho) try {
    Ho = K6();
  } catch {
    Ho = A6();
  }
  return Ho;
}, ca = () => (da || (da = H6()), da), ct$1 = { WHITESPACE: /\s/u, HYPHEN: /-/u, OPENING: /<\(\[\{/u, CLOSING: />\)\]\}.,:;!\?\//u }, jt = { CHAR: new RegExp("\\p{Script=Han}\\p{Script=Hiragana}\\p{Script=Katakana}\\p{Script=Hangul}", "u"), OPENING: //u, CLOSING: //u, CURRENCY: //u }, Pn = { FLAG: new RegExp("\\p{RI}\\p{RI}", "u"), JOINER: new RegExp("(?:\\p{Emoji_Modifier}|\\uFE0F\\u20E3?|[\\u{E0020}-\\u{E007E}]+\\u{E007F})?", "u"), ZWJ: /\u200D/u, ANY: /[\p{Emoji}]/u, MOST: /[\p{Extended_Pictographic}\p{Emoji_Presentation}]/u }, A6 = () => le$1.or(ca(), De.On(ct$1.HYPHEN, ct$1.WHITESPACE, jt.CHAR)), K6 = () => le$1.or(ca(), De.Before(ct$1.WHITESPACE).Build(), De.After(ct$1.WHITESPACE, ct$1.HYPHEN).Build(), De.Before(jt.CHAR, jt.CURRENCY).NotPrecededBy(ct$1.OPENING, jt.OPENING).Build(), De.After(jt.CHAR).NotFollowedBy(ct$1.HYPHEN, ct$1.CLOSING, jt.CLOSING).Build(), De.BeforeMany(jt.OPENING).NotPrecededBy(ct$1.OPENING).Build(), De.AfterMany(jt.CLOSING).NotFollowedBy(ct$1.CLOSING).Build(), De.AfterMany(ct$1.CLOSING).FollowedBy(ct$1.OPENING).Build()), H6 = () => le$1.group(le$1.or(Pn.FLAG, le$1.and(Pn.MOST, Pn.JOINER, le$1.build(`(?:${Pn.ZWJ.source}(?:${Pn.FLAG.source}|${Pn.ANY.source}${Pn.JOINER.source}))*`)))), le$1 = { build: (e12) => new RegExp(e12, "u"), join: (...e12) => e12.map((t3) => t3.source).join(""), and: (...e12) => le$1.build(le$1.join(...e12)), or: (...e12) => le$1.build(e12.map((t3) => t3.source).join("|")), group: (...e12) => le$1.build(`(${le$1.join(...e12)})`), class: (...e12) => le$1.build(`[${le$1.join(...e12)}]`) }, De = { On: (...e12) => {
  let t3 = le$1.join(...e12);
  return le$1.build(`([${t3}])`);
}, Before: (...e12) => {
  let t3 = le$1.join(...e12), n3 = () => le$1.build(`(?=[${t3}])`);
  return De.Chain(n3);
}, After: (...e12) => {
  let t3 = le$1.join(...e12), n3 = () => le$1.build(`(?<=[${t3}])`);
  return De.Chain(n3);
}, BeforeMany: (...e12) => {
  let t3 = le$1.join(...e12), n3 = () => le$1.build(`(?<![${t3}])(?=[${t3}])`);
  return De.Chain(n3);
}, AfterMany: (...e12) => {
  let t3 = le$1.join(...e12), n3 = () => le$1.build(`(?<=[${t3}])(?![${t3}])`);
  return De.Chain(n3);
}, NotBefore: (...e12) => {
  let t3 = le$1.join(...e12), n3 = () => le$1.build(`(?![${t3}])`);
  return De.Chain(n3);
}, NotAfter: (...e12) => {
  let t3 = le$1.join(...e12), n3 = () => le$1.build(`(?<![${t3}])`);
  return De.Chain(n3);
}, Chain: (e12) => ({ Build: e12, PreceededBy: (...t3) => {
  let n3 = e12(), r3 = De.After(...t3).Build(), o3 = () => le$1.and(r3, n3);
  return De.Chain(o3);
}, FollowedBy: (...t3) => {
  let n3 = e12(), r3 = De.Before(...t3).Build(), o3 = () => le$1.and(n3, r3);
  return De.Chain(o3);
}, NotPrecededBy: (...t3) => {
  let n3 = e12(), r3 = De.NotAfter(...t3).Build(), o3 = () => le$1.and(r3, n3);
  return De.Chain(o3);
}, NotFollowedBy: (...t3) => {
  let n3 = e12(), r3 = De.NotBefore(...t3).Build(), o3 = () => le$1.and(n3, r3);
  return De.Chain(o3);
} }) }, J6 = (e12) => {
  let t3 = O6();
  return e12.normalize("NFC").split(t3).filter(Boolean);
}, en = (e12, t3, n3) => {
  if (!Number.isFinite(n3) || n3 < 0) return e12;
  let r3 = [], o3 = e12.split(`
`);
  for (let i3 of o3) {
    if (En$1(i3, t3) <= n3) {
      r3.push(i3);
      continue;
    }
    let s3 = Y6(i3, t3, n3);
    r3.push(...s3);
  }
  return r3.join(`
`);
}, Y6 = (e12, t3, n3) => {
  let r3 = [], i3 = J6(e12)[Symbol.iterator](), a3 = "", s3 = 0, d3 = i3.next();
  for (; !d3.done; ) {
    let c3 = d3.value, l3 = a3 + c3, U3 = q6(c3) ? s3 + $n.calculate(c3, t3) : En$1(l3, t3);
    if (/\s/.test(c3) || U3 <= n3) {
      a3 = l3, s3 = U3, d3 = i3.next();
      continue;
    }
    if (a3) r3.push(a3.trimEnd()), a3 = "", s3 = 0;
    else {
      let p3 = C6(c3, t3, n3), m3 = p3[p3.length - 1] ?? "", b3 = p3.slice(0, -1);
      r3.push(...b3), a3 = m3, s3 = En$1(m3, t3), d3 = i3.next();
    }
  }
  if (a3) {
    let c3 = V6(a3, t3, n3);
    r3.push(c3);
  }
  return r3;
}, C6 = (e12, t3, n3) => {
  if (ca().test(e12)) return [e12];
  X6(e12);
  let r3 = [], o3 = Array.from(e12), i3 = "", a3 = 0;
  for (let s3 of o3) {
    let d3 = $n.calculate(s3, t3), c3 = a3 + d3;
    if (c3 <= n3) {
      i3 = i3 + s3, a3 = c3;
      continue;
    }
    i3 && r3.push(i3), i3 = s3, a3 = d3;
  }
  return i3 && r3.push(i3), r3;
}, V6 = (e12, t3, n3) => {
  if (!(En$1(e12, t3) > n3)) return e12;
  let [, o3, i3] = e12.match(/^(.+?)(\s+)$/) ?? [e12, e12.trimEnd(), ""], a3 = En$1(o3, t3);
  for (let s3 of Array.from(i3)) {
    let d3 = $n.calculate(s3, t3), c3 = a3 + d3;
    if (c3 > n3) break;
    o3 = o3 + s3, a3 = c3;
  }
  return o3;
}, q6 = (e12) => e12.codePointAt(0) !== void 0 && e12.codePointAt(1) === void 0, X6 = (e12) => {
  if ((c$1.MODE === je.TEST || c$1.DEV) && /\s/.test(e12)) throw new Error("Word should not contain any whitespaces!");
};
var Xe$1 = class Xe {
};
i$1(Xe$1, "rg", new RoughGenerator()), i$1(Xe$1, "cache", /* @__PURE__ */ new WeakMap()), i$1(Xe$1, "get", (t3) => Xe$1.cache.get(t3)), i$1(Xe$1, "set", (t3, n3) => Xe$1.cache.set(t3, n3)), i$1(Xe$1, "delete", (t3) => Xe$1.cache.delete(t3)), i$1(Xe$1, "destroy", () => {
  Xe$1.cache = /* @__PURE__ */ new WeakMap();
}), i$1(Xe$1, "generateElementShape", (t3, n3) => {
  let r3 = n3?.isExporting ? void 0 : Xe$1.get(t3);
  if (r3 !== void 0) return r3;
  Jo.delete(t3);
  let o3 = vd$1(t3, Xe$1.rg, n3 || { isExporting: false, canvasBackgroundColor: Z.white, embedsValidationStatus: null });
  return Xe$1.cache.set(t3, o3), o3;
});
var he = Xe$1;
var yt = (e12) => "var(--icon-fill-color)", $d = (e12) => e12 === ke.LIGHT ? _d$1.white : "#1e1e1e", R$2 = (e12, t3 = 512) => {
  let { width: n3 = 512, height: r3 = n3, mirror: o3, style: i3, ...a3 } = typeof t3 == "number" ? { width: t3 } : t3;
  return jsxRuntimeExports.jsx("svg", { "aria-hidden": "true", focusable: "false", role: "img", viewBox: `0 0 ${n3} ${r3}`, className: dM({ "rtl-mirror": o3 }), style: i3, ...a3, children: typeof e12 == "string" ? jsxRuntimeExports.jsx("path", { fill: "currentColor", d: e12 }) : e12 });
}, F$1 = { width: 24, height: 24, fill: "none", strokeWidth: 2, stroke: "currentColor", strokeLinecap: "round", strokeLinejoin: "round" }, G = { width: 20, height: 20, fill: "none", stroke: "currentColor", strokeLinecap: "round", strokeLinejoin: "round" };
R$2(jsxRuntimeExports.jsxs("g", { strokeWidth: "1.5", children: [jsxRuntimeExports.jsx("path", { stroke: "none", d: "M0 0h24v24H0z", fill: "none" }), jsxRuntimeExports.jsx("rect", { x: 3, y: 8, width: 18, height: 4, rx: 1 }), jsxRuntimeExports.jsx("line", { x1: 12, y1: 8, x2: 12, y2: 21 }), jsxRuntimeExports.jsx("path", { d: "M19 12v7a2 2 0 0 1 -2 2h-10a2 2 0 0 1 -2 -2v-7" }), jsxRuntimeExports.jsx("path", { d: "M7.5 8a2.5 2.5 0 0 1 0 -5a4.8 8 0 0 1 4.5 5a4.8 8 0 0 1 4.5 -5a2.5 2.5 0 0 1 0 5" })] }), F$1);
var Ux = R$2(jsxRuntimeExports.jsxs("g", { strokeWidth: "1.25", children: [jsxRuntimeExports.jsx("path", { stroke: "none", d: "M0 0h24v24H0z", fill: "none" }), jsxRuntimeExports.jsx("path", { d: "M3 19a9 9 0 0 1 9 0a9 9 0 0 1 9 0" }), jsxRuntimeExports.jsx("path", { d: "M3 6a9 9 0 0 1 9 0a9 9 0 0 1 9 0" }), jsxRuntimeExports.jsx("line", { x1: "3", y1: "6", x2: "3", y2: "19" }), jsxRuntimeExports.jsx("line", { x1: "12", y1: "6", x2: "12", y2: "19" }), jsxRuntimeExports.jsx("line", { x1: "21", y1: "6", x2: "21", y2: "19" })] }), F$1), fx = R$2(jsxRuntimeExports.jsxs("svg", { strokeWidth: "1.5", children: [jsxRuntimeExports.jsx("path", { stroke: "none", d: "M0 0h24v24H0z", fill: "none" }), jsxRuntimeExports.jsx("line", { x1: "12", y1: "5", x2: "12", y2: "19" }), jsxRuntimeExports.jsx("line", { x1: "5", y1: "12", x2: "19", y2: "12" })] }), F$1), px = R$2(jsxRuntimeExports.jsxs("g", { strokeWidth: "1.5", children: [jsxRuntimeExports.jsx("path", { stroke: "none", d: "M0 0h24v24H0z", fill: "none" }), jsxRuntimeExports.jsx("circle", { cx: "12", cy: "12", r: "1" }), jsxRuntimeExports.jsx("circle", { cx: "12", cy: "19", r: "1" }), jsxRuntimeExports.jsx("circle", { cx: "12", cy: "5", r: "1" })] }), F$1), ux = R$2(jsxRuntimeExports.jsxs("svg", { strokeWidth: "1.5", children: [jsxRuntimeExports.jsx("path", { stroke: "none", d: "M0 0h24v24H0z", fill: "none" }), jsxRuntimeExports.jsx("path", { d: "M9 4v6l-2 4v2h10v-2l-2 -4v-6" }), jsxRuntimeExports.jsx("line", { x1: "12", y1: "16", x2: "12", y2: "21" }), jsxRuntimeExports.jsx("line", { x1: "8", y1: "4", x2: "16", y2: "4" })] }), F$1), mx = R$2(jsxRuntimeExports.jsxs("g", { children: [jsxRuntimeExports.jsx("path", { d: "M13.542 8.542H6.458a2.5 2.5 0 0 0-2.5 2.5v3.75a2.5 2.5 0 0 0 2.5 2.5h7.084a2.5 2.5 0 0 0 2.5-2.5v-3.75a2.5 2.5 0 0 0-2.5-2.5Z", stroke: "currentColor", strokeWidth: "1.25" }), jsxRuntimeExports.jsx("path", { d: "M10 13.958a1.042 1.042 0 1 0 0-2.083 1.042 1.042 0 0 0 0 2.083Z", stroke: "currentColor", strokeWidth: "1.25" }), jsxRuntimeExports.jsx("mask", { id: "UnlockedIcon", style: { maskType: "alpha" }, maskUnits: "userSpaceOnUse", x: 6, y: 1, width: 9, height: 9, children: jsxRuntimeExports.jsx("path", { stroke: "none", d: "M6.399 9.561V5.175c0-.93.401-1.823 1.116-2.48a3.981 3.981 0 0 1 2.693-1.028c1.01 0 1.98.37 2.694 1.027.715.658 1.116 1.55 1.116 2.481", fill: "#fff" }) }), jsxRuntimeExports.jsx("g", { mask: "url(#UnlockedIcon)", children: jsxRuntimeExports.jsx("path", { stroke: "none", d: "M5.149 9.561v1.25h2.5v-1.25h-2.5Zm5.06-7.894V.417v1.25Zm2.559 3.508v1.25h2.5v-1.25h-2.5ZM7.648 8.51V5.175h-2.5V8.51h2.5Zm0-3.334c0-.564.243-1.128.713-1.561L6.668 1.775c-.959.883-1.52 2.104-1.52 3.4h2.5Zm.713-1.561a2.732 2.732 0 0 1 1.847-.697v-2.5c-1.31 0-2.585.478-3.54 1.358L8.36 3.614Zm1.847-.697c.71 0 1.374.26 1.847.697l1.694-1.839a5.231 5.231 0 0 0-3.54-1.358v2.5Zm1.847.697c.47.433.713.997.713 1.561h2.5c0-1.296-.56-2.517-1.52-3.4l-1.693 1.839Z", fill: "currentColor" }) })] }), G), bx = R$2(jsxRuntimeExports.jsxs("g", { strokeWidth: "1.25", children: [jsxRuntimeExports.jsx("path", { d: "M13.542 8.542H6.458a2.5 2.5 0 0 0-2.5 2.5v3.75a2.5 2.5 0 0 0 2.5 2.5h7.084a2.5 2.5 0 0 0 2.5-2.5v-3.75a2.5 2.5 0 0 0-2.5-2.5Z" }), jsxRuntimeExports.jsx("path", { d: "M10 13.958a1.042 1.042 0 1 0 0-2.083 1.042 1.042 0 0 0 0 2.083Z" }), jsxRuntimeExports.jsx("path", { d: "M6.667 8.333V5.417C6.667 3.806 8.159 2.5 10 2.5c1.841 0 3.333 1.306 3.333 2.917v2.916" })] }), G), Ex = R$2(jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [jsxRuntimeExports.jsx("path", { d: "M38.5 83.5c-14-2-17.833-10.473-21-22.5C14.333 48.984 12 22 12 12.5", stroke: "currentColor", strokeWidth: 2, strokeLinecap: "round" }), jsxRuntimeExports.jsx("path", { fillRule: "evenodd", clipRule: "evenodd", d: "m12.005 10.478 7.905 14.423L6 25.75l6.005-15.273Z", fill: "currentColor" }), jsxRuntimeExports.jsx("path", { d: "M12.005 10.478c1.92 3.495 3.838 7 7.905 14.423m-7.905-14.423c3.11 5.683 6.23 11.368 7.905 14.423m0 0c-3.68.226-7.35.455-13.91.85m13.91-.85c-5.279.33-10.566.647-13.91.85m0 0c1.936-4.931 3.882-9.86 6.005-15.273M6 25.75c2.069-5.257 4.135-10.505 6.005-15.272", stroke: "currentColor", strokeWidth: 2, strokeLinecap: "round" })] }), { width: 41, height: 94, fill: "none" }), gx = R$2(jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [jsxRuntimeExports.jsx("path", { d: "M18.026 1.232c-5.268 13.125-5.548 33.555 3.285 42.311 8.823 8.75 33.31 12.304 42.422 13.523", stroke: "currentColor", strokeWidth: 2, strokeLinecap: "round" }), jsxRuntimeExports.jsx("path", { fillRule: "evenodd", clipRule: "evenodd", d: "m72.181 59.247-13.058-10-2.948 13.62 16.006-3.62Z", fill: "currentColor" }), jsxRuntimeExports.jsx("path", { d: "M72.181 59.247c-3.163-2.429-6.337-4.856-13.058-10m13.058 10c-5.145-3.936-10.292-7.882-13.058-10m0 0c-.78 3.603-1.563 7.196-2.948 13.62m2.948-13.62c-1.126 5.168-2.24 10.346-2.948 13.62m0 0c5.168-1.166 10.334-2.343 16.006-3.62m-16.006 3.62c5.51-1.248 11.01-2.495 16.006-3.62", stroke: "currentColor", strokeWidth: 2, strokeLinecap: "round" })] }), { width: 85, height: 71, fill: "none" }), xx = R$2(jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [jsxRuntimeExports.jsx("path", { d: "M1 77c14-2 31.833-11.973 35-24 3.167-12.016-6-35-9.5-43.5", stroke: "currentColor", strokeWidth: 2, strokeLinecap: "round" }), jsxRuntimeExports.jsx("path", { fillRule: "evenodd", clipRule: "evenodd", d: "m24.165 1.093-2.132 16.309 13.27-4.258-11.138-12.05Z", fill: "currentColor" }), jsxRuntimeExports.jsx("path", { d: "M24.165 1.093c-.522 3.953-1.037 7.916-2.132 16.309m2.131-16.309c-.835 6.424-1.68 12.854-2.13 16.308m0 0c3.51-1.125 7.013-2.243 13.27-4.257m-13.27 4.257c5.038-1.608 10.08-3.232 13.27-4.257m0 0c-3.595-3.892-7.197-7.777-11.14-12.05m11.14 12.05c-3.837-4.148-7.667-8.287-11.14-12.05", stroke: "currentColor", strokeWidth: 2, strokeLinecap: "round" })] }), { width: 38, height: 78, fill: "none" });
R$2(jsxRuntimeExports.jsx("g", { fill: "currentColor", children: jsxRuntimeExports.jsx("path", { d: "M39.9 32.889a.326.326 0 0 0-.279-.056c-2.094-3.083-4.774-6-7.343-8.833l-.419-.472a.212.212 0 0 0-.056-.139.586.586 0 0 0-.167-.111l-.084-.083-.056-.056c-.084-.167-.28-.278-.475-.167-.782.39-1.507.973-2.206 1.528-.92.722-1.842 1.445-2.708 2.25a8.405 8.405 0 0 0-.977 1.028c-.14.194-.028.361.14.444-.615.611-1.23 1.223-1.843 1.861a.315.315 0 0 0-.084.223c0 .083.056.166.111.194l1.09.833v.028c1.535 1.528 4.244 3.611 7.12 5.861.418.334.865.667 1.284 1 .195.223.39.473.558.695.084.11.28.139.391.055.056.056.14.111.196.167a.398.398 0 0 0 .167.056.255.255 0 0 0 .224-.111.394.394 0 0 0 .055-.167c.029 0 .028.028.056.028a.318.318 0 0 0 .224-.084l5.082-5.528a.309.309 0 0 0 0-.444Zm-14.63-1.917a.485.485 0 0 0 .111.14c.586.5 1.2 1 1.843 1.555l-2.569-1.945-.251-.166c-.056-.028-.112-.084-.168-.111l-.195-.167.056-.056.055-.055.112-.111c.866-.861 2.346-2.306 3.1-3.028-.81.805-2.43 3.167-2.095 3.944Zm8.767 6.89-2.122-1.612a44.713 44.713 0 0 0-2.625-2.5c1.145.861 2.122 1.611 2.262 1.75 1.117.972 1.06.806 1.815 1.445l.921.666a1.06 1.06 0 0 1-.251.25Zm.558.416-.056-.028c.084-.055.168-.111.252-.194l-.196.222ZM1.089 5.75c.055.361.14.722.195 1.056.335 1.833.67 3.5 1.284 4.75l.252.944c.084.361.223.806.363.917 1.424 1.25 3.602 3.11 5.947 4.889a.295.295 0 0 0 .363 0s0 .027.028.027a.254.254 0 0 0 .196.084.318.318 0 0 0 .223-.084c2.988-3.305 5.221-6.027 6.813-8.305.112-.111.14-.278.14-.417.111-.111.195-.25.307-.333.111-.111.111-.306 0-.39l-.028-.027c0-.055-.028-.139-.084-.167-.698-.666-1.2-1.138-1.731-1.638-.922-.862-1.871-1.75-3.881-3.75l-.028-.028c-.028-.028-.056-.056-.112-.056-.558-.194-1.703-.389-3.127-.639C6.087 2.223 3.21 1.723.614.944c0 0-.168 0-.196.028l-.083.084c-.028.027-.056.055-.224.11h.056-.056c.028.167.028.278.084.473 0 .055.112.5.112.555l.782 3.556Zm15.496 3.278-.335-.334c.084.112.196.195.335.334Zm-3.546 4.666-.056.056c0-.028.028-.056.056-.056Zm-2.038-10c.168.167.866.834 1.033.973-.726-.334-2.54-1.167-3.379-1.445.838.167 1.983.334 2.346.472ZM1.424 2.306c.419.722.754 3.222 1.089 5.666-.196-.778-.335-1.555-.503-2.278-.251-1.277-.503-2.416-.838-3.416.056 0 .14 0 .252.028Zm-.168-.584c-.112 0-.223-.028-.307-.028 0-.027 0-.055-.028-.055.14 0 .223.028.335.083Zm-1.089.222c0-.027 0-.027 0 0ZM39.453 1.333c.028-.11-.558-.61-.363-.639.42-.027.42-.666 0-.666-.558.028-1.144.166-1.675.25-.977.194-1.982.389-2.96.61-2.205.473-4.383.973-6.561 1.557-.67.194-1.424.333-2.066.666-.224.111-.196.333-.084.472-.056.028-.084.028-.14.056-.195.028-.363.056-.558.083-.168.028-.252.167-.224.334 0 .027.028.083.028.11-1.173 1.556-2.485 3.195-3.909 4.945-1.396 1.611-2.876 3.306-4.356 5.056-4.719 5.5-10.052 11.75-15.943 17.25a.268.268 0 0 0 0 .389c.028.027.056.055.084.055-.084.084-.168.14-.252.222-.056.056-.084.111-.084.167a.605.605 0 0 0-.111.139c-.112.111-.112.305.028.389.111.11.307.11.39-.028.029-.028.029-.056.056-.056a.44.44 0 0 1 .615 0c.335.362.67.723.977 1.028l-.698-.583c-.112-.111-.307-.083-.39.028-.113.11-.085.305.027.389l7.427 6.194c.056.056.112.056.196.056s.14-.028.195-.084l.168-.166c.028.027.083.027.111.027.084 0 .14-.027.196-.083 10.052-10.055 18.15-17.639 27.42-24.417.083-.055.111-.166.111-.25.112 0 .196-.083.251-.194 1.704-5.194 2.039-9.806 2.15-12.083v-.028c0-.028.028-.056.028-.083.028-.056.028-.084.028-.084a1.626 1.626 0 0 0-.111-1.028ZM21.472 9.5c.446-.5.893-1.028 1.34-1.5-2.876 3.778-7.65 9.583-14.408 16.5 4.607-5.083 9.242-10.333 13.068-15ZM5.193 35.778h.084-.084Zm3.462 3.194c-.027-.028-.027-.028 0-.028v.028Zm4.16-3.583c.224-.25.448-.472.699-.722 0 0 0 .027.028.027-.252.223-.475.445-.726.695Zm1.146-1.111c.14-.14.279-.334.446-.5l.028-.028c1.648-1.694 3.351-3.389 5.082-5.111l.028-.028c.419-.333.921-.694 1.368-1.028a379.003 379.003 0 0 0-6.952 6.695ZM24.794 6.472c-.921 1.195-1.954 2.778-2.82 4.028-2.736 3.944-11.532 13.583-11.727 13.75a1976.983 1976.983 0 0 1-8.042 7.639l-.167.167c-.14-.167-.14-.417.028-.556C14.49 19.861 22.03 10.167 25.074 5.917c-.084.194-.14.36-.28.555Zm4.83 5.695c-1.116-.64-1.646-1.64-1.34-2.611l.084-.334c.028-.083.084-.194.14-.277.307-.5.754-.917 1.257-1.167.027 0 .055 0 .083-.028-.028-.056-.028-.139-.028-.222.028-.167.14-.278.335-.278.335 0 1.369.306 1.76.639.111.083.223.194.335.305.14.167.363.445.474.667.056.028.112.306.196.445.056.222.111.472.084.694-.028.028 0 .194-.028.194a2.668 2.668 0 0 1-.363 1.028c-.028.028-.028.056-.056.084l-.028.027c-.14.223-.335.417-.53.556-.643.444-1.369.583-2.095.389 0 0-.195-.084-.28-.111Zm8.154-.834a39.098 39.098 0 0 1-.893 3.167c0 .028-.028.083 0 .111-.056 0-.084.028-.14.056-2.206 1.61-4.356 3.305-6.506 5.028 1.843-1.64 3.686-3.306 5.613-4.945.558-.5.949-1.139 1.06-1.861l.28-1.667v-.055c.14-.334.67-.195.586.166Z", fill: "currentColor" }) }), { width: 40, height: 40, fill: "none" });
var Pd$1 = R$2(jsxRuntimeExports.jsxs("g", { stroke: "currentColor", strokeLinecap: "round", strokeLinejoin: "round", children: [jsxRuntimeExports.jsx("path", { stroke: "none", d: "M0 0h24v24H0z", fill: "none" }), jsxRuntimeExports.jsx("path", { d: "M6 6l4.153 11.793a0.365 .365 0 0 0 .331 .207a0.366 .366 0 0 0 .332 -.207l2.184 -4.793l4.787 -1.994a0.355 .355 0 0 0 .213 -.323a0.355 .355 0 0 0 -.213 -.323l-11.787 -4.36z" }), jsxRuntimeExports.jsx("path", { d: "M13.5 13.5l4.5 4.5" })] }), { fill: "none", width: 22, height: 22, strokeWidth: 1.25 }), Nd = R$2(jsxRuntimeExports.jsxs("g", { strokeWidth: "1.5", children: [jsxRuntimeExports.jsx("path", { stroke: "none", d: "M0 0h24v24H0z", fill: "none" }), jsxRuntimeExports.jsx("rect", { x: "4", y: "4", width: "16", height: "16", rx: "2" })] }), F$1), Fd$1 = R$2(jsxRuntimeExports.jsxs("g", { strokeWidth: "1.5", children: [jsxRuntimeExports.jsx("path", { stroke: "none", d: "M0 0h24v24H0z", fill: "none" }), jsxRuntimeExports.jsx("path", { d: "M10.5 20.4l-6.9 -6.9c-.781 -.781 -.781 -2.219 0 -3l6.9 -6.9c.781 -.781 2.219 -.781 3 0l6.9 6.9c.781 .781 .781 2.219 0 3l-6.9 6.9c-.781 .781 -2.219 .781 -3 0z" })] }), F$1), Bd$1 = R$2(jsxRuntimeExports.jsxs("g", { strokeWidth: "1.5", children: [jsxRuntimeExports.jsx("path", { stroke: "none", d: "M0 0h24v24H0z", fill: "none" }), jsxRuntimeExports.jsx("circle", { cx: "12", cy: "12", r: "9" })] }), F$1), _d = R$2(jsxRuntimeExports.jsxs("g", { strokeWidth: "1.5", children: [jsxRuntimeExports.jsx("path", { stroke: "none", d: "M0 0h24v24H0z", fill: "none" }), jsxRuntimeExports.jsx("line", { x1: "5", y1: "12", x2: "19", y2: "12" }), jsxRuntimeExports.jsx("line", { x1: "15", y1: "16", x2: "19", y2: "12" }), jsxRuntimeExports.jsx("line", { x1: "15", y1: "8", x2: "19", y2: "12" })] }), F$1), Od$1 = R$2(jsxRuntimeExports.jsx("path", { d: "M4.167 10h11.666", strokeWidth: "1.5" }), G), yx = R$2(jsxRuntimeExports.jsxs("g", { strokeWidth: "1.25", children: [jsxRuntimeExports.jsx("path", { stroke: "none", d: "M0 0h24v24H0z", fill: "none" }), jsxRuntimeExports.jsx("path", { d: "M20 17v-12c0 -1.121 -.879 -2 -2 -2s-2 .879 -2 2v12l2 2l2 -2z" }), jsxRuntimeExports.jsx("path", { d: "M16 7h4" }), jsxRuntimeExports.jsx("path", { d: "M18 19h-13a2 2 0 1 1 0 -4h4a2 2 0 1 0 0 -4h-3" })] }), F$1), Nr$1 = R$2(jsxRuntimeExports.jsxs("g", { strokeWidth: "1.25", children: [jsxRuntimeExports.jsx("path", { clipRule: "evenodd", d: "m7.643 15.69 7.774-7.773a2.357 2.357 0 1 0-3.334-3.334L4.31 12.357a3.333 3.333 0 0 0-.977 2.357v1.953h1.953c.884 0 1.732-.352 2.357-.977Z" }), jsxRuntimeExports.jsx("path", { d: "m11.25 5.417 3.333 3.333" })] }), G), Ad$1 = R$2(jsxRuntimeExports.jsxs("g", { strokeWidth: "1.5", children: [jsxRuntimeExports.jsx("path", { stroke: "none", d: "M0 0h24v24H0z", fill: "none" }), jsxRuntimeExports.jsx("line", { x1: "4", y1: "20", x2: "7", y2: "20" }), jsxRuntimeExports.jsx("line", { x1: "14", y1: "20", x2: "21", y2: "20" }), jsxRuntimeExports.jsx("line", { x1: "6.9", y1: "15", x2: "13.8", y2: "15" }), jsxRuntimeExports.jsx("line", { x1: "10.2", y1: "6.3", x2: "16", y2: "20" }), jsxRuntimeExports.jsx("polyline", { points: "5 20 11 4 13 4 20 20" })] }), F$1), Kd = R$2(jsxRuntimeExports.jsxs("g", { strokeWidth: "1.25", children: [jsxRuntimeExports.jsx("path", { d: "M12.5 6.667h.01" }), jsxRuntimeExports.jsx("path", { d: "M4.91 2.625h10.18a2.284 2.284 0 0 1 2.285 2.284v10.182a2.284 2.284 0 0 1-2.284 2.284H4.909a2.284 2.284 0 0 1-2.284-2.284V4.909a2.284 2.284 0 0 1 2.284-2.284Z" }), jsxRuntimeExports.jsx("path", { d: "m3.333 12.5 3.334-3.333c.773-.745 1.726-.745 2.5 0l4.166 4.166" }), jsxRuntimeExports.jsx("path", { d: "m11.667 11.667.833-.834c.774-.744 1.726-.744 2.5 0l1.667 1.667" })] }), G), Hd = R$2(jsxRuntimeExports.jsxs("g", { strokeWidth: "1.5", children: [jsxRuntimeExports.jsx("path", { stroke: "none", d: "M0 0h24v24H0z", fill: "none" }), jsxRuntimeExports.jsx("path", { d: "M19 20h-10.5l-4.21 -4.3a1 1 0 0 1 0 -1.41l10 -10a1 1 0 0 1 1.41 0l5 5a1 1 0 0 1 0 1.41l-9.2 9.3" }), jsxRuntimeExports.jsx("path", { d: "M18 13.3l-6.3 -6.3" })] }), F$1), Ix = R$2(jsxRuntimeExports.jsx("path", { strokeWidth: "1.25", d: "M10 4.167v11.666M4.167 10h11.666" }), G), wx = R$2(jsxRuntimeExports.jsx("path", { d: "M5 10h10", strokeWidth: "1.25" }), G), Rx = R$2(jsxRuntimeExports.jsxs("g", { strokeWidth: 1.25, children: [jsxRuntimeExports.jsx("path", { stroke: "none", d: "M0 0h24v24H0z", fill: "none" }), jsxRuntimeExports.jsx("path", { d: "M21 21l-6 -6" }), jsxRuntimeExports.jsx("path", { d: "M3.268 12.043a7.017 7.017 0 0 0 6.634 4.957a7.012 7.012 0 0 0 7.043 -6.131a7 7 0 0 0 -5.314 -7.672a7.021 7.021 0 0 0 -8.241 4.403" }), jsxRuntimeExports.jsx("path", { d: "M3 4v4h4" })] }), F$1), Tx = R$2(jsxRuntimeExports.jsx("path", { strokeWidth: "1.25", d: "M3.333 5.833h13.334M8.333 9.167v5M11.667 9.167v5M4.167 5.833l.833 10c0 .92.746 1.667 1.667 1.667h6.666c.92 0 1.667-.746 1.667-1.667l.833-10M7.5 5.833v-2.5c0-.46.373-.833.833-.833h3.334c.46 0 .833.373.833.833v2.5" }), G), Mx = R$2(jsxRuntimeExports.jsxs("g", { strokeWidth: "1.25", children: [jsxRuntimeExports.jsx("polyline", { points: "12 16 18 10 12 4" }), jsxRuntimeExports.jsx("polyline", { points: "8 4 2 10 8 16" })] }), G), Lx = R$2(jsxRuntimeExports.jsxs("g", { strokeWidth: "1.25", children: [jsxRuntimeExports.jsx("path", { d: "M14.375 6.458H8.958a2.5 2.5 0 0 0-2.5 2.5v5.417a2.5 2.5 0 0 0 2.5 2.5h5.417a2.5 2.5 0 0 0 2.5-2.5V8.958a2.5 2.5 0 0 0-2.5-2.5Z" }), jsxRuntimeExports.jsx("path", { clipRule: "evenodd", d: "M11.667 3.125c.517 0 .986.21 1.325.55.34.338.55.807.55 1.325v1.458H8.333c-.485 0-.927.185-1.26.487-.343.312-.57.75-.609 1.24l-.005 5.357H5a1.87 1.87 0 0 1-1.326-.55 1.87 1.87 0 0 1-.549-1.325V5c0-.518.21-.987.55-1.326.338-.34.807-.549 1.325-.549h6.667Z" })] }), G), Dx = R$2(jsxRuntimeExports.jsx("path", { clipRule: "evenodd", d: "M10 2.5h.328a6.25 6.25 0 0 0 6.6 10.372A7.5 7.5 0 1 1 10 2.493V2.5Z", stroke: "currentColor" }), G), Sx = R$2(jsxRuntimeExports.jsx("g", { stroke: "currentColor", strokeLinejoin: "round", children: jsxRuntimeExports.jsx("path", { d: "M10 12.5a2.5 2.5 0 1 0 0-5 2.5 2.5 0 0 0 0 5ZM10 4.167V2.5M14.167 5.833l1.166-1.166M15.833 10H17.5M14.167 14.167l1.166 1.166M10 15.833V17.5M5.833 14.167l-1.166 1.166M5 10H3.333M5.833 5.833 4.667 4.667" }) }), { ...G, strokeWidth: 1.5 }), vx = R$2(jsxRuntimeExports.jsxs("g", { strokeWidth: "1.5", children: [jsxRuntimeExports.jsx("path", { stroke: "none", d: "M0 0h24v24H0z", fill: "none" }), jsxRuntimeExports.jsx("line", { x1: "4", y1: "6", x2: "20", y2: "6" }), jsxRuntimeExports.jsx("line", { x1: "4", y1: "12", x2: "20", y2: "12" }), jsxRuntimeExports.jsx("line", { x1: "4", y1: "18", x2: "20", y2: "18" })] }), F$1), $x = R$2(jsxRuntimeExports.jsx("path", { strokeWidth: "1.25", d: "M3.333 14.167v1.666c0 .92.747 1.667 1.667 1.667h10c.92 0 1.667-.746 1.667-1.667v-1.666M5.833 9.167 10 13.333l4.167-4.166M10 3.333v10" }), G), Px = R$2(jsxRuntimeExports.jsxs("g", { strokeWidth: "1.5", children: [jsxRuntimeExports.jsx("path", { stroke: "none", d: "M0 0h24v24H0z", fill: "none" }), jsxRuntimeExports.jsx("circle", { cx: "12", cy: "12", r: "9" }), jsxRuntimeExports.jsx("line", { x1: "12", y1: "17", x2: "12", y2: "17.01" }), jsxRuntimeExports.jsx("path", { d: "M12 13.5a1.5 1.5 0 0 1 1 -1.5a2.6 2.6 0 1 0 -3 -4" })] }), F$1), Nx = R$2(jsxRuntimeExports.jsxs("g", { strokeWidth: "1.25", children: [jsxRuntimeExports.jsx("path", { stroke: "none", d: "M0 0h24v24H0z", fill: "none" }), jsxRuntimeExports.jsx("circle", { cx: "12", cy: "12", r: "9" }), jsxRuntimeExports.jsx("line", { x1: "12", y1: "17", x2: "12", y2: "17.01" }), jsxRuntimeExports.jsx("path", { d: "M12 13.5a1.5 1.5 0 0 1 1 -1.5a2.6 2.6 0 1 0 -3 -4" })] }), F$1), Fx = R$2(jsxRuntimeExports.jsx("path", { strokeWidth: "1.25", d: "M9.167 5.833H5.833c-1.254 0-2.5 1.282-2.5 2.5v5.834c0 1.283 1.252 2.5 2.5 2.5h5.834c1.251 0 2.5-1.25 2.5-2.5v-3.334M8.333 11.667l8.334-8.334M12.5 3.333h4.167V7.5" }), G), Bx = R$2(jsxRuntimeExports.jsx("path", { d: "M7.5 15.833c-3.583 1.167-3.583-2.083-5-2.5m10 4.167v-2.917c0-.833.083-1.166-.417-1.666 2.334-.25 4.584-1.167 4.584-5a3.833 3.833 0 0 0-1.084-2.667 3.5 3.5 0 0 0-.083-2.667s-.917-.25-2.917 1.084a10.25 10.25 0 0 0-5.166 0C5.417 2.333 4.5 2.583 4.5 2.583a3.5 3.5 0 0 0-.083 2.667 3.833 3.833 0 0 0-1.084 2.667c0 3.833 2.25 4.75 4.584 5-.5.5-.5 1-.417 1.666V17.5", strokeWidth: "1.25" }), G), _x = R$2(jsxRuntimeExports.jsxs("g", { strokeWidth: "1.25", children: [jsxRuntimeExports.jsx("path", { d: "M7.5 10.833a.833.833 0 1 0 0-1.666.833.833 0 0 0 0 1.666ZM12.5 10.833a.833.833 0 1 0 0-1.666.833.833 0 0 0 0 1.666ZM6.25 6.25c2.917-.833 4.583-.833 7.5 0M5.833 13.75c2.917.833 5.417.833 8.334 0" }), jsxRuntimeExports.jsx("path", { d: "M12.917 14.167c0 .833 1.25 2.5 1.666 2.5 1.25 0 2.361-1.39 2.917-2.5.556-1.39.417-4.861-1.25-9.584-1.214-.846-2.5-1.116-3.75-1.25l-.833 2.084M7.083 14.167c0 .833-1.13 2.5-1.526 2.5-1.191 0-2.249-1.39-2.778-2.5-.529-1.39-.397-4.861 1.19-9.584 1.157-.846 2.318-1.116 3.531-1.25l.833 2.084" })] }), G), Ox = R$2(jsxRuntimeExports.jsxs("g", { strokeWidth: "1.25", children: [jsxRuntimeExports.jsx("path", { stroke: "none", d: "M0 0h24v24H0z", fill: "none" }), jsxRuntimeExports.jsx("path", { d: "M4 4l11.733 16h4.267l-11.733 -16z" }), jsxRuntimeExports.jsx("path", { d: "M4 20l6.768 -6.768m2.46 -2.46l6.772 -6.772" })] }), F$1), Ax = R$2(jsxRuntimeExports.jsx("polyline", { fill: "none", stroke: "currentColor", points: "20 6 9 17 4 12" }), { width: 24, height: 24 }), Kx = R$2(jsxRuntimeExports.jsxs("g", { strokeWidth: "1.25", children: [jsxRuntimeExports.jsx("path", { d: "M8.333 11.667a2.917 2.917 0 0 0 4.167 0l3.333-3.334a2.946 2.946 0 1 0-4.166-4.166l-.417.416" }), jsxRuntimeExports.jsx("path", { d: "M11.667 8.333a2.917 2.917 0 0 0-4.167 0l-3.333 3.334a2.946 2.946 0 0 0 4.166 4.166l.417-.416" })] }), G), Hx = R$2("M433.941 129.941l-83.882-83.882A48 48 0 0 0 316.118 32H48C21.49 32 0 53.49 0 80v352c0 26.51 21.49 48 48 48h352c26.51 0 48-21.49 48-48V163.882a48 48 0 0 0-14.059-33.941zM224 416c-35.346 0-64-28.654-64-64 0-35.346 28.654-64 64-64s64 28.654 64 64c0 35.346-28.654 64-64 64zm96-304.52V212c0 6.627-5.373 12-12 12H76c-6.627 0-12-5.373-12-12V108c0-6.627 5.373-12 12-12h228.52c3.183 0 6.235 1.264 8.485 3.515l3.48 3.48A11.996 11.996 0 0 1 320 111.48z", { width: 448, height: 512 }), Jx = R$2("M252 54L203 8a28 27 0 00-20-8H28C12 0 0 12 0 27v195c0 15 12 26 28 26h204c15 0 28-11 28-26V73a28 27 0 00-8-19zM130 213c-21 0-37-16-37-36 0-19 16-35 37-35 20 0 37 16 37 35 0 20-17 36-37 36zm56-169v56c0 4-4 6-7 6H44c-4 0-7-2-7-6V42c0-4 3-7 7-7h133l4 2 3 2a7 7 0 012 5z M296 201l87 95-188 205-78 9c-10 1-19-8-18-20l9-84zm141-14l-41-44a31 31 0 00-46 0l-38 41 87 95 38-42c13-14 13-36 0-50z", { width: 448, height: 512 }), Yx = R$2(jsxRuntimeExports.jsx("path", { d: "m9.257 6.351.183.183H15.819c.34 0 .727.182 1.051.506.323.323.505.708.505 1.05v5.819c0 .316-.183.7-.52 1.035-.337.338-.723.522-1.037.522H4.182c-.352 0-.74-.181-1.058-.5-.318-.318-.499-.705-.499-1.057V5.182c0-.351.181-.736.5-1.054.32-.321.71-.503 1.057-.503H6.53l2.726 2.726Z", strokeWidth: "1.25" }), G);
R$2("M384 112v352c0 26.51-21.49 48-48 48H48c-26.51 0-48-21.49-48-48V112c0-26.51 21.49-48 48-48h80c0-35.29 28.71-64 64-64s64 28.71 64 64h80c26.51 0 48 21.49 48 48zM192 40c-13.255 0-24 10.745-24 24s10.745 24 24 24 24-10.745 24-24-10.745-24-24-24m96 114v-20a6 6 0 0 0-6-6H102a6 6 0 0 0-6 6v20a6 6 0 0 0 6 6h180a6 6 0 0 0 6-6z", { width: 384, height: 512 });
var Vx = R$2("M204.3 5C104.9 24.4 24.8 104.3 5.2 203.4c-37 187 131.7 326.4 258.8 306.7 41.2-6.4 61.4-54.6 42.5-91.7-23.1-45.4 9.9-98.4 60.9-98.4h79.7c35.8 0 64.8-29.6 64.9-65.3C511.5 97.1 368.1-26.9 204.3 5zM96 320c-17.7 0-32-14.3-32-32s14.3-32 32-32 32 14.3 32 32-14.3 32-32 32zm32-128c-17.7 0-32-14.3-32-32s14.3-32 32-32 32 14.3 32 32-14.3 32-32 32zm128-64c-17.7 0-32-14.3-32-32s14.3-32 32-32 32 14.3 32 32-14.3 32-32 32zm128 64c-17.7 0-32-14.3-32-32s14.3-32 32-32 32 14.3 32 32-14.3 32-32 32z"), qx = R$2(jsxRuntimeExports.jsxs("g", { strokeWidth: 1.25, children: [jsxRuntimeExports.jsx("path", { stroke: "none", d: "M0 0h24v24H0z", fill: "none" }), jsxRuntimeExports.jsx("path", { d: "M5 16l1.465 1.638a2 2 0 1 1 -3.015 .099l1.55 -1.737z" }), jsxRuntimeExports.jsx("path", { d: "M13.737 9.737c2.299 -2.3 3.23 -5.095 2.081 -6.245c-1.15 -1.15 -3.945 -.217 -6.244 2.082c-2.3 2.299 -3.231 5.095 -2.082 6.244c1.15 1.15 3.946 .218 6.245 -2.081z" }), jsxRuntimeExports.jsx("path", { d: "M7.492 11.818c.362 .362 .768 .676 1.208 .934l6.895 4.047c1.078 .557 2.255 -.075 3.692 -1.512c1.437 -1.437 2.07 -2.614 1.512 -3.692c-.372 -.718 -1.72 -3.017 -4.047 -6.895a6.015 6.015 0 0 0 -.934 -1.208" })] }), F$1), Xx = R$2(jsxRuntimeExports.jsxs("g", { strokeWidth: "1.25", children: [jsxRuntimeExports.jsx("path", { stroke: "none", d: "M0 0h24v24H0z", fill: "none" }), jsxRuntimeExports.jsx("path", { d: "M15 8h.01" }), jsxRuntimeExports.jsx("path", { d: "M12 20h-5a3 3 0 0 1 -3 -3v-10a3 3 0 0 1 3 -3h10a3 3 0 0 1 3 3v5" }), jsxRuntimeExports.jsx("path", { d: "M4 15l4 -4c.928 -.893 2.072 -.893 3 0l4 4" }), jsxRuntimeExports.jsx("path", { d: "M14 14l1 -1c.617 -.593 1.328 -.793 2.009 -.598" }), jsxRuntimeExports.jsx("path", { d: "M19 16v6" }), jsxRuntimeExports.jsx("path", { d: "M22 19l-3 3l-3 -3" })] }), F$1), Gx = R$2("M216 0h80c13.3 0 24 10.7 24 24v168h87.7c17.8 0 26.7 21.5 14.1 34.1L269.7 378.3c-7.5 7.5-19.8 7.5-27.3 0L90.1 226.1c-12.6-12.6-3.7-34.1 14.1-34.1H192V24c0-13.3 10.7-24 24-24zm296 376v112c0 13.3-10.7 24-24 24H24c-13.3 0-24-10.7-24-24V376c0-13.3 10.7-24 24-24h146.7l49 49c20.1 20.1 52.5 20.1 72.6 0l49-49H488c13.3 0 24 10.7 24 24zm-124 88c0-11-9-20-20-20s-20 9-20 20 9 20 20 20 20-9 20-20zm64 0c0-11-9-20-20-20s-20 9-20 20 9 20 20 20 20-9 20-20z", { width: 512, height: 512 });
R$2("M416 208H272V64c0-17.67-14.33-32-32-32h-32c-17.67 0-32 14.33-32 32v144H32c-17.67 0-32 14.33-32 32v32c0 17.67 14.33 32 32 32h144v144c0 17.67 14.33 32 32 32h32c17.67 0 32-14.33 32-32V304h144c17.67 0 32-14.33 32-32v-32c0-17.67-14.33-32-32-32z", { width: 448, height: 512 });
R$2("M416 208H32c-17.67 0-32 14.33-32 32v32c0 17.67 14.33 32 32 32h384c17.67 0 32-14.33 32-32v-32c0-17.67-14.33-32-32-32z", { width: 448, height: 512 });
var Wx = R$2("M173.898 439.404l-166.4-166.4c-9.997-9.997-9.997-26.206 0-36.204l36.203-36.204c9.997-9.998 26.207-9.998 36.204 0L192 312.69 432.095 72.596c9.997-9.997 26.207-9.997 36.204 0l36.203 36.204c9.997 9.997 9.997 26.206 0 36.204l-294.4 294.401c-9.998 9.997-26.207 9.997-36.204-.001z");
R$2("M16 132h416c8.837 0 16-7.163 16-16V76c0-8.837-7.163-16-16-16H16C7.163 60 0 67.163 0 76v40c0 8.837 7.163 16 16 16zm0 160h416c8.837 0 16-7.163 16-16v-40c0-8.837-7.163-16-16-16H16c-8.837 0-16 7.163-16 16v40c0 8.837 7.163 16 16 16zm0 160h416c8.837 0 16-7.163 16-16v-40c0-8.837-7.163-16-16-16H16c-8.837 0-16 7.163-16 16v40c0 8.837 7.163 16 16 16z");
var Qx = R$2(jsxRuntimeExports.jsx("path", { d: "M7.5 10.833 4.167 7.5 7.5 4.167M4.167 7.5h9.166a3.333 3.333 0 0 1 0 6.667H12.5", strokeWidth: "1.25" }), G), jx = R$2(jsxRuntimeExports.jsx("path", { d: "M12.5 10.833 15.833 7.5 12.5 4.167M15.833 7.5H6.667a3.333 3.333 0 1 0 0 6.667H7.5", strokeWidth: "1.25" }), G), eh = R$2("M504 256c0 136.997-111.043 248-248 248S8 392.997 8 256C8 119.083 119.043 8 256 8s248 111.083 248 248zM262.655 90c-54.497 0-89.255 22.957-116.549 63.758-3.536 5.286-2.353 12.415 2.715 16.258l34.699 26.31c5.205 3.947 12.621 3.008 16.665-2.122 17.864-22.658 30.113-35.797 57.303-35.797 20.429 0 45.698 13.148 45.698 32.958 0 14.976-12.363 22.667-32.534 33.976C247.128 238.528 216 254.941 216 296v4c0 6.627 5.373 12 12 12h56c6.627 0 12-5.373 12-12v-1.333c0-28.462 83.186-29.647 83.186-106.667 0-58.002-60.165-102-116.531-102zM256 338c-25.365 0-46 20.635-46 46 0 25.364 20.635 46 46 46s46-20.636 46-46c0-25.365-20.635-46-46-46z", { mirror: true });
R$2(jsxRuntimeExports.jsx("path", { d: "M5 12.5a2.5 2.5 0 1 0 0-5 2.5 2.5 0 0 0 0 5ZM15 7.5a2.5 2.5 0 1 0 0-5 2.5 2.5 0 0 0 0 5ZM15 17.5a2.5 2.5 0 1 0 0-5 2.5 2.5 0 0 0 0 5ZM7.25 8.917l5.5-2.834M7.25 11.083l5.5 2.834", strokeWidth: "1.5" }), G);
R$2("M256 32c14.2 0 27.3 7.5 34.5 19.8l216 368c7.3 12.4 7.3 27.7 .2 40.1S486.3 480 472 480H40c-14.3 0-27.6-7.7-34.7-20.1s-7-27.8 .2-40.1l216-368C228.7 39.5 241.8 32 256 32zm0 128c-13.3 0-24 10.7-24 24V296c0 13.3 10.7 24 24 24s24-10.7 24-24V184c0-13.3-10.7-24-24-24zm32 224a32 32 0 1 0 -64 0 32 32 0 1 0 64 0z");
R$2("M16 5l-1.42 1.42-1.59-1.59V16h-1.98V4.83L9.42 6.42 8 5l4-4 4 4zm4 5v11c0 1.1-.9 2-2 2H6c-1.11 0-2-.9-2-2V10c0-1.11.89-2 2-2h3v2H6v11h12V10h-3V8h3c1.1 0 2 .89 2 2z", { width: 24, height: 24 });
R$2(jsxRuntimeExports.jsxs("g", { strokeWidth: 1.25, children: [jsxRuntimeExports.jsx("path", { stroke: "none", d: "M0 0h24v24H0z", fill: "none" }), jsxRuntimeExports.jsx("path", { d: "M8 9h-1a2 2 0 0 0 -2 2v8a2 2 0 0 0 2 2h10a2 2 0 0 0 2 -2v-8a2 2 0 0 0 -2 -2h-1" }), jsxRuntimeExports.jsx("path", { d: "M12 14v-11" }), jsxRuntimeExports.jsx("path", { d: "M9 6l3 -3l3 3" })] }), F$1);
R$2(jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [jsxRuntimeExports.jsx("path", { fill: "currentColor", d: "M40 5.6v6.1l-4.1.7c-8.9 1.4-16.5 6.9-20.6 15C13 32 10.9 43 12.4 43c.4 0 2.4-1.3 4.4-3 5-3.9 12.1-7 18.2-7.7l5-.6v12.8l11.2-11.3L62.5 22 51.2 10.8 40-.5v6.1zm10.2 22.6L44 34.5v-6.8l-6.9.6c-3.9.3-9.8 1.7-13.2 3.1-3.5 1.4-6.5 2.4-6.7 2.2-.9-1 3-7.5 6.4-10.8C28 18.6 34.4 16 40.1 16c3.7 0 3.9-.1 3.9-3.2V9.5l6.2 6.3 6.3 6.2-6.3 6.2z" }), jsxRuntimeExports.jsx("path", { stroke: "currentColor", fill: "currentColor", d: "M0 36v20h48v-6.2c0-6 0-6.1-2-4.3-1.1 1-2 2.9-2 4.2V52H4V34c0-17.3-.1-18-2-18s-2 .7-2 20z" })] }), { width: 64, height: 64 });
R$2(jsxRuntimeExports.jsx("path", { stroke: "currentColor", strokeWidth: "40", fill: "currentColor", d: "M148 560a318 318 0 0 0 522 110 316 316 0 0 0 0-450 316 316 0 0 0-450 0c-11 11-21 22-30 34v4h47c25 0 46 21 46 46s-21 45-46 45H90c-13 0-25-6-33-14-9-9-14-20-14-33V156c0-25 20-45 45-45s45 20 45 45v32l1 1a401 401 0 0 1 623 509l212 212a42 42 0 0 1-59 59L698 757A401 401 0 0 1 65 570a42 42 0 0 1 83-10z" }), { width: 1024 });
var Jd = jsxRuntimeExports.jsxs("g", { strokeWidth: 1.5, children: [jsxRuntimeExports.jsx("path", { stroke: "none", d: "M0 0h24v24H0z", fill: "none" }), jsxRuntimeExports.jsx("path", { d: "M12 10l0 10" }), jsxRuntimeExports.jsx("path", { d: "M12 10l4 4" }), jsxRuntimeExports.jsx("path", { d: "M12 10l-4 4" }), jsxRuntimeExports.jsx("path", { d: "M4 4l16 0" })] }), Yd = jsxRuntimeExports.jsxs("g", { strokeWidth: 1.5, children: [jsxRuntimeExports.jsx("path", { stroke: "none", d: "M0 0h24v24H0z", fill: "none" }), jsxRuntimeExports.jsx("path", { d: "M12 5l0 14" }), jsxRuntimeExports.jsx("path", { d: "M16 9l-4 -4" }), jsxRuntimeExports.jsx("path", { d: "M8 9l4 -4" })] }), sh = R$2(Yd, F$1), dh = R$2(Yd, { ...F$1, style: { transform: "rotate(180deg)" } }), ch = R$2(Jd, F$1), lh = R$2(Jd, { ...F$1, style: { transform: "rotate(180deg)" } }), Uh = R$2(jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [jsxRuntimeExports.jsxs("g", { clipPath: "url(#a)", stroke: "currentColor", strokeWidth: "1.25", children: [jsxRuntimeExports.jsx("path", { d: "M3.333 3.333h13.334", strokeLinecap: "round", strokeLinejoin: "round" }), jsxRuntimeExports.jsx("path", { d: "M13.542 6.458h-.417c-.92 0-1.667.747-1.667 1.667v7.083c0 .92.746 1.667 1.667 1.667h.417c.92 0 1.666-.746 1.666-1.667V8.125c0-.92-.746-1.667-1.666-1.667ZM6.875 6.458h-.417c-.92 0-1.666.747-1.666 1.667v3.75c0 .92.746 1.667 1.666 1.667h.417c.92 0 1.667-.746 1.667-1.667v-3.75c0-.92-.747-1.667-1.667-1.667Z" })] }), jsxRuntimeExports.jsx("defs", { children: jsxRuntimeExports.jsx("clipPath", { id: "a", children: jsxRuntimeExports.jsx("path", { fill: "#fff", d: "M0 0h20v20H0z" }) }) })] }), G), fh = R$2(jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [jsxRuntimeExports.jsxs("g", { clipPath: "url(#a)", stroke: "currentColor", strokeWidth: "1.25", children: [jsxRuntimeExports.jsx("path", { d: "M3.333 16.667h13.334", strokeLinecap: "round", strokeLinejoin: "round" }), jsxRuntimeExports.jsx("path", { d: "M6.875 3.125h-.417c-.92 0-1.666.746-1.666 1.667v7.083c0 .92.746 1.667 1.666 1.667h.417c.92 0 1.667-.746 1.667-1.667V4.792c0-.92-.747-1.667-1.667-1.667ZM13.542 5.817h-.417c-.92 0-1.667.747-1.667 1.667v4.391c0 .92.746 1.667 1.667 1.667h.417c.92 0 1.666-.746 1.666-1.667V7.484c0-.92-.746-1.667-1.666-1.667Z" })] }), jsxRuntimeExports.jsx("defs", { children: jsxRuntimeExports.jsx("clipPath", { id: "a", children: jsxRuntimeExports.jsx("path", { fill: "#fff", d: "M0 0h20v20H0z" }) }) })] }), G), ph = R$2(jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [jsxRuntimeExports.jsxs("g", { clipPath: "url(#a)", stroke: "currentColor", strokeWidth: "1.25", children: [jsxRuntimeExports.jsx("path", { d: "M3.333 3.333v13.334", strokeLinecap: "round", strokeLinejoin: "round" }), jsxRuntimeExports.jsx("path", { d: "M15.208 4.792H8.125c-.92 0-1.667.746-1.667 1.666v.417c0 .92.747 1.667 1.667 1.667h7.083c.92 0 1.667-.747 1.667-1.667v-.417c0-.92-.746-1.666-1.667-1.666ZM12.516 11.458H8.125c-.92 0-1.667.746-1.667 1.667v.417c0 .92.747 1.666 1.667 1.666h4.391c.92 0 1.667-.746 1.667-1.666v-.417c0-.92-.746-1.667-1.667-1.667Z" })] }), jsxRuntimeExports.jsx("defs", { children: jsxRuntimeExports.jsx("clipPath", { id: "a", children: jsxRuntimeExports.jsx("path", { fill: "#fff", d: "M0 0h20v20H0z" }) }) })] }), G), uh = R$2(jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [jsxRuntimeExports.jsxs("g", { clipPath: "url(#a)", stroke: "currentColor", strokeWidth: "1.25", children: [jsxRuntimeExports.jsx("path", { d: "M16.667 3.333v13.334", strokeLinecap: "round", strokeLinejoin: "round" }), jsxRuntimeExports.jsx("path", { d: "M11.875 4.792H4.792c-.92 0-1.667.746-1.667 1.666v.417c0 .92.746 1.667 1.667 1.667h7.083c.92 0 1.667-.747 1.667-1.667v-.417c0-.92-.746-1.666-1.667-1.666ZM11.683 11.458H7.292c-.92 0-1.667.746-1.667 1.667v.417c0 .92.746 1.666 1.667 1.666h4.39c.921 0 1.667-.746 1.667-1.666v-.417c0-.92-.746-1.667-1.666-1.667Z" })] }), jsxRuntimeExports.jsx("defs", { children: jsxRuntimeExports.jsx("clipPath", { id: "a", children: jsxRuntimeExports.jsx("path", { fill: "#fff", d: "M0 0h20v20H0z" }) }) })] }), G), mh = R$2(jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [jsxRuntimeExports.jsxs("g", { clipPath: "url(#a)", stroke: "currentColor", strokeWidth: "1.25", children: [jsxRuntimeExports.jsx("path", { d: "M16.667 3.333v13.334M3.333 3.333v13.334", strokeLinecap: "round", strokeLinejoin: "round" }), jsxRuntimeExports.jsx("path", { d: "M14.375 10.208v-.416c0-.92-.746-1.667-1.667-1.667H7.292c-.92 0-1.667.746-1.667 1.667v.416c0 .92.746 1.667 1.667 1.667h5.416c.92 0 1.667-.746 1.667-1.667Z" })] }), jsxRuntimeExports.jsx("defs", { children: jsxRuntimeExports.jsx("clipPath", { id: "a", children: jsxRuntimeExports.jsx("path", { fill: "#fff", d: "M0 0h20v20H0z" }) }) })] }), G), bh = R$2(jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [jsxRuntimeExports.jsxs("g", { clipPath: "url(#a)", stroke: "currentColor", strokeWidth: "1.25", children: [jsxRuntimeExports.jsx("path", { d: "M3.333 3.333h13.334M3.333 16.667h13.334", strokeLinecap: "round", strokeLinejoin: "round" }), jsxRuntimeExports.jsx("path", { d: "M10.208 5.625h-.416c-.92 0-1.667.746-1.667 1.667v5.416c0 .92.746 1.667 1.667 1.667h.416c.92 0 1.667-.746 1.667-1.667V7.292c0-.92-.746-1.667-1.667-1.667Z" })] }), jsxRuntimeExports.jsx("defs", { children: jsxRuntimeExports.jsx("clipPath", { id: "a", children: jsxRuntimeExports.jsx("path", { fill: "#fff", d: "M0 0h20v20H0z" }) }) })] }), G), Eh = R$2(jsxRuntimeExports.jsxs("g", { stroke: "currentColor", strokeWidth: "1.25", children: [jsxRuntimeExports.jsx("path", { d: "M1.667 10h2.916", strokeLinecap: "round", strokeLinejoin: "round" }), jsxRuntimeExports.jsx("path", { d: "M8.333 10h3.334", strokeLinejoin: "round" }), jsxRuntimeExports.jsx("path", { d: "M15.417 10h2.916", strokeLinecap: "round", strokeLinejoin: "round" }), jsxRuntimeExports.jsx("path", { d: "M6.875 4.792h-.417c-.92 0-1.666.746-1.666 1.666v7.084c0 .92.746 1.666 1.666 1.666h.417c.92 0 1.667-.746 1.667-1.666V6.458c0-.92-.747-1.666-1.667-1.666ZM13.542 6.458h-.417c-.92 0-1.667.747-1.667 1.667v3.75c0 .92.746 1.667 1.667 1.667h.417c.92 0 1.666-.746 1.666-1.667v-3.75c0-.92-.746-1.667-1.666-1.667Z" })] }), G), gh = R$2(jsxRuntimeExports.jsxs("g", { stroke: "currentColor", strokeWidth: "1.25", children: [jsxRuntimeExports.jsx("path", { d: "M10 18.333v-2.916", strokeLinecap: "round", strokeLinejoin: "round" }), jsxRuntimeExports.jsx("path", { d: "M10 11.667V8.333", strokeLinejoin: "round" }), jsxRuntimeExports.jsx("path", { d: "M10 4.583V1.667", strokeLinecap: "round", strokeLinejoin: "round" }), jsxRuntimeExports.jsx("path", { d: "M4.792 13.125v.417c0 .92.746 1.666 1.666 1.666h7.084c.92 0 1.666-.746 1.666-1.666v-.417c0-.92-.746-1.667-1.666-1.667H6.458c-.92 0-1.666.746-1.666 1.667ZM6.458 6.458v.417c0 .92.747 1.667 1.667 1.667h3.75c.92 0 1.667-.747 1.667-1.667v-.417c0-.92-.746-1.666-1.667-1.666h-3.75c-.92 0-1.667.746-1.667 1.666Z" })] }), G), xh = R$2(jsxRuntimeExports.jsxs("g", { strokeWidth: "1.5", children: [jsxRuntimeExports.jsx("path", { stroke: "none", d: "M0 0h24v24H0z", fill: "none" }), jsxRuntimeExports.jsx("circle", { cx: "9", cy: "7", r: "4" }), jsxRuntimeExports.jsx("path", { d: "M3 21v-2a4 4 0 0 1 4 -4h4a4 4 0 0 1 4 4v2" }), jsxRuntimeExports.jsx("path", { d: "M16 3.13a4 4 0 0 1 0 7.75" }), jsxRuntimeExports.jsx("path", { d: "M21 21v-2a4 4 0 0 0 -3 -3.85" })] }), F$1);
R$2("M256 8C119 8 8 119 8 256s111 248 248 248 248-111 248-248S393 8 256 8zm115.7 272l-176 101c-15.8 8.8-35.7-2.5-35.7-21V152c0-18.4 19.8-29.8 35.7-21l176 107c16.4 9.2 16.4 32.9 0 42z");
R$2("M256 8C119 8 8 119 8 256s111 248 248 248 248-111 248-248S393 8 256 8zm96 328c0 8.8-7.2 16-16 16H176c-8.8 0-16-7.2-16-16V176c0-8.8 7.2-16 16-16h160c8.8 0 16 7.2 16 16v160z");
var Ih = R$2(jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [jsxRuntimeExports.jsx("g", { clipPath: "url(#a)", stroke: "currentColor", strokeWidth: "1.25", strokeLinecap: "round", strokeLinejoin: "round", children: jsxRuntimeExports.jsx("path", { d: "M15 5 5 15M5 5l10 10" }) }), jsxRuntimeExports.jsx("defs", { children: jsxRuntimeExports.jsx("clipPath", { id: "a", children: jsxRuntimeExports.jsx("path", { fill: "#fff", d: "M0 0h20v20H0z" }) }) })] }), G);
R$2("M464 0c26.51 0 48 21.49 48 48v288c0 26.51-21.49 48-48 48H176c-26.51 0-48-21.49-48-48V48c0-26.51 21.49-48 48-48h288M176 416c-44.112 0-80-35.888-80-80V128H48c-26.51 0-48 21.49-48 48v288c0 26.51 21.49 48 48 48h288c26.51 0 48-21.49 48-48v-48H176z", { mirror: true });
R$2("M11.553 22.894a.998.998 0 00.894 0s3.037-1.516 5.465-4.097C19.616 16.987 21 14.663 21 12V5a1 1 0 00-.649-.936l-8-3a.998.998 0 00-.702 0l-8 3A1 1 0 003 5v7c0 2.663 1.384 4.987 3.088 6.797 2.428 2.581 5.465 4.097 5.465 4.097zm-1.303-8.481l6.644-6.644a.856.856 0 111.212 1.212l-7.25 7.25a.856.856 0 01-1.212 0l-3.75-3.75a.856.856 0 111.212-1.212l3.144 3.144z", { width: 24 });
R$2("M369.9 97.9L286 14C277 5 264.8-.1 252.1-.1H48C21.5 0 0 21.5 0 48v416c0 26.5 21.5 48 48 48h288c26.5 0 48-21.5 48-48V131.9c0-12.7-5.1-25-14.1-34zM332.1 128H256V51.9l76.1 76.1zM48 464V48h160v104c0 13.3 10.7 24 24 24h104v288H48zm32-48h224V288l-23.5-23.5c-4.7-4.7-12.3-4.7-17 0L176 352l-39.5-39.5c-4.7-4.7-12.3-4.7-17 0L80 352v64zm48-240c-26.5 0-48 21.5-48 48s21.5 48 48 48 48-21.5 48-48-21.5-48-48-48z", { width: 384, height: 512 });
var Mh = React.memo(({ theme: e12 }) => R$2(jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [jsxRuntimeExports.jsx("path", { d: "M25 26H111V111H25", fill: yt() }), jsxRuntimeExports.jsx("path", { d: "M25 111C25 80.2068 25 49.4135 25 26M25 26C48.6174 26 72.2348 26 111 26H25ZM25 26C53.3671 26 81.7343 26 111 26H25ZM111 26C111 52.303 111 78.606 111 111V26ZM111 26C111 51.2947 111 76.5893 111 111V26ZM111 111C87.0792 111 63.1585 111 25 111H111ZM111 111C87.4646 111 63.9293 111 25 111H111ZM25 111C25 81.1514 25 51.3028 25 26V111Z", stroke: yt(), strokeWidth: "2" }), jsxRuntimeExports.jsx("path", { d: "M100 100H160V160H100", fill: yt() }), jsxRuntimeExports.jsx("path", { d: "M100 160C100 144.106 100 128.211 100 100M100 100C117.706 100 135.412 100 160 100H100ZM100 100C114.214 100 128.428 100 160 100H100ZM160 100C160 120.184 160 140.369 160 160V100ZM160 100C160 113.219 160 126.437 160 160V100ZM160 160C145.534 160 131.068 160 100 160H160ZM160 160C143.467 160 126.934 160 100 160H160ZM100 160C100 143.661 100 127.321 100 100V160Z", stroke: yt(), strokeWidth: "2" }), jsxRuntimeExports.jsxs("g", { fill: $d(e12), stroke: yt(), strokeWidth: "6", children: [jsxRuntimeExports.jsx("rect", { x: "2.5", y: "2.5", width: "30", height: "30" }), jsxRuntimeExports.jsx("rect", { x: "2.5", y: "149.5", width: "30", height: "30" }), jsxRuntimeExports.jsx("rect", { x: "147.5", y: "149.5", width: "30", height: "30" }), jsxRuntimeExports.jsx("rect", { x: "147.5", y: "2.5", width: "30", height: "30" })] })] }), { width: 182, height: 182, mirror: true })), Lh = React.memo(({ theme: e12 }) => R$2(jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [jsxRuntimeExports.jsx("path", { d: "M25 26H111V111H25", fill: yt() }), jsxRuntimeExports.jsx("path", { d: "M25 111C25 80.2068 25 49.4135 25 26M25 26C48.6174 26 72.2348 26 111 26H25ZM25 26C53.3671 26 81.7343 26 111 26H25ZM111 26C111 52.303 111 78.606 111 111V26ZM111 26C111 51.2947 111 76.5893 111 111V26ZM111 111C87.0792 111 63.1585 111 25 111H111ZM111 111C87.4646 111 63.9293 111 25 111H111ZM25 111C25 81.1514 25 51.3028 25 26V111Z", stroke: yt(), strokeWidth: "2" }), jsxRuntimeExports.jsx("path", { d: "M100 100H160V160H100", fill: yt() }), jsxRuntimeExports.jsx("path", { d: "M100 160C100 144.106 100 128.211 100 100M100 100C117.706 100 135.412 100 160 100H100ZM100 100C114.214 100 128.428 100 160 100H100ZM160 100C160 120.184 160 140.369 160 160V100ZM160 100C160 113.219 160 126.437 160 160V100ZM160 160C145.534 160 131.068 160 100 160H160ZM160 160C143.467 160 126.934 160 100 160H160ZM100 160C100 143.661 100 127.321 100 100V160Z", stroke: yt(), strokeWidth: "2" }), jsxRuntimeExports.jsxs("g", { fill: $d(e12), stroke: yt(), strokeWidth: "6", children: [jsxRuntimeExports.jsx("rect", { x: "2.5", y: "2.5", width: "30", height: "30" }), jsxRuntimeExports.jsx("rect", { x: "78.5", y: "149.5", width: "30", height: "30" }), jsxRuntimeExports.jsx("rect", { x: "147.5", y: "149.5", width: "30", height: "30" }), jsxRuntimeExports.jsx("rect", { x: "147.5", y: "78.5", width: "30", height: "30" }), jsxRuntimeExports.jsx("rect", { x: "105.5", y: "2.5", width: "30", height: "30" }), jsxRuntimeExports.jsx("rect", { x: "2.5", y: "102.5", width: "30", height: "30" })] })] }), { width: 182, height: 182, mirror: true })), Dh = R$2(jsxRuntimeExports.jsx("g", { strokeWidth: 1.25, children: jsxRuntimeExports.jsx("path", { d: "M5.879 2.625h8.242a3.27 3.27 0 0 1 3.254 3.254v8.242a3.27 3.27 0 0 1-3.254 3.254H5.88a3.27 3.27 0 0 1-3.254-3.254V5.88A3.27 3.27 0 0 1 5.88 2.626l-.001-.001ZM4.518 16.118l7.608-12.83m.198 13.934 5.051-9.897M2.778 9.675l9.348-6.387m-7.608 12.83 12.857-8.793" }) }), G), Sh = R$2(jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [jsxRuntimeExports.jsx("path", { d: "M5.879 2.625h8.242a3.254 3.254 0 0 1 3.254 3.254v8.242a3.254 3.254 0 0 1-3.254 3.254H5.88a3.254 3.254 0 0 1-3.254-3.254V5.88a3.254 3.254 0 0 1 3.254-3.254Z", stroke: "currentColor", strokeWidth: "1.25" }), jsxRuntimeExports.jsx("mask", { id: "FillHachureIcon", style: { maskType: "alpha" }, maskUnits: "userSpaceOnUse", x: 2, y: 2, width: 16, height: 16, children: jsxRuntimeExports.jsx("path", { d: "M5.879 2.625h8.242a3.254 3.254 0 0 1 3.254 3.254v8.242a3.254 3.254 0 0 1-3.254 3.254H5.88a3.254 3.254 0 0 1-3.254-3.254V5.88a3.254 3.254 0 0 1 3.254-3.254Z", fill: "currentColor", stroke: "currentColor", strokeWidth: "1.25" }) }), jsxRuntimeExports.jsx("g", { mask: "url(#FillHachureIcon)", children: jsxRuntimeExports.jsx("path", { d: "M2.258 15.156 15.156 2.258M7.324 20.222 20.222 7.325m-20.444 5.35L12.675-.222m-8.157 18.34L17.416 5.22", stroke: "currentColor", strokeWidth: "1.25", strokeLinecap: "round", strokeLinejoin: "round" }) })] }), G), vh = R$2(jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [jsxRuntimeExports.jsxs("g", { clipPath: "url(#a)", children: [jsxRuntimeExports.jsx("path", { d: "M5.879 2.625h8.242a3.254 3.254 0 0 1 3.254 3.254v8.242a3.254 3.254 0 0 1-3.254 3.254H5.88a3.254 3.254 0 0 1-3.254-3.254V5.88a3.254 3.254 0 0 1 3.254-3.254Z", stroke: "currentColor", strokeWidth: "1.25" }), jsxRuntimeExports.jsx("mask", { id: "FillCrossHatchIcon", style: { maskType: "alpha" }, maskUnits: "userSpaceOnUse", x: -1, y: -1, width: 22, height: 22, children: jsxRuntimeExports.jsx("path", { d: "M2.426 15.044 15.044 2.426M7.383 20 20 7.383M0 12.617 12.617 0m-7.98 17.941L17.256 5.324m-2.211 12.25L2.426 4.956M20 12.617 7.383 0m5.234 20L0 7.383m17.941 7.98L5.324 2.745", stroke: "currentColor", strokeWidth: "1.25", strokeLinecap: "round", strokeLinejoin: "round" }) }), jsxRuntimeExports.jsx("g", { mask: "url(#FillCrossHatchIcon)", children: jsxRuntimeExports.jsx("path", { d: "M14.121 2H5.88A3.879 3.879 0 0 0 2 5.879v8.242A3.879 3.879 0 0 0 5.879 18h8.242A3.879 3.879 0 0 0 18 14.121V5.88A3.879 3.879 0 0 0 14.121 2Z", fill: "currentColor" }) })] }), jsxRuntimeExports.jsx("defs", { children: jsxRuntimeExports.jsx("clipPath", { id: "a", children: jsxRuntimeExports.jsx("path", { fill: "#fff", d: "M0 0h20v20H0z" }) }) })] }), G), $h = R$2(jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [jsxRuntimeExports.jsx("g", { clipPath: "url(#a)", children: jsxRuntimeExports.jsx("path", { d: "M4.91 2.625h10.18a2.284 2.284 0 0 1 2.285 2.284v10.182a2.284 2.284 0 0 1-2.284 2.284H4.909a2.284 2.284 0 0 1-2.284-2.284V4.909a2.284 2.284 0 0 1 2.284-2.284Z", stroke: "currentColor", strokeWidth: "1.25" }) }), jsxRuntimeExports.jsx("defs", { children: jsxRuntimeExports.jsx("clipPath", { id: "a", children: jsxRuntimeExports.jsx("path", { fill: "#fff", d: "M0 0h20v20H0z" }) }) })] }), { ...G, fill: "currentColor" }), Ph = R$2(jsxRuntimeExports.jsx(jsxRuntimeExports.Fragment, { children: jsxRuntimeExports.jsx("path", { d: "M4.167 10h11.666", stroke: "currentColor", strokeWidth: "1.25", strokeLinecap: "round", strokeLinejoin: "round" }) }), G), Nh = R$2(jsxRuntimeExports.jsx("path", { d: "M5 10h10", stroke: "currentColor", strokeWidth: "2.5", strokeLinecap: "round", strokeLinejoin: "round" }), G), Fh = R$2(jsxRuntimeExports.jsx("path", { d: "M5 10h10", stroke: "currentColor", strokeWidth: "3.75", strokeLinecap: "round", strokeLinejoin: "round" }), G);
React.memo(({ theme: e12 }) => R$2(jsxRuntimeExports.jsx("path", { d: "M6 10H34", stroke: yt(), strokeWidth: 2, fill: "none", strokeLinecap: "round" }), { width: 40, height: 20 }));
var _h = R$2(jsxRuntimeExports.jsxs("g", { strokeWidth: "2", children: [jsxRuntimeExports.jsx("path", { stroke: "none", d: "M0 0h24v24H0z", fill: "none" }), jsxRuntimeExports.jsx("path", { d: "M5 12h2" }), jsxRuntimeExports.jsx("path", { d: "M17 12h2" }), jsxRuntimeExports.jsx("path", { d: "M11 12h2" })] }), F$1), Oh = R$2(jsxRuntimeExports.jsxs("g", { strokeWidth: "2", children: [jsxRuntimeExports.jsx("path", { stroke: "none", d: "M0 0h24v24H0z", fill: "none" }), jsxRuntimeExports.jsx("path", { d: "M4 12v.01" }), jsxRuntimeExports.jsx("path", { d: "M8 12v.01" }), jsxRuntimeExports.jsx("path", { d: "M12 12v.01" }), jsxRuntimeExports.jsx("path", { d: "M16 12v.01" }), jsxRuntimeExports.jsx("path", { d: "M20 12v.01" })] }), F$1), Ah = R$2(jsxRuntimeExports.jsx("path", { d: "M2.5 12.038c1.655-.885 5.9-3.292 8.568-4.354 2.668-1.063.101 2.821 1.32 3.104 1.218.283 5.112-1.814 5.112-1.814", strokeWidth: "1.25" }), G), Kh = R$2(jsxRuntimeExports.jsx("path", { d: "M2.5 12.563c1.655-.886 5.9-3.293 8.568-4.355 2.668-1.062.101 2.822 1.32 3.105 1.218.283 5.112-1.814 5.112-1.814m-13.469 2.23c2.963-1.586 6.13-5.62 7.468-4.998 1.338.623-1.153 4.11-.132 5.595 1.02 1.487 6.133-1.43 6.133-1.43", strokeWidth: "1.25" }), G), Hh = R$2(jsxRuntimeExports.jsx("path", { d: "M2.5 11.936c1.737-.879 8.627-5.346 10.42-5.268 1.795.078-.418 5.138.345 5.736.763.598 3.53-1.789 4.235-2.147M2.929 9.788c1.164-.519 5.47-3.28 6.987-3.114 1.519.165 1 3.827 2.121 4.109 1.122.281 3.839-2.016 4.606-2.42", strokeWidth: "1.25" }), G), Jh = R$2(jsxRuntimeExports.jsxs("svg", { strokeWidth: "1.5", children: [jsxRuntimeExports.jsx("path", { d: "M3.33334 9.99998V6.66665C3.33334 6.04326 3.33403 4.9332 3.33539 3.33646C4.95233 3.33436 6.06276 3.33331 6.66668 3.33331H10" }), jsxRuntimeExports.jsx("path", { d: "M13.3333 3.33331V3.34331" }), jsxRuntimeExports.jsx("path", { d: "M16.6667 3.33331V3.34331" }), jsxRuntimeExports.jsx("path", { d: "M16.6667 6.66669V6.67669" }), jsxRuntimeExports.jsx("path", { d: "M16.6667 10V10.01" }), jsxRuntimeExports.jsx("path", { d: "M3.33334 13.3333V13.3433" }), jsxRuntimeExports.jsx("path", { d: "M16.6667 13.3333V13.3433" }), jsxRuntimeExports.jsx("path", { d: "M3.33334 16.6667V16.6767" }), jsxRuntimeExports.jsx("path", { d: "M6.66666 16.6667V16.6767" }), jsxRuntimeExports.jsx("path", { d: "M10 16.6667V16.6767" }), jsxRuntimeExports.jsx("path", { d: "M13.3333 16.6667V16.6767" }), jsxRuntimeExports.jsx("path", { d: "M16.6667 16.6667V16.6767" })] }), G), Yh = R$2(jsxRuntimeExports.jsxs("g", { strokeWidth: "1.5", stroke: "currentColor", strokeLinecap: "round", strokeLinejoin: "round", children: [jsxRuntimeExports.jsx("path", { stroke: "none", d: "M0 0h24v24H0z", fill: "none" }), jsxRuntimeExports.jsx("path", { d: "M4 12v-4a4 4 0 0 1 4 -4h4" }), jsxRuntimeExports.jsx("line", { x1: "16", y1: "4", x2: "16", y2: "4.01" }), jsxRuntimeExports.jsx("line", { x1: "20", y1: "4", x2: "20", y2: "4.01" }), jsxRuntimeExports.jsx("line", { x1: "20", y1: "8", x2: "20", y2: "8.01" }), jsxRuntimeExports.jsx("line", { x1: "20", y1: "12", x2: "20", y2: "12.01" }), jsxRuntimeExports.jsx("line", { x1: "4", y1: "16", x2: "4", y2: "16.01" }), jsxRuntimeExports.jsx("line", { x1: "20", y1: "16", x2: "20", y2: "16.01" }), jsxRuntimeExports.jsx("line", { x1: "4", y1: "20", x2: "4", y2: "20.01" }), jsxRuntimeExports.jsx("line", { x1: "8", y1: "20", x2: "8", y2: "20.01" }), jsxRuntimeExports.jsx("line", { x1: "12", y1: "20", x2: "12", y2: "20.01" }), jsxRuntimeExports.jsx("line", { x1: "16", y1: "20", x2: "16", y2: "20.01" }), jsxRuntimeExports.jsx("line", { x1: "20", y1: "20", x2: "20", y2: "20.01" })] }), F$1), Ch = R$2(jsxRuntimeExports.jsxs("g", { stroke: "currentColor", opacity: 0.3, strokeWidth: 2, children: [jsxRuntimeExports.jsx("path", { d: "M12 12l9 0" }), jsxRuntimeExports.jsx("path", { d: "M3 9l6 6" }), jsxRuntimeExports.jsx("path", { d: "M3 15l6 -6" })] }), F$1), Vh = React.memo(({ flip: e12 = false }) => R$2(jsxRuntimeExports.jsxs("g", { transform: e12 ? "translate(40, 0) scale(-1, 1)" : "", stroke: "currentColor", strokeWidth: 2, fill: "none", children: [jsxRuntimeExports.jsx("path", { d: "M34 10H6M34 10L27 5M34 10L27 15" }), jsxRuntimeExports.jsx("path", { d: "M27.5 5L34.5 10L27.5 15" })] }), { width: 40, height: 20 })), qh = React.memo(({ flip: e12 = false }) => R$2(jsxRuntimeExports.jsxs("g", { stroke: "currentColor", fill: "currentColor", transform: e12 ? "translate(40, 0) scale(-1, 1)" : "", children: [jsxRuntimeExports.jsx("path", { d: "M32 10L6 10", strokeWidth: 2 }), jsxRuntimeExports.jsx("circle", { r: "4", transform: "matrix(-1 0 0 1 30 10)" })] }), { width: 40, height: 20 })), Xh = React.memo(({ flip: e12 = false }) => R$2(jsxRuntimeExports.jsxs("g", { stroke: "currentColor", fill: "none", transform: e12 ? "translate(40, 0) scale(-1, 1)" : "", strokeWidth: 2, children: [jsxRuntimeExports.jsx("path", { d: "M26 10L6 10" }), jsxRuntimeExports.jsx("circle", { r: "4", transform: "matrix(-1 0 0 1 30 10)" })] }), { width: 40, height: 20 })), Gh = React.memo(({ flip: e12 = false }) => R$2(jsxRuntimeExports.jsx("g", { transform: e12 ? "translate(40, 0) scale(-1, 1)" : "", children: jsxRuntimeExports.jsx("path", { d: "M34 10H5.99996M34 10L34 5M34 10L34 15", stroke: "currentColor", strokeWidth: 2, fill: "none" }) }), { width: 40, height: 20 })), kh = React.memo(({ flip: e12 = false }) => R$2(jsxRuntimeExports.jsxs("g", { stroke: "currentColor", fill: "currentColor", transform: e12 ? "translate(40, 0) scale(-1, 1)" : "", children: [jsxRuntimeExports.jsx("path", { d: "M32 10L6 10", strokeWidth: 2 }), jsxRuntimeExports.jsx("path", { d: "M27.5 5.5L34.5 10L27.5 14.5L27.5 5.5" })] }), { width: 40, height: 20 })), Zh = React.memo(({ flip: e12 = false }) => R$2(jsxRuntimeExports.jsxs("g", { stroke: "currentColor", fill: "none", transform: e12 ? "translate(40, 0) scale(-1, 1)" : "", strokeWidth: 2, strokeLinejoin: "round", children: [jsxRuntimeExports.jsx("path", { d: "M6,9.5H27" }), jsxRuntimeExports.jsx("path", { d: "M27,5L34,10L27,14Z", fill: "none" })] }), { width: 40, height: 20 })), Wh = React.memo(({ flip: e12 = false }) => R$2(jsxRuntimeExports.jsxs("g", { stroke: "currentColor", fill: "currentColor", transform: e12 ? "translate(40, 0) scale(-1, 1)" : "", strokeLinejoin: "round", strokeWidth: 2, children: [jsxRuntimeExports.jsx("path", { d: "M6,9.5H20" }), jsxRuntimeExports.jsx("path", { d: "M27,5L34,10L27,14L20,9.5Z" })] }), { width: 40, height: 20 })), zh = React.memo(({ flip: e12 = false }) => R$2(jsxRuntimeExports.jsxs("g", { stroke: "currentColor", fill: "none", transform: e12 ? "translate(40, 0) scale(-1, 1)" : "", strokeLinejoin: "round", strokeWidth: 2, children: [jsxRuntimeExports.jsx("path", { d: "M6,9.5H20" }), jsxRuntimeExports.jsx("path", { d: "M27,5L34,10L27,14L20,9.5Z" })] }), { width: 40, height: 20 })), Qh = React.memo(({ flip: e12 = false }) => R$2(jsxRuntimeExports.jsx("g", { stroke: "currentColor", fill: "none", transform: e12 ? "" : "translate(40, 0) scale(-1, 1)", strokeLinejoin: "round", strokeWidth: 2, children: jsxRuntimeExports.jsx("path", { d: "M34,10 H6 M15,10 L7,5 M15,10 L7,15" }) }), { width: 40, height: 20 })), jh = React.memo(({ flip: e12 = false }) => R$2(jsxRuntimeExports.jsx("g", { stroke: "currentColor", fill: "none", transform: e12 ? "" : "translate(40, 0) scale(-1, 1)", strokeLinejoin: "round", strokeWidth: 2, children: jsxRuntimeExports.jsx("path", { d: "M34,10 H6 M15,10 L15,15 L15,5" }) }), { width: 40, height: 20 })), e4 = React.memo(({ flip: e12 = false }) => R$2(jsxRuntimeExports.jsx("g", { stroke: "currentColor", fill: "none", transform: e12 ? "" : "translate(40, 0) scale(-1, 1)", strokeLinejoin: "round", strokeWidth: 2, children: jsxRuntimeExports.jsx("path", { d: "M34,10 H6 M15,10 L15,16 L15,4 M15,10 L7,5 M15,10 L7,15" }) }), { width: 40, height: 20 })), t4 = R$2(jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [jsxRuntimeExports.jsx("g", { clipPath: "url(#a)", children: jsxRuntimeExports.jsx("path", { d: "M14.167 6.667a3.333 3.333 0 0 0-3.334-3.334H9.167a3.333 3.333 0 0 0 0 6.667h1.666a3.333 3.333 0 0 1 0 6.667H9.167a3.333 3.333 0 0 1-3.334-3.334", stroke: "currentColor", strokeWidth: "1.25", strokeLinecap: "round", strokeLinejoin: "round" }) }), jsxRuntimeExports.jsx("defs", { children: jsxRuntimeExports.jsx("clipPath", { id: "a", children: jsxRuntimeExports.jsx("path", { fill: "#fff", d: "M0 0h20v20H0z" }) }) })] }), G), n4 = R$2(jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [jsxRuntimeExports.jsx("g", { clipPath: "url(#a)", children: jsxRuntimeExports.jsx("path", { d: "M5 16.667V3.333L10 15l5-11.667v13.334", stroke: "currentColor", strokeWidth: "1.25", strokeLinecap: "round", strokeLinejoin: "round" }) }), jsxRuntimeExports.jsx("defs", { children: jsxRuntimeExports.jsx("clipPath", { id: "a", children: jsxRuntimeExports.jsx("path", { fill: "#fff", d: "M0 0h20v20H0z" }) }) })] }), G), r4 = R$2(jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [jsxRuntimeExports.jsx("g", { clipPath: "url(#a)", children: jsxRuntimeExports.jsx("path", { d: "M5.833 3.333v13.334h8.334", stroke: "currentColor", strokeWidth: "1.25", strokeLinecap: "round", strokeLinejoin: "round" }) }), jsxRuntimeExports.jsx("defs", { children: jsxRuntimeExports.jsx("clipPath", { id: "a", children: jsxRuntimeExports.jsx("path", { fill: "#fff", d: "M0 0h20v20H0z" }) }) })] }), G), o4 = R$2(jsxRuntimeExports.jsx(jsxRuntimeExports.Fragment, { children: jsxRuntimeExports.jsx("path", { d: "m1.667 3.333 6.666 13.334M8.333 3.333 1.667 16.667M11.667 3.333v13.334h6.666", stroke: "currentColor", strokeWidth: "1.25", strokeLinecap: "round", strokeLinejoin: "round" }) }), G), i4 = R$2(jsxRuntimeExports.jsxs("g", { strokeWidth: 1.25, children: [jsxRuntimeExports.jsx("path", { stroke: "none", d: "M0 0h24v24H0z", fill: "none" }), jsxRuntimeExports.jsx("path", { d: "M3 7v-2h13v2" }), jsxRuntimeExports.jsx("path", { d: "M10 5v14" }), jsxRuntimeExports.jsx("path", { d: "M12 19h-4" }), jsxRuntimeExports.jsx("path", { d: "M15 13v-1h6v1" }), jsxRuntimeExports.jsx("path", { d: "M18 12v7" }), jsxRuntimeExports.jsx("path", { d: "M17 19h2" })] }), F$1), Cd$1 = R$2(jsxRuntimeExports.jsx(jsxRuntimeExports.Fragment, { children: jsxRuntimeExports.jsxs("g", { stroke: "currentColor", strokeWidth: "1.25", strokeLinecap: "round", strokeLinejoin: "round", children: [jsxRuntimeExports.jsx("path", { stroke: "none", d: "M0 0h24v24H0z", fill: "none" }), jsxRuntimeExports.jsx("path", { d: "M7 12h10" }), jsxRuntimeExports.jsx("path", { d: "M7 5v14" }), jsxRuntimeExports.jsx("path", { d: "M17 5v14" }), jsxRuntimeExports.jsx("path", { d: "M15 19h4" }), jsxRuntimeExports.jsx("path", { d: "M15 5h4" }), jsxRuntimeExports.jsx("path", { d: "M5 19h4" }), jsxRuntimeExports.jsx("path", { d: "M5 5h4" })] }) }), F$1), la = R$2(jsxRuntimeExports.jsx(jsxRuntimeExports.Fragment, { children: jsxRuntimeExports.jsx("g", { stroke: "currentColor", strokeWidth: "1.25", strokeLinecap: "round", strokeLinejoin: "round", children: jsxRuntimeExports.jsx("path", { d: "M5.833 16.667v-10a3.333 3.333 0 0 1 3.334-3.334h1.666a3.333 3.333 0 0 1 3.334 3.334v10M5.833 10.833h8.334" }) }) }), G), Ua$1 = R$2(jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [jsxRuntimeExports.jsx("g", { clipPath: "url(#a)", stroke: "currentColor", strokeWidth: "1.25", strokeLinecap: "round", strokeLinejoin: "round", children: jsxRuntimeExports.jsx("path", { d: "M5.833 6.667 2.5 10l3.333 3.333M14.167 6.667 17.5 10l-3.333 3.333M11.667 3.333 8.333 16.667" }) }), jsxRuntimeExports.jsx("defs", { children: jsxRuntimeExports.jsx("clipPath", { id: "a", children: jsxRuntimeExports.jsx("path", { fill: "#fff", d: "M0 0h20v20H0z" }) }) })] }), G), a4 = R$2(jsxRuntimeExports.jsxs("g", { stroke: "currentColor", fill: "none", strokeLinecap: "round", strokeLinejoin: "round", strokeWidth: 2, children: [jsxRuntimeExports.jsx("path", { stroke: "none", d: "M0 0h24v24H0z", fill: "none" }), jsxRuntimeExports.jsx("line", { x1: "4", y1: "8", x2: "20", y2: "8" }), jsxRuntimeExports.jsx("line", { x1: "4", y1: "12", x2: "12", y2: "12" }), jsxRuntimeExports.jsx("line", { x1: "4", y1: "16", x2: "16", y2: "16" })] }), F$1), s4 = R$2(jsxRuntimeExports.jsxs("g", { stroke: "currentColor", fill: "none", strokeLinecap: "round", strokeLinejoin: "round", children: [jsxRuntimeExports.jsx("path", { stroke: "none", d: "M0 0h24v24H0z", fill: "none" }), jsxRuntimeExports.jsx("line", { x1: "4", y1: "8", x2: "20", y2: "8" }), jsxRuntimeExports.jsx("line", { x1: "8", y1: "12", x2: "16", y2: "12" }), jsxRuntimeExports.jsx("line", { x1: "6", y1: "16", x2: "18", y2: "16" })] }), F$1), d4 = R$2(jsxRuntimeExports.jsxs("g", { stroke: "currentColor", fill: "none", strokeLinecap: "round", strokeLinejoin: "round", children: [jsxRuntimeExports.jsx("path", { stroke: "none", d: "M0 0h24v24H0z", fill: "none" }), jsxRuntimeExports.jsx("line", { x1: "4", y1: "8", x2: "20", y2: "8" }), jsxRuntimeExports.jsx("line", { x1: "10", y1: "12", x2: "20", y2: "12" }), jsxRuntimeExports.jsx("line", { x1: "8", y1: "16", x2: "20", y2: "16" })] }), F$1), c4 = React.memo(({ theme: e12 }) => R$2(jsxRuntimeExports.jsxs("g", { strokeWidth: "1.5", stroke: "currentColor", fill: "none", strokeLinecap: "round", strokeLinejoin: "round", children: [jsxRuntimeExports.jsx("path", { stroke: "none", d: "M0 0h24v24H0z", fill: "none" }), jsxRuntimeExports.jsx("line", { x1: "4", y1: "4", x2: "20", y2: "4" }), jsxRuntimeExports.jsx("rect", { x: "9", y: "8", width: "6", height: "12", rx: "2" })] }), F$1)), l4 = React.memo(({ theme: e12 }) => R$2(jsxRuntimeExports.jsxs("g", { strokeWidth: "2", stroke: "currentColor", fill: "none", strokeLinecap: "round", strokeLinejoin: "round", children: [jsxRuntimeExports.jsx("path", { stroke: "none", d: "M0 0h24v24H0z", fill: "none" }), jsxRuntimeExports.jsx("line", { x1: "4", y1: "20", x2: "20", y2: "20" }), jsxRuntimeExports.jsx("rect", { x: "9", y: "4", width: "6", height: "12", rx: "2" })] }), F$1)), U4 = React.memo(({ theme: e12 }) => R$2(jsxRuntimeExports.jsxs("g", { strokeWidth: "1.5", stroke: "currentColor", fill: "none", strokeLinecap: "round", strokeLinejoin: "round", children: [jsxRuntimeExports.jsx("path", { stroke: "none", d: "M0 0h24v24H0z", fill: "none" }), jsxRuntimeExports.jsx("line", { x1: "4", y1: "12", x2: "9", y2: "12" }), jsxRuntimeExports.jsx("line", { x1: "15", y1: "12", x2: "20", y2: "12" }), jsxRuntimeExports.jsx("rect", { x: "9", y: "6", width: "6", height: "12", rx: "2" })] }), F$1)), f4 = R$2(jsxRuntimeExports.jsxs("g", { children: [jsxRuntimeExports.jsx("path", { stroke: "none", d: "M0 0h24v24H0z", fill: "none" }), jsxRuntimeExports.jsx("path", { d: "M21 19h-18l9 -15" }), jsxRuntimeExports.jsx("path", { d: "M20.615 15.171h.015" }), jsxRuntimeExports.jsx("path", { d: "M19.515 11.771h.015" }), jsxRuntimeExports.jsx("path", { d: "M17.715 8.671h.015" }), jsxRuntimeExports.jsx("path", { d: "M15.415 5.971h.015" })] }), F$1), p4 = R$2(jsxRuntimeExports.jsx("path", { d: "M537.6 226.6c4.1-10.7 6.4-22.4 6.4-34.6 0-53-43-96-96-96-19.7 0-38.1 6-53.3 16.2C367 64.2 315.3 32 256 32c-88.4 0-160 71.6-160 160 0 2.7.1 5.4.2 8.1C40.2 219.8 0 273.2 0 336c0 79.5 64.5 144 144 144h368c70.7 0 128-57.3 128-128 0-61.9-44-113.6-102.4-125.4zM393.4 288H328v112c0 8.8-7.2 16-16 16h-48c-8.8 0-16-7.2-16-16V288h-65.4c-14.3 0-21.4-17.2-11.3-27.3l105.4-105.4c6.2-6.2 16.4-6.2 22.6 0l105.4 105.4c10.1 10.1 2.9 27.3-11.3 27.3z", fill: "currentColor" }), { width: 640, height: 512 });
R$2(jsxRuntimeExports.jsx("path", { d: "M480 416C497.7 416 512 430.3 512 448C512 465.7 497.7 480 480 480H150.6C133.7 480 117.4 473.3 105.4 461.3L25.37 381.3C.3786 356.3 .3786 315.7 25.37 290.7L258.7 57.37C283.7 32.38 324.3 32.38 349.3 57.37L486.6 194.7C511.6 219.7 511.6 260.3 486.6 285.3L355.9 416H480zM265.4 416L332.7 348.7L195.3 211.3L70.63 336L150.6 416L265.4 416z" }));
var m4 = R$2(jsxRuntimeExports.jsxs("g", { strokeWidth: 1.25, children: [jsxRuntimeExports.jsx("path", { stroke: "none", d: "M0 0h24v24H0z", fill: "none" }), jsxRuntimeExports.jsx("path", { d: "M8 13v-7.5a1.5 1.5 0 0 1 3 0v6.5" }), jsxRuntimeExports.jsx("path", { d: "M11 5.5v-2a1.5 1.5 0 1 1 3 0v8.5" }), jsxRuntimeExports.jsx("path", { d: "M14 5.5a1.5 1.5 0 0 1 3 0v6.5" }), jsxRuntimeExports.jsx("path", { d: "M17 7.5a1.5 1.5 0 0 1 3 0v8.5a6 6 0 0 1 -6 6h-2h.208a6 6 0 0 1 -5.012 -2.7a69.74 69.74 0 0 1 -.196 -.3c-.312 -.479 -1.407 -2.388 -3.286 -5.728a1.5 1.5 0 0 1 .536 -2.022a1.867 1.867 0 0 1 2.28 .28l1.47 1.47" })] }), F$1), b4 = R$2(jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [jsxRuntimeExports.jsx("path", { stroke: "none", d: "M0 0h24v24H0z", fill: "none" }), jsxRuntimeExports.jsx("path", { d: "M4 17v2a2 2 0 0 0 2 2h12a2 2 0 0 0 2 -2v-2" }), jsxRuntimeExports.jsx("path", { d: "M7 11l5 5l5 -5" }), jsxRuntimeExports.jsx("path", { d: "M12 4l0 12" })] }), F$1), E4 = R$2(jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [jsxRuntimeExports.jsx("path", { stroke: "none", d: "M0 0h24v24H0z", fill: "none" }), jsxRuntimeExports.jsx("path", { d: "M8 8m0 2a2 2 0 0 1 2 -2h8a2 2 0 0 1 2 2v8a2 2 0 0 1 -2 2h-8a2 2 0 0 1 -2 -2z" }), jsxRuntimeExports.jsx("path", { d: "M16 8v-2a2 2 0 0 0 -2 -2h-8a2 2 0 0 0 -2 2v8a2 2 0 0 0 2 2h2" })] }), F$1), g4 = R$2(jsxRuntimeExports.jsxs("g", { strokeWidth: 1.25, children: [jsxRuntimeExports.jsx("path", { stroke: "none", d: "M0 0h24v24H0z", fill: "none" }), jsxRuntimeExports.jsx("path", { d: "M7 17m-3 0a3 3 0 1 0 6 0a3 3 0 1 0 -6 0" }), jsxRuntimeExports.jsx("path", { d: "M17 17m-3 0a3 3 0 1 0 6 0a3 3 0 1 0 -6 0" }), jsxRuntimeExports.jsx("path", { d: "M9.15 14.85l8.85 -10.85" }), jsxRuntimeExports.jsx("path", { d: "M6 4l8.85 10.85" })] }), F$1), x4 = R$2(jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [jsxRuntimeExports.jsx("path", { stroke: "none", d: "M0 0h24v24H0z", fill: "none" }), jsxRuntimeExports.jsx("path", { d: "M12 12m-9 0a9 9 0 1 0 18 0a9 9 0 1 0 -18 0" }), jsxRuntimeExports.jsx("path", { d: "M12 17l0 .01" }), jsxRuntimeExports.jsx("path", { d: "M12 13.5a1.5 1.5 0 0 1 1 -1.5a2.6 2.6 0 1 0 -3 -4" })] }), F$1);
R$2(jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [jsxRuntimeExports.jsx("path", { stroke: "none", d: "M0 0h24v24H0z", fill: "none" }), jsxRuntimeExports.jsx("path", { d: "M7 4v16l13 -8z" })] }), F$1);
R$2(jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [jsxRuntimeExports.jsx("path", { stroke: "none", d: "M0 0h24v24H0z", fill: "none" }), jsxRuntimeExports.jsx("path", { d: "M17 4h-10a3 3 0 0 0 -3 3v10a3 3 0 0 0 3 3h10a3 3 0 0 0 3 -3v-10a3 3 0 0 0 -3 -3z", strokeWidth: "0", fill: "currentColor" })] }), F$1);
var I4 = R$2(jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [jsxRuntimeExports.jsx("path", { stroke: "none", d: "M0 0h24v24H0z", fill: "none" }), jsxRuntimeExports.jsx("path", { d: "M5 12l5 5l10 -10" })] }), F$1), w4 = R$2(jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [jsxRuntimeExports.jsx("path", { stroke: "none", d: "M0 0h24v24H0z", fill: "none" }), jsxRuntimeExports.jsx("path", { d: "M10.24 3.957l-8.422 14.06a1.989 1.989 0 0 0 1.7 2.983h16.845a1.989 1.989 0 0 0 1.7 -2.983l-8.423 -14.06a1.989 1.989 0 0 0 -3.4 0z" }), jsxRuntimeExports.jsx("path", { d: "M12 9v4" }), jsxRuntimeExports.jsx("path", { d: "M12 17h.01" })] }), F$1), R4 = R$2(jsxRuntimeExports.jsxs("g", { strokeWidth: 1.25, children: [jsxRuntimeExports.jsx("path", { stroke: "none", d: "M0 0h24v24H0z", fill: "none" }), jsxRuntimeExports.jsx("path", { d: "M11 7l6 6" }), jsxRuntimeExports.jsx("path", { d: "M4 16l11.7 -11.7a1 1 0 0 1 1.4 0l2.6 2.6a1 1 0 0 1 0 1.4l-11.7 11.7h-4v-4z" })] }), F$1), T4 = R$2(jsxRuntimeExports.jsxs("g", { strokeWidth: 1.5, children: [jsxRuntimeExports.jsx("path", { stroke: "none", d: "M0 0h24v24H0z", fill: "none" }), jsxRuntimeExports.jsx("path", { d: "M12 3l-4 7h8z" }), jsxRuntimeExports.jsx("path", { d: "M17 17m-3 0a3 3 0 1 0 6 0a3 3 0 1 0 -6 0" }), jsxRuntimeExports.jsx("path", { d: "M4 14m0 1a1 1 0 0 1 1 -1h4a1 1 0 0 1 1 1v4a1 1 0 0 1 -1 1h-4a1 1 0 0 1 -1 -1z" })] }), F$1), M4 = R$2(jsxRuntimeExports.jsxs("g", { strokeWidth: 1.5, children: [jsxRuntimeExports.jsx("path", { stroke: "none", d: "M0 0h24v24H0z", fill: "none" }), jsxRuntimeExports.jsx("path", { d: "M4 7l16 0" }), jsxRuntimeExports.jsx("path", { d: "M4 17l16 0" }), jsxRuntimeExports.jsx("path", { d: "M7 4l0 16" }), jsxRuntimeExports.jsx("path", { d: "M17 4l0 16" })] }), F$1), L4 = R$2(jsxRuntimeExports.jsx("path", { fill: "currentColor", d: "M407.48,111.18C335.587,108.103 269.573,152.338 245.08,220C220.587,152.338 154.573,108.103 82.68,111.18C80.285,168.229 107.577,222.632 154.74,254.82C178.908,271.419 193.35,298.951 193.27,328.27L193.27,379.13L296.9,379.13L296.9,328.27C296.816,298.953 311.255,271.42 335.42,254.82C382.596,222.644 409.892,168.233 407.48,111.18Z" })), D4 = R$2(jsxRuntimeExports.jsxs("g", { strokeWidth: "1.25", children: [jsxRuntimeExports.jsx("path", { d: "M4.16602 10H15.8327" }), jsxRuntimeExports.jsx("path", { d: "M12.5 13.3333L15.8333 10" }), jsxRuntimeExports.jsx("path", { d: "M12.5 6.66666L15.8333 9.99999" })] }), G), S4 = R$2(jsxRuntimeExports.jsxs("g", { fill: "none", stroke: "currentColor", strokeWidth: "1.25", strokeLinecap: "round", strokeLinejoin: "round", transform: "rotate(90 10 10)", children: [jsxRuntimeExports.jsx("path", { clipRule: "evenodd", d: "m9.644 13.69 7.774-7.773a2.357 2.357 0 0 0-3.334-3.334l-7.773 7.774L8 12l1.643 1.69Z" }), jsxRuntimeExports.jsx("path", { d: "m13.25 3.417 3.333 3.333M10 10l2-2M5 15l3-3M2.156 17.894l1-1M5.453 19.029l-.144-1.407M2.377 11.887l.866 1.118M8.354 17.273l-1.194-.758M.953 14.652l1.408.13" })] }), 20), v4 = R$2(jsxRuntimeExports.jsxs("g", { stroke: "currentColor", fill: "none", children: [jsxRuntimeExports.jsx("path", { stroke: "none", d: "M0 0h24v24H0z" }), jsxRuntimeExports.jsx("path", { d: "M6 21l15 -15l-3 -3l-15 15l3 3" }), jsxRuntimeExports.jsx("path", { d: "M15 6l3 3" }), jsxRuntimeExports.jsx("path", { d: "M9 3a2 2 0 0 0 2 2a2 2 0 0 0 -2 2a2 2 0 0 0 -2 -2a2 2 0 0 0 2 -2" }), jsxRuntimeExports.jsx("path", { d: "M19 13a2 2 0 0 0 2 2a2 2 0 0 0 -2 2a2 2 0 0 0 -2 -2a2 2 0 0 0 2 -2" })] }), F$1);
R$2(jsxRuntimeExports.jsxs("g", { strokeWidth: 1.25, children: [jsxRuntimeExports.jsx("path", { stroke: "none", d: "M0 0h24v24H0z" }), jsxRuntimeExports.jsx("path", { d: "M6 21l15 -15l-3 -3l-15 15l3 3" }), jsxRuntimeExports.jsx("path", { d: "M15 6l3 3" }), jsxRuntimeExports.jsx("path", { d: "M9 3a2 2 0 0 0 2 2a2 2 0 0 0 -2 2a2 2 0 0 0 -2 -2a2 2 0 0 0 2 -2" }), jsxRuntimeExports.jsx("path", { d: "M19 13a2 2 0 0 0 2 2a2 2 0 0 0 -2 2a2 2 0 0 0 -2 -2a2 2 0 0 0 2 -2" })] }), F$1);
R$2(jsxRuntimeExports.jsxs("g", { stroke: "currentColor", fill: "none", children: [jsxRuntimeExports.jsx("path", { stroke: "none", d: "M0 0h24v24H0z", fill: "none" }), jsxRuntimeExports.jsx("path", { d: "M11.217 19.384a3.501 3.501 0 0 0 6.783 -1.217v-5.167l-6 -3.35" }), jsxRuntimeExports.jsx("path", { d: "M5.214 15.014a3.501 3.501 0 0 0 4.446 5.266l4.34 -2.534v-6.946" }), jsxRuntimeExports.jsx("path", { d: "M6 7.63c-1.391 -.236 -2.787 .395 -3.534 1.689a3.474 3.474 0 0 0 1.271 4.745l4.263 2.514l6 -3.348" }), jsxRuntimeExports.jsx("path", { d: "M12.783 4.616a3.501 3.501 0 0 0 -6.783 1.217v5.067l6 3.45" }), jsxRuntimeExports.jsx("path", { d: "M18.786 8.986a3.501 3.501 0 0 0 -4.446 -5.266l-4.34 2.534v6.946" }), jsxRuntimeExports.jsx("path", { d: "M18 16.302c1.391 .236 2.787 -.395 3.534 -1.689a3.474 3.474 0 0 0 -1.271 -4.745l-4.308 -2.514l-5.955 3.42" })] }), F$1);
var N4 = R$2(jsxRuntimeExports.jsxs("g", { stroke: "currentColor", fill: "none", children: [jsxRuntimeExports.jsx("path", { stroke: "none", d: "M0 0h24v24H0z", fill: "none" }), jsxRuntimeExports.jsx("path", { d: "M4 8v-2a2 2 0 0 1 2 -2h2" }), jsxRuntimeExports.jsx("path", { d: "M4 16v2a2 2 0 0 0 2 2h2" }), jsxRuntimeExports.jsx("path", { d: "M16 4h2a2 2 0 0 1 2 2v2" }), jsxRuntimeExports.jsx("path", { d: "M16 20h2a2 2 0 0 0 2 -2v-2" })] }), F$1), F4 = R$2(jsxRuntimeExports.jsxs("g", { stroke: "currentColor", fill: "none", strokeWidth: 1.5, children: [jsxRuntimeExports.jsx("path", { stroke: "none", d: "M0 0h24v24H0z", fill: "none" }), jsxRuntimeExports.jsx("path", { d: "M10 12a2 2 0 1 0 4 0a2 2 0 0 0 -4 0" }), jsxRuntimeExports.jsx("path", { d: "M21 12c-2.4 4 -5.4 6 -9 6c-3.6 0 -6.6 -2 -9 -6c2.4 -4 5.4 -6 9 -6c3.6 0 6.6 2 9 6" })] }), F$1), B4 = R$2(jsxRuntimeExports.jsxs("g", { stroke: "currentColor", fill: "none", children: [jsxRuntimeExports.jsx("path", { stroke: "none", d: "M0 0h24v24H0z", fill: "none" }), jsxRuntimeExports.jsx("path", { d: "M10.585 10.587a2 2 0 0 0 2.829 2.828" }), jsxRuntimeExports.jsx("path", { d: "M16.681 16.673a8.717 8.717 0 0 1 -4.681 1.327c-3.6 0 -6.6 -2 -9 -6c1.272 -2.12 2.712 -3.678 4.32 -4.674m2.86 -1.146a9.055 9.055 0 0 1 1.82 -.18c3.6 0 6.6 2 9 6c-.666 1.11 -1.379 2.067 -2.138 2.87" }), jsxRuntimeExports.jsx("path", { d: "M3 3l18 18" })] }), F$1);
R$2(jsxRuntimeExports.jsxs("g", { stroke: "currentColor", fill: "none", children: [jsxRuntimeExports.jsx("path", { stroke: "none", d: "M0 0h24v24H0z", fill: "none" }), jsxRuntimeExports.jsx("path", { d: "M15.5 13a3.5 3.5 0 0 0 -3.5 3.5v1a3.5 3.5 0 0 0 7 0v-1.8" }), jsxRuntimeExports.jsx("path", { d: "M8.5 13a3.5 3.5 0 0 1 3.5 3.5v1a3.5 3.5 0 0 1 -7 0v-1.8" }), jsxRuntimeExports.jsx("path", { d: "M17.5 16a3.5 3.5 0 0 0 0 -7h-.5" }), jsxRuntimeExports.jsx("path", { d: "M19 9.3v-2.8a3.5 3.5 0 0 0 -7 0" }), jsxRuntimeExports.jsx("path", { d: "M6.5 16a3.5 3.5 0 0 1 0 -7h.5" }), jsxRuntimeExports.jsx("path", { d: "M5 9.3v-2.8a3.5 3.5 0 0 1 7 0v10" })] }), F$1);
var O4 = R$2(jsxRuntimeExports.jsxs("g", { strokeWidth: 1.25, children: [jsxRuntimeExports.jsx("path", { stroke: "none", d: "M0 0h24v24H0z", fill: "none" }), jsxRuntimeExports.jsx("path", { d: "M15.5 13a3.5 3.5 0 0 0 -3.5 3.5v1a3.5 3.5 0 0 0 7 0v-1.8" }), jsxRuntimeExports.jsx("path", { d: "M8.5 13a3.5 3.5 0 0 1 3.5 3.5v1a3.5 3.5 0 0 1 -7 0v-1.8" }), jsxRuntimeExports.jsx("path", { d: "M17.5 16a3.5 3.5 0 0 0 0 -7h-.5" }), jsxRuntimeExports.jsx("path", { d: "M19 9.3v-2.8a3.5 3.5 0 0 0 -7 0" }), jsxRuntimeExports.jsx("path", { d: "M6.5 16a3.5 3.5 0 0 1 0 -7h.5" }), jsxRuntimeExports.jsx("path", { d: "M5 9.3v-2.8a3.5 3.5 0 0 1 7 0v10" })] }), F$1), A4 = R$2(jsxRuntimeExports.jsxs("g", { strokeWidth: 1.5, children: [jsxRuntimeExports.jsx("path", { stroke: "none", d: "M0 0h24v24H0z", fill: "none" }), jsxRuntimeExports.jsx("path", { d: "M10 10m-7 0a7 7 0 1 0 14 0a7 7 0 1 0 -14 0" }), jsxRuntimeExports.jsx("path", { d: "M21 21l-6 -6" })] }), F$1), K4 = R$2(jsxRuntimeExports.jsxs("g", { strokeWidth: 1.5, children: [jsxRuntimeExports.jsx("path", { stroke: "none", d: "M0 0h24v24H0z", fill: "none" }), jsxRuntimeExports.jsx("path", { d: "M20.984 12.53a9 9 0 1 0 -7.552 8.355" }), jsxRuntimeExports.jsx("path", { d: "M12 7v5l3 3" }), jsxRuntimeExports.jsx("path", { d: "M19 16l-2 3h4l-2 3" })] }), F$1), H4 = R$2(jsxRuntimeExports.jsxs("g", { strokeWidth: 1.5, children: [jsxRuntimeExports.jsx("path", { stroke: "none", d: "M0 0h24v24H0z", fill: "none" }), jsxRuntimeExports.jsx("path", { d: "M9 2m0 3a3 3 0 0 1 3 -3h0a3 3 0 0 1 3 3v5a3 3 0 0 1 -3 3h0a3 3 0 0 1 -3 -3z" }), jsxRuntimeExports.jsx("path", { d: "M5 10a7 7 0 0 0 14 0" }), jsxRuntimeExports.jsx("path", { d: "M8 21l8 0" }), jsxRuntimeExports.jsx("path", { d: "M12 17l0 4" })] }), F$1), J4 = R$2(jsxRuntimeExports.jsxs("g", { strokeWidth: 1.5, children: [jsxRuntimeExports.jsx("path", { stroke: "none", d: "M0 0h24v24H0z", fill: "none" }), jsxRuntimeExports.jsx("path", { d: "M3 3l18 18" }), jsxRuntimeExports.jsx("path", { d: "M9 5a3 3 0 0 1 6 0v5a3 3 0 0 1 -.13 .874m-2 2a3 3 0 0 1 -3.87 -2.872v-1" }), jsxRuntimeExports.jsx("path", { d: "M5 10a7 7 0 0 0 10.846 5.85m2 -2a6.967 6.967 0 0 0 1.152 -3.85" }), jsxRuntimeExports.jsx("path", { d: "M8 21l8 0" }), jsxRuntimeExports.jsx("path", { d: "M12 17l0 4" })] }), F$1), Y4 = R$2(jsxRuntimeExports.jsxs("g", { strokeWidth: 1.25, children: [jsxRuntimeExports.jsx("path", { stroke: "none", d: "M0 0h24v24H0z", fill: "none" }), jsxRuntimeExports.jsx("path", { d: "M13 3l0 7l6 0l-8 11l0 -7l-6 0l8 -11" })] }), F$1), C4 = R$2(jsxRuntimeExports.jsxs("g", { children: [jsxRuntimeExports.jsx("path", { stroke: "none", d: "M0 0h24v24H0z", fill: "none" }), jsxRuntimeExports.jsx("path", { d: "M8 8m0 1a1 1 0 0 1 1 -1h6a1 1 0 0 1 1 1v6a1 1 0 0 1 -1 1h-6a1 1 0 0 1 -1 -1z" }), jsxRuntimeExports.jsx("path", { d: "M12 20v.01" }), jsxRuntimeExports.jsx("path", { d: "M16 20v.01" }), jsxRuntimeExports.jsx("path", { d: "M8 20v.01" }), jsxRuntimeExports.jsx("path", { d: "M4 20v.01" }), jsxRuntimeExports.jsx("path", { d: "M4 16v.01" }), jsxRuntimeExports.jsx("path", { d: "M4 12v.01" }), jsxRuntimeExports.jsx("path", { d: "M4 8v.01" }), jsxRuntimeExports.jsx("path", { d: "M4 4v.01" }), jsxRuntimeExports.jsx("path", { d: "M8 4v.01" }), jsxRuntimeExports.jsx("path", { d: "M12 4v.01" }), jsxRuntimeExports.jsx("path", { d: "M16 4v.01" }), jsxRuntimeExports.jsx("path", { d: "M20 4v.01" }), jsxRuntimeExports.jsx("path", { d: "M20 8v.01" }), jsxRuntimeExports.jsx("path", { d: "M20 12v.01" }), jsxRuntimeExports.jsx("path", { d: "M20 16v.01" }), jsxRuntimeExports.jsx("path", { d: "M20 20v.01" })] }), F$1), V4 = R$2(jsxRuntimeExports.jsxs("g", { strokeWidth: 1.25, children: [jsxRuntimeExports.jsx("path", { stroke: "none", d: "M0 0h24v24H0z", fill: "none" }), jsxRuntimeExports.jsx("path", { d: "M5 3v18" }), jsxRuntimeExports.jsx("path", { d: "M19 21v-18" }), jsxRuntimeExports.jsx("path", { d: "M5 7h14" }), jsxRuntimeExports.jsx("path", { d: "M5 15h14" }), jsxRuntimeExports.jsx("path", { d: "M8 13v4" }), jsxRuntimeExports.jsx("path", { d: "M11 13v4" }), jsxRuntimeExports.jsx("path", { d: "M16 13v4" }), jsxRuntimeExports.jsx("path", { d: "M14 5v4" }), jsxRuntimeExports.jsx("path", { d: "M11 5v4" }), jsxRuntimeExports.jsx("path", { d: "M8 5v4" }), jsxRuntimeExports.jsx("path", { d: "M3 21h18" })] }), F$1), q4 = R$2(jsxRuntimeExports.jsxs("g", { strokeWidth: 1.25, children: [jsxRuntimeExports.jsx("path", { stroke: "none", d: "M0 0h24v24H0z", fill: "none" }), jsxRuntimeExports.jsx("path", { d: "M3 12l18 0" }), jsxRuntimeExports.jsx("path", { d: "M7 16l10 0l-10 5l0 -5" }), jsxRuntimeExports.jsx("path", { d: "M7 8l10 0l-10 -5l0 5" })] }), F$1), X4 = R$2(jsxRuntimeExports.jsxs("g", { strokeWidth: 1.25, children: [jsxRuntimeExports.jsx("path", { stroke: "none", d: "M0 0h24v24H0z", fill: "none" }), jsxRuntimeExports.jsx("path", { d: "M12 3l0 18" }), jsxRuntimeExports.jsx("path", { d: "M16 7l0 10l5 0l-5 -10" }), jsxRuntimeExports.jsx("path", { d: "M8 7l0 10l-5 0l5 -10" })] }), F$1), G4 = R$2(jsxRuntimeExports.jsxs("g", { strokeWidth: 1.25, children: [jsxRuntimeExports.jsx("path", { stroke: "none", d: "M0 0h24v24H0z", fill: "none" }), jsxRuntimeExports.jsx("path", { d: "M5 3m0 2a2 2 0 0 1 2 -2h10a2 2 0 0 1 2 2v2a2 2 0 0 1 -2 2h-10a2 2 0 0 1 -2 -2z" }), jsxRuntimeExports.jsx("path", { d: "M19 6h1a2 2 0 0 1 2 2a5 5 0 0 1 -5 5l-5 0v2" }), jsxRuntimeExports.jsx("path", { d: "M10 15m0 1a1 1 0 0 1 1 -1h2a1 1 0 0 1 1 1v4a1 1 0 0 1 -1 1h-2a1 1 0 0 1 -1 -1z" })] }), F$1), k4 = R$2(jsxRuntimeExports.jsxs("g", { strokeWidth: 1.25, children: [jsxRuntimeExports.jsx("path", { stroke: "none", d: "M0 0h24v24H0z", fill: "none" }), jsxRuntimeExports.jsx("path", { d: "M15 15m-5 0a5 5 0 1 0 10 0a5 5 0 1 0 -10 0" }), jsxRuntimeExports.jsx("path", { d: "M22 22l-3 -3" }), jsxRuntimeExports.jsx("path", { d: "M6 18h-1a2 2 0 0 1 -2 -2v-1" }), jsxRuntimeExports.jsx("path", { d: "M3 11v-1" }), jsxRuntimeExports.jsx("path", { d: "M3 6v-1a2 2 0 0 1 2 -2h1" }), jsxRuntimeExports.jsx("path", { d: "M10 3h1" }), jsxRuntimeExports.jsx("path", { d: "M15 3h1a2 2 0 0 1 2 2v1" })] }), F$1), Z4 = R$2(jsxRuntimeExports.jsxs("g", { strokeWidth: 1.25, children: [jsxRuntimeExports.jsx("path", { stroke: "none", d: "M0 0h24v24H0z", fill: "none" }), jsxRuntimeExports.jsx("path", { d: "M14 3v4a1 1 0 0 0 1 1h4" }), jsxRuntimeExports.jsx("path", { d: "M5 12v-7a2 2 0 0 1 2 -2h7l5 5v4" }), jsxRuntimeExports.jsx("path", { d: "M4 20.25c0 .414 .336 .75 .75 .75h1.25a1 1 0 0 0 1 -1v-1a1 1 0 0 0 -1 -1h-1a1 1 0 0 1 -1 -1v-1a1 1 0 0 1 1 -1h1.25a.75 .75 0 0 1 .75 .75" }), jsxRuntimeExports.jsx("path", { d: "M10 15l2 6l2 -6" }), jsxRuntimeExports.jsx("path", { d: "M20 15h-1a2 2 0 0 0 -2 2v2a2 2 0 0 0 2 2h1v-3" })] }), F$1), W4 = R$2(jsxRuntimeExports.jsxs("g", { strokeWidth: 1.25, children: [jsxRuntimeExports.jsx("path", { stroke: "none", d: "M0 0h24v24H0z", fill: "none" }), jsxRuntimeExports.jsx("path", { d: "M14 3v4a1 1 0 0 0 1 1h4" }), jsxRuntimeExports.jsx("path", { d: "M5 12v-7a2 2 0 0 1 2 -2h7l5 5v4" }), jsxRuntimeExports.jsx("path", { d: "M20 15h-1a2 2 0 0 0 -2 2v2a2 2 0 0 0 2 2h1v-3" }), jsxRuntimeExports.jsx("path", { d: "M5 18h1.5a1.5 1.5 0 0 0 0 -3h-1.5v6" }), jsxRuntimeExports.jsx("path", { d: "M11 21v-6l3 6v-6" })] }), F$1), z4 = R$2(jsxRuntimeExports.jsxs("g", { strokeWidth: 1.25, children: [jsxRuntimeExports.jsx("path", { stroke: "none", d: "M0 0h24v24H0z", fill: "none" }), jsxRuntimeExports.jsx("path", { d: "M4 13v-8a2 2 0 0 1 2 -2h1a2 2 0 0 1 2 2v8a2 2 0 0 0 6 0v-8a2 2 0 0 1 2 -2h1a2 2 0 0 1 2 2v8a8 8 0 0 1 -16 0" }), jsxRuntimeExports.jsx("path", { d: "M4 8l5 0" }), jsxRuntimeExports.jsx("path", { d: "M15 8l4 0" })] }), F$1), Q4 = R$2(jsxRuntimeExports.jsxs("g", { strokeWidth: 1.25, children: [jsxRuntimeExports.jsx("path", { stroke: "none", d: "M0 0h24v24H0z", fill: "none" }), jsxRuntimeExports.jsx("path", { d: "M3 14c.83 .642 2.077 1.017 3.5 1c1.423 .017 2.67 -.358 3.5 -1c.83 -.642 2.077 -1.017 3.5 -1c1.423 -.017 2.67 .358 3.5 1" }), jsxRuntimeExports.jsx("path", { d: "M8 3a2.4 2.4 0 0 0 -1 2a2.4 2.4 0 0 0 1 2" }), jsxRuntimeExports.jsx("path", { d: "M12 3a2.4 2.4 0 0 0 -1 2a2.4 2.4 0 0 0 1 2" }), jsxRuntimeExports.jsx("path", { d: "M3 10h14v5a6 6 0 0 1 -6 6h-2a6 6 0 0 1 -6 -6v-5z" }), jsxRuntimeExports.jsx("path", { d: "M16.746 16.726a3 3 0 1 0 .252 -5.555" })] }), F$1), j4 = R$2(jsxRuntimeExports.jsxs("g", { stroke: "currentColor", children: [jsxRuntimeExports.jsx("path", { stroke: "none", d: "M0 0h24v24H0z", fill: "none" }), jsxRuntimeExports.jsx("path", { d: "M3 5a1 1 0 0 1 1-1h16a1 1 0 0 1 1 1v10a1 1 0 0 1-1 1h-16a1 1 0 0 1-1-1v-10zM7 20h10M9 16v4M15 16v4" })] }), { ...F$1, strokeWidth: 1.5 });
R$2(jsxRuntimeExports.jsxs("g", { strokeWidth: 1.5, children: [jsxRuntimeExports.jsx("path", { stroke: "none", d: "M0 0h24v24H0z", fill: "none" }), jsxRuntimeExports.jsx("path", { d: "M15 8v-2a2 2 0 0 0 -2 -2h-7a2 2 0 0 0 -2 2v12a2 2 0 0 0 2 2h7a2 2 0 0 0 2 -2v-2" }), jsxRuntimeExports.jsx("path", { d: "M21 12h-13l3 -3" }), jsxRuntimeExports.jsx("path", { d: "M11 15l-3 -3" })] }), F$1);
var ty$1 = R$2(jsxRuntimeExports.jsxs("g", { children: [jsxRuntimeExports.jsx("path", { stroke: "none", d: "M0 0h24v24H0z", fill: "none" }), jsxRuntimeExports.jsx("path", { d: "M2 8a4 4 0 0 1 4 -4h12a4 4 0 0 1 4 4v8a4 4 0 0 1 -4 4h-12a4 4 0 0 1 -4 -4v-8z" }), jsxRuntimeExports.jsx("path", { d: "M10 9l5 3l-5 3z" })] }), F$1), ny$1 = R$2(jsxRuntimeExports.jsxs("g", { strokeWidth: 1.5, children: [jsxRuntimeExports.jsx("path", { stroke: "none", d: "M0 0h24v24H0z", fill: "none" }), jsxRuntimeExports.jsx("path", { d: "M3 6h18" }), jsxRuntimeExports.jsx("path", { d: "M3 12h18" }), jsxRuntimeExports.jsx("path", { d: "M3 18h18" }), jsxRuntimeExports.jsx("path", { d: "M6 3v18" }), jsxRuntimeExports.jsx("path", { d: "M12 3v18" }), jsxRuntimeExports.jsx("path", { d: "M18 3v18" })] }), F$1), ry$1 = R$2(jsxRuntimeExports.jsxs("g", { strokeWidth: 1.5, children: [jsxRuntimeExports.jsx("path", { stroke: "none", d: "M0 0h24v24H0z", fill: "none" }), jsxRuntimeExports.jsx("path", { d: "M17 3m0 1a1 1 0 0 1 1 -1h2a1 1 0 0 1 1 1v2a1 1 0 0 1 -1 1h-2a1 1 0 0 1 -1 -1z" }), jsxRuntimeExports.jsx("path", { d: "M3 17m0 1a1 1 0 0 1 1 -1h2a1 1 0 0 1 1 1v2a1 1 0 0 1 -1 1h-2a1 1 0 0 1 -1 -1z" }), jsxRuntimeExports.jsx("path", { d: "M17 5c-6.627 0 -12 5.373 -12 12" })] }), F$1), oy$1 = R$2(jsxRuntimeExports.jsxs("g", { children: [jsxRuntimeExports.jsx("path", { stroke: "none", d: "M0 0h24v24H0z", fill: "none" }), jsxRuntimeExports.jsx("path", { d: "M6 18l12 -12" }), jsxRuntimeExports.jsx("path", { d: "M18 10v-4h-4" })] }), F$1), iy$1 = R$2(jsxRuntimeExports.jsxs("g", { children: [jsxRuntimeExports.jsx("path", { stroke: "none", d: "M0 0h24v24H0z", fill: "none" }), jsxRuntimeExports.jsx("path", { d: "M4,19L10,19C11.097,19 12,18.097 12,17L12,9C12,7.903 12.903,7 14,7L21,7" }), jsxRuntimeExports.jsx("path", { d: "M18 4l3 3l-3 3" })] }), F$1), ay$1 = R$2(jsxRuntimeExports.jsxs("g", { children: [jsxRuntimeExports.jsx("path", { d: "M16,12L20,9L16,6" }), jsxRuntimeExports.jsx("path", { d: "M6 20c0 -6.075 4.925 -11 11 -11h3" })] }), F$1), sy$1 = R$2(jsxRuntimeExports.jsxs("g", { children: [jsxRuntimeExports.jsx("path", { stroke: "none", d: "M0 0h24v24H0z", fill: "none" }), jsxRuntimeExports.jsx("path", { d: "M6 9l6 6l6 -6" })] }), F$1), dy$1 = R$2(jsxRuntimeExports.jsxs("g", { children: [jsxRuntimeExports.jsx("path", { stroke: "none", d: "M0 0h24v24H0z", fill: "none" }), jsxRuntimeExports.jsx("path", { d: "M6 15l6 -6l6 6" })] }), F$1), cy$1 = R$2(jsxRuntimeExports.jsxs("g", { children: [jsxRuntimeExports.jsx("path", { stroke: "none", d: "M0 0h24v24H0z", fill: "none" }), jsxRuntimeExports.jsx("path", { d: "M6 15l6 -6l6 6" })] }), F$1), ly$1 = R$2(jsxRuntimeExports.jsxs("g", { strokeWidth: "1.25", children: [jsxRuntimeExports.jsx("path", { stroke: "none", d: "M0 0h24v24H0z", fill: "none" }), jsxRuntimeExports.jsx("path", { d: "M8 5v10a1 1 0 0 0 1 1h10" }), jsxRuntimeExports.jsx("path", { d: "M5 8h10a1 1 0 0 1 1 1v10" })] }), F$1), Uy$1 = R$2(jsxRuntimeExports.jsxs("g", { children: [jsxRuntimeExports.jsx("path", { stroke: "none", d: "M0 0h24v24H0z", fill: "none" }), jsxRuntimeExports.jsx("path", { d: "M5 5m-2 0a2 2 0 1 0 4 0a2 2 0 1 0 -4 0" }), jsxRuntimeExports.jsx("path", { d: "M19 5m-2 0a2 2 0 1 0 4 0a2 2 0 1 0 -4 0" }), jsxRuntimeExports.jsx("path", { d: "M5 19m-2 0a2 2 0 1 0 4 0a2 2 0 1 0 -4 0" }), jsxRuntimeExports.jsx("path", { d: "M19 19m-2 0a2 2 0 1 0 4 0a2 2 0 1 0 -4 0" }), jsxRuntimeExports.jsx("path", { d: "M5 7l0 10" }), jsxRuntimeExports.jsx("path", { d: "M7 5l10 0" }), jsxRuntimeExports.jsx("path", { d: "M7 19l10 0" }), jsxRuntimeExports.jsx("path", { d: "M19 7l0 10" })] }), F$1);
var Fr = { [Ie.Excalifont]: { metrics: { unitsPerEm: 1e3, ascender: 886, descender: -374, lineHeight: 1.25 }, icon: Nr$1 }, [Ie.Nunito]: { metrics: { unitsPerEm: 1e3, ascender: 1011, descender: -353, lineHeight: 1.35 }, icon: la }, [Ie["Lilita One"]]: { metrics: { unitsPerEm: 1e3, ascender: 923, descender: -220, lineHeight: 1.15 }, icon: Cd$1 }, [Ie["Comic Shanns"]]: { metrics: { unitsPerEm: 1e3, ascender: 750, descender: -250, lineHeight: 1.25 }, icon: Ua$1 }, [Ie.Virgil]: { metrics: { unitsPerEm: 1e3, ascender: 886, descender: -374, lineHeight: 1.25 }, icon: Nr$1, deprecated: true }, [Ie.Helvetica]: { metrics: { unitsPerEm: 2048, ascender: 1577, descender: -471, lineHeight: 1.15 }, icon: la, deprecated: true, local: true }, [Ie.Cascadia]: { metrics: { unitsPerEm: 2048, ascender: 1900, descender: -480, lineHeight: 1.2 }, icon: Ua$1, deprecated: true }, [Ie["Liberation Sans"]]: { metrics: { unitsPerEm: 2048, ascender: 1854, descender: -434, lineHeight: 1.15 }, serverSide: true }, [Un.Xiaolai]: { metrics: { unitsPerEm: 1e3, ascender: 880, descender: -144, lineHeight: 1.15 }, fallback: true }, [Un["Segoe UI Emoji"]]: { metrics: { unitsPerEm: 1e3, ascender: 886, descender: -374, lineHeight: 1.25 }, local: true, fallback: true } }, tn = { LATIN: "U+0000-00FF, U+0131, U+0152-0153, U+02BB-02BC, U+02C6, U+02DA, U+02DC, U+0304, U+0308, U+0329, U+2000-206F, U+2074, U+20AC, U+2122, U+2191, U+2193, U+2212, U+2215, U+FEFF, U+FFFD", LATIN_EXT: "U+0100-02AF, U+0304, U+0308, U+0329, U+1E00-1E9F, U+1EF2-1EFF, U+2020, U+20A0-20AB, U+20AD-20C0, U+2113, U+2C60-2C7F, U+A720-A7FF", CYRILIC_EXT: "U+0460-052F, U+1C80-1C88, U+20B4, U+2DE0-2DFF, U+A640-A69F, U+FE2E-FE2F", CYRILIC: "U+0301, U+0400-045F, U+0490-0491, U+04B0-04B1, U+2116", VIETNAMESE: "U+0102-0103, U+0110-0111, U+0128-0129, U+0168-0169, U+01A0-01A1, U+01AF-01B0, U+0300-0301, U+0303-0304, U+0308-0309, U+0323, U+0329, U+1EA0-1EF9, U+20AB" }, Wn = "local:";
var Yo = class extends Error {
  constructor(t3 = "Couldn't export canvas.", n3 = "CANVAS_ERROR") {
    super(), this.name = n3, this.message = t3;
  }
}, Co = class extends DOMException {
  constructor(t3 = "Request Aborted") {
    super(t3, "AbortError");
  }
}, nn = class extends Error {
  constructor(n3 = "Image Scene Data Error", r3 = "IMAGE_SCENE_DATA_ERROR") {
    super(n3);
    i$1(this, "code");
    this.name = "EncodingError", this.code = r3;
  }
}, Vo = class extends Error {
  constructor() {
    super(...arguments);
    i$1(this, "code", "ELEMENT_HAS_INVALID_INDEX");
  }
}, zn = class extends Error {
  constructor(n3 = "Worker URL is not defined!", r3 = "WORKER_URL_NOT_DEFINED") {
    super(n3);
    i$1(this, "code");
    this.name = "WorkerUrlNotDefinedError", this.code = r3;
  }
}, Qn = class extends Error {
  constructor(n3 = "Worker has to be in a separate chunk!", r3 = "WORKER_IN_THE_MAIN_CHUNK") {
    super(n3);
    i$1(this, "code");
    this.name = "WorkerInTheMainChunkError", this.code = r3;
  }
}, Br = class extends Error {
  constructor(t3) {
    super(t3), this.name = "ExcalidrawError";
  }
};
var fa = class {
  constructor(t3) {
    i$1(this, "instance");
    i$1(this, "debounceTerminate");
    this.instance = new Worker(t3, { type: "module" });
  }
}, qo$1 = class e2 {
  constructor(t3, n3) {
    i$1(this, "idleWorkers", /* @__PURE__ */ new Set());
    i$1(this, "workerUrl");
    i$1(this, "workerTTL");
    this.workerUrl = t3, this.workerTTL = n3.ttl || 1e3;
  }
  static create(t3, n3 = {}) {
    if (!t3) throw new zn();
    if (!import.meta.url || t3.toString() === import.meta.url) throw new Qn();
    return new e2(t3, n3);
  }
  async postMessage(t3, n3) {
    let r3, o3 = Array.from(this.idleWorkers).shift();
    return o3 ? (this.idleWorkers.delete(o3), r3 = o3) : r3 = await this.createWorker(), new Promise((i3, a3) => {
      r3.instance.onmessage = this.onMessageHandler(r3, i3), r3.instance.onerror = this.onErrorHandler(r3, a3), r3.instance.postMessage(t3, n3), r3.debounceTerminate(() => a3(new Error(`Active worker did not respond for ${this.workerTTL}ms!`)));
    });
  }
  async clear() {
    for (let t3 of this.idleWorkers) t3.debounceTerminate.cancel(), t3.instance.terminate();
    this.idleWorkers.clear();
  }
  async createWorker() {
    let t3 = new fa(this.workerUrl);
    return t3.debounceTerminate = $o((n3) => {
      t3.instance.terminate(), this.idleWorkers.has(t3) ? (this.idleWorkers.delete(t3), console.debug("Job finished! Idle worker has been released from the pool.")) : n3 ? n3() : console.error("Worker has been terminated!");
    }, this.workerTTL), t3;
  }
  onMessageHandler(t3, n3) {
    return (r3) => {
      t3.debounceTerminate(), this.idleWorkers.add(t3), n3(r3.data);
    };
  }
  onErrorHandler(t3, n3) {
    return (r3) => {
      t3.debounceTerminate(() => n3(r3)), t3.debounceTerminate.flush(), this.clear();
    };
  }
};
var Vd = typeof Worker < "u", qd = async (e12, t3) => {
  let { Commands: n3, subsetToBase64: r3, toBase64: o3 } = await z6();
  return Vd ? mn(async () => {
    try {
      let i3 = await Q6(), a3 = e12.slice(0), s3 = await i3.postMessage({ command: n3.Subset, arrayBuffer: a3, codePoints: t3 }, { transfer: [a3] });
      return o3(s3);
    } catch (i3) {
      return Vd = false, bd$1() && (i3 instanceof zn || i3 instanceof Qn) || console.error("Failed to use workers for subsetting, falling back to the main thread.", i3), r3(e12, t3);
    }
  }) : r3(e12, t3);
}, pa = null, ua = null, W6 = async () => (pa || (pa = __vitePreload(() => import("./subset-worker.chunk-CAElXgZ2.js"), true ? __vite__mapDeps([0,1]) : void 0, import.meta.url)), pa), z6 = async () => (ua || (ua = __vitePreload(() => import("./subset-shared.chunk-OxIjZu0m.js"), true ? [] : void 0, import.meta.url)), ua), ma = null, Q6 = () => (ma || (ma = mn(async () => {
  let { WorkerUrl: e12 } = await W6();
  return qo$1.create(e12);
})), ma);
var jn = class jn2 {
  constructor(t3, n3, r3) {
    i$1(this, "urls");
    i$1(this, "fontFace");
    this.urls = jn2.createUrls(n3);
    let o3 = this.urls.map((i3) => `url(${i3}) ${jn2.getFormat(i3)}`).join(", ");
    this.fontFace = new FontFace(t3, o3, { display: "swap", style: "normal", weight: "400", ...r3 });
  }
  toCSS(t3) {
    if (!this.getUnicodeRangeRegex().test(t3)) return;
    let n3 = Array.from(t3).map((r3) => r3.codePointAt(0));
    return this.getContent(n3).then((r3) => `@font-face { font-family: ${this.fontFace.family}; src: url(${r3}); }`);
  }
  async getContent(t3) {
    let n3 = 0, r3 = [];
    for (; n3 < this.urls.length; ) {
      let o3 = this.urls[n3];
      try {
        let i3 = await this.fetchFont(o3);
        return await qd(i3, t3);
      } catch (i3) {
        r3.push(`"${o3.toString()}" returned error "${i3}"`);
      }
      n3++;
    }
    return console.error(`Failed to fetch font family "${this.fontFace.family}"`, JSON.stringify(r3, void 0, 2)), this.urls.length ? this.urls[this.urls.length - 1].toString() : "";
  }
  fetchFont(t3) {
    return mn(async () => {
      let n3 = await fetch(t3, { cache: "force-cache", headers: { Accept: "font/woff2" } });
      if (!n3.ok) {
        let o3 = t3 instanceof URL ? t3.toString() : "dataurl";
        throw new Error(`Failed to fetch "${o3}": ${n3.statusText}`);
      }
      return await n3.arrayBuffer();
    });
  }
  getUnicodeRangeRegex() {
    let t3 = this.fontFace.unicodeRange.split(/,\s*/).map((n3) => {
      let [r3, o3] = n3.replace("U+", "").split("-");
      return o3 ? `\\u{${r3}}-\\u{${o3}}` : `\\u{${r3}}`;
    }).join("");
    return new RegExp(`[${t3}]`, "u");
  }
  static createUrls(t3) {
    if (t3.startsWith("data")) return [t3];
    if (t3.startsWith(Wn)) return [];
    if (t3.startsWith("http")) return [new URL(t3)];
    let n3 = t3.replace(/^\/+/, ""), r3 = [];
    if (typeof window.EXCALIDRAW_ASSET_PATH == "string") {
      let o3 = this.normalizeBaseUrl(window.EXCALIDRAW_ASSET_PATH);
      r3.push(new URL(n3, o3));
    } else Array.isArray(window.EXCALIDRAW_ASSET_PATH) && window.EXCALIDRAW_ASSET_PATH.forEach((o3) => {
      let i3 = this.normalizeBaseUrl(o3);
      r3.push(new URL(n3, i3));
    });
    return r3.push(new URL(n3, jn2.ASSETS_FALLBACK_URL)), r3;
  }
  static getFormat(t3) {
    if (!(t3 instanceof URL)) return "";
    try {
      let n3 = new URL(t3).pathname.split(".");
      return n3.length === 1 ? "" : `format('${n3.pop()}')`;
    } catch {
      return "";
    }
  }
  static normalizeBaseUrl(t3) {
    let n3 = t3;
    return /^\.?\//.test(n3) && (n3 = new URL(n3.replace(/^\.?\/+/, ""), window?.location?.origin).toString()), n3 = `${n3.replace(/\/+$/, "")}/`, n3;
  }
};
i$1(jn, "ASSETS_FALLBACK_URL", `https://esm.sh/${`${c$1.PKG_NAME}@${c$1.PKG_VERSION}`}/dist/prod/`);
var Xo = jn;
var Xd = "./fonts/Cascadia/CascadiaCode-Regular.woff2";
var Gd = [{ uri: Xd }];
var kd = "./fonts/ComicShanns/ComicShanns-Regular-279a7b317d12eb88de06167bd672b4b4.woff2";
var Zd = "./fonts/ComicShanns/ComicShanns-Regular-fcb0fc02dcbee4c9846b3e2508668039.woff2";
var Wd = "./fonts/ComicShanns/ComicShanns-Regular-dc6a8806fa96795d7b3be5026f989a17.woff2";
var zd = "./fonts/ComicShanns/ComicShanns-Regular-6e066e8de2ac57ea9283adb9c24d7f0c.woff2";
var Qd = [{ uri: kd, descriptors: { unicodeRange: "U+20-7e,U+a1-a6,U+a8,U+ab-ac,U+af-b1,U+b4,U+b8,U+bb-bc,U+bf-cf,U+d1-d7,U+d9-de,U+e0-ef,U+f1-f7,U+f9-ff,U+131,U+152-153,U+2c6,U+2da,U+2dc,U+2013-2014,U+2018-201a,U+201c-201d,U+2020-2022,U+2026,U+2039-203a,U+2044,U+20ac,U+2191,U+2193,U+2212" } }, { uri: Zd, descriptors: { unicodeRange: "U+100-10f,U+112-125,U+128-130,U+134-137,U+139-13c,U+141-148,U+14c-151,U+154-161,U+164-165,U+168-17f,U+1bf,U+1f7,U+218-21b,U+237,U+1e80-1e85,U+1ef2-1ef3,U+a75b" } }, { uri: Wd, descriptors: { unicodeRange: "U+2c7,U+2d8-2d9,U+2db,U+2dd,U+315,U+2190,U+2192,U+2200,U+2203-2204,U+2264-2265,U+f6c3" } }, { uri: zd, descriptors: { unicodeRange: "U+3bb" } }];
var jd = [{ uri: Wn }];
var ec$1 = "./fonts/Excalifont/Excalifont-Regular-a88b72a24fb54c9f94e3b5fdaa7481c9.woff2";
var tc = "./fonts/Excalifont/Excalifont-Regular-be310b9bcd4f1a43f571c46df7809174.woff2";
var nc = "./fonts/Excalifont/Excalifont-Regular-b9dcf9d2e50a1eaf42fc664b50a3fd0d.woff2";
var rc = "./fonts/Excalifont/Excalifont-Regular-41b173a47b57366892116a575a43e2b6.woff2";
var oc$1 = "./fonts/Excalifont/Excalifont-Regular-3f2c5db56cc93c5a6873b1361d730c16.woff2";
var ic$1 = "./fonts/Excalifont/Excalifont-Regular-349fac6ca4700ffec595a7150a0d1e1d.woff2";
var ac$1 = "./fonts/Excalifont/Excalifont-Regular-623ccf21b21ef6b3a0d87738f77eb071.woff2";
var sc$1 = [{ uri: ec$1, descriptors: { unicodeRange: "U+20-7e,U+a0-a3,U+a5-a6,U+a8-ab,U+ad-b1,U+b4,U+b6-b8,U+ba-ff,U+131,U+152-153,U+2bc,U+2c6,U+2da,U+2dc,U+304,U+308,U+2013-2014,U+2018-201a,U+201c-201e,U+2020,U+2022,U+2024-2026,U+2030,U+2039-203a,U+20ac,U+2122,U+2212" } }, { uri: tc, descriptors: { unicodeRange: "U+100-130,U+132-137,U+139-149,U+14c-151,U+154-17e,U+192,U+1fc-1ff,U+218-21b,U+237,U+1e80-1e85,U+1ef2-1ef3,U+2113" } }, { uri: nc, descriptors: { unicodeRange: "U+400-45f,U+490-491,U+2116" } }, { uri: rc, descriptors: { unicodeRange: "U+37e,U+384-38a,U+38c,U+38e-393,U+395-3a1,U+3a3-3a8,U+3aa-3cf,U+3d7" } }, { uri: oc$1, descriptors: { unicodeRange: "U+2c7,U+2d8-2d9,U+2db,U+2dd,U+302,U+306-307,U+30a-30c,U+326-328,U+212e,U+2211,U+fb01-fb02" } }, { uri: ic$1, descriptors: { unicodeRange: "U+462-463,U+472-475,U+4d8-4d9,U+4e2-4e3,U+4e6-4e9,U+4ee-4ef" } }, { uri: ac$1, descriptors: { unicodeRange: "U+300-301,U+303" } }];
var dc$1 = [{ uri: Wn }];
var cc$1 = "./fonts/Liberation/LiberationSans-Regular.woff2";
var lc$1 = [{ uri: cc$1 }];
var Uc = "./fonts/Lilita/Lilita-Regular-i7dPIFZ9Zz-WBtRtedDbYEF8RXi4EwQ.woff2";
var fc$1 = "./fonts/Lilita/Lilita-Regular-i7dPIFZ9Zz-WBtRtedDbYE98RXi4EwSsbg.woff2";
var pc$1 = [{ uri: fc$1, descriptors: { unicodeRange: tn.LATIN_EXT } }, { uri: Uc, descriptors: { unicodeRange: tn.LATIN } }];
var uc$1 = "./fonts/Nunito/Nunito-Regular-XRXI3I6Li01BKofiOc5wtlZ2di8HDIkhdTQ3j6zbXWjgeg.woff2";
var mc = "./fonts/Nunito/Nunito-Regular-XRXI3I6Li01BKofiOc5wtlZ2di8HDIkhdTo3j6zbXWjgevT5.woff2";
var bc$1 = "./fonts/Nunito/Nunito-Regular-XRXI3I6Li01BKofiOc5wtlZ2di8HDIkhdTA3j6zbXWjgevT5.woff2";
var Ec = "./fonts/Nunito/Nunito-Regular-XRXI3I6Li01BKofiOc5wtlZ2di8HDIkhdTk3j6zbXWjgevT5.woff2";
var gc$1 = "./fonts/Nunito/Nunito-Regular-XRXI3I6Li01BKofiOc5wtlZ2di8HDIkhdTs3j6zbXWjgevT5.woff2";
var xc$1 = [{ uri: Ec, descriptors: { unicodeRange: tn.CYRILIC_EXT, weight: "500" } }, { uri: bc$1, descriptors: { unicodeRange: tn.CYRILIC, weight: "500" } }, { uri: gc$1, descriptors: { unicodeRange: tn.VIETNAMESE, weight: "500" } }, { uri: mc, descriptors: { unicodeRange: tn.LATIN_EXT, weight: "500" } }, { uri: uc$1, descriptors: { unicodeRange: tn.LATIN, weight: "500" } }];
var hc = "./fonts/Virgil/Virgil-Regular.woff2";
var yc$1 = [{ uri: hc }];
var Ic$1 = "./fonts/Xiaolai/Xiaolai-Regular-09850c4077f3fffe707905872e0e2460.woff2";
var wc$1 = "./fonts/Xiaolai/Xiaolai-Regular-7eb9fffd1aa890d07d0f88cc82e6cfe4.woff2";
var Rc$1 = "./fonts/Xiaolai/Xiaolai-Regular-60a3089806700d379f11827ee9843b6b.woff2";
var Tc$1 = "./fonts/Xiaolai/Xiaolai-Regular-6fe5c5973cc06f74b2387a631ea36b88.woff2";
var Mc$1 = "./fonts/Xiaolai/Xiaolai-Regular-b96d9226ce77ec94ceca043d712182e6.woff2";
var Lc = "./fonts/Xiaolai/Xiaolai-Regular-6ae5b42180ad70b971c91e7eefb8eba2.woff2";
var Dc = "./fonts/Xiaolai/Xiaolai-Regular-a4c34be6d42152e64b0df90bc4607f64.woff2";
var Sc$1 = "./fonts/Xiaolai/Xiaolai-Regular-c69f61a4ab18d0488c8d1fc12e7028e8.woff2";
var vc$1 = "./fonts/Xiaolai/Xiaolai-Regular-e3fcf5180fd466c8915c4e8069491054.woff2";
var $c$1 = "./fonts/Xiaolai/Xiaolai-Regular-c1f94158256bb1f3bf665b053d895af9.woff2";
var Pc = "./fonts/Xiaolai/Xiaolai-Regular-544fc28abe2c5c30e62383fd4dac255f.woff2";
var Nc = "./fonts/Xiaolai/Xiaolai-Regular-7197d6fda6cba7c3874c53d6381ca239.woff2";
var Fc = "./fonts/Xiaolai/Xiaolai-Regular-70c2eb8d64e71a42a834eb857ea9df51.woff2";
var Bc = "./fonts/Xiaolai/Xiaolai-Regular-069e77aac84590e2e991d0a0176d34f2.woff2";
var _c$1 = "./fonts/Xiaolai/Xiaolai-Regular-41521fade99856108931b4768b1b2648.woff2";
var Oc = "./fonts/Xiaolai/Xiaolai-Regular-a004ddfcb26e67bd6e678c8ed19e25ce.woff2";
var Ac = "./fonts/Xiaolai/Xiaolai-Regular-04b718e5623574919c8b0dea5f301444.woff2";
var Kc = "./fonts/Xiaolai/Xiaolai-Regular-7e4bde7e9c7f84cd34d8a845e384c746.woff2";
var Hc$1 = "./fonts/Xiaolai/Xiaolai-Regular-23686f7f29da6e8008c36dd3a80c83d6.woff2";
var Jc$1 = "./fonts/Xiaolai/Xiaolai-Regular-69c09cc5fa3e55c74fc4821f76909cc3.woff2";
var Yc$1 = "./fonts/Xiaolai/Xiaolai-Regular-25b7f38e18f035f96cb5e547bd2bd08c.woff2";
var Cc$1 = "./fonts/Xiaolai/Xiaolai-Regular-ba3de316d63c7e339987b16f41a0b879.woff2";
var Vc$1 = "./fonts/Xiaolai/Xiaolai-Regular-12b52b58eb3df36804b9a654ec9ee194.woff2";
var qc$1 = "./fonts/Xiaolai/Xiaolai-Regular-b1220a3c61f85cc0408deedb4c5f57a2.woff2";
var Xc$1 = "./fonts/Xiaolai/Xiaolai-Regular-4535823663ad81405188a528d8f2b1a2.woff2";
var Gc$1 = "./fonts/Xiaolai/Xiaolai-Regular-3eaa538115d76932653c21d8dc28f207.woff2";
var kc$1 = "./fonts/Xiaolai/Xiaolai-Regular-7e929f262f30c8ee78bf398150b1a7cd.woff2";
var Zc$1 = "./fonts/Xiaolai/Xiaolai-Regular-73e309718fd16cea44b4d54a33581811.woff2";
var Wc = "./fonts/Xiaolai/Xiaolai-Regular-9eb5a99df4e76ac3363453ac9ca288b1.woff2";
var zc = "./fonts/Xiaolai/Xiaolai-Regular-3e63ed8162808a9e425ed80a8bc79114.woff2";
var Qc$1 = "./fonts/Xiaolai/Xiaolai-Regular-cb17fc3db95f6d139afc9d31a8e93293.woff2";
var jc = "./fonts/Xiaolai/Xiaolai-Regular-c8b71798409ccc126ee264a00aadcf21.woff2";
var el$1 = "./fonts/Xiaolai/Xiaolai-Regular-11c345711937f0ba4b8f7b6b919c8440.woff2";
var tl = "./fonts/Xiaolai/Xiaolai-Regular-e480d9c614742d05f0e78f274f1e69e6.woff2";
var nl$1 = "./fonts/Xiaolai/Xiaolai-Regular-95429962233afd82db1c27df1500a28c.woff2";
var rl = "./fonts/Xiaolai/Xiaolai-Regular-2cf96d082d35ea3d8106851223ad0d16.woff2";
var ol$1 = "./fonts/Xiaolai/Xiaolai-Regular-2d43040e86ff03ba677f6f9c04cd0805.woff2";
var il$1 = "./fonts/Xiaolai/Xiaolai-Regular-2a26d20a23b00898ce82f09d2ee47c3f.woff2";
var al$1 = "./fonts/Xiaolai/Xiaolai-Regular-a365e82ed54697a52f27adcea1315fe8.woff2";
var sl$1 = "./fonts/Xiaolai/Xiaolai-Regular-f5d079153c99a25b9be5b8583c4cc8a7.woff2";
var dl$1 = "./fonts/Xiaolai/Xiaolai-Regular-10a7ae9a371830a80c3d844acf1c02d7.woff2";
var cl$1 = "./fonts/Xiaolai/Xiaolai-Regular-e4bca6cfa53e499cae0a6be4894a90e9.woff2";
var ll$1 = "./fonts/Xiaolai/Xiaolai-Regular-60a41c7e1c68f22424e6d22df544bc82.woff2";
var Ul = "./fonts/Xiaolai/Xiaolai-Regular-7ab2bed91166a9dca83a5ebfbe2a7f38.woff2";
var fl = "./fonts/Xiaolai/Xiaolai-Regular-670ba603758d94268e8606f240a42e12.woff2";
var pl = "./fonts/Xiaolai/Xiaolai-Regular-e656f091b9dc4709722c9f4b84d3c797.woff2";
var ul = "./fonts/Xiaolai/Xiaolai-Regular-15dc6d811c9cd078f9086a740d5a1038.woff2";
var ml = "./fonts/Xiaolai/Xiaolai-Regular-f0f13b5c60e0af5553bd359f5513be1b.woff2";
var bl = "./fonts/Xiaolai/Xiaolai-Regular-8c2f33cee3993174f7e87c28e4bf42ee.woff2";
var El = "./fonts/Xiaolai/Xiaolai-Regular-761d05e3cd968cf574166867998ef06a.woff2";
var gl = "./fonts/Xiaolai/Xiaolai-Regular-642b26e2e5f5fb780b51b593dbc8c851.woff2";
var xl = "./fonts/Xiaolai/Xiaolai-Regular-5572b3513ba8df57a3d5d7303ee6b11b.woff2";
var hl = "./fonts/Xiaolai/Xiaolai-Regular-3c9de2ae0ea4bc91a510942dfa4be8d2.woff2";
var yl = "./fonts/Xiaolai/Xiaolai-Regular-671a2c20b1eb9e4ef8a192833940e319.woff2";
var Il = "./fonts/Xiaolai/Xiaolai-Regular-4dc6d5f188d5c96d44815cd1e81aa885.woff2";
var wl = "./fonts/Xiaolai/Xiaolai-Regular-ce4884f96f11589608b76b726a755803.woff2";
var Rl = "./fonts/Xiaolai/Xiaolai-Regular-8f476c4c99813d57cbe6eca4727388ad.woff2";
var Tl = "./fonts/Xiaolai/Xiaolai-Regular-5935a5775af3d5c6307ac667bd9ae74e.woff2";
var Ml = "./fonts/Xiaolai/Xiaolai-Regular-79f007c1c6d07557120982951ea67998.woff2";
var Ll = "./fonts/Xiaolai/Xiaolai-Regular-bafff7a14c27403dcc6cf1432e8ea836.woff2";
var Dl = "./fonts/Xiaolai/Xiaolai-Regular-543fa46ace099a7099dad69123399400.woff2";
var Sl = "./fonts/Xiaolai/Xiaolai-Regular-4ddc14ed3eb0c3e46364317dfc0144a3.woff2";
var vl = "./fonts/Xiaolai/Xiaolai-Regular-0fa55a080fcd0f9dc2e0b0058b793df8.woff2";
var $l = "./fonts/Xiaolai/Xiaolai-Regular-66493ba5a8367f2928812f446f47b56a.woff2";
var Pl = "./fonts/Xiaolai/Xiaolai-Regular-57862b464a55b18c7bf234ce22907d73.woff2";
var Nl = "./fonts/Xiaolai/Xiaolai-Regular-8d3bcabb847b56243b16afe62adaaf21.woff2";
var Fl = "./fonts/Xiaolai/Xiaolai-Regular-2b77e8ebfb2367ab2662396a60e7d320.woff2";
var Bl = "./fonts/Xiaolai/Xiaolai-Regular-0b5d723fdc4e249c140f0909e87d03b4.woff2";
var _l = "./fonts/Xiaolai/Xiaolai-Regular-cdbce89e82cc1ab53a2decbf5819278f.woff2";
var Ol = "./fonts/Xiaolai/Xiaolai-Regular-739bc1a567439c7cffcd1614644593d2.woff2";
var Al = "./fonts/Xiaolai/Xiaolai-Regular-72252d73220fa3cd856677888cee1635.woff2";
var Kl = "./fonts/Xiaolai/Xiaolai-Regular-08e0dc436ad0ad61ba5558db0674d762.woff2";
var Hl = "./fonts/Xiaolai/Xiaolai-Regular-cf6ff4e0f491ca0cf3038187a997b9b4.woff2";
var Jl = "./fonts/Xiaolai/Xiaolai-Regular-9cfb2a77a4e45025105ad29a1748b90d.woff2";
var Yl = "./fonts/Xiaolai/Xiaolai-Regular-450da755d5bcb70906e1295e559b9602.woff2";
var Cl = "./fonts/Xiaolai/Xiaolai-Regular-0986d134c05864f5025962eef9f994a0.woff2";
var Vl = "./fonts/Xiaolai/Xiaolai-Regular-1ee544f0f1dac422545c505baa788992.woff2";
var ql = "./fonts/Xiaolai/Xiaolai-Regular-4806e761d750087c2d734fc64596eaff.woff2";
var Xl = "./fonts/Xiaolai/Xiaolai-Regular-33432927cd87d40cfe393c7482bf221f.woff2";
var Gl = "./fonts/Xiaolai/Xiaolai-Regular-be549ab72f0719d606a5c01e2c0219b6.woff2";
var kl = "./fonts/Xiaolai/Xiaolai-Regular-019d66dcad46dc156b162d267f981c20.woff2";
var Zl = "./fonts/Xiaolai/Xiaolai-Regular-b5c1596551c256e0e9cf02028595b092.woff2";
var Wl = "./fonts/Xiaolai/Xiaolai-Regular-e5f453bb04da18eed01675eeebd88bf8.woff2";
var zl = "./fonts/Xiaolai/Xiaolai-Regular-cf2cc71752631e579e35b0e423bf2638.woff2";
var Ql = "./fonts/Xiaolai/Xiaolai-Regular-6f3256af8454371776bc46670d33cc65.woff2";
var jl = "./fonts/Xiaolai/Xiaolai-Regular-23f228f3999c01983860012330e4be08.woff2";
var eU = "./fonts/Xiaolai/Xiaolai-Regular-21430ee05a1248901da8d0de08744d47.woff2";
var tU = "./fonts/Xiaolai/Xiaolai-Regular-5330a2119a716e4e7224ed108b085dac.woff2";
var nU = "./fonts/Xiaolai/Xiaolai-Regular-cd145ce4a0ea18469358df53c207bc1b.woff2";
var rU = "./fonts/Xiaolai/Xiaolai-Regular-36925dfe329a45086cbb7fc5c20d45ac.woff2";
var oU = "./fonts/Xiaolai/Xiaolai-Regular-4bfaa8ffa64c5ee560aa2daba7c9cbd3.woff2";
var iU = "./fonts/Xiaolai/Xiaolai-Regular-112c051027b2d766c19a519f6ee1f4f7.woff2";
var aU = "./fonts/Xiaolai/Xiaolai-Regular-5b0ed6971aaab9c8ad563230bd5471a7.woff2";
var sU = "./fonts/Xiaolai/Xiaolai-Regular-98f2ad84457de7f3740d9920b8fa8667.woff2";
var dU = "./fonts/Xiaolai/Xiaolai-Regular-733171b4ffcd17ea1fe1c0ba627173bf.woff2";
var cU = "./fonts/Xiaolai/Xiaolai-Regular-684d65f1793cac449dde5d59cb3c47fb.woff2";
var lU = "./fonts/Xiaolai/Xiaolai-Regular-cbaaefaaf326668277aa24dfa93c4d28.woff2";
var UU = "./fonts/Xiaolai/Xiaolai-Regular-58fd02350d0bc52cf1ca3bb32ce9766e.woff2";
var fU = "./fonts/Xiaolai/Xiaolai-Regular-7ccce86603f80a099ddb0cb21d4ae3e3.woff2";
var pU = "./fonts/Xiaolai/Xiaolai-Regular-3717077e38f98d89eae729b6c14e56dc.woff2";
var uU = "./fonts/Xiaolai/Xiaolai-Regular-dbea1af6dcd9860be40c3d18254338f5.woff2";
var mU = "./fonts/Xiaolai/Xiaolai-Regular-4a0fdb40036e87b40aa08dd30584cb85.woff2";
var bU = "./fonts/Xiaolai/Xiaolai-Regular-0f626226ba1272e832aea87bafd9720e.woff2";
var EU = "./fonts/Xiaolai/Xiaolai-Regular-938d90c10ff8c20386af7f242c05d6b0.woff2";
var gU = "./fonts/Xiaolai/Xiaolai-Regular-b6d128682ee29e471486354d486a1b90.woff2";
var xU = "./fonts/Xiaolai/Xiaolai-Regular-e51ef413167c6e14e0c0fdcc585f2fc9.woff2";
var hU = "./fonts/Xiaolai/Xiaolai-Regular-9d81066dd2b337c938df6e90380a00dc.woff2";
var yU = "./fonts/Xiaolai/Xiaolai-Regular-20e7bf72fa05de9adf7dbcc7bf51dde6.woff2";
var IU = "./fonts/Xiaolai/Xiaolai-Regular-4095eb84ef3874e2600247bee0b04026.woff2";
var wU = "./fonts/Xiaolai/Xiaolai-Regular-4ee10ae43505e2e0bc62656ced49c0fa.woff2";
var RU = "./fonts/Xiaolai/Xiaolai-Regular-7494dc504ae00ee9cd0505f990f88c5d.woff2";
var TU = "./fonts/Xiaolai/Xiaolai-Regular-8de5b863cb50dfefdd07cb11c774d579.woff2";
var MU = "./fonts/Xiaolai/Xiaolai-Regular-3e1f8f654357353bf0e04ba5c34b5f7f.woff2";
var LU = "./fonts/Xiaolai/Xiaolai-Regular-2e33e8dc771ef5e1d9127d60a6b73679.woff2";
var DU = "./fonts/Xiaolai/Xiaolai-Regular-173945821411c09f70c95f98d590e697.woff2";
var SU = "./fonts/Xiaolai/Xiaolai-Regular-b358f7a51ece39a3247942b1feabdb29.woff2";
var vU = "./fonts/Xiaolai/Xiaolai-Regular-23ad2d71b280f00b1363b95b7bea94eb.woff2";
var $U = "./fonts/Xiaolai/Xiaolai-Regular-5882ffa04f32584d26109137e2da4352.woff2";
var PU = "./fonts/Xiaolai/Xiaolai-Regular-a203b91dad570bf05a58c3c3ddb529bf.woff2";
var NU = "./fonts/Xiaolai/Xiaolai-Regular-bd77e3c7f9e0b072d96af37f73d1aa32.woff2";
var FU = "./fonts/Xiaolai/Xiaolai-Regular-5a45d991244d4c7140217e1e5f5ca4f4.woff2";
var BU = "./fonts/Xiaolai/Xiaolai-Regular-f56414bf9bced67990def8660e306759.woff2";
var _U = "./fonts/Xiaolai/Xiaolai-Regular-583d166e56ba0de4b77eabb47ef67839.woff2";
var OU = "./fonts/Xiaolai/Xiaolai-Regular-7f855356ab893b0d2b9c1c83b8116f0e.woff2";
var AU = "./fonts/Xiaolai/Xiaolai-Regular-b57aaedfd8ebdf3931f25119dc6a5eb2.woff2";
var KU = "./fonts/Xiaolai/Xiaolai-Regular-b6fd38ca30869792244804b04bc058da.woff2";
var HU = "./fonts/Xiaolai/Xiaolai-Regular-452225341522a7942f0f6aab1a5c91a3.woff2";
var JU = "./fonts/Xiaolai/Xiaolai-Regular-866fa7613df6b3fd272bcfd4530c0bb9.woff2";
var YU = "./fonts/Xiaolai/Xiaolai-Regular-52a84a22fd1369bffeaf21da2d6158dc.woff2";
var CU = "./fonts/Xiaolai/Xiaolai-Regular-829615148e6357d826b9242eb7fbbd1e.woff2";
var VU = "./fonts/Xiaolai/Xiaolai-Regular-c99eda15fc26a2941579560f76c3a5cf.woff2";
var qU = "./fonts/Xiaolai/Xiaolai-Regular-395c35dd584b56b0789f58a0559beaf1.woff2";
var XU = "./fonts/Xiaolai/Xiaolai-Regular-203b0e569e3b14aac86a003dc3fa523e.woff2";
var GU = "./fonts/Xiaolai/Xiaolai-Regular-51a0e808bbc8361236ac521a119758a3.woff2";
var kU = "./fonts/Xiaolai/Xiaolai-Regular-6e092f71c1e634059ada0e52abadce67.woff2";
var ZU = "./fonts/Xiaolai/Xiaolai-Regular-0f7fb1e0d5015bb1371343153ecf7ce3.woff2";
var WU = "./fonts/Xiaolai/Xiaolai-Regular-d0cf73942fea1c74edbdf0b3011f4656.woff2";
var zU = "./fonts/Xiaolai/Xiaolai-Regular-968cffdc8ee679da094e77ebf50f58ef.woff2";
var QU = "./fonts/Xiaolai/Xiaolai-Regular-7a07ddc0f0c0f5f4a9bad6ee3dda66b5.woff2";
var jU = "./fonts/Xiaolai/Xiaolai-Regular-ec181b795ac1fb5a50d700b6e996d745.woff2";
var ef = "./fonts/Xiaolai/Xiaolai-Regular-cfb211578629b7e8153b37240de6a9d5.woff2";
var tf = "./fonts/Xiaolai/Xiaolai-Regular-59e9ff77b0efaf684bc09274fb6908c9.woff2";
var nf = "./fonts/Xiaolai/Xiaolai-Regular-2adbc89c11e65905393d3dfc468b9d5b.woff2";
var rf = "./fonts/Xiaolai/Xiaolai-Regular-70e811fd7994e61f408c923de6ddd078.woff2";
var of = "./fonts/Xiaolai/Xiaolai-Regular-c4a687ac4f0c2766eefc9f77ed99cddf.woff2";
var af = "./fonts/Xiaolai/Xiaolai-Regular-51502f1206be09c565f1547c406e9558.woff2";
var sf = "./fonts/Xiaolai/Xiaolai-Regular-1fdc0c67ed57263a80fd108c1f6ccf24.woff2";
var df = "./fonts/Xiaolai/Xiaolai-Regular-e11567fd2accf9957cd0d3c2be937d87.woff2";
var cf = "./fonts/Xiaolai/Xiaolai-Regular-20cc1bbf50e7efb442756cb605672c1f.woff2";
var lf = "./fonts/Xiaolai/Xiaolai-Regular-5d2898fbc097a7e24c6f38d80587621e.woff2";
var Uf = "./fonts/Xiaolai/Xiaolai-Regular-ac9ceb44437becc3e9c4dbfebab7fc2d.woff2";
var ff = "./fonts/Xiaolai/Xiaolai-Regular-c16ed9740b85badf16e86ea782a3062f.woff2";
var pf = "./fonts/Xiaolai/Xiaolai-Regular-aa0d470430e6391eca720c7cfa44446f.woff2";
var uf = "./fonts/Xiaolai/Xiaolai-Regular-f2b54d4e7be0eaefe1c2c56836fa5368.woff2";
var mf = "./fonts/Xiaolai/Xiaolai-Regular-99a16ef6a64934d5781933dbd9c46b2e.woff2";
var bf = "./fonts/Xiaolai/Xiaolai-Regular-c40533fdf4cc57177b12803598af7e59.woff2";
var Ef = "./fonts/Xiaolai/Xiaolai-Regular-91ddb2969bf2d31ba02ad82998d1314c.woff2";
var gf = "./fonts/Xiaolai/Xiaolai-Regular-774d4f764a1299da5d28ec2f2ffe0d69.woff2";
var xf = "./fonts/Xiaolai/Xiaolai-Regular-7718fe60986d8b42b1be9c5ace5ccf25.woff2";
var hf = "./fonts/Xiaolai/Xiaolai-Regular-aa5c9ca6cf4fba00433b7aa3fa10671a.woff2";
var yf = "./fonts/Xiaolai/Xiaolai-Regular-4f50e5136e136527280bc902c5817561.woff2";
var If = "./fonts/Xiaolai/Xiaolai-Regular-093b9ef39a46ceae95a1df18a0a3a326.woff2";
var wf = "./fonts/Xiaolai/Xiaolai-Regular-a0ca5df4258213d7fc9fce80f65ce760.woff2";
var Rf = "./fonts/Xiaolai/Xiaolai-Regular-d2666cbed13462c5dc36fa2f15c202ca.woff2";
var Tf = "./fonts/Xiaolai/Xiaolai-Regular-1e6fd68f1f3902ce48ce8c69df385622.woff2";
var Mf = "./fonts/Xiaolai/Xiaolai-Regular-87599f94b6cc129d505b375798d0d751.woff2";
var Lf = "./fonts/Xiaolai/Xiaolai-Regular-06c77b8c66e51ed6c63ccb502dd8b8af.woff2";
var Df = "./fonts/Xiaolai/Xiaolai-Regular-13ae07ed2e272d26d59bc0691cd7117a.woff2";
var Sf = "./fonts/Xiaolai/Xiaolai-Regular-353f33792a8f60dc69323ddf635a269e.woff2";
var vf = "./fonts/Xiaolai/Xiaolai-Regular-0facdf1ea213ba40261022f5d5ed4493.woff2";
var $f = "./fonts/Xiaolai/Xiaolai-Regular-f8ee5d36068a42b51d0e4a1116cfcec1.woff2";
var Pf = "./fonts/Xiaolai/Xiaolai-Regular-79d494361ae093b69e74ee9dbe65bfd4.woff2";
var Nf = "./fonts/Xiaolai/Xiaolai-Regular-74e2263a91439c25b91d5132ce9f4d62.woff2";
var Ff = "./fonts/Xiaolai/Xiaolai-Regular-ee8bae97908d5147b423f77ad0d3c1bb.woff2";
var Bf = "./fonts/Xiaolai/Xiaolai-Regular-56467a5c8840c4d23a60b2f935114848.woff2";
var _f = "./fonts/Xiaolai/Xiaolai-Regular-145aa02cdd91946e67dc934e1acffe75.woff2";
var Of = "./fonts/Xiaolai/Xiaolai-Regular-54acdfc2166ad7fcbd074f75fd4a56ba.woff2";
var Af = "./fonts/Xiaolai/Xiaolai-Regular-29cec36cd205b211da97acabaa62f055.woff2";
var Kf = "./fonts/Xiaolai/Xiaolai-Regular-3756e81d3e149cf6099163ee79944fec.woff2";
var Hf = "./fonts/Xiaolai/Xiaolai-Regular-8e9f97f01034820170065b2921b4fb5e.woff2";
var Jf = "./fonts/Xiaolai/Xiaolai-Regular-13d2887ec8ee73c43acdabc52a05af7b.woff2";
var Yf = "./fonts/Xiaolai/Xiaolai-Regular-72536a3d71b694a0d53dd90ddceae41e.woff2";
var Cf = "./fonts/Xiaolai/Xiaolai-Regular-603aefd23e350ba7eb124273e3c9bcf1.woff2";
var Vf = "./fonts/Xiaolai/Xiaolai-Regular-095c169f3314805276f603a362766abd.woff2";
var qf = "./fonts/Xiaolai/Xiaolai-Regular-9544732d2e62d1a429674f8ee41b5d3a.woff2";
var Xf = "./fonts/Xiaolai/Xiaolai-Regular-d3716376641d615e2995605b29bca7b6.woff2";
var Gf = "./fonts/Xiaolai/Xiaolai-Regular-5a1ce3117cfe90c48e8fb4a9a00f694d.woff2";
var kf = "./fonts/Xiaolai/Xiaolai-Regular-b7d203b051eff504ff59ddca7576b6a9.woff2";
var Zf = "./fonts/Xiaolai/Xiaolai-Regular-4a38cc3e9cf104e69ba246d37f8cf135.woff2";
var Wf = "./fonts/Xiaolai/Xiaolai-Regular-982b630266d87db93d2539affb1275c6.woff2";
var zf = "./fonts/Xiaolai/Xiaolai-Regular-9592bfc861f07bcb8d75c196b370e548.woff2";
var Qf = "./fonts/Xiaolai/Xiaolai-Regular-a7accba310e821da5505f71c03b76bdb.woff2";
var jf = "./fonts/Xiaolai/Xiaolai-Regular-dac48066b5883d8b4551fc584f0c2a3e.woff2";
var e1 = "./fonts/Xiaolai/Xiaolai-Regular-a1f916d6039285c4ffb900cd654e418f.woff2";
var t1$1 = "./fonts/Xiaolai/Xiaolai-Regular-95bfd249da4902577b4b7d76ebdd0b44.woff2";
var n1 = "./fonts/Xiaolai/Xiaolai-Regular-93fc8f28a33234bcadf1527cafabd502.woff2";
var r1$1 = "./fonts/Xiaolai/Xiaolai-Regular-903bb6865f3452e2fda42e3a25547bc5.woff2";
var o1 = "./fonts/Xiaolai/Xiaolai-Regular-4aca6a43e59aceee2166b0c7e4e85ef1.woff2";
var i1 = "./fonts/Xiaolai/Xiaolai-Regular-24476a126f129212beb33f66853ea151.woff2";
var a1$1 = "./fonts/Xiaolai/Xiaolai-Regular-1b611157cd46bb184d4fa4dae2d6a2b8.woff2";
var s1 = "./fonts/Xiaolai/Xiaolai-Regular-56a32a7689abd0326e57c10c6c069bb4.woff2";
var d1 = "./fonts/Xiaolai/Xiaolai-Regular-3cc70dbb64df5b21f1326cc24dee2195.woff2";
var c1 = "./fonts/Xiaolai/Xiaolai-Regular-f6032fc06eb20480f096199713f70885.woff2";
var l1$1 = "./fonts/Xiaolai/Xiaolai-Regular-e2ead7ea7da0437f085f42ffc05f8d13.woff2";
var U1$1 = "./fonts/Xiaolai/Xiaolai-Regular-97f7f48ce90c9429bf32ae51469db74d.woff2";
var f1$1 = "./fonts/Xiaolai/Xiaolai-Regular-24a21c1e4449222e8d1898d69ff3a404.woff2";
var p1$1 = "./fonts/Xiaolai/Xiaolai-Regular-726303e0774b4e678bff8c2deb6ca603.woff2";
var u1 = "./fonts/Xiaolai/Xiaolai-Regular-5a7fac4b8b23a6e4e5ba0c9bf1756c91.woff2";
var m1 = "./fonts/Xiaolai/Xiaolai-Regular-2b7441d46298788ac94e610ffcc709b6.woff2";
var b1$1 = [{ uri: Ic$1, descriptors: { unicodeRange: "U+f9b8-fa6d,U+fe32,U+fe45-fe4f,U+ff02-ff0b,U+ff0d-ff1e,U+ff20-ff2a" } }, { uri: wc$1, descriptors: { unicodeRange: "U+20dd-20de,U+25ef,U+ff2b-ffbe,U+ffc2-ffc7,U+ffca-ffcf,U+ffd2-ffd7,U+ffda-ffdc,U+ffe0-ffe6,U+ffe8-ffee" } }, { uri: Rc$1, descriptors: { unicodeRange: "U+d7eb-d7fb,U+f900-f9b7" } }, { uri: Tc$1, descriptors: { unicodeRange: "U+d6f2-d7a3,U+d7b0-d7c6,U+d7cb-d7ea" } }, { uri: Mc$1, descriptors: { unicodeRange: "U+d609-d6f1" } }, { uri: Lc, descriptors: { unicodeRange: "U+d520-d608" } }, { uri: Dc, descriptors: { unicodeRange: "U+d437-d51f" } }, { uri: Sc$1, descriptors: { unicodeRange: "U+d34e-d436" } }, { uri: vc$1, descriptors: { unicodeRange: "U+d265-d34d" } }, { uri: $c$1, descriptors: { unicodeRange: "U+d17c-d264" } }, { uri: Pc, descriptors: { unicodeRange: "U+d093-d17b" } }, { uri: Nc, descriptors: { unicodeRange: "U+cfaa-d092" } }, { uri: Fc, descriptors: { unicodeRange: "U+cec1-cfa9" } }, { uri: Bc, descriptors: { unicodeRange: "U+cdd8-cec0" } }, { uri: _c$1, descriptors: { unicodeRange: "U+ccf1-cdd7" } }, { uri: Oc, descriptors: { unicodeRange: "U+cc08-ccf0" } }, { uri: Ac, descriptors: { unicodeRange: "U+cb43-cc07" } }, { uri: Kc, descriptors: { unicodeRange: "U+ca83-cb42" } }, { uri: Hc$1, descriptors: { unicodeRange: "U+c9a1-ca82" } }, { uri: Jc$1, descriptors: { unicodeRange: "U+c8b8-c9a0" } }, { uri: Yc$1, descriptors: { unicodeRange: "U+c7cf-c8b7" } }, { uri: Cc$1, descriptors: { unicodeRange: "U+c6e6-c7ce" } }, { uri: Vc$1, descriptors: { unicodeRange: "U+c5fd-c6e5" } }, { uri: qc$1, descriptors: { unicodeRange: "U+c514-c5fc" } }, { uri: Xc$1, descriptors: { unicodeRange: "U+c42b-c513" } }, { uri: Gc$1, descriptors: { unicodeRange: "U+c341-c34e,U+c350-c42a" } }, { uri: kc$1, descriptors: { unicodeRange: "U+c258-c340" } }, { uri: Zc$1, descriptors: { unicodeRange: "U+c16f-c257" } }, { uri: Wc, descriptors: { unicodeRange: "U+c086-c16e" } }, { uri: zc, descriptors: { unicodeRange: "U+bf9d-c085" } }, { uri: Qc$1, descriptors: { unicodeRange: "U+beb4-bf9c" } }, { uri: jc, descriptors: { unicodeRange: "U+bdcb-beb3" } }, { uri: el$1, descriptors: { unicodeRange: "U+bce2-bdca" } }, { uri: tl, descriptors: { unicodeRange: "U+bbf9-bce1" } }, { uri: nl$1, descriptors: { unicodeRange: "U+bb10-bbf8" } }, { uri: rl, descriptors: { unicodeRange: "U+ba27-bb0f" } }, { uri: ol$1, descriptors: { unicodeRange: "U+b93e-ba26" } }, { uri: il$1, descriptors: { unicodeRange: "U+b855-b93d" } }, { uri: al$1, descriptors: { unicodeRange: "U+b76c-b854" } }, { uri: sl$1, descriptors: { unicodeRange: "U+b683-b76b" } }, { uri: dl$1, descriptors: { unicodeRange: "U+b59a-b682" } }, { uri: cl$1, descriptors: { unicodeRange: "U+b4b1-b599" } }, { uri: ll$1, descriptors: { unicodeRange: "U+11fb-11ff,U+b3cd-b4b0" } }, { uri: Ul, descriptors: { unicodeRange: "U+11e6-11fa,U+b2f9-b3cc" } }, { uri: fl, descriptors: { unicodeRange: "U+11d1-11e5,U+b225-b2f8" } }, { uri: pl, descriptors: { unicodeRange: "U+11bc-11d0,U+b151-b224" } }, { uri: ul, descriptors: { unicodeRange: "U+11a7-11bb,U+b07d-b150" } }, { uri: ml, descriptors: { unicodeRange: "U+1191-11a6,U+afaa-b07c" } }, { uri: bl, descriptors: { unicodeRange: "U+117c-1190,U+aed6-afa9" } }, { uri: El, descriptors: { unicodeRange: "U+1167-117b,U+ae02-aed5" } }, { uri: gl, descriptors: { unicodeRange: "U+1152-115e,U+1160-1166,U+ad2d-ae01" } }, { uri: xl, descriptors: { unicodeRange: "U+113d-1151,U+ac59-ad2c" } }, { uri: hl, descriptors: { unicodeRange: "U+1100-113c,U+9f95-9f98,U+9f9c-9f9e,U+9fa1-9fce,U+9fd0,U+a960-a97c,U+ac00-ac58" } }, { uri: yl, descriptors: { unicodeRange: "U+9771-9772,U+9775,U+9777-977b,U+977d-9784,U+9786-978a,U+978c,U+978e-9790,U+9793,U+9795-9797,U+9799-979f,U+97a1-97a2,U+97a4-97aa,U+97ac,U+97ae,U+97b0-97b1,U+97b3,U+97b5-97e5,U+97e8,U+97ee-97f2,U+97f4,U+97f7-982d" } }, { uri: Il, descriptors: { unicodeRange: "U+9491,U+9496,U+9498,U+94c7,U+94cf,U+94d3-94d4,U+94da,U+94e6,U+94fb,U+951c,U+9520,U+9527,U+9533,U+953d,U+9543,U+9548,U+954b,U+9555,U+955a,U+9560,U+956e,U+9574-9575,U+9577-957e,U+9580-95e7,U+95ec,U+95ff,U+9607,U+9613,U+9618,U+961b,U+961e,U+9620,U+9623-9629,U+962b-962d,U+962f-9630,U+9637-963a,U+963e,U+9641,U+9643,U+964a,U+964e-964f,U+9651-9653,U+9656-965a,U+965c-965e,U+9660,U+9663,U+9665-9666,U+966b,U+966d-9671,U+9673,U+9678-9684,U+9687,U+9689-968a,U+968c,U+968e,U+9691-9693" } }, { uri: wl, descriptors: { unicodeRange: "U+923c-9273,U+9275-928d,U+928f-92ad,U+92af-92c7,U+92c9-92ee" } }, { uri: Rl, descriptors: { unicodeRange: "U+9159,U+915b-915c,U+915f-9160,U+9166-9168,U+916b,U+916d,U+9173,U+917a-917c,U+9180-9184,U+9186,U+9188,U+918a,U+918e-918f,U+9193-9199,U+919c-91a1,U+91a4-91a9,U+91ab-91ac,U+91b0-91b3,U+91b6-91b9,U+91bb-91c6,U+91c8,U+91cb,U+91d0,U+91d2-91db,U+91dd-923b" } }, { uri: Tl, descriptors: { unicodeRange: "U+902b-902c,U+9030-9034,U+9037,U+9039-903a,U+903d,U+903f-9040,U+9043,U+9045-9046,U+9048-904c,U+904e,U+9054-9056,U+9059-905a,U+905c-9061,U+9064,U+9066-9067,U+9069-906c,U+906f-9073,U+9076-907c,U+907e,U+9081,U+9084-9087,U+9089-908a,U+908c-9090,U+9092,U+9094,U+9096,U+9098,U+909a,U+909c,U+909e-90a0,U+90a4-90a5,U+90a7-90a9,U+90ab,U+90ad,U+90b2,U+90b7,U+90bc-90bd,U+90bf-90c0,U+90c2-90c3,U+90c6,U+90c8-90c9,U+90cb-90cd,U+90d2,U+90d4-90d6,U+90d8-90da,U+90de-90e0,U+90e3-90e5,U+90e9-90ea,U+90ec,U+90ee,U+90f0-90f3,U+90f5-90f7,U+90f9-90fc,U+90ff-9101,U+9103,U+9105-9118,U+911a-911d,U+911f-9121,U+9124-912e,U+9130,U+9132-9138,U+913a-9142,U+9144-9145,U+9147-9148,U+9151,U+9153-9156,U+9158" } }, { uri: Ml, descriptors: { unicodeRange: "U+8f03-8f65,U+8f6a,U+8f80,U+8f8c,U+8f92,U+8f9d,U+8fa0-8fa2,U+8fa4-8fa7,U+8faa,U+8fac-8faf,U+8fb2-8fb5,U+8fb7-8fb8,U+8fba-8fbc,U+8fbf-8fc0,U+8fc3,U+8fc6,U+8fc9-8fcd,U+8fcf,U+8fd2,U+8fd6-8fd7,U+8fda,U+8fe0-8fe1,U+8fe3,U+8fe7,U+8fec,U+8fef,U+8ff1-8ff2,U+8ff4-8ff6,U+8ffa-8ffc,U+8ffe-8fff,U+9007-9008,U+900c,U+900e,U+9013,U+9015,U+9018-9019,U+901c,U+9023-9025,U+9027-902a" } }, { uri: Ll, descriptors: { unicodeRange: "U+8d03-8d1c,U+8d20,U+8d51-8d52,U+8d57,U+8d5f,U+8d65,U+8d68-8d6a,U+8d6c,U+8d6e-8d6f,U+8d71-8d72,U+8d78-8d80,U+8d82-8d83,U+8d86-8d89,U+8d8c-8d90,U+8d92-8d93,U+8d95-8d9e,U+8da0-8da2,U+8da4-8db0,U+8db2,U+8db6-8db7,U+8db9,U+8dbb,U+8dbd,U+8dc0-8dc2,U+8dc5,U+8dc7-8dca,U+8dcd,U+8dd0,U+8dd2-8dd5,U+8dd8-8dd9,U+8ddc,U+8de0-8de2,U+8de5-8de7,U+8de9,U+8ded-8dee,U+8df0-8df2,U+8df4,U+8df6,U+8dfc,U+8dfe-8e04,U+8e06-8e08,U+8e0b,U+8e0d-8e0e,U+8e10-8e13,U+8e15-8e1c,U+8e20-8e21,U+8e24-8e28,U+8e2b,U+8e2d,U+8e30,U+8e32-8e34,U+8e36-8e38,U+8e3b-8e3c,U+8e3e-8e3f,U+8e43,U+8e45-8e46" } }, { uri: Dl, descriptors: { unicodeRange: "U+8bea,U+8c09,U+8c1e,U+8c38-8c40,U+8c42-8c45,U+8c48,U+8c4a-8c4b,U+8c4d-8c54,U+8c56-8c59,U+8c5b-8c60,U+8c63-8c69,U+8c6c-8c72,U+8c74-8c77,U+8c7b-8c81,U+8c83-8c84,U+8c86-8c88,U+8c8b,U+8c8d-8c93,U+8c95-8c97,U+8c99-8d02" } }, { uri: Sl, descriptors: { unicodeRange: "U+8a64-8a78,U+8a7a-8a88,U+8a8b-8a92,U+8a94-8b06,U+8b08-8b1b" } }, { uri: vl, descriptors: { unicodeRange: "U+8987-89c0,U+89c3,U+89cd,U+89d3-89d5,U+89d7-89d9,U+89db,U+89dd,U+89df-89e2,U+89e4,U+89e7-89ea,U+89ec-89ee,U+89f0-89f2,U+89f4-89ff,U+8a01-8a06,U+8a08-8a3d,U+8a3f-8a47,U+8a49-8a63" } }, { uri: $l, descriptors: { unicodeRange: "U+87e3-87e4,U+87e6-87e9,U+87eb-87ed,U+87ef-87f8,U+87fa-87fd,U+87ff-8802,U+8804-8809,U+880b-8812,U+8814,U+8817-881a,U+881c-8820,U+8823-8831,U+8833-8838,U+883a-883b,U+883d-883f,U+8841-8843,U+8846-884b,U+884e-8853,U+8855-8856,U+8858,U+885a-8860,U+8866-8867,U+886a,U+886d,U+886f,U+8871,U+8873-8876,U+8878-887c,U+8880,U+8883,U+8886-8887,U+8889-888a,U+888c,U+888e-8891,U+8893-8895,U+8897-889b,U+889d-88a1,U+88a3,U+88a5-88aa,U+88ac,U+88ae-88b0,U+88b2-88b6,U+88b8-88bb" } }, { uri: Pl, descriptors: { unicodeRange: "U+86e7-86e8,U+86ea-86ec,U+86ef,U+86f5-86f7,U+86fa-86fd,U+86ff,U+8701,U+8704-8706,U+870b-870c,U+870e-8711,U+8714,U+8716,U+8719,U+871b,U+871d,U+871f-8720,U+8724,U+8726-8728,U+872a-872d,U+872f-8730,U+8732-8733,U+8735-8736,U+8738-873a,U+873c-873d,U+8740-8746,U+874a-874b,U+874d,U+874f-8752,U+8754-8756,U+8758,U+875a-875f,U+8761-8762,U+8766-876d,U+876f,U+8771-8773,U+8775,U+8777-877a,U+877f-8781,U+8784,U+8786-8787,U+8789-878a,U+878c,U+878e-8792,U+8794-8796,U+8798-879e,U+87a0-87a7,U+87a9-87aa,U+87ae,U+87b0-87b2,U+87b4,U+87b6-87b9,U+87bb-87bc,U+87be-87bf,U+87c1-87c5,U+87c7-87c9,U+87cc-87d0,U+87d4-87da,U+87dc-87df,U+87e1-87e2" } }, { uri: Nl, descriptors: { unicodeRange: "U+8604,U+8606-8610,U+8612-8615,U+8617-8626,U+8628,U+862a-8637,U+8639-863b,U+863d-864c,U+8652-8653,U+8655-8659,U+865b-865d,U+865f-8661,U+8663-866a,U+866d,U+866f-8670,U+8672-8678,U+8683-8689,U+868e-8692,U+8694,U+8696-869b,U+869e-86a2,U+86a5-86a6,U+86ab,U+86ad-86ae,U+86b2-86b3,U+86b7-86b9,U+86bb-86bf,U+86c1-86c3,U+86c5,U+86c8,U+86cc-86cd,U+86d2-86d3,U+86d5-86d7,U+86da,U+86dc-86dd,U+86e0-86e3,U+86e5-86e6" } }, { uri: Fl, descriptors: { unicodeRange: "U+8456,U+8458,U+845d-8460,U+8462,U+8464-8468,U+846a,U+846e-8470,U+8472,U+8474,U+8477,U+8479,U+847b-8481,U+8483-8486,U+848a,U+848d,U+848f-8496,U+8498,U+849a-849b,U+849d-84a0,U+84a2-84ae,U+84b0-84b1,U+84b3,U+84b5-84b7,U+84bb-84bc,U+84be,U+84c0,U+84c2-84c3,U+84c5-84c8,U+84cb-84cc,U+84ce-84cf,U+84d2,U+84d4-84d5,U+84d7-84dc,U+84de,U+84e1-84e2,U+84e4,U+84e7-84eb,U+84ed-84ef,U+84f1-84fb,U+84fd-84fe,U+8500-850b,U+850d-8510,U+8512,U+8514-8516,U+8518-8519,U+851b-851e,U+8520,U+8522-852a,U+852d-8536,U+853e-8542,U+8544-8547,U+854b-854f" } }, { uri: Bl, descriptors: { unicodeRange: "U+82c2-82c3,U+82c5-82c6,U+82c9,U+82d0,U+82d6,U+82d9-82da,U+82dd,U+82e2,U+82e7-82ea,U+82ec-82ee,U+82f0,U+82f2-82f3,U+82f5-82f6,U+82f8,U+82fa,U+82fc-8300,U+830a-830b,U+830d,U+8310,U+8312-8313,U+8316,U+8318-8319,U+831d-8326,U+8329-832a,U+832e,U+8330,U+8332,U+8337,U+833b,U+833d-833f,U+8341-8342,U+8344-8345,U+8348,U+834a-834e,U+8353,U+8355-8359,U+835d,U+8362,U+8370-8376,U+8379-837a,U+837e-8384,U+8387-8388,U+838a-838d,U+838f-8391,U+8394-8397,U+8399-839a,U+839d,U+839f,U+83a1-83a7,U+83ac-83af,U+83b5,U+83bb,U+83be-83bf,U+83c2-83c4,U+83c6,U+83c8-83c9,U+83cb,U+83cd-83ce,U+83d0-83d3,U+83d5,U+83d7,U+83d9-83db,U+83de,U+83e2-83e4,U+83e6-83e8,U+83eb-83ef,U+83f3-83f7,U+83fa-83fc,U+83fe-8400,U+8402,U+8405,U+8407-840a,U+8410,U+8412-8417,U+8419-841b,U+841e-8423,U+8429-8430,U+8432-8437,U+8439-843b,U+843e-8445,U+8447-8450,U+8452-8455" } }, { uri: _l, descriptors: { unicodeRange: "U+81a4-81a5,U+81a7,U+81a9,U+81ab-81b2,U+81b4-81b9,U+81bc-81bf,U+81c4-81c5,U+81c7-81c9,U+81cb,U+81cd-81e2,U+81e4-81e6,U+81e8-81e9,U+81eb,U+81ee-81f2,U+81f5-81fa,U+81fd,U+81ff,U+8203,U+8207-820b,U+820e-820f,U+8211,U+8213,U+8215-821a,U+821d,U+8220,U+8224-8227,U+8229,U+822e,U+8232,U+823a,U+823c-823d,U+823f-8243,U+8245-8246,U+8248,U+824a,U+824c-824e,U+8250-8257,U+8259,U+825b-825e,U+8260-8267,U+8269-826d,U+8271,U+8275-8278,U+827b-827c,U+8280-8281,U+8283,U+8285-8287,U+8289,U+828c,U+8290,U+8293-8296,U+829a-829b,U+829e,U+82a0,U+82a2-82a3,U+82a7,U+82b2,U+82b5-82b6,U+82ba-82bc,U+82bf-82c0" } }, { uri: Ol, descriptors: { unicodeRange: "U+8059,U+805b-8068,U+806b-8070,U+8072-807e,U+8081-8082,U+8085,U+8088,U+808a,U+808d-8092,U+8094-8095,U+8097,U+8099,U+809e,U+80a3,U+80a6-80a8,U+80ac,U+80b0,U+80b3,U+80b5-80b6,U+80b8-80b9,U+80bb,U+80c5,U+80c7-80cb,U+80cf-80d5,U+80d8,U+80df-80e0,U+80e2-80e3,U+80e6,U+80ee,U+80f5,U+80f7,U+80f9,U+80fb,U+80fe-8101,U+8103-8105,U+8107-8108,U+810b-810c,U+8115,U+8117,U+8119,U+811b-811d,U+811f-812b,U+812d-812e,U+8130,U+8133-8135,U+8137,U+8139-813d,U+813f-8145,U+8147,U+8149,U+814d-814f,U+8152,U+8156-8158,U+815b-815f,U+8161-8164,U+8166,U+8168,U+816a-816c,U+816f,U+8172-8173,U+8175-8178,U+8181,U+8183-8187,U+8189,U+818b-818e,U+8190,U+8192-8197,U+8199-819a,U+819e-81a2" } }, { uri: Al, descriptors: { unicodeRange: "U+7f3c-7f41,U+7f43,U+7f46-7f4f,U+7f52-7f53,U+7f56,U+7f59,U+7f5b-7f5e,U+7f60,U+7f63-7f67,U+7f6b-7f6d,U+7f6f-7f70,U+7f73,U+7f75-7f78,U+7f7a-7f7d,U+7f7f-7f80,U+7f82-7f89,U+7f8b,U+7f8d,U+7f8f-7f93,U+7f95-7f99,U+7f9b-7f9c,U+7fa0,U+7fa2-7fa3,U+7fa5-7fa6,U+7fa8-7fae,U+7fb1,U+7fb3-7fb7,U+7fba-7fbb,U+7fbe,U+7fc0,U+7fc2-7fc4,U+7fc6-7fc9,U+7fcb,U+7fcd,U+7fcf-7fd3,U+7fd6-7fd7,U+7fd9-7fde,U+7fe2-7fe4,U+7fe7-7fe8,U+7fea-7fed,U+7fef,U+7ff2,U+7ff4-7ffa,U+7ffd-7fff,U+8002,U+8007-800a,U+800e-800f,U+8011,U+8013,U+801a-801b,U+801d-801f,U+8021,U+8023-8024,U+802b-8030,U+8032,U+8034,U+8039-803a,U+803c,U+803e,U+8040-8041,U+8044-8045,U+8047-8049,U+804e-8051,U+8053,U+8055-8057" } }, { uri: Kl, descriptors: { unicodeRange: "U+7cd8,U+7cda-7cdb,U+7cdd-7cde,U+7ce1-7ce7,U+7ce9-7cee,U+7cf0-7cf7,U+7cf9-7cfa,U+7cfc-7d09,U+7d0b-7d1f,U+7d21,U+7d23-7d26,U+7d28-7d2a,U+7d2c-7d2e,U+7d30-7d6d,U+7d6f-7d76,U+7d78-7d94" } }, { uri: Hl, descriptors: { unicodeRange: "U+7afe,U+7b00-7b02,U+7b05,U+7b07,U+7b09,U+7b0c-7b0e,U+7b10,U+7b12-7b13,U+7b16-7b18,U+7b1a,U+7b1c-7b1d,U+7b1f,U+7b21-7b23,U+7b27,U+7b29,U+7b2d,U+7b2f-7b30,U+7b32,U+7b34-7b37,U+7b39,U+7b3b,U+7b3d,U+7b3f-7b44,U+7b46,U+7b48,U+7b4a,U+7b4d-7b4e,U+7b53,U+7b55,U+7b57,U+7b59,U+7b5c,U+7b5e-7b5f,U+7b61,U+7b63-7b6d,U+7b6f-7b70,U+7b73-7b74,U+7b76,U+7b78,U+7b7a,U+7b7c-7b7d,U+7b7f,U+7b81-7b84,U+7b86-7b8c,U+7b8e-7b8f,U+7b91-7b93,U+7b96,U+7b98-7b9b,U+7b9e-7ba0,U+7ba3-7ba5,U+7bae-7bb0,U+7bb2-7bb3,U+7bb5-7bb7,U+7bb9-7bc0,U+7bc2-7bc5,U+7bc8-7bcb,U+7bcd-7bd0,U+7bd2,U+7bd4-7bd8,U+7bdb-7bdc,U+7bde-7be0,U+7be2-7be4,U+7be7-7be9,U+7beb-7bed,U+7bef-7bf0,U+7bf2-7bf6,U+7bf8-7bfb,U+7bfd,U+7bff-7c06,U+7c08-7c0a,U+7c0d-7c0e,U+7c10-7c13" } }, { uri: Jl, descriptors: { unicodeRange: "U+7a10-7a13,U+7a15-7a16,U+7a18-7a19,U+7a1b-7a1d,U+7a1f,U+7a21-7a22,U+7a24-7a32,U+7a34-7a36,U+7a38,U+7a3a,U+7a3e,U+7a40-7a45,U+7a47-7a50,U+7a52-7a56,U+7a58-7a6f,U+7a71-7a73,U+7a75,U+7a7b-7a7e,U+7a82,U+7a85,U+7a87,U+7a89-7a8c,U+7a8e-7a90,U+7a93-7a94,U+7a99-7a9b,U+7a9e,U+7aa1-7aa4,U+7aa7,U+7aa9-7aab,U+7aae-7ab2,U+7ab4-7abe,U+7ac0-7aca,U+7acc-7ad5,U+7ad7-7ad8,U+7ada-7add,U+7ae1-7ae2,U+7ae4,U+7ae7-7aec,U+7aee,U+7af0-7af8,U+7afb-7afc" } }, { uri: Yl, descriptors: { unicodeRange: "U+790d-7912,U+7914-791d,U+791f-7923,U+7925-7933,U+7935-7939,U+793d,U+793f,U+7942-7945,U+7947,U+794a-7952,U+7954-7955,U+7958-7959,U+7961,U+7963-7964,U+7966,U+7969-796c,U+796e,U+7970-7976,U+7979,U+797b-797f,U+7982-7983,U+7986-7989,U+798b-798e,U+7990-7999,U+799b-79a6,U+79a8-79b2,U+79b4-79b8,U+79bc,U+79bf,U+79c2,U+79c4-79c5,U+79c7-79c8,U+79ca,U+79cc,U+79ce-79d0,U+79d3-79d4,U+79d6-79d7,U+79d9-79de,U+79e0-79e2,U+79e5,U+79e8,U+79ea,U+79ec,U+79ee,U+79f1-79f7,U+79f9-79fa,U+79fc,U+79fe-79ff,U+7a01,U+7a04-7a05,U+7a07-7a0a,U+7a0c,U+7a0f" } }, { uri: Cl, descriptors: { unicodeRange: "U+77d8-77da,U+77dd-77e1,U+77e4,U+77e6,U+77e8,U+77ea,U+77ef-77f2,U+77f4-77f5,U+77f7,U+77f9-77fc,U+7803-7808,U+780a-780b,U+780e-7810,U+7813,U+7815,U+7819,U+781b,U+781e,U+7820-7822,U+7824,U+7828,U+782a-782b,U+782e-782f,U+7831-7833,U+7835-7836,U+783d,U+783f,U+7841-7844,U+7846,U+7848-784b,U+784d,U+784f,U+7851,U+7853-7854,U+7858-785c,U+785e-7869,U+786f-7876,U+7878-787b,U+787d-7886,U+7888,U+788a-788b,U+788f-7890,U+7892,U+7894-7896,U+7899,U+789d-789e,U+78a0,U+78a2,U+78a4,U+78a6,U+78a8-78af,U+78b5-78b8,U+78ba-78bd,U+78bf-78c0,U+78c2-78c4,U+78c6-78c8,U+78cc-78cf,U+78d1-78d3,U+78d6-78d8,U+78da-78e7,U+78e9-78eb,U+78ed-78f1,U+78f3,U+78f5-78f6,U+78f8-78f9,U+78fb-7900,U+7902-7904,U+7906-790c" } }, { uri: Vl, descriptors: { unicodeRange: "U+76af-76b0,U+76b3,U+76b5-76be,U+76c0-76c1,U+76c3-76c4,U+76c7,U+76c9,U+76cb-76cc,U+76d3,U+76d5,U+76d9-76da,U+76dc-76de,U+76e0-76e4,U+76e6-76ed,U+76f0,U+76f3,U+76f5-76f7,U+76fa-76fb,U+76fd,U+76ff-7703,U+7705-7706,U+770a,U+770c,U+770e-7718,U+771b-771e,U+7721,U+7723-7725,U+7727,U+772a-772c,U+772e,U+7730-7734,U+7739,U+773b,U+773d-773f,U+7742,U+7744-7746,U+7748-774f,U+7752-7759,U+775c-7760,U+7764,U+7767,U+7769-776a,U+776d-7778,U+777a-777c,U+7781-7783,U+7786-778b,U+778f-7790,U+7793-779e,U+77a1,U+77a3-77a4,U+77a6,U+77a8,U+77ab,U+77ad-77af,U+77b1-77b2,U+77b4,U+77b6-77ba,U+77bc,U+77be,U+77c0-77cc,U+77ce-77d6" } }, { uri: ql, descriptors: { unicodeRange: "U+7589-758a,U+758c-758e,U+7590,U+7593,U+7595,U+7598,U+759b-759c,U+759e,U+75a2,U+75a6-75aa,U+75ad,U+75b6-75b7,U+75ba-75bb,U+75bf-75c1,U+75c6,U+75cb-75cc,U+75ce-75d1,U+75d3,U+75d7,U+75d9-75da,U+75dc-75dd,U+75df-75e1,U+75e5,U+75e9,U+75ec-75ef,U+75f2-75f3,U+75f5-75f8,U+75fa-75fb,U+75fd-75fe,U+7602,U+7604,U+7606-7609,U+760b,U+760d-760f,U+7611-7614,U+7616,U+761a,U+761c-761e,U+7621,U+7623,U+7627-7628,U+762c,U+762e-762f,U+7631-7632,U+7636-7637,U+7639-763b,U+763d,U+7641-7642,U+7644-764b,U+764e-7653,U+7655,U+7657-765b,U+765d,U+765f-7662,U+7664-766a,U+766c-766e,U+7670-7677,U+7679-767a,U+767c,U+767f-7681,U+7683,U+7685,U+7689-768a,U+768c-768d,U+768f-7690,U+7692,U+7694-7695,U+7697-7698,U+769a-76a3,U+76a5-76ad" } }, { uri: Xl, descriptors: { unicodeRange: "U+7492-749b,U+749d,U+749f-74a6,U+74aa-74b9,U+74bb-74d1,U+74d3-74db,U+74dd,U+74df,U+74e1,U+74e5,U+74e7-74ed,U+74f0-74f3,U+74f5,U+74f8-74fe,U+7500-7503,U+7505-750c,U+750e,U+7510,U+7512,U+7514-7517,U+751b,U+751d-751e,U+7520-7524,U+7526-7527,U+752a,U+752e,U+7534,U+7536,U+7539,U+753c-753d,U+753f,U+7541-7544,U+7546-7547,U+7549-754a,U+754d,U+7550-7553,U+7555-7558,U+755d-7564,U+7567-7569,U+756b-7571,U+7573,U+7575-7577,U+757a-757e,U+7580-7582,U+7584-7585,U+7587-7588" } }, { uri: Gl, descriptors: { unicodeRange: "U+7372-737d,U+737f-7383,U+7385-7386,U+7388,U+738a,U+738c-738d,U+738f-7390,U+7392-7395,U+7397-739a,U+739c-739e,U+73a0-73a1,U+73a3-73a8,U+73aa,U+73ac-73ad,U+73b1,U+73b4-73b6,U+73b8-73b9,U+73bc-73bf,U+73c1,U+73c3-73c7,U+73cb-73cc,U+73ce,U+73d2-73d8,U+73da-73dd,U+73df,U+73e1-73e4,U+73e6,U+73e8,U+73ea-73ec,U+73ee-73f1,U+73f3-7402,U+7404,U+7407-7408,U+740b-740e,U+7411-7419,U+741c-7421,U+7423-7424,U+7427,U+7429,U+742b,U+742d,U+742f,U+7431-7432,U+7437-743b,U+743d-7440,U+7442-7454,U+7456,U+7458,U+745d,U+7460-746c,U+746e-746f,U+7471-7475,U+7478-747d,U+747f,U+7482,U+7484-7486,U+7488-748a,U+748c-748d,U+748f,U+7491" } }, { uri: kl, descriptors: { unicodeRange: "U+7054-705d,U+705f-706a,U+706e,U+7071-7074,U+7077,U+7079-707b,U+707d,U+7081-7084,U+7086-7088,U+708b-708d,U+708f-7091,U+7093,U+7097-7098,U+709a-709b,U+709e-70aa,U+70b0,U+70b2,U+70b4-70b6,U+70ba,U+70be-70bf,U+70c4-70c7,U+70c9,U+70cb-70d7,U+70da,U+70dc-70de,U+70e0-70e3,U+70e5,U+70ea,U+70ee,U+70f0-70f6,U+70f8,U+70fa-70fc,U+70fe-7108,U+710b-710f,U+7111-7112,U+7114,U+7117,U+711b-7125,U+7127-712e,U+7132-7135,U+7137-7144,U+7146-7149,U+714b,U+714d,U+714f-715b,U+715d,U+715f-7163,U+7165,U+7169-716d,U+716f-7171,U+7174-7177" } }, { uri: Zl, descriptors: { unicodeRange: "U+722e-722f,U+7232-7234,U+723a,U+723c,U+723e,U+7240-7246,U+7249-724b,U+724e-7251,U+7253-7255,U+7257-7258,U+725a,U+725c,U+725e,U+7260,U+7263-7265,U+7268,U+726a-726d,U+7270-7271,U+7273-7274,U+7276-7278,U+727b-727d,U+7282-7283,U+7285-7289,U+728c,U+728e,U+7290-7291,U+7293-729e,U+72a0-72ab,U+72ae,U+72b1-72b3,U+72b5,U+72ba-72c0,U+72c5-72c7,U+72c9-72cc,U+72cf,U+72d1,U+72d3-72d6,U+72d8,U+72da-72dd,U+72df,U+72e2-72e7,U+72ea-72eb,U+72f5-72f6,U+72f9,U+72fd-7300,U+7302,U+7304-7309,U+730b-730d,U+730f-7312,U+7314,U+7318-731a,U+731f-7320,U+7323-7324,U+7326-7328,U+732d,U+732f-7330,U+7332-7333,U+7335-7336,U+733a-733d,U+7340-734c,U+734e-734f,U+7351,U+7353-7356,U+7358-735f,U+7361-736b,U+736e,U+7370-7371" } }, { uri: Wl, descriptors: { unicodeRange: "U+6ec5-6ec6,U+6ec8-6eca,U+6ecc-6ece,U+6ed0,U+6ed2,U+6ed6,U+6ed8-6ed9,U+6edb-6edd,U+6ee3,U+6ee7,U+6eea-6ef3,U+6ef5-6ef8,U+6efa-6f01,U+6f03-6f05,U+6f07-6f08,U+6f0a-6f0e,U+6f10-6f12,U+6f16-6f1f,U+6f21-6f23,U+6f25-6f28,U+6f2c,U+6f2e,U+6f30,U+6f32,U+6f34-6f35,U+6f37-6f3d,U+6f3f-6f45,U+6f48-6f4a,U+6f4c,U+6f4e-6f57,U+6f59-6f5b,U+6f5d,U+6f5f-6f61,U+6f63-6f65,U+6f67-6f6c,U+6f6f-6f71,U+6f73,U+6f75-6f77,U+6f79,U+6f7b,U+6f7d-6f83,U+6f85-6f87,U+6f8a-6f8b,U+6f8f-6f9b,U+6f9d-6fa0,U+6fa2-6fa6,U+6fa8-6fb1" } }, { uri: zl, descriptors: { unicodeRange: "U+6d73,U+6d75-6d76,U+6d79-6d7b,U+6d7d-6d81,U+6d83-6d84,U+6d86-6d87,U+6d8a-6d8b,U+6d8d,U+6d8f-6d90,U+6d92,U+6d96-6d9a,U+6d9c,U+6da2,U+6da5,U+6dac-6dad,U+6db0-6db1,U+6db3-6db4,U+6db6-6db7,U+6db9-6dbe,U+6dc1-6dc3,U+6dc8-6dca,U+6dcd-6dd0,U+6dd2-6dd5,U+6dd7,U+6dda-6ddc,U+6ddf,U+6de2-6de3,U+6de5,U+6de7-6dea,U+6ded,U+6def-6df0,U+6df2,U+6df4-6df6,U+6df8,U+6dfa,U+6dfd-6e04,U+6e06-6e09,U+6e0b,U+6e0f,U+6e12-6e13,U+6e15,U+6e18-6e19,U+6e1b-6e1c,U+6e1e-6e1f,U+6e22,U+6e26-6e28,U+6e2a,U+6e2c,U+6e2e,U+6e30-6e31,U+6e33,U+6e35-6e37,U+6e39,U+6e3b-6e42,U+6e45-6e4c,U+6e4f-6e52,U+6e55,U+6e57,U+6e59-6e5a,U+6e5c-6e5e,U+6e60-6e6a,U+6e6c-6e6d,U+6e6f-6e7d,U+6e80-6e82,U+6e84,U+6e87-6e88,U+6e8a-6e8e,U+6e91-6e97,U+6e99-6e9b,U+6e9d-6e9e,U+6ea0-6ea1,U+6ea3-6ea4,U+6ea6,U+6ea8-6ea9,U+6eab-6eae,U+6eb0,U+6eb3,U+6eb5,U+6eb8-6eb9,U+6ebc,U+6ebe-6ec0,U+6ec3-6ec4" } }, { uri: Ql, descriptors: { unicodeRange: "U+6bbb-6bbe,U+6bc0,U+6bc3-6bc4,U+6bc6-6bca,U+6bcc,U+6bce,U+6bd0-6bd1,U+6bd8,U+6bda,U+6bdc-6be0,U+6be2-6be9,U+6bec-6bee,U+6bf0-6bf2,U+6bf4,U+6bf6-6bf8,U+6bfa-6bfc,U+6bfe-6c04,U+6c08-6c0c,U+6c0e,U+6c12,U+6c17,U+6c1c-6c1e,U+6c20,U+6c23,U+6c25,U+6c2b-6c2d,U+6c31,U+6c33,U+6c36-6c37,U+6c39-6c3c,U+6c3e-6c3f,U+6c43-6c45,U+6c48,U+6c4b-6c4f,U+6c51-6c53,U+6c56,U+6c58-6c5a,U+6c62-6c63,U+6c65-6c67,U+6c6b-6c6f,U+6c71,U+6c73,U+6c75,U+6c77-6c78,U+6c7a-6c7c,U+6c7f-6c80,U+6c84,U+6c87,U+6c8a-6c8b,U+6c8d-6c8e,U+6c91-6c92,U+6c95-6c98,U+6c9a,U+6c9c-6c9e,U+6ca0,U+6ca2,U+6ca8,U+6cac,U+6caf-6cb0,U+6cb4-6cb7,U+6cba,U+6cc0-6cc3,U+6cc6-6cc8,U+6ccb,U+6ccd-6ccf,U+6cd1-6cd2,U+6cd8-6cda,U+6cdc-6cdd,U+6cdf,U+6ce4,U+6ce6-6ce7,U+6ce9,U+6cec-6ced,U+6cf2,U+6cf4,U+6cf9,U+6cff-6d00,U+6d02-6d03,U+6d05-6d06,U+6d08-6d0a,U+6d0d,U+6d0f-6d11,U+6d13-6d16,U+6d18,U+6d1c-6d1d,U+6d1f-6d24,U+6d26,U+6d28-6d29,U+6d2c-6d2d,U+6d2f-6d30,U+6d34,U+6d36-6d38,U+6d3a,U+6d3f-6d40,U+6d42,U+6d44,U+6d49,U+6d4c,U+6d50,U+6d55-6d58,U+6d5b,U+6d5d,U+6d5f,U+6d61-6d62,U+6d64-6d65,U+6d67-6d68,U+6d6b-6d6d,U+6d70-6d72" } }, { uri: jl, descriptors: { unicodeRange: "U+6967-696a,U+696c-696d,U+696f-6970,U+6972-6976,U+697a-697b,U+697d-697f,U+6981,U+6983,U+6985,U+698a-698c,U+698e-6993,U+6996-6997,U+6999-699a,U+699d-69a6,U+69a9-69aa,U+69ac,U+69ae-69b0,U+69b2-69b3,U+69b5-69b6,U+69b8-69ba,U+69bc-69c0,U+69c2-69c9,U+69cb,U+69cd,U+69cf,U+69d1-69d3,U+69d5-69da,U+69dc-69de,U+69e1-69ec,U+69ee-69f1,U+69f3-69fc,U+69fe,U+6a00-6a09,U+6a0b-6a16,U+6a19-6a1e,U+6a20,U+6a22-6a27,U+6a29,U+6a2b-6a2e,U+6a30,U+6a32-6a34,U+6a36-6a3c,U+6a3f-6a43,U+6a45-6a46,U+6a48-6a4a" } }, { uri: eU, descriptors: { unicodeRange: "U+6830-6831,U+6834-6836,U+683a-683b,U+683f,U+6847,U+684b,U+684d,U+684f,U+6852,U+6856-685f,U+686a,U+686c-6873,U+6875,U+6878-6880,U+6882,U+6884,U+6887-688e,U+6890-6892,U+6894-6896,U+6898-68a1,U+68a3-68a5,U+68a9-68ac,U+68ae,U+68b1-68b2,U+68b4,U+68b6-68bf,U+68c1,U+68c3-68c8,U+68ca,U+68cc,U+68ce-68d1,U+68d3-68d4,U+68d6-68d7,U+68d9,U+68db-68df,U+68e1-68e2,U+68e4-68ed,U+68ef,U+68f2-68f4,U+68f6-68f8,U+68fb,U+68fd-6900,U+6902-6904,U+6906-690a,U+690c,U+690f,U+6911,U+6913-691e,U+6921-6923,U+6925-692c,U+692e-692f,U+6931-6933,U+6935-6938,U+693a-693c,U+693e,U+6940-6941,U+6943-6953,U+6955-6956,U+6958-6959,U+695b-695c,U+695f,U+6961-6962,U+6964-6965" } }, { uri: tU, descriptors: { unicodeRange: "U+66b8,U+66ba-66bd,U+66bf-66d8,U+66da,U+66de-66e5,U+66e7-66e8,U+66ea-66ef,U+66f1,U+66f5-66f6,U+66f8,U+66fa-66fb,U+66fd,U+6701-6707,U+670c,U+670e-670f,U+6711-6713,U+6716,U+6718-671a,U+671c,U+671e,U+6720-6725,U+6727,U+6729,U+672e,U+6730,U+6732-6733,U+6736-6739,U+673b-673c,U+673e-673f,U+6741,U+6744-6745,U+6747,U+674a-674b,U+674d,U+6752,U+6754-6755,U+6757-675b,U+675d,U+6762-6764,U+6766-6767,U+676b-676c,U+676e,U+6771,U+6774,U+6776,U+6778-677b,U+677d,U+6780,U+6782-6783,U+6785-6786,U+6788,U+678a,U+678c-678f,U+6791-6794,U+6796,U+6799,U+679b,U+679f-67a1,U+67a4,U+67a6,U+67a9,U+67ac,U+67ae,U+67b1-67b2,U+67b4,U+67b9-67c0,U+67c2,U+67c5-67ce,U+67d5-67d7,U+67db,U+67df,U+67e1,U+67e3-67e4,U+67e6-67e8,U+67ea-67eb,U+67ed-67ee,U+67f2,U+67f5-67fc,U+67fe,U+6801-6804,U+6806,U+680d,U+6810,U+6812,U+6814-6815,U+6818-681c,U+681e-6820,U+6822-6828,U+682b-682f" } }, { uri: nU, descriptors: { unicodeRange: "U+6569-656a,U+656d-656f,U+6571,U+6573,U+6575-6576,U+6578-6586,U+6588-658a,U+658d-658f,U+6592,U+6594-6596,U+6598,U+659a,U+659d-659e,U+65a0,U+65a2-65a3,U+65a6,U+65a8,U+65aa,U+65ac,U+65ae,U+65b1-65b8,U+65ba-65bb,U+65be-65c0,U+65c2,U+65c7-65ca,U+65cd,U+65d0-65d1,U+65d3-65d5,U+65d8-65df,U+65e1,U+65e3-65e4,U+65ea-65eb,U+65f2-65f5,U+65f8-65f9,U+65fb-65ff,U+6601,U+6604-6605,U+6607-6609,U+660b,U+660d,U+6610-6612,U+6616-6618,U+661a-661c,U+661e,U+6621-6624,U+6626,U+6629-662c,U+662e,U+6630,U+6632-6633,U+6637-663b,U+663d,U+663f-6640,U+6642,U+6644-664a,U+664d-664e,U+6650-6651,U+6658-6659,U+665b-665e,U+6660,U+6662-6663,U+6665,U+6667,U+6669-666d,U+6671-6673,U+6675,U+6678-6679,U+667b-667d,U+667f-6681,U+6683,U+6685-6686,U+6688-668b,U+668d-6690,U+6692-6695,U+6698-669c,U+669e-66a6,U+66a9-66ad,U+66af-66b3,U+66b5-66b7" } }, { uri: rU, descriptors: { unicodeRange: "U+5f30,U+5f32-5f38,U+5f3b,U+5f3d-5f3f,U+5f41-5f4f,U+5f51,U+5f54,U+5f59-5f5c,U+5f5e-5f60,U+5f63,U+5f65,U+5f67-5f68,U+5f6b,U+5f6e-5f6f,U+5f72,U+5f74-5f76,U+5f78,U+5f7a,U+5f7d-5f7f,U+5f83,U+5f86,U+5f8d-5f8f,U+5f91,U+5f93-5f94,U+5f96,U+5f9a-5f9b,U+5f9d-5fa0,U+5fa2-5fa7,U+5fa9,U+5fab-5fac,U+5faf-5fb4,U+5fb6,U+5fb8-5fbb,U+5fbe-5fc2,U+5fc7-5fc8,U+5fca-5fcb,U+5fce,U+5fd3-5fd5,U+5fda-5fdc,U+5fde-5fdf,U+5fe2-5fe3,U+5fe5-5fe6,U+5fe8-5fe9,U+5fec,U+5fef-5ff0,U+5ff2-5ff4,U+5ff6-5ff7,U+5ff9-5ffa,U+5ffc,U+6007-6009,U+600b-600c,U+6010-6011,U+6013,U+6017-6018,U+601a,U+601e-601f,U+6022-6024,U+602c-602e,U+6030-6034,U+6036-603a,U+603d-603e,U+6040,U+6044-604a,U+604c,U+604e-604f,U+6051,U+6053-6054,U+6056-6058,U+605b-605c,U+605e-6061,U+6065-6066,U+606e,U+6071-6072,U+6074-6075,U+6077,U+607e,U+6080-6082,U+6085-6088,U+608a-608b,U+608e-6091,U+6093,U+6095,U+6097-6099,U+609c,U+609e,U+60a1-60a2,U+60a4-60a5,U+60a7,U+60a9-60aa,U+60ae,U+60b0,U+60b3,U+60b5-60b7,U+60b9-60ba,U+60bd-60c4,U+60c7-60c9,U+60cc" } }, { uri: oU, descriptors: { unicodeRange: "U+635a-635d,U+6360,U+6364-6366,U+6368,U+636a-636c,U+636f-6370,U+6372-6375,U+6378-6379,U+637c-637f,U+6381,U+6383-6386,U+638b,U+638d,U+6391,U+6393-6395,U+6397,U+6399-639f,U+63a1,U+63a4,U+63a6,U+63ab,U+63af,U+63b1-63b2,U+63b5-63b6,U+63b9,U+63bb,U+63bd,U+63bf-63c3,U+63c5,U+63c7-63c8,U+63ca-63cc,U+63d1,U+63d3-63d5,U+63d7-63dd,U+63df,U+63e2,U+63e4-63e8,U+63eb-63ec,U+63ee-63f1,U+63f3,U+63f5,U+63f7,U+63f9-63fc,U+63fe,U+6403-6404,U+6406-640a,U+640d-640e,U+6411-6412,U+6415-641a,U+641d,U+641f,U+6422-6425,U+6427-6429,U+642b,U+642e-6433,U+6435-6439,U+643b-643c,U+643e,U+6440,U+6442-6443,U+6449,U+644b-6451,U+6453,U+6455-6457,U+6459-645d,U+645f-6466,U+6468,U+646a-646c,U+646e-6477,U+647b-6481,U+6483,U+6486,U+6488-648f" } }, { uri: iU, descriptors: { unicodeRange: "U+61c5-61c7,U+61c9,U+61cc-61d0,U+61d3,U+61d5-61e5,U+61e7-61f4,U+61f6-61fe,U+6200-6205,U+6207,U+6209,U+6213-6214,U+6219,U+621c-621e,U+6220,U+6223,U+6226-6229,U+622b,U+622d,U+622f-6232,U+6235-6236,U+6238-623c,U+6242,U+6244-6246,U+624a,U+624f-6250,U+6255-6257,U+6259-625a,U+625c-6262,U+6264-6265,U+6268,U+6271-6272,U+6274-6275,U+6277-6278,U+627a-627b,U+627d,U+6281-6283,U+6285-6288,U+628b-6290,U+6294,U+6299,U+629c-629e,U+62a3,U+62a6-62a7,U+62a9-62aa,U+62ad-62b0,U+62b2-62b4,U+62b6-62b8,U+62ba,U+62be,U+62c0-62c1,U+62c3,U+62cb,U+62cf,U+62d1,U+62d5,U+62dd-62de,U+62e0-62e1,U+62e4,U+62ea-62eb,U+62f0,U+62f2,U+62f5,U+62f8-62fb,U+6300,U+6303-6306,U+630a-630d,U+630f-6310,U+6312-6315,U+6317-6319,U+631c,U+6326-6327,U+6329,U+632c-632e,U+6330-6331,U+6333-6338,U+633b-633c,U+633e-6341,U+6344,U+6347-6348,U+634a,U+6351-6354,U+6356-6359" } }, { uri: aU, descriptors: { unicodeRange: "U+5dd0-5dda,U+5ddc,U+5ddf-5de0,U+5de3-5de4,U+5dea,U+5dec-5ded,U+5df0,U+5df5-5df6,U+5df8-5dfc,U+5dff-5e00,U+5e04,U+5e07,U+5e09-5e0b,U+5e0d-5e0e,U+5e12-5e13,U+5e17,U+5e1e-5e25,U+5e28-5e2c,U+5e2f-5e30,U+5e32-5e36,U+5e39-5e3a,U+5e3e-5e41,U+5e43,U+5e46-5e4b,U+5e4d-5e53,U+5e56-5e5a,U+5e5c-5e5d,U+5e5f-5e60,U+5e63-5e71,U+5e75,U+5e77,U+5e79,U+5e7e,U+5e81-5e83,U+5e85,U+5e88-5e89,U+5e8c-5e8e,U+5e92,U+5e98,U+5e9b,U+5e9d,U+5ea1-5ea4,U+5ea8-5eac,U+5eae-5eb2,U+5eb4,U+5eba-5ebd,U+5ebf-5ec8,U+5ecb-5ed0,U+5ed4-5ed5,U+5ed7-5eda,U+5edc-5ee7,U+5ee9,U+5eeb-5ef3,U+5ef5,U+5ef8-5ef9,U+5efb-5efd,U+5f05-5f07,U+5f09,U+5f0c-5f0e,U+5f10,U+5f12,U+5f14,U+5f16,U+5f19-5f1a,U+5f1c-5f1e,U+5f21-5f24,U+5f28,U+5f2b-5f2c,U+5f2e" } }, { uri: sU, descriptors: { unicodeRange: "U+60cd-60d0,U+60d2-60d4,U+60d6-60d7,U+60d9,U+60db,U+60de,U+60e1-60e5,U+60ea,U+60f1-60f2,U+60f5,U+60f7-60f8,U+60fb-60ff,U+6102-6105,U+6107,U+610a-610c,U+6110-6114,U+6116-6119,U+611b-611e,U+6121-6122,U+6125,U+6128-612a,U+612c-613e,U+6140-6147,U+6149,U+614b,U+614d,U+614f-6150,U+6152-6154,U+6156-615c,U+615e-6161,U+6163-6166,U+6169-616f,U+6171-6174,U+6176,U+6178-618a,U+618c-618d,U+618f-6193,U+6195-619c,U+619e-61a6,U+61aa-61ab,U+61ad-61b6,U+61b8-61bd,U+61bf-61c1,U+61c3-61c4" } }, { uri: dU, descriptors: { unicodeRange: "U+5cf4-5cfa,U+5cfc-5d01,U+5d04-5d05,U+5d08-5d0d,U+5d0f-5d13,U+5d15,U+5d17-5d1a,U+5d1c-5d1d,U+5d1f-5d23,U+5d25,U+5d28,U+5d2a-5d2c,U+5d2f-5d33,U+5d35-5d3c,U+5d3f-5d46,U+5d48-5d49,U+5d4d-5d57,U+5d59-5d5a,U+5d5c,U+5d5e-5d68,U+5d6a,U+5d6d-5d6e,U+5d70-5d73,U+5d75-5d81,U+5d83-5d98,U+5d9a-5d9c,U+5d9e-5db6,U+5db8-5dc4,U+5dc6-5dcc,U+5dce-5dcf" } }, { uri: cU, descriptors: { unicodeRange: "U+5b52,U+5b56,U+5b5e,U+5b60-5b61,U+5b67-5b68,U+5b6b,U+5b6d-5b6f,U+5b72,U+5b74,U+5b76-5b79,U+5b7b-5b7c,U+5b7e-5b7f,U+5b82,U+5b86,U+5b8a,U+5b8d-5b8e,U+5b90-5b92,U+5b94,U+5b96,U+5b9f,U+5ba7-5ba9,U+5bac-5baf,U+5bb1-5bb2,U+5bb7,U+5bba-5bbc,U+5bc0-5bc1,U+5bc3,U+5bc8-5bcb,U+5bcd-5bcf,U+5bd1,U+5bd4-5bdc,U+5be0,U+5be2-5be3,U+5be6-5be7,U+5be9-5bed,U+5bef,U+5bf1-5bf7,U+5bfd-5bfe,U+5c00,U+5c02-5c03,U+5c05,U+5c07-5c08,U+5c0b-5c0e,U+5c10,U+5c12-5c13,U+5c17,U+5c19,U+5c1b,U+5c1e-5c21,U+5c23,U+5c26,U+5c28-5c2b,U+5c2d-5c30,U+5c32-5c33,U+5c35-5c37,U+5c43-5c44,U+5c46-5c47,U+5c4c-5c4d,U+5c52-5c54,U+5c56-5c58,U+5c5a-5c5d,U+5c5f,U+5c62,U+5c64,U+5c67-5c6d,U+5c70,U+5c72-5c78,U+5c7b-5c7e,U+5c80,U+5c83-5c87,U+5c89-5c8b,U+5c8e-5c8f,U+5c92-5c93,U+5c95,U+5c9d-5ca1,U+5ca4-5ca8,U+5caa,U+5cae-5cb0,U+5cb2,U+5cb4,U+5cb6,U+5cb9-5cbc,U+5cbe,U+5cc0,U+5cc2-5cc3,U+5cc5-5cca,U+5ccc-5cd1,U+5cd3-5cd8,U+5cda-5ce0,U+5ce2-5ce3,U+5ce7,U+5ce9,U+5ceb-5cec,U+5cee-5cef,U+5cf1-5cf3" } }, { uri: lU, descriptors: { unicodeRange: "U+593b,U+593d-5940,U+5943,U+5945-5946,U+594a,U+594c-594d,U+5950,U+5952-5953,U+5959,U+595b-595f,U+5961,U+5963-5964,U+5966-5972,U+5975,U+5977,U+597a-597c,U+597e-5980,U+5985,U+5989,U+598b-598c,U+598e-5991,U+5994-5995,U+5998,U+599a-599d,U+599f-59a2,U+59a6-59a7,U+59ac-59ad,U+59b0-59b1,U+59b3-59b8,U+59ba,U+59bc-59bd,U+59bf-59c5,U+59c7-59c9,U+59cc-59cf,U+59d5-59d6,U+59d9,U+59db,U+59de-59e2,U+59e4,U+59e6-59e7,U+59e9-59eb,U+59ed-59f8,U+59fa,U+59fc-59fe,U+5a00,U+5a02,U+5a0a-5a0b,U+5a0d-5a10,U+5a12,U+5a14-5a17,U+5a19-5a1b,U+5a1d-5a1e,U+5a21-5a22,U+5a24,U+5a26-5a28,U+5a2a-5a30,U+5a33,U+5a35,U+5a37-5a3b,U+5a3d-5a3f,U+5a41-5a45,U+5a47-5a48,U+5a4b-5a54,U+5a56-5a59,U+5a5b-5a61,U+5a63-5a66,U+5a68-5a69,U+5a6b-5a73,U+5a78-5a79,U+5a7b-5a7e,U+5a80-5a90" } }, { uri: UU, descriptors: { unicodeRange: "U+5a91,U+5a93-5a99,U+5a9c-5aa9,U+5aab-5ab1,U+5ab4,U+5ab6-5ab7,U+5ab9-5abd,U+5abf-5ac0,U+5ac3-5ac8,U+5aca-5acb,U+5acd-5ad1,U+5ad3,U+5ad5,U+5ad7,U+5ad9-5adb,U+5add-5adf,U+5ae2,U+5ae4-5ae5,U+5ae7-5ae8,U+5aea,U+5aec-5af0,U+5af2-5b08,U+5b0a-5b15,U+5b18-5b31,U+5b33,U+5b35-5b36,U+5b38-5b3f,U+5b41-5b4f" } }, { uri: fU, descriptors: { unicodeRange: "U+5843,U+5845-584b,U+584e-5850,U+5852-5853,U+5855-5857,U+5859-585d,U+585f-5864,U+5866-586a,U+586d-587d,U+587f,U+5882,U+5884,U+5886-5888,U+588a-5891,U+5894-5898,U+589b-589d,U+58a0-58a7,U+58aa-58bb,U+58bd-58c0,U+58c2-58c4,U+58c6-58d0,U+58d2-58d4,U+58d6-58e3,U+58e5-58ea,U+58ed,U+58ef,U+58f1-58f2,U+58f4-58f5,U+58f7-58f8,U+58fa-5901,U+5903,U+5905-5906,U+5908-590c,U+590e,U+5910-5913,U+5917-5918,U+591b,U+591d-591e,U+5920-5923,U+5926,U+5928,U+592c,U+5930,U+5932-5933,U+5935-5936" } }, { uri: pU, descriptors: { unicodeRange: "U+56d0-56d3,U+56d5-56d6,U+56d8-56d9,U+56dc,U+56e3,U+56e5-56ea,U+56ec,U+56ee-56ef,U+56f2-56f3,U+56f6-56f8,U+56fb-56fc,U+5700-5702,U+5705,U+5707,U+570b-571b,U+571d-571e,U+5720-5722,U+5724-5727,U+572b,U+5731-5732,U+5734-5738,U+573c-573d,U+573f,U+5741,U+5743-5746,U+5748-5749,U+574b,U+5752-5756,U+5758-5759,U+5762-5763,U+5765,U+5767,U+576c,U+576e,U+5770-5772,U+5774-5775,U+5778-577a,U+577d-5781,U+5787-578a,U+578d-5791,U+5794-579a,U+579c-579f,U+57a5,U+57a8,U+57aa,U+57ac,U+57af-57b1,U+57b3,U+57b5-57b7,U+57b9-57c1,U+57c4-57ca,U+57cc-57cd,U+57d0-57d1,U+57d3,U+57d6-57d7,U+57db-57dc,U+57de,U+57e1-57e3,U+57e5-57ec,U+57ee,U+57f0-57f3,U+57f5-57f7,U+57fb-57fc,U+57fe-57ff,U+5801,U+5803-5805,U+5808-580a,U+580c,U+580e-5810,U+5812-5814,U+5816-5818,U+581a-581d,U+581f,U+5822-5823,U+5825-5829,U+582b-582f,U+5831-5834,U+5836-5842" } }, { uri: uU, descriptors: { unicodeRange: "U+55f9-55fc,U+55ff,U+5602-5607,U+560a-560b,U+560d,U+5610-5617,U+5619-561a,U+561c-561d,U+5620-5622,U+5625-5626,U+5628-562b,U+562e-5630,U+5633,U+5635,U+5637-5638,U+563a,U+563c-563e,U+5640-564b,U+564f-5653,U+5655-5656,U+565a-565b,U+565d-5661,U+5663,U+5665-5667,U+566d-5670,U+5672-5675,U+5677-567a,U+567d-5684,U+5687-568d,U+5690-5692,U+5694-56a2,U+56a4-56ae,U+56b0-56b6,U+56b8-56bb,U+56bd-56c9,U+56cb-56cf" } }, { uri: mU, descriptors: { unicodeRange: "U+5286-5287,U+5289-528f,U+5291-5292,U+5294-529a,U+529c,U+52a4-52a7,U+52ae-52b0,U+52b4-52bd,U+52c0-52c2,U+52c4-52c6,U+52c8,U+52ca,U+52cc-52cf,U+52d1,U+52d3-52d5,U+52d7,U+52d9-52de,U+52e0-52e3,U+52e5-52ef,U+52f1-52f8,U+52fb-52fd,U+5301-5304,U+5307,U+5309-530c,U+530e,U+5311-5314,U+5318,U+531b-531c,U+531e-531f,U+5322,U+5324-5325,U+5327-5329,U+532b-532d,U+532f-5338,U+533c-533d,U+5340,U+5342,U+5344,U+5346,U+534b-534d,U+5350,U+5354,U+5358-5359,U+535b,U+535d,U+5365,U+5368,U+536a,U+536c-536d,U+5372,U+5376,U+5379,U+537b-537e,U+5380-5381,U+5383,U+5387-5388,U+538a,U+538e-5394,U+5396-5397,U+5399,U+539b-539c,U+539e,U+53a0-53a1,U+53a4,U+53a7,U+53aa-53ad,U+53af-53b5,U+53b7-53ba,U+53bc-53be,U+53c0,U+53c3-53c7,U+53ce-53d0,U+53d2-53d3,U+53d5,U+53da,U+53dc-53de,U+53e1-53e2,U+53e7,U+53f4,U+53fa,U+53fe-5400,U+5402,U+5405,U+5407,U+540b,U+5414,U+5418-541a,U+541c,U+5422,U+5424-5425,U+542a,U+5430,U+5433,U+5436-5437,U+543a" } }, { uri: bU, descriptors: { unicodeRange: "U+5101-5105,U+5108-510a,U+510c-5111,U+5113-5120,U+5122-513e,U+5142,U+5147,U+514a,U+514c,U+514e-5150,U+5152-5153,U+5157-5159,U+515b,U+515d-5161,U+5163-5164,U+5166-5167,U+5169-516a,U+516f,U+5172,U+517a,U+517e-517f,U+5183-5184,U+5186-5187,U+518a-518b,U+518e-5191,U+5193-5194,U+5198,U+519a,U+519d-519f,U+51a1,U+51a3,U+51a6-51aa,U+51ad-51ae,U+51b4,U+51b8-51ba,U+51be-51bf,U+51c1-51c3,U+51c5,U+51c8,U+51ca,U+51cd-51ce,U+51d0,U+51d2-51da,U+51dc,U+51de-51df,U+51e2-51e3,U+51e5-51ea,U+51ec,U+51ee,U+51f1-51f2,U+51f4,U+51f7,U+51fe,U+5204-5205,U+5209,U+520b-520c,U+520f-5210,U+5213-5215,U+521c,U+521e-521f,U+5221-5223,U+5225-5227,U+522a,U+522c,U+522f,U+5231-5232,U+5234-5235,U+523c,U+523e,U+5244-5249,U+524b,U+524e-524f,U+5252-5253,U+5255,U+5257-525b,U+525d,U+525f-5260,U+5262-5264,U+5266,U+5268,U+526b-526e,U+5270-5271,U+5273-527c,U+527e,U+5280,U+5283-5285" } }, { uri: EU, descriptors: { unicodeRange: "U+543d,U+543f,U+5441-5442,U+5444-5445,U+5447,U+5449,U+544c-544f,U+5451,U+545a,U+545d-5461,U+5463,U+5465,U+5467,U+5469-5470,U+5474,U+5479-547a,U+547e-547f,U+5481,U+5483,U+5485,U+5487-548a,U+548d,U+5491,U+5493,U+5497-5498,U+549c,U+549e-54a2,U+54a5,U+54ae,U+54b0,U+54b2,U+54b5-54b7,U+54b9-54ba,U+54bc,U+54be,U+54c3,U+54c5,U+54ca-54cb,U+54d6,U+54d8,U+54db,U+54e0-54e4,U+54eb-54ec,U+54ef-54f1,U+54f4-54f9,U+54fb,U+54fe,U+5500,U+5502-5505,U+5508,U+550a-550e,U+5512-5513,U+5515-551a,U+551c-551f,U+5521,U+5525-5526,U+5528-5529,U+552b,U+552d,U+5532,U+5534-5536,U+5538-553b,U+553d,U+5540,U+5542,U+5545,U+5547-5548,U+554b-554f,U+5551-5554,U+5557-555b,U+555d-5560,U+5562-5563,U+5568-5569,U+556b,U+556f-5574,U+5579-557a,U+557d,U+557f,U+5585-5586,U+558c-558e,U+5590,U+5592-5593,U+5595-5597,U+559a-559b,U+559e,U+55a0-55a6,U+55a8-55b0,U+55b2,U+55b4,U+55b6,U+55b8,U+55ba,U+55bc,U+55bf-55c3,U+55c6-55c8,U+55ca-55cb,U+55ce-55d0,U+55d5,U+55d7-55db,U+55de,U+55e0,U+55e2,U+55e7,U+55e9,U+55ed-55ee,U+55f0-55f1,U+55f4,U+55f6,U+55f8" } }, { uri: gU, descriptors: { unicodeRange: "U+4fe0,U+4fe2,U+4fe4-4fe5,U+4fe7,U+4feb-4fec,U+4ff0,U+4ff2,U+4ff4-4ff7,U+4ff9,U+4ffb-4ffd,U+4fff-500b,U+500e,U+5010-5011,U+5013,U+5015-5017,U+501b,U+501d-501e,U+5020,U+5022-5024,U+5027,U+502b,U+502f-5039,U+503b,U+503d,U+503f-5042,U+5044-5046,U+5049-504b,U+504d,U+5050-5054,U+5056-5059,U+505b,U+505d-5064,U+5066-506b,U+506d-5075,U+5078-507a,U+507c-507d,U+5081-5084,U+5086-5087,U+5089-508c,U+508e-50a2,U+50a4,U+50a6,U+50aa-50ab,U+50ad-50b1,U+50b3-50b9,U+50bc-50ce,U+50d0-50d5,U+50d7-50d9,U+50db-50e5,U+50e8-50eb,U+50ef-50f2,U+50f4,U+50f6-50fa,U+50fc-5100" } }, { uri: xU, descriptors: { unicodeRange: "U+49d5-4a77" } }, { uri: hU, descriptors: { unicodeRange: "U+4dac-4dad,U+4daf-4db5,U+4e02,U+4e04-4e06,U+4e0f,U+4e12,U+4e17,U+4e1f-4e21,U+4e23,U+4e26,U+4e29,U+4e2e-4e2f,U+4e31,U+4e33,U+4e35,U+4e37,U+4e3c,U+4e40-4e42,U+4e44,U+4e46,U+4e4a,U+4e51,U+4e55,U+4e57,U+4e5a-4e5b,U+4e62-4e65,U+4e67-4e68,U+4e6a-4e6f,U+4e72,U+4e74-4e7d,U+4e7f-4e85,U+4e87,U+4e8a,U+4e90,U+4e96-4e97,U+4e99,U+4e9c-4e9e,U+4ea3,U+4eaa,U+4eaf-4eb1,U+4eb4,U+4eb6-4eb9,U+4ebc-4ebe,U+4ec8,U+4ecc,U+4ecf-4ed0,U+4ed2,U+4eda-4edc,U+4ee0,U+4ee2,U+4ee6-4ee7,U+4ee9,U+4eed-4eef,U+4ef1,U+4ef4,U+4ef8-4efa,U+4efc,U+4efe,U+4f00,U+4f02-4f08,U+4f0b-4f0c,U+4f12-4f16,U+4f1c-4f1d,U+4f21,U+4f23,U+4f28-4f29,U+4f2c-4f2e,U+4f31,U+4f33,U+4f35,U+4f37,U+4f39,U+4f3b,U+4f3e-4f42,U+4f44-4f45,U+4f47-4f4c,U+4f52,U+4f54,U+4f56,U+4f61-4f62,U+4f66,U+4f68,U+4f6a-4f6b,U+4f6d-4f6e,U+4f71-4f72,U+4f75,U+4f77-4f7a,U+4f7d,U+4f80-4f82,U+4f85-4f87,U+4f8a,U+4f8c,U+4f8e,U+4f90,U+4f92-4f93,U+4f95-4f96,U+4f98-4f9a,U+4f9c,U+4f9e-4f9f,U+4fa1-4fa2,U+4fa4,U+4fab,U+4fad,U+4fb0-4fb4,U+4fb6-4fbe,U+4fc0-4fc2,U+4fc6-4fc9,U+4fcb-4fcd,U+4fd2-4fd6,U+4fd9,U+4fdb" } }, { uri: yU, descriptors: { unicodeRange: "U+4933-49d4" } }, { uri: IU, descriptors: { unicodeRange: "U+487a-4932" } }, { uri: wU, descriptors: { unicodeRange: "U+47d2-4879,U+2ce7c,U+2ce88,U+2ce93" } }, { uri: RU, descriptors: { unicodeRange: "U+4756-47d1,U+2ca02,U+2ca0e,U+2ca7d,U+2caa9,U+2cb29,U+2cb2e,U+2cb31,U+2cb38-2cb39,U+2cb3f,U+2cb41,U+2cb4e,U+2cb5a,U+2cb64,U+2cb69,U+2cb6c,U+2cb6f,U+2cb76,U+2cb78,U+2cb7c,U+2cbb1,U+2cbbf-2cbc0,U+2cbce,U+2cc5f,U+2ccf5-2ccf6,U+2ccfd,U+2ccff,U+2cd02-2cd03,U+2cd0a,U+2cd8b,U+2cd8d,U+2cd8f-2cd90,U+2cd9f-2cda0,U+2cda8,U+2cdad-2cdae,U+2cdd5,U+2ce18,U+2ce1a,U+2ce23,U+2ce26,U+2ce2a" } }, { uri: TU, descriptors: { unicodeRange: "U+46c3-4755,U+2c488,U+2c494,U+2c497,U+2c542,U+2c613,U+2c618,U+2c621,U+2c629,U+2c62b-2c62d,U+2c62f,U+2c642,U+2c64a-2c64b,U+2c72c,U+2c72f,U+2c79f,U+2c7c1,U+2c7fd,U+2c8d9,U+2c8de,U+2c8e1,U+2c8f3,U+2c907,U+2c90a,U+2c91d" } }, { uri: MU, descriptors: { unicodeRange: "U+4629-46c2,U+2bdf7,U+2be29,U+2c029-2c02a,U+2c0a9,U+2c0ca,U+2c1d5,U+2c1d9,U+2c1f9,U+2c27c,U+2c288,U+2c2a4,U+2c317,U+2c35b,U+2c361,U+2c364" } }, { uri: LU, descriptors: { unicodeRange: "U+458e-4628,U+2b7a9,U+2b7c5,U+2b7e6,U+2b7f9,U+2b806,U+2b80a,U+2b81c,U+2b8b8,U+2bac7,U+2bb5f,U+2bb62,U+2bb7c,U+2bb83,U+2bc1b,U+2bd77,U+2bd87" } }, { uri: DU, descriptors: { unicodeRange: "U+4449-4511,U+2afa2,U+2b127-2b128,U+2b137-2b138,U+2b1ed" } }, { uri: SU, descriptors: { unicodeRange: "U+439b-4448,U+2a437,U+2a5f1,U+2a602,U+2a61a,U+2a6b2,U+2a7dd,U+2a8fb,U+2a917,U+2aa30,U+2aa36,U+2aa58" } }, { uri: vU, descriptors: { unicodeRange: "U+4275-430d,U+298c6,U+29a72,U+29d98,U+29ddb,U+29e15,U+29e3d,U+29e49" } }, { uri: $U, descriptors: { unicodeRange: "U+4132-41de,U+28bef,U+28c47,U+28c4f,U+28c51,U+28c54,U+28d10,U+28d71,U+28dfb,U+28e1f,U+28e36,U+28e89,U+28e99,U+28eeb,U+28f32,U+28ff8,U+292a0" } }, { uri: PU, descriptors: { unicodeRange: "U+41df-4274,U+292b1,U+29490,U+295cf,U+2967f,U+296f0,U+29719,U+29750" } }, { uri: NU, descriptors: { unicodeRange: "U+408e-4131,U+285c8-285c9,U+28678,U+28695,U+286d7,U+286fa,U+287e0,U+28946,U+28949,U+2896b,U+28987-28988,U+289ba-289bb,U+28a1e,U+28a29,U+28a43,U+28a71,U+28a99,U+28acd,U+28add,U+28ae4,U+28b49,U+28bc1" } }, { uri: FU, descriptors: { unicodeRange: "U+3e83-3f2f,U+27139,U+273da-273db,U+273fe,U+27410,U+27449,U+27614-27615,U+27631,U+27684,U+27693,U+2770e,U+27723,U+27752" } }, { uri: BU, descriptors: { unicodeRange: "U+3f30-3fdb,U+27985,U+27a84,U+27bb3,U+27bbe,U+27bc7,U+27cb8,U+27da0,U+27e10" } }, { uri: _U, descriptors: { unicodeRange: "U+3fdc-408d,U+27fb7,U+27ff9,U+2808a,U+280bb,U+2815d,U+28277,U+28282,U+282e2,U+282f3,U+283cd,U+28408,U+2840c,U+28455,U+28468,U+2856b" } }, { uri: OU, descriptors: { unicodeRange: "U+3dd2-3e82,U+26a58,U+26a8c,U+26ab7,U+26aff,U+26b5c,U+26c21,U+26c29,U+26c73,U+26cdd,U+26e40,U+26e65,U+26f94,U+26ff6-26ff8,U+270f4,U+2710d" } }, { uri: AU, descriptors: { unicodeRange: "U+3d34-3dd1,U+2648d,U+26676,U+2667e,U+266b0,U+2671d,U+2677c,U+267cc,U+268dd,U+268ea,U+26951,U+2696f,U+269dd,U+269fa,U+26a1e" } }, { uri: KU, descriptors: { unicodeRange: "U+3c76-3d33,U+25d0a,U+25da1,U+25e2e,U+25e56,U+25e62,U+25e65,U+25ec2,U+25ed7-25ed8,U+25ee8,U+25f23,U+25f5c,U+25fd4,U+25fe0,U+25ffb,U+2600c,U+26017,U+26060,U+260ed,U+26221,U+26270,U+26286,U+2634c,U+26402" } }, { uri: HU, descriptors: { unicodeRange: "U+3bda-3c75,U+25771,U+257a9,U+257b4,U+259c4,U+259d4,U+25ae3-25ae4,U+25af1,U+25bb2,U+25c14,U+25c4b,U+25c64" } }, { uri: JU, descriptors: { unicodeRange: "U+3b25-3bd9,U+2504a,U+25055,U+25122,U+2512b,U+251a9,U+251cd,U+251e5,U+2521e,U+2524c,U+2542e,U+2548e,U+254d9,U+2550e,U+25532,U+25562,U+255a7-255a8" } }, { uri: YU, descriptors: { unicodeRange: "U+3a6b-3b24,U+24896,U+249db,U+24a4d,U+24a7d,U+24ac9,U+24b56,U+24b6f,U+24c16,U+24d14,U+24dea,U+24e0e,U+24e37,U+24e6a,U+24e8b,U+24eaa" } }, { uri: CU, descriptors: { unicodeRange: "U+39a9-3a6a,U+24096,U+24103,U+241ac,U+241c6,U+241fe,U+243bc,U+243f8,U+244d3,U+24629,U+246a5,U+247f1" } }, { uri: VU, descriptors: { unicodeRange: "U+38e3-39a8,U+23a98,U+23c7f,U+23c97-23c98,U+23cfe,U+23d00,U+23d0e,U+23d40,U+23dd3,U+23df9-23dfa,U+23e23,U+23f7e" } }, { uri: qU, descriptors: { unicodeRange: "U+3760-382a,U+22ab8,U+22b43,U+22b46,U+22b4f-22b50,U+22ba6,U+22bca,U+22c1d,U+22c24,U+22c55,U+22d4c,U+22de1" } }, { uri: XU, descriptors: { unicodeRange: "U+382b-38e2,U+231b6,U+231c3-231c4,U+231f5,U+23350,U+23372,U+233d0,U+233d2-233d3,U+233d5,U+233da,U+233df,U+233e4,U+2344a-2344b,U+23451,U+23465,U+234e4,U+2355a,U+23594,U+235c4,U+235cb,U+23638-2363a,U+23647,U+2370c,U+2371c,U+2373f,U+23763-23764,U+237e7,U+237ff,U+23824,U+2383d" } }, { uri: GU, descriptors: { unicodeRange: "U+3698-375f,U+22218,U+2231e,U+223ad,U+224dc,U+226f3,U+2285b,U+228ab,U+2298f" } }, { uri: kU, descriptors: { unicodeRange: "U+35e6-3697,U+21c56,U+21cde,U+21d2d,U+21d45,U+21d62,U+21d78,U+21d92,U+21d9c,U+21da1,U+21db7,U+21de0,U+21e33-21e34,U+21f1e,U+21f76,U+21ffa,U+2217b" } }, { uri: ZU, descriptors: { unicodeRange: "U+3444-350e,U+20ad3,U+20b1d,U+20b9f,U+20c41,U+20cbf,U+20cd0,U+20d45,U+20de1,U+20e64,U+20e6d,U+20e95,U+20e9d,U+20ea2,U+20f5f,U+210c1,U+21201,U+2123d,U+21255,U+21274,U+2127b" } }, { uri: WU, descriptors: { unicodeRange: "U+350f-35e5,U+212d7,U+212e4,U+212fd,U+2131b,U+21336,U+21344,U+2139a,U+213c4,U+21413,U+2146d-2146e,U+215d7,U+21647,U+216b4,U+21706,U+21742,U+218bd,U+219c3" } }, { uri: zU, descriptors: { unicodeRange: "U+336d-3443,U+2032b,U+20371,U+20381,U+203f9,U+2044a,U+20509,U+20547,U+205d6,U+20628,U+20676,U+2074f,U+20779,U+20807,U+2083a,U+20895,U+208b9,U+2097c,U+2099d" } }, { uri: QU, descriptors: { unicodeRange: "U+328b-336c,U+2000b,U+20089,U+200a2,U+200a4,U+20164,U+201a2,U+20213" } }, { uri: jU, descriptors: { unicodeRange: "U+3192-31ba,U+31c0-31e3,U+31f0-321e,U+3220-328a,U+1f250-1f251" } }, { uri: ef, descriptors: { unicodeRange: "U+2f74-2fd5,U+3000,U+3003-3007,U+3012-3013,U+3018-301c,U+3020-3029,U+302f-303f,U+3041-3096,U+3099-30a1" } }, { uri: tf, descriptors: { unicodeRange: "U+30a2-30ff,U+3105-312f,U+3131-318e,U+3190-3191" } }, { uri: nf, descriptors: { unicodeRange: "U+4e36,U+4ea0,U+4f74,U+4f91,U+4f94,U+4fc5,U+507e,U+50ed,U+5182,U+51f5,U+525e,U+5282,U+52f9,U+5326,U+537a,U+53a3,U+5423,U+5459,U+54b4,U+54d9,U+55c9,U+57f4,U+580b,U+5902,U+5925,U+5a08,U+5ab5,U+5b84,U+5be4,U+5c22,U+5cb5,U+5cbd,U+5d3e,U+5e31,U+5e5e,U+5e80,U+5ee8,U+5f82,U+5fc9,U+5fed,U+600a,U+605d,U+609b,U+609d,U+60dd,U+6243,U+6322,U+63ce,U+640c,U+643f,U+6445,U+64d7,U+6534,U+6549,U+656b,U+6603,U+674c,U+680a,U+6864,U+69d4,U+6a65,U+6c2a,U+6c46,U+6c5c,U+6d0e,U+6d48,U+6e2b,U+6eb2,U+6eb7,U+6f89,U+706c,U+70b1,U+7113,U+71d4,U+727f,U+72f3,U+7303,U+7321,U+736c,U+736f,U+74a9,U+74de,U+750d,U+7513,U+7592,U+75c4,U+7605,U+760a,U+761b,U+7625,U+762d,U+7643,U+7707,U+7747,U+77b5,U+7839,U+784e,U+78a5,U+7924,U+793b,U+798a,U+7a03,U+7a06,U+7a78,U+7a80,U+7aad,U+7ba8,U+7be5,U+7cc8,U+7ec1,U+7f0b,U+7f0f,U+7f12,U+7f68,U+7f9d,U+8025,U+809c,U+80ad,U+80b7,U+80e8,U+811e,U+8204,U+8223,U+822d,U+823b,U+824b,U+825a,U+827d,U+827f,U+828f,U+82c8,U+8307,U+831b,U+8347,U+837d,U+839b,U+83a9,U+83f9,U+84b9,U+8579,U+864d,U+867f,U+86b0,U+86d1,U+86d8,U+86f2,U+8764,U+8770,U+8788,U+8797,U+87ac-87ad,U+87b5,U+881b,U+8844,U+88bc,U+88fc,U+8930,U+89cf,U+89d6,U+8ba0,U+8bd4,U+8c02,U+8c2b,U+8c85,U+8e23,U+8f81-8f82,U+8fd5,U+90b6,U+90db,U+914e,U+9164,U+91ad,U+943e,U+94b7-94b8,U+94eb,U+950d,U+9514,U+9516,U+9518,U+9529,U+9538,U+953f,U+954e,U+955f,U+95fc,U+9667,U+96b3,U+9792,U+97b2,U+98a1,U+9969,U+9987,U+9998,U+9a80,U+9a92,U+9a96,U+9adf,U+9cb4,U+9cbd,U+9cd0,U+9cd4,U+9e31,U+9e3a,U+9e71,U+9ee5,U+9eea,U+9ef9,U+9fa0" } }, { uri: rf, descriptors: { unicodeRange: "U+4e0c,U+4e28,U+4e3f,U+4ec2,U+502e,U+50ba,U+5155,U+5181,U+522d,U+5281,U+5290,U+5369,U+53b6,U+54d5,U+54dc,U+54ff,U+552a,U+553c,U+5588,U+55b5,U+5686,U+570a,U+5776,U+5786,U+57a4,U+5820,U+5865,U+58bc,U+5b32,U+5b65,U+5c1c,U+5c66,U+5c6e,U+5c8d,U+5ddb,U+5f2a,U+5f50,U+5f61,U+6067,U+614a,U+615d,U+619d,U+61d4,U+620b,U+6224-6225,U+6343,U+63ad,U+63f2,U+640b,U+6420,U+6434,U+6496,U+64d0,U+6509,U+652e,U+67a8,U+6833,U+6844,U+684a,U+6920,U+6957,U+6971,U+6a8e,U+6a91,U+6aa0,U+6b43,U+6bea,U+6bf5,U+6c15,U+6cd0,U+6ee0,U+6f24,U+6f2d,U+70c0,U+721d,U+728b,U+72c3,U+72e8,U+730a,U+7338-7339,U+734d,U+746d,U+752f,U+754e,U+770d,U+7735,U+778d,U+77a2,U+77e7,U+7857,U+786d,U+78c9,U+78f2,U+791e,U+7953,U+7b58,U+7b9d,U+7bda,U+7cd7,U+7f32-7f33,U+8022,U+8028-8029,U+8035,U+804d,U+8080,U+80c2,U+80e9,U+80ec,U+80f2,U+810e,U+8221,U+8274,U+82b0,U+82e0,U+83b0,U+8487-8488,U+848e,U+84cd,U+84d0,U+8539,U+857a,U+85a8,U+85b7,U+867c,U+871e,U+8723,U+877e,U+878b,U+8793,U+8803,U+88d2,U+8966,U+89cc,U+89eb,U+8b26,U+8c8a,U+8c98,U+8d33,U+8d47,U+8d55,U+8dbc,U+8e40,U+8e94,U+8f77,U+8f79,U+9058,U+91a2,U+91b5,U+928e,U+9494,U+94b6,U+94de,U+94f4,U+94f9,U+950a,U+950e,U+951e,U+952b,U+953c,U+953e,U+9544,U+9561,U+9564,U+9569,U+95f6,U+9603,U+960d,U+963d,U+9674,U+9794,U+97ab,U+98a5,U+9a9f,U+9ab1,U+9ad1,U+9b0f,U+9b2f,U+9c92,U+9c95,U+9cba,U+9cbc,U+9cc6,U+9ccb,U+9cd8,U+9e32,U+9e38,U+9e5b,U+9e7e,U+9eb4,U+9efb-9efc,U+9f3d" } }, { uri: of, descriptors: { unicodeRange: "U+2e3b,U+2e80-2e99,U+2e9b-2ef3,U+2f00-2f73,U+ffffd" } }, { uri: af, descriptors: { unicodeRange: "U+4e69,U+4f1b,U+4f67,U+4f7e,U+4fdc,U+50e6,U+5196,U+5202,U+5233,U+523f,U+52a2,U+536e,U+5476,U+54ad,U+54cf,U+5537,U+561e,U+56dd,U+56df,U+5709,U+572c,U+57cf,U+57f8,U+580d,U+5881,U+589a,U+5941,U+59b2,U+5c25,U+5d24,U+5d74,U+5e42,U+5e8b,U+5eb3,U+5ed2,U+5fad,U+6003,U+603c,U+6083,U+6100,U+6126,U+6206,U+62ca,U+638e,U+63b4,U+6426,U+646d,U+6535,U+65c4,U+66db,U+6715,U+6769,U+6798,U+67c3,U+6861,U+698d,U+69ca,U+69ed,U+69f2,U+69ff,U+6a18,U+6b39,U+6bb3,U+6c0d,U+6cb2,U+6cd6,U+6cf7,U+6cfa,U+6d33,U+6e16,U+6e53-6e54,U+6ebb,U+6fb6,U+709d,U+72ad,U+72f7,U+72fb,U+7313,U+739f,U+74ba,U+754b,U+755b,U+758b,U+75ac,U+75d6,U+7617,U+7635,U+7640,U+76a4,U+76b2,U+775a,U+77bd,U+781f,U+79b3,U+7b2b,U+7b31,U+7b3e,U+7b6e,U+7b9c,U+7c0b,U+7c9e,U+7cc1,U+7ce8,U+7ea5,U+7f21,U+7f27,U+7f74,U+7fb0,U+8031,U+8071,U+80ea,U+8114,U+8160,U+81a6,U+81c1,U+829f,U+82a4,U+82fb,U+831a,U+8333,U+836c,U+83b6,U+83f8,U+8411,U+841c,U+8489,U+848c,U+85a4,U+8627,U+8629,U+866e,U+86b5,U+872e,U+8731,U+877b,U+877d,U+87ea,U+8813,U+8816,U+8864,U+88ce,U+88e5,U+897b,U+89cb,U+89f3,U+8bfc,U+8c35,U+8d46,U+8d4d,U+8dba,U+8e3a,U+8f75,U+8f7e,U+8fd3,U+9161,U+9179,U+917e,U+91a3,U+94ac,U+94d7,U+94e5,U+952a,U+952c,U+9545,U+9565,U+9568,U+956a,U+961d,U+96e0,U+972a,U+9730,U+989f,U+98e7,U+990d,U+9967,U+9993,U+9aa3,U+9ac0,U+9ae1,U+9aeb,U+9af9,U+9c86,U+9c8b,U+9ca0-9ca1,U+9ca3,U+9ce2,U+9e48,U+9e6a,U+9e87,U+9ee2,U+9ee9,U+9f17,U+9f19,U+9f2c,U+9f80" } }, { uri: sf, descriptors: { unicodeRange: "U+4ef3,U+50d6,U+50ec,U+51ab,U+51b1,U+52d6,U+54a9,U+54da,U+55be,U+55cd,U+564d,U+572f,U+574c,U+576b,U+57d8,U+57fd,U+5844,U+59d2,U+5ae0,U+5b16,U+5b37,U+5b5b,U+5b80,U+5d1e,U+5d6b,U+5efe,U+5f11,U+5f56,U+5f58,U+5f73,U+5f8c,U+5fc4,U+5fe4,U+602b,U+6106,U+610d,U+63de,U+63f8,U+641b,U+64e4,U+6634,U+676a,U+67b5,U+681d,U+6883,U+69b1,U+69e0,U+6b37,U+6b9b,U+6d7c,U+6ed7,U+6f36,U+6f72,U+6f8c,U+7035,U+7039,U+7173,U+7178,U+7228,U+728f,U+72b4,U+72ef,U+72f4,U+7331,U+7481,U+74e0,U+7540,U+75c3,U+75e6,U+763c,U+764d,U+76cd,U+7704,U+7743,U+7780,U+7847,U+786a,U+78b9,U+7962,U+7a02,U+7aac,U+7ab3,U+7b0a,U+7b4c,U+7b7b,U+7bfc,U+7c0f,U+7c16,U+7c40,U+7ca2,U+7cc7,U+7cf8,U+7d77,U+7e3b,U+7ea1,U+7ea9,U+7ef2,U+7f02,U+7f07,U+7f0c,U+7f23,U+7f2f,U+7fbc,U+8016,U+8020,U+812c,U+8136,U+8182,U+822f,U+8233,U+825f,U+8268,U+8284,U+8288,U+8291,U+8308,U+8311,U+835b,U+836d,U+83dd,U+8406,U+840f,U+845c,U+84b4,U+84e3,U+850c,U+855e,U+863c,U+86ba,U+86c4,U+86de,U+86f1,U+873e,U+87bd,U+87db,U+880a,U+883c,U+887f,U+88f0,U+890a,U+892b,U+895e,U+89ef,U+8a48,U+8bdc,U+8c18,U+8c33,U+8c94,U+8db1,U+8dcf,U+8dd6,U+8de3,U+8e6f,U+8e90,U+8f7a,U+8fb6,U+902d,U+90be,U+91af,U+936a,U+948b,U+94d8,U+9513,U+953a,U+956c,U+963c,U+9654,U+966c,U+9688,U+97b4,U+996b,U+9a75,U+9a7a,U+9aba,U+9aed,U+9b08,U+9b43,U+9c8e,U+9c94,U+9c9a,U+9e2b,U+9e36,U+9e4b,U+9e4e,U+9e55,U+9e63,U+9e68-9e69,U+9ebd,U+9ec9,U+9f0d,U+9f37,U+9f51" } }, { uri: df, descriptors: { unicodeRange: "U+50a7,U+5240,U+5261,U+52ac,U+531a,U+5363,U+5432,U+5452,U+5456,U+5472,U+5478,U+553f,U+5575,U+5581,U+55cc,U+55fe,U+5601,U+572e,U+57d2,U+57ef,U+581e,U+5924,U+5981,U+5997,U+59a3,U+5aaa,U+5ab8,U+5b34,U+5d5d,U+5def,U+5e11,U+5e91,U+5ed1,U+5ef4,U+5f40,U+600d,U+6019,U+601b,U+605a,U+6092,U+60ab,U+6217,U+623d,U+6369,U+65d2,U+6661,U+670a,U+6753,U+67a7,U+6855,U+68f9,U+6939,U+696e,U+6980,U+6a7c,U+6aab,U+6b82,U+6bf3,U+6bf9,U+6c05,U+6c19-6c1a,U+6ca9,U+6cf6,U+6d1a,U+6dab,U+6f74,U+7085,U+7198,U+71b5,U+7256,U+725d,U+727e,U+72fa,U+7322,U+738e,U+73e5,U+750f,U+755a,U+7594,U+75b3,U+760c,U+7615,U+7630,U+763f,U+77ec,U+7817,U+78a1,U+78d9,U+7905,U+7b2a,U+7b2e,U+7b62,U+7b85,U+7bcc,U+7bea,U+7c26,U+7c74,U+7c9c-7c9d,U+7e47,U+7e9b,U+7e9f,U+7ee0,U+7ee8,U+7ef1,U+7f01,U+7f11,U+7f17,U+7f36,U+7f7e,U+7fee,U+802a,U+80cd,U+8112,U+8169,U+8234,U+8279,U+8298,U+82ca,U+82d8,U+82e1,U+83c0,U+83d4,U+83df,U+8401,U+8451,U+845a,U+8476,U+8478,U+84ba,U+84bd,U+84e0,U+851f,U+8548,U+8556,U+8585,U+868d,U+86e9,U+86f4,U+86f8,U+8765,U+8785,U+87ab,U+87ee,U+8832,U+8872,U+88b7,U+88e2-88e3,U+89da,U+8bce,U+8bd3,U+8bd6,U+8bf9,U+8c16,U+8c73,U+8d5c,U+8dde,U+8f6d,U+8f94,U+8fe8,U+9011,U+915e,U+9185,U+918c,U+94ab,U+94d1,U+94f3,U+9515,U+951d,U+9558,U+9567,U+96ce,U+96e9,U+9785,U+9878,U+987c,U+9883,U+98d1,U+9954,U+9963,U+9a93,U+9ac1,U+9acc,U+9b1f,U+9b49,U+9b4d,U+9b51,U+9ca7,U+9cae,U+9cce,U+9cd3,U+9e37,U+9e39,U+9e41,U+9e46,U+9f22,U+9f2f,U+9f39,U+9f85" } }, { uri: cf, descriptors: { unicodeRange: "U+4e5c,U+4edf,U+4f25,U+4f32,U+4f5e,U+4f76,U+4faa,U+4fe6,U+5028,U+5048,U+5250,U+535f,U+538d,U+53c1,U+5412,U+5443,U+54d4,U+54dd,U+5541,U+5550,U+5577,U+55dd,U+55f3,U+560f,U+562c,U+5657-5658,U+5664,U+56af,U+575c,U+577c,U+57b2,U+57da,U+5800,U+5a62,U+5aeb,U+5c3b,U+5ca3,U+5d26,U+5d9d,U+5f01,U+5fb5,U+5fdd,U+5ff8,U+6029,U+6041,U+6079,U+60b1,U+6222,U+629f,U+6332,U+63bc,U+63e0,U+6485,U+65ab,U+65c3,U+65c6,U+668c,U+669d,U+66be,U+67fd,U+6800,U+68fc,U+690b,U+6924,U+6978,U+69a7,U+6a3e,U+6a50,U+6a5b,U+6a97,U+6b24,U+6b8d,U+6baa,U+6c10,U+6c54,U+6ceb,U+6d04,U+6d4d,U+6eb1,U+6ebd,U+7110,U+71b3,U+71f9,U+7230,U+728d,U+7292,U+72b8,U+72d2,U+7360,U+73a2,U+7511,U+75a0,U+75c8,U+779f,U+7826,U+7877,U+7a39,U+7aa8,U+7ae6,U+7b04,U+7b0f,U+7baa,U+7bac,U+7c1f,U+7ccd,U+7ecb,U+7ed4,U+7ed7,U+7efb,U+7f0d,U+7f5f,U+7faf,U+7fd5,U+7fe5,U+8027,U+80bc,U+80dd,U+80fc,U+8132,U+815a,U+8167,U+816d,U+81ca,U+8228,U+82a1,U+82a9,U+82ab,U+82cc,U+8351,U+8368,U+83b8,U+83d8,U+83ea,U+83f0,U+8497,U+84c1,U+858f,U+85ff,U+867b,U+86a8-86a9,U+870a,U+8722,U+876e,U+877c,U+87e5,U+8888,U+88df,U+8919,U+8bcc,U+8bdf,U+8be8,U+8bee,U+8c20,U+8c2f,U+8d36,U+8df8,U+8e05,U+8e2f,U+8f9a,U+9021,U+908b,U+90b4,U+90ba,U+90d0,U+90eb,U+90fe,U+91aa,U+933e,U+9486-9487,U+948d,U+9490,U+94ad,U+94bd,U+94d6,U+94d9,U+9507,U+9546,U+955e,U+956b,U+95e9,U+9604,U+960b,U+9612,U+9615,U+9617,U+96b9,U+989a-989b,U+989e,U+9a78,U+9a7d,U+9aa0,U+9aa2,U+9ac2,U+9b23,U+9b3b,U+9c82,U+9cca,U+9cd9,U+9e28,U+9e5a,U+9e5e,U+9e6c,U+9efe,U+9f0b" } }, { uri: lf, descriptors: { unicodeRange: "U+4e47,U+4e8d,U+4f65,U+4f89,U+50ee,U+520e,U+5416,U+5454,U+54bb,U+54c2,U+54d3,U+54de,U+5591,U+55e5,U+560c,U+566b,U+5769,U+578c,U+5793,U+57e4,U+5889,U+593c,U+59ab,U+5ad4,U+5ad8,U+5af1,U+5b53,U+5ba5,U+5c59,U+5c63,U+5d5b,U+5e0f,U+5e14,U+5edb,U+5fbc,U+6004,U+60ad,U+610e,U+61b7,U+624c,U+634c,U+647a,U+64ba,U+65f0,U+6600,U+66f7,U+67e2,U+67f0,U+680c,U+686b,U+6874,U+691f,U+6989,U+6a17,U+6b81,U+6b84,U+6c06-6c07,U+6c3d,U+6d07,U+6d27,U+6d2b,U+6d91,U+6e6b,U+6e8f,U+6fde,U+70bb,U+723b,U+726e,U+72b0,U+72ce,U+72f2,U+7301,U+731e,U+737e,U+7477,U+748e,U+74ff,U+7633,U+7654,U+771a,U+7726,U+7765,U+7768,U+781c,U+7829,U+78d4,U+7913,U+7957,U+79d5,U+79eb,U+7a70,U+7a86,U+7b25,U+7b38,U+7b47,U+7b72,U+7ba6-7ba7,U+7dae,U+7ee1,U+7efe,U+7f26,U+7f31,U+7f35,U+801c,U+8043,U+809f,U+80ab,U+80d7,U+8118,U+8188,U+81cc,U+823e,U+8244,U+824f,U+82b4,U+82c1,U+82e4,U+82f4,U+8306,U+833a,U+835c,U+839c,U+83b3,U+83bc,U+846d,U+867a,U+868b,U+8734,U+87ca,U+886e,U+887e,U+88a2,U+88c9,U+8921,U+8bb5,U+8bf3,U+8c04,U+8c17,U+8c1d,U+8c25,U+8c36,U+8c55,U+8c78,U+8d3d,U+8d40,U+8d59,U+8d67,U+8d91,U+8dbf,U+8deb-8dec,U+8dfd,U+8e14,U+8e41,U+8f8e,U+900b,U+9044,U+9062,U+90cf,U+9123,U+9146,U+9162,U+9172,U+918d,U+9190,U+92c8,U+93ca,U+948c,U+94aa,U+94b2,U+94c8,U+94ca,U+94d5,U+94df,U+94e9-94ea,U+94f7,U+94fc-94fd,U+951b,U+954f,U+9554,U+9559,U+9566,U+9571-9572,U+95f1,U+9608,U+960f,U+97af,U+988f,U+98d5,U+992e,U+9955,U+9ab0,U+9b32,U+9c90,U+9c9e,U+9ca5,U+9ca9,U+9cad,U+9cb1,U+9cc3,U+9e47,U+9ee7,U+9f87" } }, { uri: Uf, descriptors: { unicodeRange: "U+4e93,U+4ec4,U+4ef5,U+4f27,U+4f7b,U+4fe3,U+5080,U+5121,U+51eb,U+5208,U+52f0,U+53f5,U+5453,U+5466,U+54a6,U+54bf,U+54d0,U+5533,U+5549,U+5556,U+556d,U+558f,U+55f2,U+55f5,U+5627,U+567b,U+56d4,U+571c,U+5739,U+57b4,U+5807,U+58c5,U+59a4,U+59af,U+59d8,U+5a09,U+5a0c,U+5a4a,U+5ad2,U+5b6c,U+5ca2,U+5cac,U+5d03,U+5d6c,U+5db7,U+5ebe,U+5f2d,U+5fea,U+6042,U+6120,U+6175,U+6221,U+623e,U+6339,U+638a,U+643d,U+64b8,U+64e2,U+66e9,U+67b3,U+67c1,U+67d2,U+6832,U+6877,U+68f0,U+6934,U+6966,U+6987,U+6998,U+69c1,U+69ce,U+6a3d,U+6a84,U+6aa9,U+6b87,U+6bd6,U+6c16,U+6c18,U+6cd4,U+6cee,U+6de0,U+6e0c,U+6ecf,U+6f4b,U+70b7,U+7168,U+72d9,U+7352,U+73b3,U+73d0,U+7441,U+74d2,U+75a5,U+75e7-75e8,U+7610,U+7619,U+765e,U+772d,U+7812,U+782c,U+784c,U+7850,U+7856,U+789b,U+78f4,U+7a51,U+7b15,U+7b1e,U+7b24,U+7b5a,U+7bb8,U+7bc1,U+7bd9,U+7ed0,U+7ee6,U+7efa,U+7f1b,U+7f1f,U+7f22,U+7f45,U+7f71,U+7fa7,U+7fbf,U+7ff3,U+8052,U+80b1,U+80db,U+80f4,U+81bb,U+81ec,U+8202,U+8210,U+8249,U+828a,U+828e,U+82e3,U+8315,U+8369,U+8378,U+83a8,U+83aa,U+83b4,U+83e1,U+84fc,U+8538,U+853b,U+859c,U+85ae,U+86b4,U+86c9,U+86cf,U+8725,U+879f,U+87b3,U+887d,U+88fe,U+8a8a,U+8ba7,U+8c07,U+8c14,U+8c30,U+8c47,U+8db5,U+8dd7,U+8e1f,U+8e69,U+8e70,U+8e85,U+8f78,U+8f87,U+8f8b,U+8f8f,U+90c4,U+9143,U+917d,U+948f,U+94cd,U+94d2,U+94ef,U+954a,U+9609-960a,U+96d2,U+9708,U+9765,U+97ea,U+9880,U+98a7,U+996c,U+9980,U+9991,U+9a88,U+9ab6,U+9afb,U+9b47,U+9c87,U+9c9b,U+9cb5,U+9cc7,U+9e2c,U+9e42,U+9e58,U+9ecd,U+9ecf,U+9f8a,U+9f8c" } }, { uri: ff, descriptors: { unicodeRange: "U+4ebb,U+4edd,U+4fa9,U+502c,U+50a5,U+51c7,U+51fc,U+523d,U+5241,U+530f,U+5464,U+549d,U+54a3,U+5514,U+5527,U+555c,U+556e,U+5576,U+55b1,U+55b9,U+55eb,U+5624,U+564c,U+5671,U+5685,U+568f,U+56d7,U+56e1,U+57a1,U+57d9,U+5942,U+5a67,U+5c50,U+5c7a,U+5c98,U+5d06,U+5d27,U+5d6f,U+5df3,U+5dfd,U+5e19,U+5ea0,U+5eb9,U+5eea,U+5ffe,U+600f,U+606b,U+6215,U+622c,U+6266,U+62bb,U+62bf,U+6308,U+6387,U+63b8,U+63c4,U+63c6,U+63f6,U+6441,U+6555,U+659b,U+6677,U+66a7,U+6775,U+678b,U+679e,U+6840,U+6849,U+6860,U+68c2,U+6910,U+6a28,U+6a2f,U+6a79,U+6b92-6b93,U+6bc2,U+6bfd,U+6c29,U+6c32,U+6c86,U+6cc5,U+6d0c,U+6d60,U+6da0,U+6ddd,U+6e86,U+6ed3,U+6edf,U+6fb9,U+6fd1,U+6fef,U+7023,U+7080,U+70ca,U+712f,U+7145,U+7284,U+732c,U+73c8,U+73d9,U+740a,U+7457,U+7596,U+759d,U+75a3,U+75d8,U+75e3-75e4,U+75ff,U+7622,U+7688,U+76b4,U+76e5,U+7818,U+7887,U+789a,U+78b2,U+7b08,U+7b33,U+7c2a,U+7ccc,U+7ea8,U+7ec0,U+7fe6,U+8012,U+8084,U+8093,U+80e4,U+80ef,U+8297,U+82a8,U+82be,U+8331,U+8366,U+83c5,U+83fd,U+8473,U+84a1,U+84ca,U+84d1,U+857b,U+85c1,U+85d3,U+8605,U+8662,U+86aa,U+86b1,U+86d4,U+86ed,U+86f3,U+8709,U+8748,U+874c,U+8763,U+89c7,U+89de,U+89e5,U+8a3e,U+8ba6,U+8c00,U+8c21,U+8c49,U+8c7a,U+8d30,U+8df9,U+8e51,U+8e59,U+8f6b,U+8f73,U+8ff3,U+9016,U+9026,U+902f,U+9099,U+909b,U+90c7,U+914a,U+91ae,U+91ba,U+9495,U+94a3,U+94af,U+94ba,U+94bf,U+94cc,U+94e1,U+94f0,U+9531,U+955d,U+95f3,U+9697,U+96bc,U+975b,U+977c,U+98a2,U+998a,U+9994-9995,U+9a9b,U+9ab7,U+9ac5,U+9c91,U+9ccf,U+9cd5,U+9e29,U+9edc,U+9edf,U+9f83,U+9f88-9f89" } }, { uri: pf, descriptors: { unicodeRange: "U+4ee8,U+4f22,U+4f43,U+4f57,U+4f5d,U+4f6f,U+4ff8,U+502d,U+507b,U+5345,U+53df,U+53fb,U+544b,U+5482,U+54a7,U+54cc,U+550f,U+5544,U+5555,U+5594,U+55e8,U+55ec,U+55ef,U+564e,U+56f9,U+5704,U+576d,U+5785,U+57ad,U+5914,U+5958,U+599e,U+59aa,U+59be,U+5a06,U+5abe,U+5ae1,U+5b40,U+5bee,U+5cbf,U+5cc4,U+5ccb,U+5d47,U+603f,U+6078,U+607d,U+607f,U+608c,U+609a,U+60fa,U+61ff,U+621b,U+622e,U+626a,U+6371,U+63ae,U+63cd,U+63d6,U+6410,U+6414,U+6421,U+6448,U+64d8,U+6710,U+6748,U+6772,U+680e,U+6954,U+69ab,U+6c68,U+6c8f,U+6ca4,U+6d2e,U+6e4e,U+6e98,U+6fe0,U+7094,U+70e9,U+7116,U+7119,U+723f,U+73c9,U+74e4,U+753e,U+7548,U+75bd,U+75cd,U+7618,U+7634,U+76c5,U+76f1,U+7708,U+7719,U+777e,U+7791,U+77b3,U+7823,U+7827,U+7830,U+7889,U+7893,U+7949,U+795c,U+79e3,U+7a14,U+7a88,U+7a95,U+7aa0,U+7afd,U+7b90,U+7bd1,U+7bfe,U+7da6,U+7ec2,U+7eef,U+7f03-7f04,U+7f08,U+7f58,U+7f61,U+7f9f,U+8174,U+8200,U+828d,U+82c4,U+82d5,U+82dc,U+82f7,U+832d,U+835a,U+840b,U+8438,U+852b,U+869d,U+86ac,U+86d0,U+86f0,U+8782,U+87a8,U+87d1-87d2,U+87e0,U+8839,U+8913,U+891b,U+8934,U+8941,U+89ca,U+89ce,U+8a07,U+8ba3,U+8bc5,U+8bcb,U+8bdb,U+8c11,U+8c15,U+8c29,U+8c32,U+8dc4,U+8dce,U+8ddb,U+8dfa,U+8e09,U+8e1d,U+8e39,U+8e42,U+8e49,U+8e4b,U+8e8f,U+8f71-8f72,U+9004,U+9036,U+9097,U+90dc,U+90e2,U+90e6,U+90ef,U+9104,U+919a,U+91b4,U+938f,U+9497,U+950f,U+9557,U+9562-9563,U+9573,U+9606,U+9649,U+972d,U+973e,U+97a3,U+97eb,U+988c,U+9894,U+98a6,U+9974,U+9977,U+997d,U+9a90,U+9a9d,U+9aef,U+9ca2,U+9ccd,U+9cdf,U+9e20,U+9e4c,U+9e6b,U+9f3e" } }, { uri: uf, descriptors: { unicodeRange: "U+4ede,U+4ee1,U+4eeb,U+4fda,U+4ffe,U+5025,U+506c,U+50f3,U+5106,U+520d,U+525c,U+52ad,U+530d,U+5310,U+539d,U+53a9,U+53fc,U+5421,U+5477,U+54e7,U+551b,U+5530,U+557e,U+5599,U+55c4,U+55d1,U+55d4,U+55df,U+55e4,U+55ea,U+5623,U+562d,U+5654,U+56eb,U+56f5,U+57a7,U+57d5,U+57dd,U+584d,U+5880,U+58ec,U+59dd,U+5a32,U+5a55,U+5a75,U+5b51,U+5b71,U+5b73,U+5cd2,U+5ce4,U+5e5b,U+5e96,U+5fd2,U+607b,U+61d1,U+634b,U+636d,U+63b3,U+63ff,U+64c0,U+661d,U+6657,U+66dc,U+67a5,U+6841,U+6867,U+6901,U+699b,U+6a47,U+6b46,U+6c21,U+6c24,U+6c35,U+6c4a,U+6c94,U+6ca3,U+6d39,U+6d63,U+6d6f,U+6d94,U+705e,U+71e7,U+726f,U+72cd,U+72de,U+72f0,U+7325,U+7350,U+7391,U+741a,U+757f,U+7583,U+75b1,U+75b4,U+75b8,U+75c2,U+75f1,U+766f,U+7699,U+7751,U+789c,U+7a17,U+7be6,U+7cb2,U+7ea3,U+7eb0,U+7ebe,U+7eeb,U+7f25,U+7f2c,U+7fb8,U+8026,U+8037,U+8153,U+8171,U+8191,U+8214,U+821b,U+8222,U+826e,U+82eb,U+830c,U+8314,U+8334,U+83d6,U+8418,U+843c,U+84ff,U+8564,U+8572,U+8616,U+866c,U+8693,U+86a3,U+86a7,U+86af,U+86b6,U+86c6,U+86ca,U+8708,U+870d,U+8759,U+8760,U+87af,U+87c6,U+8869,U+88c6,U+89d0,U+8b07,U+8baa-8bab,U+8bc2,U+8be4,U+8bf0,U+8c2a,U+8c62,U+8c89,U+8d49,U+8d6d,U+8d84,U+8d94,U+8db8,U+8dc6,U+8e2e,U+8e3d,U+8e47,U+8e7f,U+9005,U+9051,U+907d,U+9082,U+9088,U+90b0,U+90d3,U+9150,U+949c,U+94a4,U+94b9,U+94cb,U+94e0,U+9509,U+9512,U+951f,U+9534,U+9552-9553,U+965f,U+96b0,U+9791,U+9889,U+9990,U+9a9c,U+9aa7,U+9c88,U+9cb2-9cb3,U+9cb6-9cb7,U+9cc5,U+9cdc,U+9e22,U+9e2a,U+9e57,U+9e67,U+9e73,U+9e82,U+9eb8,U+9ee0,U+9f9b" } }, { uri: mf, descriptors: { unicodeRange: "U+4eb5,U+4f09,U+4f5a,U+4f8f,U+4fce,U+4fdf,U+4fea,U+4ff3,U+500c,U+500f,U+504e,U+5088,U+52be,U+5420,U+5457,U+5499,U+549b,U+54c6,U+54d2,U+558b,U+559f,U+55bd,U+55d6,U+565c,U+567c,U+568e,U+5768,U+577b,U+57a9,U+57ed,U+59f9,U+5a11,U+5a40,U+5ae6,U+5b6a,U+5b93,U+5bb8,U+5c15,U+5c99,U+5c9c,U+5cc1,U+5d2e,U+5d4b,U+5d99,U+5e54,U+5e61,U+5fcf-5fd1,U+6002,U+6006,U+6014,U+60af,U+60c6,U+60da,U+60f4,U+621f,U+62c8,U+631b,U+631e,U+63e9,U+64b5,U+655d,U+6619,U+6635,U+6641,U+67ad,U+67b0,U+67b7,U+67e9,U+684e,U+688f,U+695d,U+696b,U+69b7,U+6a58,U+6c26,U+6d35,U+6d43,U+6d9e,U+6dd9,U+6dec,U+6e11,U+6e6e,U+6e9f,U+6ec2,U+6ee2,U+6ef9,U+6f09,U+6f66,U+6f8d,U+6fc2,U+6fc9,U+729f,U+72c8,U+73de,U+7430,U+7566,U+7579,U+75c9,U+75e2,U+75fc,U+762a,U+7638,U+7678,U+76c2,U+76f9,U+778c,U+77cd,U+77dc,U+7800,U+781d,U+782d,U+783b-783c,U+78a3,U+78ec,U+7980,U+7a23,U+7b95,U+7bdd,U+7c0c,U+7c41,U+7c91,U+7cb3,U+7cc5,U+7ecc,U+7f19,U+7fca,U+8006,U+8069,U+807f,U+80bd,U+80ed,U+814b,U+8198,U+82cb,U+82d2,U+834f,U+8360,U+847a,U+84d6,U+84e5,U+8537,U+85d0,U+8671,U+86a4,U+86ce,U+86f9,U+8703,U+8707,U+8737,U+873b,U+8815,U+8936,U+8bc3,U+8bcf,U+8bd2,U+8bd8,U+8be9,U+8c0c,U+8c0f,U+8c4c,U+8d45,U+8d5d,U+8d73,U+8e31,U+8e6d,U+8e76,U+8fe4,U+9041,U+90d7,U+9169,U+92ae,U+94a1,U+94c4,U+94c9,U+94db,U+94e7,U+9503,U+9506,U+9517,U+9528,U+9537,U+9542,U+9549,U+95fe,U+9616,U+961a,U+96c9,U+96f3,U+9701,U+970e,U+9739,U+9753,U+9798,U+98d2-98d3,U+98d9-98da,U+9968,U+996f,U+9984,U+9997,U+9acb,U+9b03,U+9c85,U+9ca8,U+9cab,U+9e49,U+9e51,U+9e66,U+9f10" } }, { uri: bf, descriptors: { unicodeRange: "U+4e15,U+4e1e,U+4e2b,U+4eb3,U+4ec9,U+4f0e,U+4f64,U+501c,U+50a9,U+510b,U+51a2,U+51bc,U+527d,U+52d0,U+53fd,U+5429,U+542e,U+5486,U+54af,U+5506,U+5511,U+5522,U+552c,U+556c,U+55b3,U+55d2,U+55e6,U+55fd,U+561f,U+5639,U+5659,U+5662,U+5693,U+572a,U+5892,U+598a,U+5992,U+59a9,U+5a20,U+5ae3,U+5b17,U+5b7d,U+5d34,U+5d3d,U+5d4a,U+5d82,U+5e1a-5e1b,U+5ea5,U+5f0b,U+5f77,U+5fd6,U+5fff,U+6026,U+6035,U+6063,U+60b4,U+60bb,U+60ee,U+612b,U+6194,U+61ca,U+61e6,U+61f5,U+620a,U+6248,U+62a1,U+62d7,U+6376,U+637b,U+652b,U+65bc,U+65cc,U+65ce,U+65d6,U+664c,U+665f,U+6666,U+6684,U+66b9,U+6773,U+6777,U+6787,U+67de,U+6845,U+693d,U+6994,U+6a35,U+6d54,U+6d5c,U+6d8e,U+6dd6,U+6eb4,U+6f2a,U+6f78,U+704f,U+70ec,U+7118,U+714a,U+7172,U+71b9,U+724d,U+728a,U+7337,U+733e,U+7396,U+73b7,U+73cf,U+7428,U+742c,U+742e,U+74ee,U+74f4,U+7525,U+753a,U+7572,U+75d4,U+765c,U+768e,U+7762,U+777d,U+77fd,U+7825,U+7837,U+78b4,U+795f,U+79ed,U+7a1e,U+7b06,U+7b20,U+7ba9,U+7bab,U+7c7c,U+7cbd,U+7cdc,U+7ec9,U+7ef6,U+7f30,U+7f42,U+7f44,U+7f54,U+7f94,U+8004,U+800b,U+8019,U+809b,U+80ae,U+80c4,U+80f1,U+8146,U+816e,U+817c,U+81c0,U+81fc,U+81fe,U+822b,U+830f,U+832f,U+8340,U+8365,U+8385,U+8392,U+83a0,U+8424,U+84af,U+869c,U+8713,U+8717-8718,U+87c0,U+87cb,U+87fe,U+8821,U+8902,U+89d1,U+8bb9,U+8c12,U+8d32,U+8d53,U+8df7,U+8e7c,U+8f7c,U+8f95,U+8fab,U+9052,U+905b,U+9095,U+909d,U+90c5,U+911e,U+9122,U+916a,U+919b,U+948e,U+9492,U+949a,U+94b5,U+94bc,U+94c6,U+94f1,U+9502,U+9511,U+9536,U+956f-9570,U+9602,U+9621,U+9631,U+998b,U+99a5,U+9a81,U+9a9e,U+9ebe,U+9f8b" } }, { uri: Ef, descriptors: { unicodeRange: "U+4f2b,U+4f3d,U+4fac,U+5043,U+5055,U+5140,U+5156,U+51cb,U+5243,U+531d,U+536f,U+53a5,U+53ae,U+53f1,U+541d,U+5431,U+547b,U+5492,U+5494,U+54a4,U+54aa,U+54ce,U+54fd,U+5509,U+5520,U+553e,U+557b,U+55c5,U+55e1,U+55f7,U+5608,U+5636,U+563b,U+5773,U+57a0,U+5811,U+587e,U+58d5,U+59e3,U+5a29,U+5a6a,U+5a76,U+5a7a,U+5ac9,U+5b62,U+5b95,U+5c49,U+5c8c,U+5cab,U+5cb7,U+5d02,U+5d58,U+5e44,U+5e7a,U+5eff,U+5f29,U+5f89,U+5f9c,U+5fa8,U+6005,U+6043,U+60b8,U+60d8,U+60ec,U+60f0,U+6115,U+618e,U+630e,U+637a,U+6390,U+63ac,U+63b0,U+64de,U+6525,U+6538,U+65ee-65ef,U+6631,U+6636,U+6654,U+677c,U+67b8,U+67d8,U+683e,U+6886,U+68b5,U+692d,U+6963,U+6979,U+6988,U+6b59,U+6b9a,U+6c69,U+6c74,U+6cae,U+6ce0,U+6cef,U+6d95,U+6dc5,U+6dde,U+6de6,U+6dfc,U+6ea7,U+6f15,U+6f29,U+7096,U+70c3,U+7131,U+715c,U+7166,U+7266,U+7317,U+731d,U+7329,U+73e9,U+7425,U+7455,U+7490,U+74ef,U+7519,U+75b5,U+75b9,U+75de,U+7656,U+7663,U+7691,U+7729,U+77fe,U+783e,U+787c,U+795a,U+7a79,U+7abf,U+7b3a,U+7b4f,U+7b60,U+7b75,U+7b8d,U+7bb4,U+7bd3,U+7be1,U+7cbc,U+7edb,U+7f1c,U+7f8c,U+7fb2,U+7fb9,U+7fce,U+7ff1,U+810d,U+81c6,U+82a5,U+82aa,U+82de,U+8317,U+8343,U+835e,U+8364,U+836a,U+853a,U+8543,U+854a,U+8559,U+8568,U+85b0,U+85b9,U+864f,U+86e4,U+8715,U+8845,U+8884,U+88e8,U+88f1,U+8983,U+8be1,U+8c1f,U+8c27,U+8c5a,U+8c82,U+8d58,U+8dbe,U+8f98,U+9035,U+9074,U+90a1,U+9149,U+9157,U+93d6,U+949d,U+94c2,U+94e3-94e4,U+95eb,U+95f0,U+9611,U+9619,U+9642,U+968d,U+9706,U+970f,U+97ed,U+988a,U+9893,U+98e8,U+9a77,U+9a87,U+9aa1,U+9abc,U+9cdd,U+9e2f,U+9e33,U+9e44,U+9e5c,U+9e9d,U+9edd" } }, { uri: gf, descriptors: { unicodeRange: "U+4f58,U+4f6c,U+4f70,U+4fd0,U+5014,U+51bd,U+524c,U+5315,U+5323,U+535e,U+540f,U+542d,U+545b,U+548e,U+549a,U+54ab,U+54fc,U+5567,U+556a,U+5600,U+5618,U+563f,U+5669,U+56f1,U+56ff,U+573b,U+574d,U+579b,U+57b8,U+57c2,U+586c,U+58f9,U+595a,U+598d,U+5993,U+5996,U+59d7,U+5b7a,U+5ba6,U+5c4e,U+5c96,U+5ce5,U+5eb6,U+5f08,U+5f99,U+602f,U+6059,U+606c,U+607a,U+60ed,U+61a9,U+620c,U+6249,U+62a8,U+62c4,U+62ed,U+62fd,U+6342,U+6345,U+6396,U+63a3,U+6402,U+6413,U+642a,U+6487,U+64a9,U+64ac,U+64ae,U+64b7,U+659f,U+65a1,U+667e,U+66f3,U+67e0,U+69db,U+69df,U+6aac,U+6b86,U+6c50,U+6c5e,U+6c76,U+6c85,U+6c8c,U+6cde,U+6d19,U+6d52,U+6da7,U+6db8,U+6e1a,U+6e25,U+6e4d,U+6e5f,U+6ec1,U+6f31,U+6f7a,U+6fa7,U+6fe1,U+701b,U+70ab,U+70f7,U+717d,U+71a8,U+7252,U+72c4,U+72e1,U+7315,U+736d,U+73ae,U+73c0,U+73c2,U+740f,U+75a4,U+7600-7601,U+768b,U+76bf,U+76d4,U+7728,U+772f,U+776c,U+77a0,U+77b0,U+77f8,U+783a,U+78d0,U+78fa,U+7977,U+7a37,U+7a92,U+7afa,U+7b71,U+7b94,U+7cef,U+7f28,U+7fe1,U+808b,U+80e5,U+80eb,U+8110,U+8113,U+812f,U+814c,U+81c3,U+8235,U+82d4,U+8309,U+83c1,U+8431,U+8469,U+84bf,U+84d3,U+84df,U+84e6,U+8511,U+8638,U+86c0,U+86db,U+86fe,U+8757,U+8822,U+8882,U+8885,U+8892,U+88f3,U+892a,U+8ba5,U+8bd9,U+8be0,U+8be7,U+8bfd,U+8c1a,U+8d4a,U+8d4e,U+8d66,U+8dda,U+8e0c,U+8e52,U+8e74,U+8e87,U+8f76,U+8fc2,U+8fe6,U+900d,U+9068,U+90ac,U+90b3,U+90b8,U+90e7,U+9119,U+9131,U+915a,U+916e,U+94b4,U+94d0,U+94e2,U+94ec,U+94ff,U+9522,U+9535,U+9556,U+965b,U+96f9,U+9774,U+9981,U+998d,U+998f,U+9a6e,U+9a7f,U+9a8a,U+9b13,U+9c9f,U+9e3e,U+9e43,U+9e6d,U+9e8b,U+9e92,U+9edb,U+9eef" } }, { uri: xf, descriptors: { unicodeRange: "U+4e10,U+4e56,U+4e98,U+4ec3,U+4f3a,U+4f5f,U+4f88,U+4f97,U+4fa5,U+4fe8,U+504c,U+5197,U+52fa,U+5364,U+53e8,U+5406,U+543c,U+545c,U+5471,U+5480,U+5495,U+54b3,U+54df,U+54e6,U+54ee,U+557c,U+5583,U+55dc,U+55e3,U+566c,U+592f,U+5944,U+5983,U+59ca,U+59e5,U+5a13,U+5a7f,U+5b09,U+5bd0,U+5e4c,U+5eb5,U+5f1b,U+5f3c,U+608d,U+60cb,U+61a7,U+61ac,U+61cb,U+6233,U+62a0,U+62e7,U+62ee,U+62f4,U+62f7,U+634e,U+6382,U+63c9,U+63ea,U+6400,U+645e,U+6482,U+6556,U+6593,U+6615,U+664f,U+66e6,U+672d,U+675e,U+67da,U+6805,U+6808,U+6868,U+68a2,U+695e,U+69ad,U+6a80,U+6a90,U+6b83,U+6be1,U+6c30,U+6cad,U+6cb1,U+6cf1,U+6d31,U+6d93,U+6dae,U+6dbf,U+6dc6-6dc7,U+6e0d,U+6e32,U+6e3a,U+6e85,U+6eba,U+6f3e,U+6f5e,U+6f7c,U+6fee,U+71ee,U+722a,U+72b7,U+72e9,U+73ba,U+73d1,U+7409,U+7435-7436,U+7459-745a,U+747e,U+7487,U+74e2,U+7504,U+752c-752d,U+7599,U+759f,U+75a1,U+75ca,U+75f0,U+761f,U+7629,U+777f,U+7785,U+77a5,U+77bf,U+78d5,U+7934,U+7940,U+79a7,U+7b19,U+7c38,U+7c95,U+7cb1,U+7ce0,U+7eca,U+7ef7,U+7f2b,U+7f81,U+7fcc,U+8046,U+8148,U+8165,U+819b,U+81ba,U+828b,U+82ae,U+82b7,U+82d3,U+8301,U+830e,U+831c,U+8338,U+837c,U+8393,U+8398,U+83ba,U+83e0,U+83e9,U+853c,U+8654,U+86df,U+8712,U+873f,U+874e,U+8783,U+8859,U+88a4,U+8925,U+8bb7,U+8bff,U+8c19,U+8c1b,U+8c24,U+8c2c,U+8d61,U+8db4,U+8e6c,U+8f8a,U+8fe5,U+8ff8,U+901e,U+90f4,U+912f,U+9163,U+9170,U+91dc,U+949b,U+94a8,U+94b3,U+94c0,U+94e8,U+9525,U+9530,U+9539,U+954c-954d,U+9550,U+955b,U+962a,U+9685,U+96cc,U+9776,U+988d,U+9975,U+9985,U+9a6f,U+9aa5,U+9ab8,U+9c7f,U+9ca4,U+9cb8,U+9e25,U+9e35,U+9e4a" } }, { uri: hf, descriptors: { unicodeRange: "U+4ea2,U+4ea5,U+4f36,U+4f84,U+4f8d,U+501a,U+5029,U+516e,U+51a5,U+51c4,U+51f8,U+5201,U+527f,U+5321,U+5352,U+5366,U+53e9,U+54c7,U+5632,U+5676,U+56b7,U+56bc,U+56da,U+56e4,U+5703,U+5729,U+5742,U+57a2-57a3,U+5815,U+58d1,U+5919,U+592d,U+5955,U+5a05,U+5a25,U+5a34,U+5b70,U+5b75,U+5bdd,U+5bf0,U+5c41,U+5c79,U+5c91,U+5c94,U+5ce6,U+5ced,U+5d69,U+5dc5,U+5e16,U+5e27,U+5f27,U+5f95,U+5ffb,U+6020,U+604d,U+6055,U+60e6,U+60eb,U+6123,U+618b,U+61a8,U+620d,U+62c7,U+62ce,U+62d9,U+631f,U+634d,U+6452,U+6479,U+64ce,U+64d2,U+655b,U+660a,U+6726,U+67c4,U+6809,U+6853,U+68e3,U+68f1,U+68fa,U+693f,U+6942,U+6995,U+69a8,U+69b4,U+6a71,U+6b89,U+6bcb,U+6bd3,U+6bd9,U+6c40,U+6cf8,U+6cfe,U+6d85,U+6da3,U+6daa,U+6e0e,U+6e43-6e44,U+6f88,U+7078,U+7099,U+70bd,U+70d9,U+70fd,U+7109,U+7184,U+7239,U+733f,U+73f2,U+748b,U+749c,U+749e,U+759a,U+75d2,U+75eb,U+7620,U+766b,U+7693,U+76cf,U+7738,U+773a,U+776b,U+778e,U+77aa,U+7852,U+78be,U+7948,U+795b,U+7960,U+796f,U+79ba,U+7a20,U+7a96,U+7aa5,U+7b03,U+7b28,U+7b50,U+7b77,U+7bc6,U+7bf1,U+7c27,U+7d0a,U+7ead,U+7ec5,U+7ee2,U+7ef0,U+7efd,U+7f0e,U+7f2e,U+7f79,U+7f9a,U+8098,U+80da,U+80e7,U+80f0,U+80f3,U+80fa,U+818a,U+81e7,U+8237-8238,U+8299,U+82b8,U+82ce,U+837b,U+83bd,U+83cf,U+8426,U+8475,U+85c9,U+85d5,U+85dc,U+85e9,U+871a,U+8747,U+8749,U+888d,U+8910,U+891a,U+8bb4,U+8be3,U+8bec,U+8bf2,U+8c06,U+8c0d,U+8d31,U+8d48,U+8de4,U+8e1e,U+8e4a,U+8e66,U+8f84,U+8f97,U+9083,U+90e1,U+9165,U+91c9,U+94b0,U+94f5,U+9504,U+9532,U+956d,U+95f5,U+95fa,U+9668,U+9698,U+96bd,U+9704,U+9773,U+9890,U+996a,U+997a,U+9a74,U+9a8b,U+9cc4,U+9ccc" } }, { uri: yf, descriptors: { unicodeRange: "U+4ea8,U+4f1e,U+4f51,U+4f63,U+4f7c,U+4f83,U+4fa0,U+4fd1,U+4ffa,U+5018,U+5026,U+508d,U+50bb,U+50f5,U+50fb,U+5162,U+5319,U+5320,U+538c,U+5413,U+541f,U+5475,U+54bd,U+54d1,U+5589,U+5598,U+575f,U+57ae,U+57e0,U+5937,U+5974,U+5978,U+59ae,U+5a1f,U+5a49,U+5ab3,U+5b99,U+5b9b,U+5ba0,U+5be1,U+5be5,U+5c09,U+5c27,U+5de2,U+5e9a,U+5f26,U+5f8a,U+5f98,U+6021,U+606d,U+60bc,U+60d5,U+60e7,U+611a,U+614c,U+6254,U+626f,U+6292,U+6296,U+62b9,U+62e2,U+631a,U+631d,U+6320,U+6346,U+63ba,U+6467,U+64bc,U+658b,U+663c,U+6643,U+6652,U+6656,U+6687,U+66d9,U+66dd,U+66f0,U+673d,U+67ab,U+6816-6817,U+68a7,U+68ad,U+68cd,U+68e0,U+6986,U+69fd,U+6b47,U+6bd7,U+6c1f,U+6c2e-6c2f,U+6cbe,U+6de4,U+6e1d,U+6e83,U+6e9c,U+6ed4-6ed5,U+6f4d,U+70f9,U+7130,U+716e,U+718f,U+71ac,U+71e5,U+72fc,U+731c,U+7334,U+73ca,U+7422,U+7426,U+745f,U+7470,U+75af,U+75f4,U+762b,U+763e,U+7696,U+7737,U+7741,U+77a7,U+77bb,U+77ee,U+785d,U+788c,U+78ca,U+7901,U+796d,U+7985,U+79fd,U+7a3c,U+7a57,U+7a74,U+7b5b,U+7caa,U+7cb9,U+7cd5,U+7eac,U+7eb6,U+7ed1,U+7ee5,U+7f20,U+7f2a,U+7f38,U+7f69,U+7fa1,U+8018,U+8038,U+803f,U+804b,U+80a2,U+80be,U+80d6,U+817a,U+81fb,U+820c,U+82ad,U+82af,U+82bd,U+8327,U+8354,U+835f,U+8367,U+836b,U+840c,U+841d,U+8471,U+849c,U+84b2,U+84c9,U+8517,U+851a,U+8549,U+8681,U+8721,U+8776,U+88d9,U+88f9,U+89c5,U+8c1c,U+8c34,U+8d81,U+8d9f,U+8e0a,U+8e72,U+8eb2,U+8fed,U+901b,U+902e,U+906e,U+9091,U+90aa,U+90af,U+915d,U+9171,U+946b,U+9489,U+9499,U+94a5,U+9508,U+9524,U+952d,U+9551,U+9576,U+95f7,U+9600,U+96b6,U+96c0,U+9756,U+97f6,U+98a0,U+98a4,U+997f,U+9a73,U+9a86,U+9ad3,U+9e3d,U+9ed4" } }, { uri: If, descriptors: { unicodeRange: "U+4e4d,U+4e5e,U+4ec7,U+4ed5,U+50da,U+50e7,U+515c,U+51a4,U+51ff,U+5203,U+5254,U+5300,U+533e,U+5375,U+53ee,U+5435,U+543b,U+5455,U+548b,U+548f,U+54d7,U+54fa,U+5578,U+5587,U+55a7,U+560e,U+5760,U+576f,U+5777,U+5830,U+58a9,U+5962,U+59e8,U+5a07,U+5a23,U+5a3c,U+5b5a,U+5bb5,U+5bc5,U+5bde,U+5c7f,U+5cb1,U+5ce8,U+5cea,U+5d29,U+5d4c,U+5e18,U+5f57,U+5f5d,U+5f87,U+5ff1,U+6016,U+601c,U+6064,U+6177,U+61d2,U+625b,U+62e3,U+62f1,U+634f,U+63a0,U+6401,U+6405,U+6495,U+64c2,U+6512,U+6577,U+6590,U+65a7,U+65a9,U+65f7,U+6627,U+6655,U+6714,U+6795,U+67d1,U+67ff,U+68b3,U+68d5,U+68d8,U+6930,U+6960,U+6977,U+69bb,U+69d0,U+6a31,U+6b7c,U+6bb4,U+6c22,U+6c72,U+6c79,U+6c7e,U+6c81,U+6c93,U+6ca5,U+6cbc,U+6ce3,U+6cfb,U+6d3c,U+6da9,U+6df3,U+6e2d,U+6eaf,U+6ec7,U+6f13,U+6f33,U+6f62,U+6fa1,U+7011,U+707c,U+708a,U+70c1,U+70d8,U+70eb,U+711a,U+7194,U+7281,U+7316,U+7357,U+7384,U+7405,U+742a,U+745b,U+7574,U+7578,U+75ea,U+7682,U+7792,U+77d7,U+77e9,U+77eb,U+77f6,U+780c,U+78c5,U+7941,U+79e4,U+7a1a,U+7a9c,U+7ad6,U+7b5d,U+7bf7,U+7c07,U+7c3f,U+7c9f,U+7ca5,U+7cdf,U+7e82,U+7eab,U+7ece,U+7eda,U+7f09,U+7f15,U+7f9e,U+7fdf,U+7fe9,U+803b,U+803d,U+80aa,U+80b4,U+813e,U+8155,U+817b,U+819d,U+821c,U+82b9,U+82df,U+82ef,U+8304,U+83b9,U+8446,U+853d,U+85af,U+85fb,U+8650,U+865e,U+86d9,U+86ee,U+8700,U+8862,U+889c,U+88d4,U+88f8,U+895f,U+8a79,U+8bb3,U+8bb6,U+8bc0,U+8beb,U+8bf5,U+8c23,U+8c79,U+8d1e,U+8dcb,U+8e29,U+8e44,U+8e81,U+8eac,U+8eaf,U+8f8d,U+9050,U+90f8,U+914b,U+948a,U+94be,U+94ee,U+950c,U+9540,U+962e,U+9647,U+9661,U+9699,U+96cf,U+9716,U+9761,U+97a0,U+97e7,U+9a7c,U+9a8f,U+9ae6,U+9cd6,U+9e26" } }, { uri: wf, descriptors: { unicodeRange: "U+4fa3,U+4fae,U+4fd8,U+4fef,U+50a3,U+5189,U+5195,U+51db,U+51f3,U+51f9,U+5220,U+5228,U+5288,U+52ff,U+532e,U+533f,U+5351,U+53db,U+53ed,U+5450,U+5484,U+5490,U+54c9,U+54e9,U+5501,U+5507,U+5543,U+55d3,U+56a3,U+575e,U+589f,U+5984,U+59ec,U+5a04,U+5a36,U+5a77,U+5a9a-5a9b,U+5ab2,U+5ac2,U+5ad6,U+5bc7,U+5c2c,U+5c34,U+5c51,U+5cd9,U+5d0e,U+5deb,U+5e3c,U+5e87,U+5ed3,U+5f13,U+5f64,U+5fe1,U+606a,U+6096,U+60df,U+60f6,U+60f9,U+6151,U+620e,U+6241,U+6252,U+6273,U+627c,U+6289,U+62c2,U+62cc,U+62ef,U+6361,U+6363,U+63b7,U+63e3,U+6518,U+66ae,U+6756,U+6789,U+6813,U+6829,U+6862,U+6866,U+6893,U+6897,U+690e,U+6984,U+69cc,U+6a1f,U+6a44,U+6a59,U+6ba1,U+6c13,U+6c90,U+6ca6,U+6cbd,U+6ccc,U+6cd3,U+6cd7,U+6d4a,U+6d4f,U+6d5a,U+6d9f,U+6da1,U+6dcc,U+6ea5,U+6ee4,U+6ee6,U+6f2f,U+6f8e,U+701a,U+7095,U+709c,U+70af,U+70db,U+70e8,U+714e,U+715e,U+71a0,U+71ce,U+7235,U+7280,U+72d0,U+72f8,U+73ab,U+7410,U+745c,U+7480,U+74a7-74a8,U+74e3,U+75ae,U+75f9,U+76b1,U+76ce,U+7736,U+77e2-77e3,U+781a,U+789f,U+797a,U+79be,U+79c3,U+79c6,U+79f8,U+7a8d,U+7a98,U+7aa6,U+7aff,U+7b1b,U+7cd9,U+7d6e,U+7ede,U+7eee,U+7f00,U+7f24,U+7f2d,U+7fd8,U+800d,U+8116,U+8151,U+81b3,U+8205,U+82c7,U+82db,U+832c,U+8335,U+8339,U+8386,U+846b,U+8587,U+8611,U+8682,U+868a,U+868c,U+8774,U+88d8,U+88f4,U+8912,U+8b6c,U+8bbd,U+8c0e,U+8c41,U+8d26,U+8d3b-8d3c,U+8d50,U+8dea,U+8e35,U+8f99,U+8fe2,U+8fe9,U+9017,U+914c,U+916f,U+9175-9176,U+918b,U+94a0,U+94ae,U+94ce,U+94f2,U+951a,U+952f,U+9541,U+9640,U+9672,U+968b,U+96cd,U+96ef,U+9713,U+97ec,U+9885,U+9992,U+9a6d,U+9a79,U+9a85,U+9cbb,U+9cd7,U+9cde,U+9e93,U+9f9f" } }, { uri: Rf, descriptors: { unicodeRange: "U+4e11,U+4ed7,U+4fcf,U+4fe9,U+4fed,U+50ac,U+50b2,U+5112,U+5180,U+5188,U+51f6,U+522e,U+5265,U+52cb,U+52df,U+5349,U+5367,U+5378,U+537f,U+5395,U+5398,U+53d4,U+543e,U+5440,U+5446,U+54b8,U+5565-5566,U+5580,U+55bb,U+56ca,U+572d,U+573e,U+574e,U+5782-5784,U+58f3,U+5938-5939,U+5948,U+594e,U+5a1c,U+5a74,U+5ae9,U+5b55,U+5b5c,U+5bb0,U+5bd3,U+5bf8,U+5c3f,U+5d14,U+5d2d,U+5df7,U+5dfe,U+5e05-5e06,U+5e1c,U+5e62,U+5e7b,U+5e7d,U+5ed6,U+5f2f,U+5f66,U+5f6c,U+5fa1,U+604b,U+609f,U+60a6,U+60e8,U+6101,U+6124,U+6127,U+6148,U+61be,U+6247,U+62d8,U+62da,U+633d,U+635e,U+6367,U+6380,U+638f,U+63a9,U+63fd,U+641c,U+64e6,U+655e,U+6572,U+6591,U+65a5,U+6691,U+6735,U+67a2-67a3,U+67ef,U+680b,U+6876,U+6905,U+6a0a,U+6a61,U+6b79,U+6bb7,U+6bbf,U+6c41,U+6c55,U+6c83,U+6c9b,U+6ca7,U+6cfc,U+6d46,U+6d51,U+6d74,U+6d9d,U+6daf,U+6dc0,U+6deb,U+6e17,U+6e24,U+6e89,U+6ea2,U+6ef4,U+6f6d,U+707f,U+70b3,U+70e4,U+70ef,U+710a,U+722c,U+725f,U+7261,U+72ee,U+72f1,U+730e,U+732b,U+7433,U+7538,U+75bc,U+7624,U+7709,U+7750,U+7779,U+7802,U+7898,U+78a7,U+78b1,U+78cb,U+78f7,U+7984,U+7a83,U+7aed,U+7b3c,U+7b4b,U+7c92,U+7c98,U+7ca4,U+7eb9,U+7ee3,U+7ef3,U+7ef5,U+7f05,U+7f55,U+7f62,U+7fc1,U+7fd4,U+7fe0,U+8042,U+806a,U+80a0,U+80a4,U+80c3,U+8102,U+8106,U+814a,U+8154,U+8247,U+8258,U+82cd,U+8328,U+832b,U+8389,U+83ca,U+845b,U+846c,U+84b8,U+8574,U+859b,U+8680,U+8695,U+86c7,U+8702,U+886c,U+8896,U+88b1,U+88e4,U+8bc8,U+8c10,U+8c26,U+8c28,U+8c2d,U+8d4c,U+8d63,U+8f67,U+8f74,U+8fc4,U+9006,U+9063,U+90a2,U+90b1,U+90c1,U+9177,U+9189,U+9493,U+949e,U+94fe,U+9610,U+961c,U+96a7,U+96fe,U+978d,U+97f5,U+9888,U+997c,U+9a84,U+9b3c,U+9b44-9b45,U+9b54,U+9e64,U+9f0e,U+9f9a" } }, { uri: Tf, descriptors: { unicodeRange: "U+4e19,U+4e38,U+4e53,U+4e7e,U+4e9f,U+4ec6,U+4f50,U+4fde,U+502a,U+5154,U+517d,U+51d1,U+51f0,U+5239,U+5256,U+52c9,U+52fe,U+5308,U+532a,U+535c,U+5384,U+53a2,U+53a8,U+53c9,U+53e0,U+5496,U+54ac,U+54c0,U+54c4,U+54e8,U+5561,U+5582,U+561b,U+5631,U+566a,U+5764,U+576a,U+5792,U+57ab,U+584c,U+5885,U+58f6,U+59a8,U+5acc,U+5bc2,U+5c38-5c39,U+5c60,U+5c6f,U+5c82,U+5c90,U+5d16,U+5dcd,U+5e37,U+5e90,U+5eb8,U+5f6a,U+5fcc,U+6012,U+6068,U+6073,U+607c,U+6094,U+6109,U+621a,U+626e,U+6284,U+62d0,U+62e6,U+62fe,U+6321,U+6328,U+632b,U+6349,U+6454,U+65ed,U+660f,U+6674,U+66a8,U+6749,U+674f,U+6760,U+67af,U+6850,U+6854,U+6869,U+68a8,U+68d2,U+68f5,U+6912,U+6b49,U+6b6a,U+6bef,U+6c28,U+6c5d,U+6c82,U+6cab,U+6cb8,U+6cc4,U+6cf5,U+6d47,U+6d78,U+6da4,U+6dc4,U+6dcb,U+6df9,U+6e0a,U+6e23,U+6e5b,U+6eb6,U+6f06,U+6f47,U+6f84,U+6f9c,U+6fd2,U+7076,U+70ac,U+7199,U+723d,U+72ac,U+72ed,U+7476,U+7529,U+752b,U+754f,U+7554,U+75d5,U+7626,U+76ef,U+7720,U+7766,U+7784,U+77ac,U+780d,U+7838,U+7845,U+786b,U+78b3,U+7978,U+79b9,U+79c9,U+79e7,U+7a3d,U+7a84,U+7a9f,U+7b0b,U+7b52,U+7c7d,U+7f1a,U+7fc5,U+7ff0,U+804a,U+8086-8087,U+808c,U+809a,U+80ba,U+810a,U+8180,U+818f,U+81c2,U+81ed,U+8231,U+8292,U+829c,U+82a6,U+82d1,U+8346,U+838e,U+839e,U+83c7,U+83f1,U+8403,U+840e,U+8513,U+857e,U+85e4,U+867e,U+871c,U+87ba,U+87f9,U+884d,U+8944,U+8a93,U+8c05,U+8d2c,U+8d2e,U+8d42-8d43,U+8dfb,U+8e22,U+8eba,U+8f69,U+8f9c,U+8fa3,U+8fa8,U+8fb1,U+900a,U+9038,U+903b,U+9042,U+904f,U+90b5,U+90dd,U+9102,U+9187,U+94a7,U+94c5,U+9523,U+95f8,U+95fd,U+960e,U+964b-964c,U+96c1,U+9709,U+971c,U+97ad,U+9882,U+9965,U+9976,U+9988,U+99a8,U+9a82,U+9a9a,U+9b41,U+9c8d,U+9e45,U+9e70,U+9e9f,U+9f3b,U+9f7f" } }, { uri: Mf, descriptors: { unicodeRange: "U+4e08,U+4e18,U+4e1b,U+4e22,U+4e27,U+4e32,U+4e52,U+4e73,U+4ead,U+4ed4,U+4ed9,U+4ef0,U+4fa6,U+5076,U+5179,U+51bb,U+51c9,U+51ef,U+51fd,U+524a,U+526a,U+529d,U+52ab,U+5306,U+5339,U+53d9,U+540a,U+5410,U+541e,U+5439,U+54b1,U+54ed,U+5564,U+558a,U+55b7,U+5634,U+574a,U+5751,U+57a6,U+57cb,U+57d4,U+5824,U+582a,U+5835,U+5858,U+5893,U+58e4,U+5951,U+5986,U+59da,U+59fb,U+59ff,U+5a03,U+5a46,U+5ac1,U+5b5d,U+5bfa,U+5c18,U+5c3a,U+5c48,U+5c4f,U+5c61,U+5cb3,U+5d1b,U+5e15,U+5e3d,U+5e99,U+5e9e,U+5eca,U+5f0a,U+5f17-5f18,U+5f25,U+5f7c,U+5fcd,U+6028,U+60a0,U+60ac,U+60d1,U+614e,U+6155,U+6168,U+61c8,U+6208,U+6212,U+6251,U+629a-629b,U+62ab-62ac,U+62fc,U+6323,U+632a,U+63d2,U+643a,U+6491-6492,U+649e,U+64b0,U+64c5,U+659c,U+6614,U+662d,U+6664,U+6670,U+6676,U+6746,U+67cf,U+67d4,U+682a,U+6843,U+6846,U+68da,U+6b3a,U+6b67,U+6c27,U+6c5b,U+6c64,U+6c70,U+6caa,U+6cca,U+6ce1,U+6d12,U+6d45,U+6dd1,U+6dd8,U+6e34,U+6e7f,U+6ee5,U+6f02,U+7092,U+70c2,U+70e6,U+7115,U+7237,U+7272,U+727a,U+72c2,U+739b,U+73b2,U+743c,U+751c,U+758f,U+75b2,U+7686,U+76c6,U+76d2,U+76fc,U+775b,U+77a9,U+7816,U+788e,U+7897,U+78b0,U+79bd,U+7a0d,U+7a91,U+7a9d,U+7ae3,U+7bad,U+7cca,U+7d2b,U+7eb1,U+7f06,U+7f14,U+7f1d,U+7f50,U+7ffc,U+8036,U+80bf,U+80c1,U+80ce,U+80f8,U+8109,U+810f,U+8170,U+8179,U+819c,U+821f,U+8230,U+8236,U+8273,U+829d,U+82f9,U+8305,U+8350,U+83b2,U+83cc,U+8404,U+840d,U+8427,U+8482,U+8679,U+8854,U+886b,U+8bbc,U+8be6,U+8c31,U+8c6b,U+8d4b,U+8dcc,U+8e2a,U+8e48,U+8f90,U+8fb0,U+9022,U+903c,U+903e,U+9065,U+916c,U+917f,U+94a9,U+94c3,U+94dd,U+94ed,U+9510,U+953b,U+96c7,U+970d,U+9738,U+9877,U+987d,U+989c,U+98d8,U+9a70,U+9a91,U+9aa4,U+9b42,U+9b4f,U+9e2d,U+9e3f,U+9e7f,U+9f20" } }, { uri: Lf, descriptors: { unicodeRange: "U+4e59,U+4ed3,U+4f0f,U+4f38,U+4f69,U+4fa7,U+4faf,U+4ff1,U+5077,U+5085,U+5144,U+5151,U+51af,U+51b6,U+51cc,U+523a,U+5251,U+5269,U+5272,U+52d8,U+5353,U+5389,U+53f9,U+5401,U+5415,U+541b,U+54f2,U+5524,U+554a,U+559d,U+5609,U+5740,U+575d,U+5806,U+5821,U+586b,U+5915,U+594f,U+5960,U+5999,U+59a5,U+59b9,U+59c6,U+59d1,U+59dc,U+5b5f,U+5b64,U+5b87,U+5bb4,U+5bbf,U+5c16,U+5c1d,U+5c3e,U+5c9a,U+5ca9,U+5cad,U+5cfb,U+5de1,U+5de7,U+5de9,U+5ef7,U+5f04,U+5f70,U+5f79,U+5fc6,U+602a,U+6050,U+6052,U+6070,U+6084,U+60b2,U+60dc,U+60e9,U+6167,U+6170,U+61c2,U+6270,U+6291,U+62b1,U+62bc,U+62dc,U+62df,U+62f3,U+6324,U+633a,U+6377,U+6398,U+63cf,U+640f,U+642c-642d,U+6458,U+6478,U+6500,U+654c,U+6566,U+658c,U+65c1,U+65cb,U+65e8,U+65ec,U+6696-6697,U+6734,U+679a,U+679d,U+67dc,U+67f3-67f4,U+680f,U+683d,U+684c,U+68af,U+699c,U+6bc1,U+6c0f,U+6c1b,U+6c57,U+6c6a,U+6d3d,U+6d6e,U+6d82,U+6db5,U+6dee,U+6e58,U+6eaa,U+6ecb,U+6ede,U+6ee9,U+6f0f,U+6f20,U+6f58,U+704c,U+7070,U+70b8,U+718a,U+7238,U+7262,U+7275,U+72b9,U+72d7,U+72e0,U+741b,U+7434,U+7483,U+74f6-74f7,U+75ab,U+764c,U+7761,U+7855,U+7891,U+78c1,U+79d2,U+7a00,U+7a3b,U+7c97,U+7ea4,U+7eb2,U+7ed2,U+7eea,U+7ef8,U+7f18,U+7fbd,U+8000,U+8010,U+8096,U+809d,U+80a9,U+817f,U+81e3,U+8206,U+8212,U+82ac,U+8302,U+8361,U+8377,U+83f2,U+8461,U+848b,U+84ec,U+8521,U+85aa,U+8870,U+8877,U+8881,U+888b,U+88ad,U+88c2,U+8986,U+8bd1,U+8bf1,U+8d24,U+8d2a,U+8d3e-8d3f,U+8d41,U+8d56,U+8d64,U+8d6b,U+8e0f,U+8f70,U+8f85,U+8f88,U+8fa9,U+9003,U+901d,U+90b9,U+90ce,U+94a6,U+94f8,U+9505,U+95ea,U+95ef,U+95f2,U+95f9,U+9601,U+9605,U+9634,U+966a,U+9677,U+9690,U+9694,U+96d5,U+971e,U+9896-9897,U+9972,U+9a71,U+9a76,U+9a7e,U+9e1f,U+9e23" } }, { uri: Df, descriptors: { unicodeRange: "U+4e01,U+4e43,U+4ea6,U+4ef2,U+4eff,U+4f26,U+4f2a,U+4f2f,U+4f5b,U+4fa8,U+4fca,U+4fd7,U+5021,U+504f,U+5141,U+51c0,U+51dd,U+51e4,U+51ed,U+5200,U+5237,U+5427,U+5448,U+54a8,U+5706,U+5708,U+5723,U+575b,U+57c3,U+5899,U+58a8,U+58c1,U+5976,U+5988,U+59bb,U+59d0,U+59d3,U+5a18,U+5a31,U+5a92,U+5b54,U+5b85,U+5baa-5bab,U+5bc4,U+5bd2,U+5be8,U+5bff,U+5c65,U+5d07,U+5e1d,U+5e78,U+5e7c,U+5f03,U+5f1f,U+5f39,U+5f6d,U+5f92,U+5faa,U+5fbd,U+5fe7,U+5ffd,U+60a8,U+60ef,U+6108,U+6162,U+622a,U+6234,U+626b,U+626d,U+62c6,U+62d2,U+62d4,U+62d6,U+62e8,U+6316,U+6355,U+63ed,U+6447,U+64a4,U+65f1,U+6606,U+6628,U+664b,U+6668,U+6682,U+66f9,U+66fc,U+66ff,U+6717,U+6740,U+676d,U+67aa,U+67ec,U+67f1,U+6842,U+6851,U+695a,U+6982,U+6a2a,U+6b20,U+6b23,U+6b32,U+6b96,U+6bc5,U+6beb,U+6c60,U+6c9f,U+6cea,U+6cf3,U+6d1e,U+6d53,U+6d66,U+6d69,U+6d8c,U+6d9b,U+6db2,U+6de1,U+6dfb,U+6e14,U+6ed1,U+6eda,U+6ee8,U+6f2b,U+706d,U+7089,U+708e,U+70ad-70ae,U+70e7,U+7126,U+714c,U+71c3,U+71d5,U+7206,U+7259,U+731b,U+73a9,U+73bb,U+74dc,U+7532,U+7545,U+755c,U+75c7,U+7687,U+76d7,U+76f2,U+788d,U+78e8,U+79e6,U+79e9,U+7a3f,U+7a46,U+7a97,U+7af9,U+7bee,U+7c4d,U+7c89,U+7cd6,U+7eb5,U+7ebd,U+7ed8,U+8017,U+8033,U+80c0,U+80de,U+80f6,U+8138,U+817e,U+81a8,U+820d,U+827e,U+82b3,U+82d7,U+83b1,U+84c4,U+84dd,U+8584,U+864e,U+865a,U+866b,U+86cb,U+88d5,U+89e6,U+8bca,U+8bde,U+8bfa,U+8c0a,U+8c37,U+8c46,U+8c6a,U+8c8c,U+8d1d,U+8d29,U+8d4f,U+8d54,U+8d5a,U+8d60,U+8d62,U+8f7f,U+8f96,U+8f9e-8f9f,U+8fc1,U+8fdf,U+8fea,U+8ff7,U+9012,U+906d,U+9075,U+90a6,U+90bb,U+90ca,U+9178,U+9192,U+91ca,U+94bb,U+94dc,U+94fa,U+9501,U+950b,U+9521,U+955c,U+963b,U+9655,U+9675-9676,U+9887,U+9891,U+9971,U+9a97,U+9ece,U+9ed8" } }, { uri: Sf, descriptors: { unicodeRange: "U+4e1d,U+4e39,U+4e4c,U+4e4f,U+4e54,U+4e58,U+4e95,U+4ea1,U+4eab,U+4eae,U+4ec1,U+4f10,U+4f19,U+4f30,U+4f34,U+4fb5,U+503e,U+518c,U+5192,U+51a0,U+51ac,U+51b0,U+51e1,U+5211,U+5242,U+52a3,U+52b2,U+52c3,U+52c7,U+52d2,U+52e4,U+5377,U+539a,U+53a6,U+53e5,U+5417,U+5510,U+552f,U+5531,U+574f-5750,U+5761,U+5851,U+5854,U+58ee,U+593a,U+5949,U+5954,U+5a5a,U+5b8b,U+5bbd,U+5c04,U+5c0a,U+5c4b,U+5ce1,U+5cf0,U+5e10,U+5e8a,U+5e9f,U+5ec9,U+5f31,U+5f84,U+5fd8-5fd9,U+5fe0,U+6015,U+6062,U+6069,U+6076,U+6089,U+60a3,U+60ca,U+620f,U+624e,U+6263,U+6298,U+62a2,U+62bd,U+6311,U+6350,U+6389,U+638c,U+63f4,U+6446,U+644a,U+6469,U+64cd,U+654f,U+6562,U+656c,U+65d7,U+65e6,U+65fa,U+660c,U+6653,U+66b4,U+670b,U+672b,U+676f-6770,U+6881,U+6885,U+68a6,U+68cb,U+68ee,U+6b8a,U+6c88-6c89,U+6cc9,U+6ce5,U+6d01,U+6d17,U+6d1b,U+6d59,U+6d6a,U+6da8,U+6df7,U+6e10,U+6e20-6e21,U+6f5c,U+706f,U+70bc,U+719f,U+7267,U+732a,U+73cd,U+7518,U+756a,U+7586,U+7591,U+75db,U+76c8,U+76d0,U+76d6,U+76d8,U+76df,U+76fe,U+77db,U+7801,U+786c,U+795d,U+7965,U+79cb,U+7a77,U+7a7f,U+7aef,U+7b11,U+7bb1,U+7bc7,U+7ea0,U+7eaf,U+7ed5,U+7edc,U+7f13,U+7f29,U+7f34,U+7f8a,U+7ffb,U+8015,U+8058,U+805a,U+8083,U+80af,U+80c6,U+80cc,U+811a,U+8150,U+82e5,U+8336,U+8352,U+83ab,U+8428,U+8463,U+852c,U+8861,U+89c8,U+8bcd,U+8bd7,U+8bda,U+8be2,U+8bef,U+8bf8,U+8c0b,U+8c13,U+8d34,U+8d3a,U+8d74,U+8d76,U+8da3,U+8dd1,U+8ddd,U+8ddf,U+8df3,U+8f68,U+8f6f,U+8f7d,U+8f91,U+8f9b,U+8fbd,U+8fc8,U+8fd4,U+8feb,U+8ff9,U+900f,U+9057,U+907f-9080,U+90d1,U+90ed,U+91ce,U+9519,U+9526,U+95ed,U+9614,U+9635,U+9644,U+9686,U+96c5,U+96ea,U+9707,U+9732,U+9759,U+978b,U+9876,U+9881,U+9910,U+996e,U+9970,U+9c81,U+9e21,U+9ebb,U+9f84" } }, { uri: vf, descriptors: { unicodeRange: "U+4e3d,U+4e4e,U+4e71,U+4e8f,U+4ed8,U+4eea,U+4f0a,U+4f0d,U+4f11,U+4f1f,U+4f24,U+4f3c,U+4f73,U+4fc4,U+500d,U+5012,U+501f,U+503a,U+505c,U+507f,U+50a8,U+514d,U+5178,U+517c,U+51b2,U+51b7,U+520a,U+5238,U+523b,U+52b1,U+535a,U+5371,U+5385,U+53eb-53ec,U+53f3,U+53f6,U+5409,U+542b,U+542f,U+5434,U+5462,U+5473,U+547c,U+54c8,U+54ea,U+56fa,U+5733,U+5757,U+5766,U+5802,U+585e,U+590f,U+591c,U+591f,U+5947,U+594b,U+5987,U+5a01,U+5b59,U+5b63,U+5b88,U+5b97,U+5b9c,U+5bbe,U+5bfb,U+5c01,U+5c1a,U+5c24,U+5c3c,U+5c97,U+5c9b,U+5cb8,U+5de6,U+5e01,U+5e2e,U+5e45,U+5e55,U+5e84,U+5ef6,U+5f02,U+5f52,U+5f69,U+5f7b,U+5f90,U+5fae,U+6000,U+600e,U+6025,U+60e0,U+6276,U+6297,U+62b5,U+62cd,U+62d3,U+62e5,U+62e9,U+62ff,U+6302,U+632f,U+63e1,U+6444,U+64ad,U+653b,U+6551,U+6563,U+65a4,U+65e7,U+6620,U+667a,U+66f2,U+671d,U+6731,U+6742,U+675f,U+6768,U+677e-677f,U+6790,U+67b6,U+67d3,U+6863,U+68b0,U+68c9,U+690d,U+6b8b,U+6bcd,U+6bd2,U+6bd5,U+6c38,U+6c61,U+6cbf,U+6cdb,U+6cf0,U+6d2a,U+6d89,U+6da6,U+6f6e,U+6fb3,U+7075,U+707e,U+70df,U+7164,U+7236,U+725b,U+7389,U+73e0,U+745e,U+74e6,U+751a,U+7537,U+75be,U+76ae,U+76db,U+793c,U+7956,U+7981,U+79d8,U+79df,U+79fb,U+7adf,U+7ae5,U+7b14,U+7b26,U+7b54,U+7b79,U+7d2f,U+7eb8,U+7eba,U+7ec6,U+7ee9,U+7eff,U+7f5a,U+7f6a,U+7f72,U+8089,U+80a5,U+80e1,U+8111,U+8131,U+821e,U+822c,U+8270,U+8499,U+8651,U+867d,U+8840,U+8857,U+8863,U+88c1,U+89c9,U+89d2,U+8a89,U+8bed,U+8bfe,U+8c01,U+8c22,U+8d21,U+8d25,U+8d2f,U+8d5e,U+8d75,U+8d8b,U+8dc3,U+8de8,U+8df5,U+8f6e,U+8f86,U+8f89,U+8fc5,U+8ff0,U+8ffd,U+9014,U+904d,U+90ae,U+9274,U+949f,U+952e,U+969c,U+96c4,U+96e8,U+96f6-96f7,U+97e9,U+987f,U+996d,U+9a7b,U+9aa8,U+9c7c,U+9c9c,U+9e4f,U+9f13,U+9f50" } }, { uri: $f, descriptors: { unicodeRange: "U+4e13,U+4e16,U+4e1c,U+4e24,U+4e3e,U+4e49,U+4e61,U+4e66,U+4e89,U+4e8c,U+4e94,U+4e9b,U+4ea4,U+4eac,U+4ebf,U+4eca,U+4ef6-4ef7,U+4efb,U+4f18,U+4f20,U+4f46,U+4f7f,U+4fe1,U+503c,U+505a,U+5146,U+5148,U+515a,U+5171,U+5177,U+519b,U+51b3,U+51c6,U+51e0,U+5212,U+521b,U+522b,U+529e,U+52bf,U+534e-534f,U+5355,U+5357,U+5382,U+539f,U+53bb,U+53bf,U+53c2,U+53c8,U+53ca,U+53d6-53d8,U+53e3,U+53ea,U+53f0,U+540d,U+5411,U+56db,U+56de,U+56e0,U+56e2,U+578b,U+57ce,U+57fa,U+589e,U+5904,U+5934,U+5982,U+5b89,U+5b8c,U+5bfc,U+5c06,U+5c11,U+5c40,U+5c71,U+5e38,U+5e72,U+5e76,U+5e7f,U+5e94,U+5e9c,U+5f0f,U+5f15,U+5f20,U+5f3a,U+5f62,U+5f88,U+5fc5,U+5fd7,U+5feb,U+601d,U+6027,U+60c5,U+60f3,U+610f,U+6216,U+6218,U+624b,U+624d,U+6279,U+628a,U+6295,U+6301,U+6307,U+636e,U+63a5,U+63a8,U+652f,U+6536,U+653e,U+6548,U+6559,U+6570,U+65bd,U+65e0,U+6602,U+660e,U+6613,U+66f4,U+6700,U+670d,U+671f,U+672f,U+6743,U+674e,U+6751,U+6761,U+6784,U+6797,U+679c,U+67e5,U+6807,U+6837,U+683c,U+6b21,U+6b63-6b65,U+6bcf,U+6bd4,U+6c42,U+6c5f,U+6ca1,U+6cbb,U+6d3b,U+6d41,U+6d88,U+6df1,U+70b9,U+7136,U+7269,U+7279,U+7531,U+754c,U+767e,U+76ca,U+76f8,U+770b,U+7740,U+7814,U+79ef,U+7a0b,U+7a0e,U+7a76,U+7b80,U+7cbe,U+7cfb,U+7e41,U+7ea7,U+7ec4,U+7ec7,U+7ed3,U+7ed9,U+7edf,U+7f8e,U+8001,U+804c,U+8054,U+80b2,U+81f3,U+8425,U+8868,U+88ab,U+897f,U+89c1-89c2,U+89c4,U+89c6,U+89e3,U+8ba1,U+8ba4,U+8bae,U+8bb0,U+8bba,U+8bc1,U+8c03,U+8d28,U+8d39,U+8def,U+8f66,U+8f6c,U+8fd0-8fd1,U+9020,U+9053,U+90a3,U+90fd,U+91cc,U+9500,U+9547,U+95e8,U+95f4,U+961f,U+9645,U+9662,U+96be,U+96c6,U+9700,U+9769,U+97e6,U+9875,U+9879,U+9886,U+9898,U+98ce,U+9996,U+2b5af,U+2cc56,U+2e9f5,U+30edd-30ede" } }, { uri: Pf, descriptors: { unicodeRange: "U+4e03,U+4e30,U+4e34,U+4e45,U+4e60,U+4e70,U+4e88,U+4e91-4e92,U+4ea9,U+4eb2,U+4ec0,U+4ecb,U+4ecd,U+4ee4,U+4fee,U+5019,U+5047,U+50cf,U+5145,U+516d,U+5170,U+5175,U+5199,U+51cf,U+51fb,U+521a,U+5224,U+5267,U+52aa,U+5347-5348,U+534a,U+5356,U+5361,U+536b,U+5370,U+538b,U+53e4,U+53e6,U+5403,U+5426,U+5428,U+542c,U+5438,U+5668,U+56ed,U+56f4,U+56fe,U+57df,U+592a,U+5957,U+5b69,U+5b81,U+5b8f,U+5b98,U+5b9d,U+5ba1,U+5ba4,U+5bb3,U+5bc6,U+5bdf,U+5c3d,U+5c5e,U+5c81,U+5ddd,U+5de8,U+5dee,U+5e0c,U+5e86,U+5e8f,U+5e93,U+5e95,U+5e97,U+5ea7,U+5ead,U+5eb7,U+5f55,U+5f81,U+5f85,U+5ff5,U+6001,U+613f,U+6258,U+6267,U+6269,U+626c,U+627e,U+62db,U+62ec,U+6325,U+635f,U+6362,U+6388,U+6392,U+63a2,U+63a7,U+63aa,U+641e,U+6545,U+6597,U+65e2,U+65e9,U+661f,U+665a,U+666e-666f,U+66fe,U+6728,U+67d0,U+6811,U+6838,U+6865,U+697c,U+6b22,U+6b27,U+6b4c,U+6b62,U+6b66,U+6b7b,U+6bdb,U+6c47,U+6c49,U+6c7d,U+6c99,U+6cfd,U+6d0b,U+6d25,U+6d32,U+6d3e,U+6d4b,U+6e29,U+6e56,U+6e7e,U+6f14,U+6fc0,U+706b,U+70c8,U+7247,U+72af,U+72b6,U+72ec,U+732e,U+73ed,U+7403,U+7533,U+753b,U+7559,U+7565,U+7597,U+767b,U+773c,U+7763,U+77ed,U+77ff,U+7968,U+798f,U+79bb,U+79c0-79c1,U+7ad9,U+7ae0,U+7b51,U+7b7e,U+7cae,U+7d22,U+7ea2,U+7eb3,U+7eb7,U+7ec3,U+7ec8,U+7ecd,U+7edd,U+7efc,U+7f16,U+7f3a,U+7f51,U+7f57,U+7f6e,U+80dc,U+822a,U+8239,U+826f,U+82cf,U+82e6,U+8349,U+8363,U+83dc,U+8457,U+85cf,U+878d,U+8865,U+8a00,U+8b66,U+8ba2,U+8ba8,U+8bad,U+8bb2,U+8bc9,U+8bd5,U+8bfb,U+8d2b,U+8d35,U+8d37,U+8f7b,U+8f93,U+8fce,U+8fdd,U+9000-9002,U+9010,U+9047,U+9093,U+9152,U+9488,U+94a2,U+9633,U+9636,U+963f,U+9646,U+9648,U+964d,U+9664,U+9669,U+9760,U+97f3,U+987a,U+987e,U+9884,U+98de,U+9986,U+9ed1" } }, { uri: Nf, descriptors: { unicodeRange: "U+4e14,U+4e25,U+4e48,U+4e50,U+4e5d,U+4e9a,U+4ec5,U+4efd,U+4f17,U+4f4e-4f4f,U+4f55,U+4f59,U+4f60,U+4f8b,U+4f9b,U+4f9d,U+4fbf,U+4fc3,U+5065,U+513f,U+5149,U+514b,U+516b,U+5174,U+517b,U+518d,U+51b5,U+5207,U+5217-5219,U+521d,U+526f,U+529f,U+52a9,U+52b3,U+5305,U+533b,U+5343,U+5360,U+5373-5374,U+5386,U+53cb-53cd,U+53f2,U+53f7,U+544a,U+5468,U+547d,U+54cd,U+552e,U+5584,U+56f0,U+571f,U+5747,U+575a,U+57f9,U+5883,U+58eb,U+58f0,U+5907,U+590d,U+592e,U+5931,U+5956,U+5965,U+5973,U+5979,U+59cb,U+5b57-5b58,U+5b83,U+5ba2-5ba3,U+5bb9,U+5bcc,U+5c42,U+5c45,U+5c4a,U+5dde,U+5df1,U+5df4,U+5e03,U+5e08,U+5e26,U+5e2d,U+5f71,U+5f80,U+5f8b,U+5fb7,U+606f,U+611f,U+6237,U+623f,U+6253,U+627f,U+6293,U+62a4,U+62c5,U+62c9,U+6309,U+6574,U+6599,U+65ad,U+65af,U+65c5,U+65cf,U+6625,U+663e,U+671b,U+672a,U+6750,U+6781,U+6821,U+6839,U+6848,U+68c0,U+6a21,U+6b3e,U+6bb5,U+6c14,U+6cb3,U+6cb9,U+6ce8,U+6e05,U+6e2f,U+6e38,U+6e90,U+6ee1,U+70ed,U+7167,U+7231,U+7248,U+724c,U+7387,U+738b,U+73af,U+7530,U+75c5,U+767d,U+76d1,U+76f4,U+771f,U+77e5,U+77f3,U+7834,U+7840,U+786e,U+793a,U+795e,U+79f0,U+7a33,U+7a7a,U+7a81,U+7ade,U+7b56,U+7b97,U+7c73,U+7c7b,U+7d20,U+7d27,U+7ea6,U+7eaa,U+7ebf,U+7ee7,U+7eed,U+7ef4,U+7fa4,U+8003,U+80a1,U+81f4,U+8272,U+827a,U+8282,U+82b1,U+82f1,U+8303,U+836f,U+83b7,U+843d,U+88c5,U+8ba9,U+8baf,U+8bb8,U+8bbf,U+8bc4,U+8bc6,U+8bdd,U+8be5,U+8bf7,U+8c08,U+8c61,U+8d1f,U+8d22-8d23,U+8d27,U+8d2d,U+8d38,U+8d5b,U+8d70,U+8d85,U+8d8a,U+8db3,U+8eab,U+8f83,U+8fb9,U+8fdc,U+8fde,U+9009,U+901f,U+914d,U+91c7,U+94b1,U+94c1,U+94f6,U+95fb,U+9632,U+9650,U+968f,U+9752,U+975e,U+987b,U+989d,U+98df,U+9999,U+9a6c,U+9a8c,U+9ec4,U+9feb-9fec" } }, { uri: Ff, descriptors: { unicodeRange: "U+98fb-990c,U+990e-990f,U+9911-992d,U+992f-9953,U+9956-9962,U+9964,U+9966,U+9973,U+9978-9979,U+997b,U+997e,U+9982-9983,U+9989,U+998c,U+998e,U+999a-99a4,U+99a6-99a7,U+99a9-99c8" } }, { uri: Bf, descriptors: { unicodeRange: "U+8e4c-8e50,U+8e53-8e58,U+8e5a-8e65,U+8e67-8e68,U+8e6a-8e6b,U+8e6e,U+8e71,U+8e73,U+8e75,U+8e77-8e7b,U+8e7d-8e7e,U+8e80,U+8e82-8e84,U+8e86,U+8e88-8e8e,U+8e91-8e93,U+8e95-8e9b,U+8e9d,U+8e9f-8eaa,U+8ead-8eae,U+8eb0-8eb1,U+8eb3-8eb9,U+8ebb-8ecd,U+8ecf-8f02" } }, { uri: _f, descriptors: { unicodeRange: "U+2e3a,U+3001-3002,U+3008-3011,U+3014-3017,U+301d-301f,U+4dae,U+4e00,U+4e07,U+4e09-4e0b,U+4e0d-4e0e,U+4e1a,U+4e2a,U+4e2d,U+4e3a-4e3b,U+4e4b,U+4e5f,U+4e86,U+4e8b,U+4e8e,U+4ea7,U+4eba,U+4ece,U+4ed1,U+4ed6,U+4ee3,U+4ee5,U+4eec,U+4f01,U+4f1a,U+4f4d,U+4f53,U+4f5c,U+4fdd,U+5143,U+5165,U+5168,U+516c,U+5173,U+5176,U+5185,U+519c,U+51fa,U+5206,U+5229,U+5230,U+5236,U+524d,U+529b,U+52a0-52a1,U+52a8,U+5316-5317,U+533a,U+5341,U+5362,U+53d1,U+53ef,U+53f8,U+5404,U+5408,U+540c,U+540e,U+5458,U+548c,U+54c1,U+54e5,U+5546,U+559c,U+56fd,U+5728,U+5730,U+573a,U+5916,U+591a,U+5927,U+5929,U+592b,U+597d,U+59d4,U+5b50,U+5b66,U+5b9a,U+5b9e,U+5bb6,U+5bf9,U+5c0f,U+5c14,U+5c31,U+5c55,U+5de5,U+5df2,U+5e02,U+5e73-5e74,U+5ea6,U+5efa,U+5f00,U+5f53,U+5f97,U+5fc3,U+603b,U+6210-6211,U+6240,U+6280,U+62a5,U+63d0,U+6539,U+653f,U+6587,U+65b0,U+65b9,U+65e5,U+65f6,U+662f,U+6708-6709,U+672c,U+673a,U+675c,U+6765,U+6c11,U+6c34,U+6cd5,U+6ce2,U+6d4e,U+6d77,U+73b0,U+7406,U+751f,U+7528,U+7535,U+7684,U+76ee,U+793e,U+79cd,U+79d1,U+7acb,U+7b2c,U+7b49,U+7ba1,U+7ecf,U+8005,U+800c,U+80fd,U+81ea,U+884c,U+8981,U+8bbe,U+8bf4,U+8d44,U+8d77,U+8fbe,U+8fc7,U+8fd8-8fd9,U+8fdb,U+901a,U+90e8,U+91cd,U+91cf,U+91d1,U+9485,U+957f,U+95ee,U+9762,U+9ad8,U+9ea6,U+9f99,U+9fcf,U+9fd4,U+9fed,U+fe10-fe19,U+fe30-fe31,U+fe33-fe44,U+ff01,U+ff0c,U+ff1f,U+2b4e7,U+2b7f7,U+2b7fc,U+2cb2d,U+2cb3b,U+2cb4a,U+2cb5b,U+2cb73" } }, { uri: Of, descriptors: { unicodeRange: "U+6490,U+6493-6494,U+6497-6498,U+649a-649d,U+649f-64a3,U+64a5-64a8,U+64aa-64ab,U+64af,U+64b1-64b4,U+64b6,U+64b9,U+64bb,U+64bd-64bf,U+64c1,U+64c3-64c4,U+64c6-64cc,U+64cf,U+64d1,U+64d3-64d6,U+64d9-64dd,U+64df-64e1,U+64e3,U+64e5,U+64e7-64ff,U+6501-6508,U+650a-6511,U+6513-6517,U+6519-6524,U+6526-652a,U+652c-652d,U+6530-6533,U+6537,U+653a,U+653c-653d,U+6540-6544,U+6546-6547,U+654a-654b,U+654d-654e,U+6550,U+6552-6554,U+6557-6558,U+655a,U+655c,U+655f-6561,U+6564-6565,U+6567-6568" } }, { uri: Af, descriptors: { unicodeRange: "U+9695-9696,U+969a-969b,U+969d-96a6,U+96a8-96af,U+96b1-96b2,U+96b4-96b5,U+96b7-96b8,U+96ba-96bb,U+96bf,U+96c2-96c3,U+96c8,U+96ca-96cb,U+96d0-96d1,U+96d3-96d4,U+96d6-96df,U+96e1-96e7,U+96eb-96ee,U+96f0-96f2,U+96f4-96f5,U+96f8,U+96fa-96fd,U+96ff,U+9702-9703,U+9705,U+970a-970c,U+9710-9712,U+9714-9715,U+9717-971b,U+971d,U+971f-9729,U+972b-972c,U+972e-972f,U+9731,U+9733-9737,U+973a-973d,U+973f-9751,U+9754-9755,U+9757-9758,U+975a,U+975c-975d,U+975f,U+9763-9764,U+9766-9768,U+976a-9770" } }, { uri: Kf, descriptors: { unicodeRange: "U+6af0-6b1f,U+6b25-6b26,U+6b28-6b31,U+6b33-6b36,U+6b38,U+6b3b-6b3d,U+6b3f-6b42,U+6b44-6b45,U+6b48,U+6b4a-6b4b,U+6b4d-6b58,U+6b5a-6b61,U+6b68-6b69,U+6b6b-6b78,U+6b7a,U+6b7d-6b80,U+6b85,U+6b88,U+6b8c,U+6b8e-6b91,U+6b94-6b95,U+6b97-6b99,U+6b9c-6ba0,U+6ba2-6ba9,U+6bab-6bb2,U+6bb6,U+6bb8-6bba" } }, { uri: Hf, descriptors: { unicodeRange: "U+430e-439a,U+29e8a,U+29ec4,U+29edb,U+29ee9,U+29f7e,U+29f83,U+29f8c,U+29fce,U+2a01a,U+2a02f,U+2a082,U+2a0f9,U+2a190,U+2a38c" } }, { uri: Jf, descriptors: { unicodeRange: "U+92ef-933d,U+933f-9369,U+936b-9388" } }, { uri: Yf, descriptors: { unicodeRange: "U+4512-458d,U+2b300,U+2b363,U+2b36f,U+2b372,U+2b37d,U+2b404,U+2b410,U+2b413,U+2b461,U+2b4ef,U+2b4f6,U+2b4f9,U+2b50d-2b50e,U+2b536,U+2b5ae,U+2b5b3,U+2b5e7,U+2b5f4,U+2b61c-2b61d,U+2b626-2b628,U+2b62a,U+2b62c,U+2b695-2b696,U+2b6ad,U+2b6ed" } }, { uri: Cf, descriptors: { unicodeRange: "U+88bd-88c0,U+88c3-88c4,U+88c7-88c8,U+88ca-88cd,U+88cf-88d1,U+88d3,U+88d6-88d7,U+88da-88de,U+88e0-88e1,U+88e6-88e7,U+88e9-88ef,U+88f2,U+88f5-88f7,U+88fa-88fb,U+88fd,U+88ff-8901,U+8903-8909,U+890b-890f,U+8911,U+8914-8918,U+891c-8920,U+8922-8924,U+8926-8929,U+892c-892f,U+8931-8933,U+8935,U+8937-8940,U+8942-8943,U+8945-895d,U+8960-8965,U+8967-897a,U+897c-897e,U+8980,U+8982,U+8984-8985" } }, { uri: Vf, descriptors: { unicodeRange: "U+4b0b-4ba0" } }, { uri: qf, descriptors: { unicodeRange: "U+7179,U+717b-717c,U+717e-7183,U+7185-7189,U+718b-718e,U+7190-7193,U+7195-7197,U+719a-719e,U+71a1-71a7,U+71a9-71ab,U+71ad-71b2,U+71b4,U+71b6-71b8,U+71ba-71c2,U+71c4-71cd,U+71cf-71d3,U+71d6-71df,U+71e1-71e4,U+71e6,U+71e8-71ed,U+71ef-71f8,U+71fa-7205,U+7207-721c,U+721e-7227,U+7229,U+722b,U+722d" } }, { uri: Xf, descriptors: { unicodeRange: "U+982e-9874,U+988b,U+988e,U+9892,U+9895,U+9899,U+98a3,U+98a8-98cd,U+98cf-98d0,U+98d4,U+98d6-98d7,U+98db-98dd,U+98e0-98e6,U+98e9-98fa" } }, { uri: Gf, descriptors: { unicodeRange: "U+7c14-7c15,U+7c17-7c1e,U+7c20-7c25,U+7c28-7c29,U+7c2b-7c37,U+7c39-7c3e,U+7c42-7c4c,U+7c4e-7c72,U+7c75-7c7a,U+7c7e-7c88,U+7c8a-7c90,U+7c93-7c94,U+7c96,U+7c99-7c9b,U+7ca0-7ca1,U+7ca3,U+7ca6-7ca9,U+7cab-7cad,U+7caf-7cb0,U+7cb4-7cb8,U+7cba-7cbb,U+7cbf-7cc0,U+7cc2-7cc4,U+7cc6,U+7cc9,U+7ccb,U+7cce-7cd4" } }, { uri: kf, descriptors: { unicodeRange: "U+7d95-7da5,U+7da7-7dad,U+7daf-7e2a" } }, { uri: Zf, descriptors: { unicodeRange: "U+4a78-4b0a" } }, { uri: Wf, descriptors: { unicodeRange: "U+9b30-9b31,U+9b33-9b3a,U+9b3d-9b40,U+9b46,U+9b4a-9b4c,U+9b4e,U+9b50,U+9b52-9b53,U+9b55-9bcf" } }, { uri: zf, descriptors: { unicodeRange: "U+6a4b-6a4f,U+6a51-6a57,U+6a5a,U+6a5c-6a60,U+6a62-6a64,U+6a66-6a70,U+6a72-6a78,U+6a7a-6a7b,U+6a7d-6a7f,U+6a81-6a83,U+6a85-6a8d,U+6a8f,U+6a92-6a96,U+6a98-6a9f,U+6aa1-6aa8,U+6aaa,U+6aad-6aef" } }, { uri: Qf, descriptors: { unicodeRange: "U+99c9-9a53" } }, { uri: jf, descriptors: { unicodeRange: "U+8550-8555,U+8557-8558,U+855a-855d,U+855f-8563,U+8565-8567,U+8569-8571,U+8573,U+8575-8578,U+857c-857d,U+857f-8583,U+8586,U+8588-858e,U+8590-859a,U+859d-85a3,U+85a5-85a7,U+85a9,U+85ab-85ad,U+85b1-85b6,U+85b8,U+85ba-85c0,U+85c2-85c8,U+85ca-85ce,U+85d1-85d2,U+85d4,U+85d6-85db,U+85dd-85e3,U+85e5-85e8,U+85ea-85fa,U+85fc-85fe,U+8600-8603" } }, { uri: e1, descriptors: { unicodeRange: "U+6fb2,U+6fb4-6fb5,U+6fb7-6fb8,U+6fba-6fbf,U+6fc1,U+6fc3-6fc8,U+6fca-6fd0,U+6fd3-6fdd,U+6fdf,U+6fe2-6fed,U+6ff0-7010,U+7012-7019,U+701c-7022,U+7024-7034,U+7036-7038,U+703a-704b,U+704d-704e,U+7050-7053" } }, { uri: t1$1, descriptors: { unicodeRange: "U+4ba1-4c2c" } }, { uri: n1, descriptors: { unicodeRange: "U+9a54-9a6b,U+9a72,U+9a83,U+9a89,U+9a8d-9a8e,U+9a94-9a95,U+9a99,U+9aa6,U+9aa9-9aaf,U+9ab2-9ab5,U+9ab9,U+9abb,U+9abd-9abf,U+9ac3-9ac4,U+9ac6-9aca,U+9acd-9ad0,U+9ad2,U+9ad4-9ad7,U+9ad9-9ade,U+9ae0,U+9ae2-9ae5,U+9ae7-9aea,U+9aec,U+9aee,U+9af0-9af8,U+9afa,U+9afc-9b02,U+9b04-9b07,U+9b09-9b0e,U+9b10-9b12,U+9b14-9b1e,U+9b20-9b22,U+9b24-9b2e" } }, { uri: r1$1, descriptors: { unicodeRange: "U+9d1a-9da1" } }, { uri: o1, descriptors: { unicodeRange: "U+9e13-9e1e,U+9e24,U+9e27,U+9e2e,U+9e30,U+9e34,U+9e3b-9e3c,U+9e40,U+9e4d,U+9e50,U+9e52-9e54,U+9e56,U+9e59,U+9e5d,U+9e5f-9e62,U+9e65,U+9e6e-9e6f,U+9e72,U+9e74-9e7d,U+9e80-9e81,U+9e83-9e86,U+9e89-9e8a,U+9e8c-9e91,U+9e94-9e9c,U+9e9e,U+9ea0-9ea5,U+9ea7-9eb3,U+9eb5-9eb7,U+9eb9-9eba,U+9ebc,U+9ebf-9ec3,U+9ec5-9ec8,U+9eca-9ecc,U+9ed0,U+9ed2-9ed3,U+9ed5-9ed7,U+9ed9-9eda,U+9ede,U+9ee1,U+9ee3-9ee4,U+9ee6,U+9ee8,U+9eeb-9eee,U+9ef0-9ef8" } }, { uri: i1, descriptors: { unicodeRange: "U+8b1c-8b25,U+8b27-8b65,U+8b67-8b6b,U+8b6d-8b9f,U+8bac,U+8bb1,U+8bbb,U+8bc7,U+8bd0" } }, { uri: a1$1, descriptors: { unicodeRange: "U+4cad-4d2f" } }, { uri: s1, descriptors: { unicodeRange: "U+9c4b-9c7b,U+9c7d-9c7e,U+9c80,U+9c83-9c84,U+9c89-9c8a,U+9c8c,U+9c8f,U+9c93,U+9c96-9c99,U+9c9d,U+9caa,U+9cac,U+9caf,U+9cb9,U+9cbe-9cc2,U+9cc8-9cc9,U+9cd1-9cd2,U+9cda-9cdb,U+9ce0-9ce1,U+9ce3-9d19" } }, { uri: d1, descriptors: { unicodeRange: "U+9389-938e,U+9390-93c9,U+93cb-93d5,U+93d7-9410" } }, { uri: c1, descriptors: { unicodeRange: "U+20a0-20b5,U+20b9-20ba,U+20bc-20bd,U+4e2c,U+5107,U+5216,U+5293,U+54f3,U+5523,U+5819,U+5adc,U+5c88,U+5e3b,U+5fee,U+62f6,U+63be,U+6484,U+6499,U+67d9,U+67dd,U+6d5e,U+6f46,U+717a,U+71e0,U+72c1,U+73e7,U+75b0,U+7603,U+7722,U+7809,U+7811,U+7946,U+7967,U+799a,U+7b45,U+7ba2,U+8014,U+80d9,U+8159,U+817d,U+81a3,U+81aa,U+8201,U+833c,U+836e,U+83e5,U+8459,U+84f0,U+8729,U+8753,U+87d3,U+89dc,U+8bf6,U+8c2e,U+8e2c,U+8e9c,U+8e9e,U+8ece,U+8fee,U+9139,U+914f,U+9174,U+9191,U+960c,U+9622,U+9a98,U+9b48,U+9ca6,U+9cb0,U+9da2-9e12,U+9e88,U+9f44,U+9f86" } }, { uri: l1$1, descriptors: { unicodeRange: "U+9bd0-9c4a" } }, { uri: U1$1, descriptors: { unicodeRange: "U+4c2d-4cac" } }, { uri: f1$1, descriptors: { unicodeRange: "U+4d30-4dab" } }, { uri: p1$1, descriptors: { unicodeRange: "U+9411-943d,U+943f-946a,U+946c-9484" } }, { uri: u1, descriptors: { unicodeRange: "U+9efa,U+9efd,U+9eff-9f0a,U+9f0c,U+9f0f,U+9f11-9f12,U+9f14-9f16,U+9f18,U+9f1a-9f1f,U+9f21,U+9f23-9f2b,U+9f2d-9f2e,U+9f30-9f36,U+9f38,U+9f3a,U+9f3c,U+9f3f-9f43,U+9f45-9f4f,U+9f52-9f7e,U+9f81-9f82,U+9f8d-9f94" } }, { uri: m1, descriptors: { unicodeRange: "U+7e2b-7e3a,U+7e3c-7e40,U+7e42-7e46,U+7e48-7e81,U+7e83-7e9a,U+7e9c-7e9e,U+7eae,U+7eb4,U+7ebb-7ebc,U+7ed6,U+7ee4,U+7eec,U+7ef9,U+7f0a,U+7f10,U+7f1e,U+7f37,U+7f39,U+7f3b" } }];
var ne = class ne2 {
  constructor(t3) {
    i$1(this, "scene");
    i$1(this, "getSceneFamilies", () => ne2.getUniqueFamilies(this.scene.getNonDeletedElements()));
    i$1(this, "onLoaded", (t5) => {
      let n3 = true;
      for (let i3 of t5) {
        let a3 = `${i3.family}-${i3.style}-${i3.weight}-${i3.unicodeRange}`;
        ne2.loadedFontsCache.has(a3) || (ne2.loadedFontsCache.add(a3), n3 = false);
      }
      if (n3) return;
      let r3 = false, o3 = this.scene.getNonDeletedElementsMap();
      for (let i3 of this.scene.getNonDeletedElements()) if (k$2(i3)) {
        r3 = true, he.delete(i3), $n.clearCache(Ee(i3));
        let a3 = qe(i3, o3);
        a3 && he.delete(a3);
      }
      r3 && this.scene.triggerUpdate();
    });
    i$1(this, "loadSceneFonts", async () => {
      let t5 = this.getSceneFamilies(), n3 = ne2.getCharsPerFamily(this.scene.getNonDeletedElements());
      return ne2.loadFontFaces(t5, n3);
    });
    this.scene = t3;
  }
  static get registered() {
    return ne2._registered ? ne2._initialized || (ne2._registered = new Map([...ne2.init().entries(), ...ne2._registered.entries()])) : ne2._registered = ne2.init(), ne2._registered;
  }
  get registered() {
    return ne2.registered;
  }
  static async generateFontFaceDeclarations(t3) {
    let n3 = ne2.getUniqueFamilies(t3), r3 = ne2.getCharsPerFamily(t3), o3 = n3.find((d3) => bo(d3).includes(Mn$1));
    if (o3) {
      let d3 = ne2.getCharacters(r3, o3);
      if (Sd$1(d3)) {
        let c3 = Un[Mn$1];
        r3[c3] = new Set(d3), n3.unshift(Un[Mn$1]);
      }
    }
    let i3 = ne2.fontFacesStylesGenerator(n3, r3), a3 = 3, s3 = await new vr(i3, a3).all();
    return Array.from(new Set(s3));
  }
  static async loadFontFaces(t3, n3) {
    for (let { fontFaces: a3, metadata: s3 } of ne2.registered.values()) if (!s3.local) for (let { fontFace: d3 } of a3) window.document.fonts.has(d3) || window.document.fonts.add(d3);
    let r3 = ne2.fontFacesLoader(t3, n3), o3 = 10;
    return (await new vr(r3, o3).all()).flat().filter(Boolean);
  }
  static *fontFacesLoader(t3, n3) {
    for (let [r3, o3] of t3.entries()) {
      let i3 = Ee({ fontFamily: o3, fontSize: 16 }), a3 = ne2.getCharacters(n3, o3);
      window.document.fonts.check(i3, a3) || (yield mn(async () => {
        try {
          let s3 = await window.document.fonts.load(i3, a3);
          return [r3, s3];
        } catch (s3) {
          console.error(`Failed to load font "${i3}" from urls "${ne2.registered.get(o3)?.fontFaces.map((d3) => d3.urls)}"`, s3);
        }
      }));
    }
  }
  static *fontFacesStylesGenerator(t3, n3) {
    for (let [r3, o3] of t3.entries()) {
      let { fontFaces: i3, metadata: a3 } = ne2.registered.get(o3) ?? {};
      if (!Array.isArray(i3)) {
        console.error(`Couldn't find registered fonts for font-family "${o3}"`, ne2.registered);
        continue;
      }
      if (!a3?.local) for (let [s3, d3] of i3.entries()) yield mn(async () => {
        try {
          let c3 = ne2.getCharacters(n3, o3), l3 = await d3.toCSS(c3);
          return l3 ? [r3 * 1e4 + s3, l3] : void 0;
        } catch (c3) {
          console.error(`Couldn't transform font-face to css for family "${d3.fontFace.family}"`, c3);
        }
      });
    }
  }
  static register(t3, n3, ...r3) {
    let o3 = Ie[t3] ?? Un[t3];
    return this.registered.get(o3) || this.registered.set(o3, { metadata: n3, fontFaces: r3.map(({ uri: a3, descriptors: s3 }) => new Xo(t3, a3, s3)) }), this.registered;
  }
  static init() {
    let t3 = { registered: /* @__PURE__ */ new Map() }, n3 = (r3, ...o3) => {
      let i3 = Ie[r3] ?? Un[r3], a3 = Fr[i3] ?? Fr[Ie.Excalifont];
      ne2.register.call(t3, r3, a3, ...o3);
    };
    return n3("Cascadia", ...Gd), n3("Comic Shanns", ...Qd), n3("Excalifont", ...sc$1), n3("Helvetica", ...dc$1), n3("Liberation Sans", ...lc$1), n3("Lilita One", ...pc$1), n3("Nunito", ...xc$1), n3("Virgil", ...yc$1), n3(Mn$1, ...b1$1), n3(Tn$1, ...jd), ne2._initialized = true, t3.registered;
  }
  static getUniqueFamilies(t3) {
    return Array.from(t3.reduce((n3, r3) => (k$2(r3) && n3.add(r3.fontFamily), n3), /* @__PURE__ */ new Set()));
  }
  static getCharsPerFamily(t3) {
    let n3 = {};
    for (let r3 of t3) if (k$2(r3)) for (let o3 of r3.originalText) n3[r3.fontFamily] || (n3[r3.fontFamily] = /* @__PURE__ */ new Set()), n3[r3.fontFamily].add(o3);
    return n3;
  }
  static getCharacters(t3, n3) {
    return t3[n3] ? Array.from(t3[n3]).join("") : "";
  }
  static getAllFamilies() {
    return Array.from(ne2.registered.keys());
  }
};
i$1(ne, "loadedFontsCache", /* @__PURE__ */ new Set()), i$1(ne, "_registered"), i$1(ne, "_initialized", false), i$1(ne, "loadElementsFonts", async (t3) => {
  let n3 = ne.getUniqueFamilies(t3), r3 = ne.getCharsPerFamily(t3);
  return ne.loadFontFaces(n3, r3);
});
var Nn = ne, Go = (e12, t3, n3) => {
  let { unitsPerEm: r3, ascender: o3, descender: i3 } = Nn.registered.get(e12)?.metadata.metrics || Fr[Ie.Virgil].metrics, a3 = t3 / r3, s3 = (n3 - a3 * o3 + a3 * i3) / 2;
  return a3 * o3 + s3;
}, ko = (e12) => {
  let { lineHeight: t3 } = Nn.registered.get(e12)?.metadata.metrics || Fr[Ie.Excalifont].metrics;
  return t3;
};
var Zo = (e12) => {
  let { angle: t3, width: n3, height: r3, x: o3, y: i3 } = e12, a3 = o3 + n3 / 2, s3 = i3 + r3 / 2, d3 = u$1(a3, s3), c3;
  return e12.type === "diamond" ? c3 = Qi(T$1(u$1(a3, i3), d3, t3), T$1(u$1(o3 + n3, s3), d3, t3), T$1(u$1(a3, i3 + r3), d3, t3), T$1(u$1(o3, s3), d3, t3)) : c3 = Qi(T$1(u$1(o3, i3), d3, t3), T$1(u$1(o3 + n3, i3), d3, t3), T$1(u$1(o3 + n3, i3 + r3), d3, t3), T$1(u$1(o3, i3 + r3), d3, t3)), { type: "polygon", data: c3 };
}, f$ = (e12, t3, n3 = 10) => {
  let [r3, o3, i3, a3, s3, d3] = C$1(e12, t3, true);
  r3 -= n3, i3 += n3, o3 -= n3, a3 += n3;
  let c3 = u$1(s3, d3), l3 = T$1(u$1(r3, o3), c3, e12.angle), U3 = T$1(u$1(i3, o3), c3, e12.angle), p3 = T$1(u$1(r3, a3), c3, e12.angle), m3 = T$1(u$1(i3, a3), c3, e12.angle);
  return { type: "polygon", data: [l3, U3, m3, p3] };
}, E1$1 = (e12) => {
  let { width: t3, height: n3, angle: r3, x: o3, y: i3 } = e12;
  return { type: "ellipse", data: { center: u$1(o3 + t3 / 2, i3 + n3 / 2), angle: r3, halfWidth: t3 / 2, halfHeight: n3 / 2 } };
}, It = (e12) => {
  if (!e12) return [];
  for (let t3 of e12.sets) if (t3.type === "path") return t3.ops;
  return e12.sets[0].ops;
}, g1$1 = (e12, t3 = u$1(0, 0), n3, r3) => {
  let o3 = (d3) => T$1(u$1(d3[0] + t3[0], d3[1] + t3[1]), r3, n3), i3 = It(e12), a3 = [], s3 = u$1(0, 0);
  for (let d3 of i3) {
    if (d3.op === "move") {
      let c3 = Ir$1(d3.data);
      Ae(c3 != null, "Ops data is not a point"), s3 = o3(c3);
    }
    if (d3.op === "bcurveTo") {
      let c3 = o3(u$1(d3.data[0], d3.data[1])), l3 = o3(u$1(d3.data[2], d3.data[3])), U3 = o3(u$1(d3.data[4], d3.data[5]));
      a3.push(Et(s3, c3, l3, U3)), s3 = U3;
    }
  }
  return { type: "polycurve", data: a3 };
}, um = (e12) => {
  let t3 = e12[0], n3 = [];
  for (let r3 = 1; r3 < e12.length; r3++) {
    let o3 = e12[r3];
    n3.push(A$1(t3, o3)), t3 = o3;
  }
  return n3;
}, x1$1 = (e12, t3, n3 = false) => {
  let r3 = (i3) => T$1(q(st$1(O(i3), Be(e12.x, e12.y))), t3, e12.angle), o3 = um(e12.points.map((i3) => r3(i3)));
  return n3 ? { type: "polygon", data: Gn(o3.flat()) } : { type: "polyline", data: o3 };
}, h1$1 = (e12, t3, n3 = u$1(0, 0), r3, o3) => {
  let i3 = (l3) => T$1(u$1(l3[0] + n3[0], l3[1] + n3[1]), o3, r3);
  if (e12.roundness === null) return { type: "polygon", data: Gn(e12.points.map((l3) => i3(l3))) };
  let a3 = It(t3), s3 = [], d3 = false;
  for (let l3 of a3) l3.op === "move" ? (d3 = !d3, d3 && s3.push(u$1(l3.data[0], l3.data[1]))) : l3.op === "bcurveTo" ? d3 && (s3.push(u$1(l3.data[0], l3.data[1])), s3.push(u$1(l3.data[2], l3.data[3])), s3.push(u$1(l3.data[4], l3.data[5]))) : l3.op === "lineTo" && d3 && s3.push(u$1(l3.data[0], l3.data[1]));
  let c3 = pointsOnBezierCurves(s3, 10, 5).map((l3) => i3(l3));
  return { type: "polygon", data: Gn(c3) };
};
var mm = (e12, t3) => {
  let { angle: n3, halfWidth: r3, halfHeight: o3, center: i3 } = t3, a3 = r3, s3 = o3, d3 = st$1(O(e12), ue(O(i3), -1)), [c3, l3] = T$1(q(d3), u$1(0, 0), -n3), U3 = Math.abs(c3), p3 = Math.abs(l3), m3 = 0.707, b3 = 0.707;
  for (let h3 = 0; h3 < 3; h3++) {
    let x3 = a3 * m3, y3 = s3 * b3, w3 = (a3 * a3 - s3 * s3) * m3 ** 3 / a3, I3 = (s3 * s3 - a3 * a3) * b3 ** 3 / s3, S3 = x3 - w3, v3 = y3 - I3, D3 = U3 - w3, $3 = p3 - I3, N3 = Math.hypot(v3, S3), B3 = Math.hypot($3, D3);
    m3 = Math.min(1, Math.max(0, (D3 * N3 / B3 + w3) / a3)), b3 = Math.min(1, Math.max(0, ($3 * N3 / B3 + I3) / s3));
    let _3 = Math.hypot(b3, m3);
    m3 /= _3, b3 /= _3;
  }
  let [E3, g3] = [a3 * m3 * Math.sign(c3), s3 * b3 * Math.sign(l3)];
  return ie(u$1(c3, l3), u$1(E3, g3));
}, y1$1 = (e12, t3, n3 = 1e-4) => mm(e12, t3) <= n3, I1 = (e12, t3) => {
  let { center: n3, angle: r3, halfWidth: o3, halfHeight: i3 } = t3, a3 = st$1(O(e12), ue(O(n3), -1)), [s3, d3] = T$1(q(a3), u$1(0, 0), -r3);
  return s3 / o3 * (s3 / o3) + d3 / i3 * (d3 / i3) <= 1;
};
var _r$1 = (e12, t3, n3 = 0) => {
  switch (t3.type) {
    case "polygon":
      return dd(e12, t3.data, n3);
    case "ellipse":
      return y1$1(e12, t3.data, n3);
    case "line":
      return Bt(e12, t3.data, n3);
    case "polyline":
      return R1$1(e12, t3.data, n3);
    case "curve":
      return w1$1(e12, t3.data, n3);
    case "polycurve":
      return bm(e12, t3.data, n3);
    default:
      throw Error(`shape ${t3} is not implemented`);
  }
}, Wo = (e12, t3) => {
  switch (t3.type) {
    case "polygon":
      return ji$1(e12, t3.data);
    case "line":
      return false;
    case "curve":
      return false;
    case "ellipse":
      return I1(e12, t3.data);
    case "polyline": {
      let n3 = Gn(t3.data.flat());
      return ji$1(e12, n3);
    }
    case "polycurve":
      return false;
    default:
      throw Error(`shape ${t3} is not implemented`);
  }
};
var bm = (e12, t3, n3) => t3.some((r3) => w1$1(e12, r3, n3)), Em = (e12) => {
  let [t3, n3, r3, o3] = e12;
  return (i3, a3) => Math.pow(1 - i3, 3) * o3[a3] + 3 * i3 * Math.pow(1 - i3, 2) * r3[a3] + 3 * Math.pow(i3, 2) * (1 - i3) * n3[a3] + t3[a3] * Math.pow(i3, 3);
}, gm = (e12, t3 = 10) => {
  let n3 = Em(e12), r3 = [n3(0, 0), n3(0, 1)], o3 = [], i3 = 0, a3 = 1 / t3;
  for (let s3 = 0; s3 < t3; s3++) if (i3 += a3, i3 <= 1) {
    let d3 = u$1(n3(i3, 0), n3(i3, 1));
    o3.push(A$1(r3, d3)), r3 = d3;
  }
  return o3;
}, w1$1 = (e12, t3, n3) => R1$1(e12, gm(t3), n3), R1$1 = (e12, t3, n3 = 1e-4) => t3.some((r3) => Bt(e12, r3, n3));
function zo(e12, t3, n3) {
  return { center: e12, halfWidth: t3, halfHeight: n3 };
}
var T1$1 = (e12, t3) => {
  let { halfWidth: n3, halfHeight: r3, center: o3 } = t3, i3 = n3, a3 = r3, s3 = st$1(O(e12), ue(O(o3), -1)), d3 = Math.abs(s3[0]), c3 = Math.abs(s3[1]), l3 = 0.707, U3 = 0.707;
  for (let b3 = 0; b3 < 3; b3++) {
    let E3 = i3 * l3, g3 = a3 * U3, h3 = (i3 * i3 - a3 * a3) * l3 ** 3 / i3, x3 = (a3 * a3 - i3 * i3) * U3 ** 3 / a3, y3 = E3 - h3, w3 = g3 - x3, I3 = d3 - h3, S3 = c3 - x3, v3 = Math.hypot(w3, y3), D3 = Math.hypot(S3, I3);
    l3 = Math.min(1, Math.max(0, (I3 * v3 / D3 + h3) / i3)), U3 = Math.min(1, Math.max(0, (S3 * v3 / D3 + x3) / a3));
    let $3 = Math.hypot(U3, l3);
    l3 /= $3, U3 /= $3;
  }
  let [p3, m3] = [i3 * l3 * Math.sign(s3[0]), a3 * U3 * Math.sign(s3[1])];
  return ie(q(s3), u$1(p3, m3));
};
function M1$1({ center: e12, halfWidth: t3, halfHeight: n3 }, [r3, o3]) {
  let [i3, a3] = e12, s3 = r3[0] - i3, d3 = r3[1] - a3, c3 = o3[0] - i3, l3 = o3[1] - a3, U3 = Math.pow(c3 - s3, 2) / Math.pow(t3, 2) + Math.pow(l3 - d3, 2) / Math.pow(n3, 2), p3 = 2 * (s3 * (c3 - s3) / Math.pow(t3, 2) + d3 * (l3 - d3) / Math.pow(n3, 2)), m3 = Math.pow(s3, 2) / Math.pow(t3, 2) + Math.pow(d3, 2) / Math.pow(n3, 2) - 1, b3 = (-p3 + Math.sqrt(Math.pow(p3, 2) - 4 * U3 * m3)) / (2 * U3), E3 = (-p3 - Math.sqrt(Math.pow(p3, 2) - 4 * U3 * m3)) / (2 * U3), g3 = [u$1(s3 + b3 * (c3 - s3) + i3, d3 + b3 * (l3 - d3) + a3), u$1(s3 + E3 * (c3 - s3) + i3, d3 + E3 * (l3 - d3) + a3)].filter((h3) => !isNaN(h3[0]) && !isNaN(h3[1]));
  return g3.length === 2 && _e$1(g3[0], g3[1]) ? [g3[0]] : g3;
}
function Qo$1(e12, t3 = 0) {
  let n3 = it$1(Math.min(e12.width, e12.height), e12);
  if (n3 <= 0) {
    let p3 = Tr$1(u$1(e12.x - t3, e12.y - t3), u$1(e12.x + e12.width + t3, e12.y + e12.height + t3)), m3 = A$1(u$1(p3[0][0] + n3, p3[0][1]), u$1(p3[1][0] - n3, p3[0][1])), b3 = A$1(u$1(p3[1][0], p3[0][1] + n3), u$1(p3[1][0], p3[1][1] - n3)), E3 = A$1(u$1(p3[0][0] + n3, p3[1][1]), u$1(p3[1][0] - n3, p3[1][1])), g3 = A$1(u$1(p3[0][0], p3[1][1] - n3), u$1(p3[0][0], p3[0][1] + n3));
    return [[m3, b3, E3, g3], []];
  }
  let r3 = u$1(e12.x + e12.width / 2, e12.y + e12.height / 2), o3 = Tr$1(u$1(e12.x, e12.y), u$1(e12.x + e12.width, e12.y + e12.height)), i3 = A$1(u$1(o3[0][0] + n3, o3[0][1]), u$1(o3[1][0] - n3, o3[0][1])), a3 = A$1(u$1(o3[1][0], o3[0][1] + n3), u$1(o3[1][0], o3[1][1] - n3)), s3 = A$1(u$1(o3[0][0] + n3, o3[1][1]), u$1(o3[1][0] - n3, o3[1][1])), d3 = A$1(u$1(o3[0][0], o3[1][1] - n3), u$1(o3[0][0], o3[0][1] + n3)), c3 = [ue(Je(O(u$1(o3[0][0] - t3, o3[0][1] - t3), r3)), t3), ue(Je(O(u$1(o3[1][0] + t3, o3[0][1] - t3), r3)), t3), ue(Je(O(u$1(o3[1][0] + t3, o3[1][1] + t3), r3)), t3), ue(Je(O(u$1(o3[0][0] - t3, o3[1][1] + t3), r3)), t3)], l3 = [Et(q(c3[0], d3[1]), q(c3[0], u$1(d3[1][0] + 2 / 3 * (o3[0][0] - d3[1][0]), d3[1][1] + 2 / 3 * (o3[0][1] - d3[1][1]))), q(c3[0], u$1(i3[0][0] + 2 / 3 * (o3[0][0] - i3[0][0]), i3[0][1] + 2 / 3 * (o3[0][1] - i3[0][1]))), q(c3[0], i3[0])), Et(q(c3[1], i3[1]), q(c3[1], u$1(i3[1][0] + 2 / 3 * (o3[1][0] - i3[1][0]), i3[1][1] + 2 / 3 * (o3[0][1] - i3[1][1]))), q(c3[1], u$1(a3[0][0] + 2 / 3 * (o3[1][0] - a3[0][0]), a3[0][1] + 2 / 3 * (o3[0][1] - a3[0][1]))), q(c3[1], a3[0])), Et(q(c3[2], a3[1]), q(c3[2], u$1(a3[1][0] + 2 / 3 * (o3[1][0] - a3[1][0]), a3[1][1] + 2 / 3 * (o3[1][1] - a3[1][1]))), q(c3[2], u$1(s3[1][0] + 2 / 3 * (o3[1][0] - s3[1][0]), s3[1][1] + 2 / 3 * (o3[1][1] - s3[1][1]))), q(c3[2], s3[1])), Et(q(c3[3], s3[0]), q(c3[3], u$1(s3[0][0] + 2 / 3 * (o3[0][0] - s3[0][0]), s3[0][1] + 2 / 3 * (o3[1][1] - s3[0][1]))), q(c3[3], u$1(d3[0][0] + 2 / 3 * (o3[0][0] - d3[0][0]), d3[0][1] + 2 / 3 * (o3[1][1] - d3[0][1]))), q(c3[3], d3[0]))];
  return [[A$1(l3[0][3], l3[1][0]), A$1(l3[1][3], l3[2][0]), A$1(l3[2][3], l3[3][0]), A$1(l3[3][3], l3[0][0])], l3];
}
function jo(e12, t3 = 0) {
  let [n3, r3, o3, i3, a3, s3, d3, c3] = Or(e12), l3 = it$1(Math.abs(n3 - d3), e12), U3 = it$1(Math.abs(i3 - r3), e12);
  if (e12.roundness?.type == null) {
    let [w3, I3, S3, v3] = [u$1(e12.x + n3, e12.y + r3 - t3), u$1(e12.x + o3 + t3, e12.y + i3), u$1(e12.x + a3, e12.y + s3 + t3), u$1(e12.x + d3 - t3, e12.y + c3)], D3 = A$1(u$1(w3[0] + l3, w3[1] + U3), u$1(I3[0] - l3, I3[1] - U3)), $3 = A$1(u$1(I3[0] - l3, I3[1] + U3), u$1(S3[0] + l3, S3[1] - U3)), N3 = A$1(u$1(S3[0] - l3, S3[1] - U3), u$1(v3[0] + l3, v3[1] + U3)), B3 = A$1(u$1(v3[0] + l3, v3[1] - U3), u$1(w3[0] - l3, w3[1] + U3));
    return [[D3, $3, N3, B3], []];
  }
  let p3 = u$1(e12.x + e12.width / 2, e12.y + e12.height / 2), [m3, b3, E3, g3] = [u$1(e12.x + n3, e12.y + r3), u$1(e12.x + o3, e12.y + i3), u$1(e12.x + a3, e12.y + s3), u$1(e12.x + d3, e12.y + c3)], h3 = [ue(Je(O(b3, p3)), t3), ue(Je(O(E3, p3)), t3), ue(Je(O(g3, p3)), t3), ue(Je(O(m3, p3)), t3)], x3 = [Et(q(h3[0], u$1(b3[0] - l3, b3[1] - U3)), q(h3[0], b3), q(h3[0], b3), q(h3[0], u$1(b3[0] - l3, b3[1] + U3))), Et(q(h3[1], u$1(E3[0] + l3, E3[1] - U3)), q(h3[1], E3), q(h3[1], E3), q(h3[1], u$1(E3[0] - l3, E3[1] - U3))), Et(q(h3[2], u$1(g3[0] + l3, g3[1] + U3)), q(h3[2], g3), q(h3[2], g3), q(h3[2], u$1(g3[0] + l3, g3[1] - U3))), Et(q(h3[3], u$1(m3[0] - l3, m3[1] + U3)), q(h3[3], m3), q(h3[3], m3), q(h3[3], u$1(m3[0] + l3, m3[1] + U3)))];
  return [[A$1(x3[0][3], x3[1][0]), A$1(x3[1][3], x3[2][0]), A$1(x3[2][3], x3[3][0]), A$1(x3[3][3], x3[0][0])], x3];
}
var ei = (e12) => {
  if (e12.type === "arrow") return false;
  let t3 = !Wt(e12.backgroundColor) || bn(e12) || gt$1(e12) || k$2(e12);
  return e12.type === "line" ? t3 && Kt(e12.points) : e12.type === "freedraw" ? t3 && Kt(e12.points) : t3 || Ye$1(e12);
}, xm = ({ x: e12, y: t3, element: n3, shape: r3, threshold: o3 = 10, frameNameBound: i3 = null }) => {
  let a3 = ei(n3) ? Wo(u$1(e12, t3), r3) || _r$1(u$1(e12, t3), r3, o3) : _r$1(u$1(e12, t3), r3, o3);
  return !a3 && i3 && (a3 = Wo(u$1(e12, t3), { type: "polygon", data: Zo(i3).data })), a3;
}, ba = (e12, t3, n3, r3, o3 = 0) => {
  let [i3, a3, s3, d3] = Ke$1(n3, r3);
  return i3 -= o3, a3 -= o3, s3 += o3, d3 += o3, So(u$1(i3, a3), u$1(e12, t3), u$1(s3, d3));
}, A$ = (e12, t3) => !xm(e12) && !hm(e12.x, e12.y, L1$1(e12.element, t3)) && ba(e12.x, e12.y, e12.element, t3), hm = (e12, t3, n3) => !!n3 && Wo(u$1(e12, t3), n3), Ea = (e12, t3, n3 = 0) => {
  switch (e12.type) {
    case "rectangle":
    case "image":
    case "text":
    case "iframe":
    case "embeddable":
    case "frame":
    case "magicframe":
      return ym(e12, t3, n3);
    case "diamond":
      return Im(e12, t3, n3);
    case "ellipse":
      return wm(e12, t3, n3);
    default:
      throw new Error(`Unimplemented element type '${e12.type}'`);
  }
}, ym = (e12, t3, n3 = 0) => {
  let r3 = u$1(e12.x + e12.width / 2, e12.y + e12.height / 2), o3 = T$1(t3[0], r3, -e12.angle), i3 = T$1(t3[1], r3, -e12.angle), [a3, s3] = Qo$1(e12, n3);
  return [...a3.map((d3) => pn(A$1(o3, i3), d3)).filter((d3) => d3 != null).map((d3) => T$1(d3, r3, e12.angle)), ...s3.flatMap((d3) => Wi$1(d3, A$1(o3, i3))).filter((d3) => d3 != null).map((d3) => T$1(d3, r3, e12.angle))].filter((d3, c3, l3) => l3.findIndex((U3) => _e$1(d3, U3)) === c3);
}, Im = (e12, t3, n3 = 0) => {
  let r3 = u$1(e12.x + e12.width / 2, e12.y + e12.height / 2), o3 = T$1(t3[0], r3, -e12.angle), i3 = T$1(t3[1], r3, -e12.angle), [a3, s3] = jo(e12, n3);
  return [...a3.map((d3) => pn(A$1(o3, i3), d3)).filter((d3) => d3 != null).map((d3) => T$1(d3, r3, e12.angle)), ...s3.flatMap((d3) => Wi$1(d3, A$1(o3, i3))).filter((d3) => d3 != null).map((d3) => T$1(d3, r3, e12.angle))].filter((d3, c3, l3) => l3.findIndex((U3) => _e$1(d3, U3)) === c3);
}, wm = (e12, t3, n3 = 0) => {
  let r3 = u$1(e12.x + e12.width / 2, e12.y + e12.height / 2), o3 = T$1(t3[0], r3, -e12.angle), i3 = T$1(t3[1], r3, -e12.angle);
  return M1$1(zo(r3, e12.width / 2 + n3, e12.height / 2 + n3), Rr(o3, i3)).map((a3) => T$1(a3, r3, e12.angle));
};
var D1 = { EQUAL: "Equal", MINUS: "Minus", NUM_ADD: "NumpadAdd", NUM_SUBTRACT: "NumpadSubtract", NUM_ZERO: "Numpad0", BRACKET_RIGHT: "BracketRight", BRACKET_LEFT: "BracketLeft", ONE: "Digit1", TWO: "Digit2", THREE: "Digit3", QUOTE: "Quote", ZERO: "Digit0", SLASH: "Slash", C: "KeyC", D: "KeyD", H: "KeyH", V: "KeyV", Z: "KeyZ", Y: "KeyY", R: "KeyR", S: "KeyS" }, Q = { ARROW_DOWN: "ArrowDown", ARROW_LEFT: "ArrowLeft", ARROW_RIGHT: "ArrowRight", ARROW_UP: "ArrowUp", PAGE_UP: "PageUp", PAGE_DOWN: "PageDown", BACKSPACE: "Backspace", ALT: "Alt", CTRL_OR_CMD: uo ? "metaKey" : "ctrlKey", DELETE: "Delete", ENTER: "Enter", ESCAPE: "Escape", QUESTION_MARK: "?", SPACE: " ", TAB: "Tab", CHEVRON_LEFT: "<", CHEVRON_RIGHT: ">", PERIOD: ".", COMMA: ",", SLASH: "/", A: "a", D: "d", E: "e", F: "f", G: "g", H: "h", I: "i", L: "l", O: "o", P: "p", Q: "q", R: "r", S: "s", T: "t", V: "v", X: "x", Y: "y", Z: "z", K: "k", 0: "0", 1: "1", 2: "2", 3: "3", 4: "4", 5: "5", 6: "6", 7: "7", 8: "8", 9: "9" }, Rm = /* @__PURE__ */ new Map([[Q.Z, D1.Z], [Q.Y, D1.Y]]), Tm = (e12) => /^[a-z]$/.test(e12.toLowerCase()), Y$ = (e12, t3) => {
  if (t3 === e12.key.toLowerCase()) return true;
  let n3 = Rm.get(t3);
  return !!(n3 && !Tm(e12.key) && e12.code === n3);
}, C$ = (e12) => e12 === Q.ARROW_LEFT || e12 === Q.ARROW_RIGHT || e12 === Q.ARROW_DOWN || e12 === Q.ARROW_UP, V$ = (e12) => e12.altKey, q$ = (e12) => e12.shiftKey, ga = (e12) => e12.shiftKey;
var Mm = [{ icon: Pd$1, value: "selection", key: Q.V, numericKey: Q[1], fillable: true }, { icon: Nd, value: "rectangle", key: Q.R, numericKey: Q[2], fillable: true }, { icon: Fd$1, value: "diamond", key: Q.D, numericKey: Q[3], fillable: true }, { icon: Bd$1, value: "ellipse", key: Q.O, numericKey: Q[4], fillable: true }, { icon: _d, value: "arrow", key: Q.A, numericKey: Q[5], fillable: true }, { icon: Od$1, value: "line", key: Q.L, numericKey: Q[6], fillable: true }, { icon: Nr$1, value: "freedraw", key: [Q.P, Q.X], numericKey: Q[7], fillable: false }, { icon: Ad$1, value: "text", key: Q.T, numericKey: Q[8], fillable: false }, { icon: Kd, value: "image", key: null, numericKey: Q[9], fillable: false }, { icon: Hd, value: "eraser", key: Q.E, numericKey: Q[0], fillable: false }], iP = (e12) => Mm.find((n3, r3) => n3.numericKey != null && e12 === n3.numericKey.toString() || n3.key && (typeof n3.key == "string" ? n3.key === e12 : n3.key.includes(e12)))?.value || null, ti = (e12, t3) => {
  switch (e12.type) {
    case "rectangle":
    case "diamond":
    case "frame":
    case "magicframe":
    case "embeddable":
    case "image":
    case "iframe":
    case "text":
    case "selection":
      return Zo(e12);
    case "arrow":
    case "line": {
      let n3 = he.get(e12)?.[0] ?? he.generateElementShape(e12, null)[0], [, , , , r3, o3] = C$1(e12, t3);
      return ei(e12) ? h1$1(e12, n3, u$1(e12.x, e12.y), e12.angle, u$1(r3, o3)) : g1$1(n3, u$1(e12.x, e12.y), e12.angle, u$1(r3, o3));
    }
    case "ellipse":
      return E1$1(e12);
    case "freedraw": {
      let [, , , , n3, r3] = C$1(e12, t3);
      return x1$1(e12, u$1(n3, r3), ei(e12));
    }
  }
}, L1$1 = (e12, t3) => {
  let n3 = oe(e12, t3);
  return n3 ? e12.type === "arrow" ? ti({ ...n3, ...z$1.getBoundTextElementPosition(e12, n3, t3) }, t3) : ti(n3, t3) : null;
}, xa = (e12, t3) => {
  let n3 = he.generateElementShape(e12, null);
  if (!n3) return null;
  let r3 = It(n3[0]), o3 = u$1(0, 0), i3 = 0, a3 = 1 / 0, s3 = null;
  for (; i3 < r3.length; ) {
    let { op: d3, data: c3 } = r3[i3];
    if (d3 === "move" && (Ae(Do$1(c3), "The returned ops is not compatible with a point"), o3 = c3), d3 === "bcurveTo") {
      let l3 = o3, U3 = u$1(c3[0], c3[1]), p3 = u$1(c3[2], c3[3]), m3 = u$1(c3[4], c3[5]), b3 = ie(m3, t3);
      b3 < a3 && (a3 = b3, s3 = [l3, U3, p3, m3]), o3 = m3;
    }
    i3++;
  }
  return s3;
}, ha = (e12, t3, n3, r3, o3) => {
  let i3 = (d3, c3) => Math.pow(1 - d3, 3) * r3[c3] + 3 * d3 * Math.pow(1 - d3, 2) * n3[c3] + 3 * Math.pow(d3, 2) * (1 - d3) * t3[c3] + e12[c3] * Math.pow(d3, 3), a3 = i3(o3, 0), s3 = i3(o3, 1);
  return u$1(a3, s3);
}, Lm = (e12, t3) => {
  let n3 = xa(e12, t3);
  if (!n3) return [];
  let r3 = [], o3 = 1;
  for (; o3 > 0; ) {
    let i3 = ha(n3[0], n3[1], n3[2], n3[3], o3);
    r3.push(u$1(i3[0], i3[1])), o3 -= 0.05;
  }
  return r3.length && _e$1(r3.at(-1), t3) && r3.push(u$1(t3[0], t3[1])), r3;
}, v1$1 = (e12, t3) => {
  let n3 = [];
  n3[0] = 0;
  let r3 = Lm(e12, t3), o3 = 0, i3 = 0;
  for (; o3 < r3.length - 1; ) {
    let a3 = ie(r3[o3], r3[o3 + 1]);
    i3 += a3, n3.push(i3), o3++;
  }
  return n3;
}, $1$1 = (e12, t3) => v1$1(e12, t3).at(-1), P1$1 = (e12, t3, n3) => {
  let r3 = v1$1(e12, t3), o3 = r3.length - 1, i3 = r3.at(-1), a3 = n3 * i3, s3 = 0, d3 = o3, c3 = 0;
  for (; s3 < d3; ) c3 = Math.floor(s3 + (d3 - s3) / 2), r3[c3] < a3 ? s3 = c3 + 1 : d3 = c3;
  return r3[c3] > a3 && c3--, r3[c3] === a3 ? c3 / o3 : 1 - (c3 + (a3 - r3[c3]) / (r3[c3 + 1] - r3[c3])) / o3;
}, wt$1 = (e12, t3) => {
  let n3 = { minX: e12.x, minY: e12.y, maxX: e12.x + e12.width, maxY: e12.y + e12.height, midX: e12.x + e12.width / 2, midY: e12.y + e12.height / 2 }, r3 = u$1(n3.midX, n3.midY), [o3, i3] = T$1(u$1(n3.minX, n3.minY), r3, e12.angle), [a3, s3] = T$1(u$1(n3.maxX, n3.minY), r3, e12.angle), [d3, c3] = T$1(u$1(n3.maxX, n3.maxY), r3, e12.angle), [l3, U3] = T$1(u$1(n3.minX, n3.maxY), r3, e12.angle), p3 = [Math.min(o3, a3, d3, l3), Math.min(i3, s3, c3, U3), Math.max(o3, a3, d3, l3), Math.max(i3, s3, c3, U3)];
  if (t3) {
    let [m3, b3, E3, g3] = t3;
    return [p3[0] - g3, p3[1] - m3, p3[2] + b3, p3[3] + E3];
  }
  return p3;
}, gn = (e12, t3) => e12[0] > t3[0] && e12[0] < t3[2] && e12[1] > t3[1] && e12[1] < t3[3];
var it$1 = (e12, t3) => {
  if (t3.roundness?.type === ot.PROPORTIONAL_RADIUS || t3.roundness?.type === ot.LEGACY) return e12 * wo;
  if (t3.roundness?.type === ot.ADAPTIVE_RADIUS) {
    let n3 = t3.roundness?.value ?? Gs, r3 = n3 / wo;
    return e12 <= r3 ? e12 * wo : n3;
  }
  return 0;
}, Kt = (e12, t3 = 1) => {
  if (e12.length >= 3) {
    let [n3, r3] = [e12[0], e12[e12.length - 1]];
    return ie(n3, r3) <= Ks$1 / t3;
  }
  return false;
};
var Ge$1 = 10, lP = (e12, t3, n3, r3, o3, i3, a3) => {
  let { width: s3, height: d3 } = er$1(e12), c3 = n3 / s3, l3 = r3 / d3, U3 = (e12.crop?.x ?? 0) / c3, p3 = (e12.crop?.y ?? 0) / l3, m3 = T$1(u$1(o3, i3), u$1(e12.x + e12.width / 2, e12.y + e12.height / 2), -e12.angle);
  o3 = m3[0], i3 = m3[1];
  let b3 = e12.width, E3 = e12.height, g3 = e12.crop ?? { x: 0, y: 0, width: n3, height: r3, naturalWidth: n3, naturalHeight: r3 }, h3 = g3.height, x3 = g3.width, y3 = e12.scale[0] === -1, w3 = e12.scale[1] === -1, I3 = i3 - e12.y, S3 = o3 - e12.x;
  t3.includes("n") && (E3 = se(e12.height - I3, Ge$1, w3 ? d3 - p3 : e12.height + p3)), t3.includes("s") && (I3 = i3 - e12.y - e12.height, E3 = se(e12.height + I3, Ge$1, w3 ? e12.height + p3 : d3 - p3)), t3.includes("e") && (S3 = o3 - e12.x - e12.width, b3 = se(e12.width + S3, Ge$1, y3 ? e12.width + U3 : s3 - U3)), t3.includes("w") && (b3 = se(e12.width - S3, Ge$1, y3 ? s3 - U3 : e12.width + U3));
  let v3 = (N3) => {
    N3.height = E3 * l3, N3.width = b3 * c3;
  };
  v3(g3);
  let D3 = (N3, B3) => {
    v3(B3), N3.includes("n") && (w3 || (B3.y += h3 - B3.height)), N3.includes("s") && w3 && (B3.y += h3 - B3.height), N3.includes("e") && y3 && (B3.x += x3 - B3.width), N3.includes("w") && (y3 || (B3.x += x3 - B3.width));
  };
  switch (t3) {
    case "n": {
      if (a3) {
        let N3 = U3 + e12.width / 2, B3 = s3 - U3 - e12.width / 2, _3 = Math.min(N3, B3) * 2;
        b3 = se(E3 * a3, Ge$1, _3), E3 = b3 / a3;
      }
      D3(t3, g3), a3 && (g3.x += (x3 - g3.width) / 2);
      break;
    }
    case "s": {
      if (a3) {
        let N3 = U3 + e12.width / 2, B3 = s3 - U3 - e12.width / 2, _3 = Math.min(N3, B3) * 2;
        b3 = se(E3 * a3, Ge$1, _3), E3 = b3 / a3;
      }
      D3(t3, g3), a3 && (g3.x += (x3 - g3.width) / 2);
      break;
    }
    case "w": {
      if (a3) {
        let N3 = p3 + e12.height / 2, B3 = d3 - p3 - e12.height / 2, _3 = Math.min(N3, B3) * 2;
        E3 = se(b3 / a3, Ge$1, _3), b3 = E3 * a3;
      }
      D3(t3, g3), a3 && (g3.y += (h3 - g3.height) / 2);
      break;
    }
    case "e": {
      if (a3) {
        let N3 = p3 + e12.height / 2, B3 = d3 - p3 - e12.height / 2, _3 = Math.min(N3, B3) * 2;
        E3 = se(b3 / a3, Ge$1, _3), b3 = E3 * a3;
      }
      D3(t3, g3), a3 && (g3.y += (h3 - g3.height) / 2);
      break;
    }
    case "ne": {
      if (a3) if (S3 > -I3) {
        let N3 = w3 ? d3 - p3 : p3 + e12.height;
        E3 = se(b3 / a3, Ge$1, N3), b3 = E3 * a3;
      } else {
        let N3 = y3 ? U3 + e12.width : s3 - U3;
        b3 = se(E3 * a3, Ge$1, N3), E3 = b3 / a3;
      }
      D3(t3, g3);
      break;
    }
    case "nw": {
      if (a3) if (S3 < I3) {
        let N3 = w3 ? d3 - p3 : p3 + e12.height;
        E3 = se(b3 / a3, Ge$1, N3), b3 = E3 * a3;
      } else {
        let N3 = y3 ? s3 - U3 : U3 + e12.width;
        b3 = se(E3 * a3, Ge$1, N3), E3 = b3 / a3;
      }
      D3(t3, g3);
      break;
    }
    case "se": {
      if (a3) if (S3 > I3) {
        let N3 = w3 ? p3 + e12.height : d3 - p3;
        E3 = se(b3 / a3, Ge$1, N3), b3 = E3 * a3;
      } else {
        let N3 = y3 ? U3 + e12.width : s3 - U3;
        b3 = se(E3 * a3, Ge$1, N3), E3 = b3 / a3;
      }
      D3(t3, g3);
      break;
    }
    case "sw": {
      if (a3) if (-S3 > I3) {
        let N3 = w3 ? p3 + e12.height : d3 - p3;
        E3 = se(b3 / a3, Ge$1, N3), b3 = E3 * a3;
      } else {
        let N3 = y3 ? s3 - U3 : U3 + e12.width;
        b3 = se(E3 * a3, Ge$1, N3), E3 = b3 / a3;
      }
      D3(t3, g3);
      break;
    }
  }
  let $3 = Dm(e12, t3, b3, E3, !!a3);
  return Zi(g3.width, g3.naturalWidth) && Zi(g3.height, g3.naturalHeight) && (g3 = null), { x: $3[0], y: $3[1], width: b3, height: E3, crop: g3 };
}, Dm = (e12, t3, n3, r3, o3) => {
  let [i3, a3, s3, d3] = Rt(e12, e12.width, e12.height, true), c3 = u$1(i3, a3), l3 = u$1(s3, d3), U3 = Zt(c3, l3), [p3, m3, b3, E3] = Rt(e12, n3, r3, true), g3 = b3 - p3, h3 = E3 - m3, x3 = [...c3];
  if (["n", "w", "nw"].includes(t3) && (x3 = [l3[0] - Math.abs(g3), l3[1] - Math.abs(h3)]), t3 === "ne") {
    let D3 = [c3[0], l3[1]];
    x3 = [D3[0], D3[1] - Math.abs(h3)];
  }
  if (t3 === "sw") {
    let D3 = [l3[0], c3[1]];
    x3 = [D3[0] - Math.abs(g3), D3[1]];
  }
  o3 && (["s", "n"].includes(t3) && (x3[0] = U3[0] - g3 / 2), ["e", "w"].includes(t3) && (x3[1] = U3[1] - h3 / 2));
  let y3 = e12.angle, w3 = T$1(x3, U3, y3), I3 = [x3[0] + Math.abs(g3) / 2, x3[1] + Math.abs(h3) / 2], S3 = T$1(I3, U3, y3);
  x3 = T$1(w3, S3, -y3);
  let v3 = [...x3];
  return v3[0] += e12.x - p3, v3[1] += e12.y - m3, v3;
}, N1$1 = (e12, t3) => {
  if (e12.crop) {
    let { width: n3, height: r3 } = er$1(e12), [o3, i3, a3, s3, d3, c3] = C$1(e12, t3), l3 = O(T$1(u$1(o3, i3), u$1(d3, c3), e12.angle)), U3 = O(T$1(u$1(a3, i3), u$1(d3, c3), e12.angle)), p3 = Je(Lo(U3, l3)), m3 = O(T$1(u$1(o3, s3), u$1(d3, c3), e12.angle)), b3 = Lo(m3, l3), E3 = Je(b3), { cropX: g3, cropY: h3 } = Sm(e12.crop, e12.scale), x3 = st$1(st$1(l3, ue(p3, -g3 * n3 / e12.crop.naturalWidth)), ue(E3, -h3 * r3 / e12.crop.naturalHeight)), y3 = q(st$1(st$1(x3, ue(p3, n3 / 2)), ue(E3, r3 / 2))), w3 = T$1(q(x3), y3, -e12.angle);
    return { ...e12, x: w3[0], y: w3[1], width: n3, height: r3, crop: null };
  }
  return e12;
}, er$1 = (e12) => {
  if (e12.crop) {
    let t3 = e12.width / (e12.crop.width / e12.crop.naturalWidth), n3 = e12.height / (e12.crop.height / e12.crop.naturalHeight);
    return { width: t3, height: n3 };
  }
  return { width: e12.width, height: e12.height };
}, Sm = (e12, t3) => {
  let n3 = e12.x, r3 = e12.y, o3 = t3[0] === -1, i3 = t3[1] === -1;
  return o3 && (n3 = e12.naturalWidth - Math.abs(n3) - e12.width), i3 && (r3 = e12.naturalHeight - Math.abs(r3) - e12.height), { cropX: n3, cropY: r3 };
}, UP = (e12, t3 = false) => {
  let n3 = e12.crop;
  if (!n3) return null;
  let r3 = e12.scale[0] === -1, o3 = e12.scale[1] === -1, i3 = n3.x, a3 = n3.y;
  if (r3 && (i3 = n3.naturalWidth - n3.width - n3.x), o3 && (a3 = n3.naturalHeight - n3.height - n3.y), t3) return { x: i3, y: a3 };
  let { width: s3, height: d3 } = er$1(e12);
  return { x: i3 / (n3.naturalWidth / s3), y: a3 / (n3.naturalHeight / d3) };
};
var Ia = "invert(100%) hue-rotate(180deg) saturate(1.25)", $m = mt(), O1$1 = (e12, t3) => At(e12) && !t3.imageCache.has(e12.fileId), A1$1 = (e12, t3, n3) => n3.theme === ke.DARK && At(e12) && !O1$1(e12, t3) && t3.imageCache.get(e12.fileId)?.mimeType !== H.svg, ri = (e12) => {
  switch (e12.type) {
    case "freedraw":
      return e12.strokeWidth * 12;
    case "text":
      return e12.fontSize / 2;
    default:
      return 20;
  }
}, Pm = (e12, t3, n3, r3, o3 = 1) => {
  let i3 = (t3?.opacity ?? 100) * e12.opacity / 1e4 * o3;
  return (n3.has(e12.id) || r3 && r3.some((a3) => a3.id === e12.id) || t3 && n3.has(t3.id)) && (i3 *= Xs$1 / 100), i3;
}, Nm = (e12, t3, n3) => {
  let i3 = ri(e12), [a3, s3, d3, c3] = C$1(e12, t3), l3 = ae(e12) || Ce$1(e12) ? dt(a3, d3) : e12.width, U3 = ae(e12) || Ce$1(e12) ? dt(s3, c3) : e12.height, p3 = l3 * window.devicePixelRatio + i3 * 2, m3 = U3 * window.devicePixelRatio + i3 * 2, b3 = n3.value;
  return (p3 * b3 > 32767 || m3 * b3 > 32767) && (b3 = Math.min(32767 / p3, 32767 / m3)), p3 * m3 * b3 * b3 > 16777216 && (b3 = Math.sqrt(16777216 / (p3 * m3))), p3 = Math.floor(p3 * b3), m3 = Math.floor(m3 * b3), { width: p3, height: m3, scale: b3 };
}, K1$1 = (e12, t3, n3, r3, o3) => {
  let i3 = document.createElement("canvas"), a3 = i3.getContext("2d"), s3 = ri(e12), { width: d3, height: c3, scale: l3 } = Nm(e12, t3, n3);
  if (!d3 || !c3) return null;
  i3.width = d3, i3.height = c3;
  let U3 = -100, p3 = 0;
  if (ae(e12) || Ce$1(e12)) {
    let [h3, x3] = C$1(e12, t3);
    U3 = e12.x > h3 ? dt(e12.x, h3) * window.devicePixelRatio * l3 : 0, p3 = e12.y > x3 ? dt(e12.y, x3) * window.devicePixelRatio * l3 : 0, a3.translate(U3, p3);
  }
  a3.save(), a3.translate(s3 * l3, s3 * l3), a3.scale(window.devicePixelRatio * l3, window.devicePixelRatio * l3);
  let m3 = q5.canvas(i3);
  A1$1(e12, r3, o3) && (a3.filter = Ia), ni(e12, m3, a3, r3), a3.restore();
  let b3 = oe(e12, t3), E3 = document.createElement("canvas"), g3 = E3.getContext("2d");
  if (ee(e12) && b3) {
    let [h3, x3, y3, w3] = C$1(e12, t3), I3 = Math.max(dt(h3, y3), dt(x3, w3));
    E3.width = I3 * window.devicePixelRatio * l3 + s3 * l3 * 10, E3.height = I3 * window.devicePixelRatio * l3 + s3 * l3 * 10, g3.translate(E3.width / 2, E3.height / 2), g3.rotate(e12.angle), g3.drawImage(i3, -i3.width / 2, -i3.height / 2, i3.width, i3.height);
    let [, , , , S3, v3] = C$1(b3, t3);
    g3.rotate(-e12.angle);
    let D3 = (E3.width - i3.width) / 2, $3 = (E3.height - i3.height) / 2, N3 = E3.width / 2 - (S3 - h3) * window.devicePixelRatio * l3 - D3 - s3 * l3, B3 = E3.height / 2 - (v3 - x3) * window.devicePixelRatio * l3 - $3 - s3 * l3;
    g3.translate(-N3, -B3), g3.clearRect(-(b3.width / 2 + Se) * window.devicePixelRatio * l3, -(b3.height / 2 + Se) * window.devicePixelRatio * l3, (b3.width + Se * 2) * window.devicePixelRatio * l3, (b3.height + Se * 2) * window.devicePixelRatio * l3);
  }
  return { element: e12, canvas: i3, theme: o3.theme, scale: l3, zoomValue: n3.value, canvasOffsetX: U3, canvasOffsetY: p3, boundTextElementVersion: oe(e12, t3)?.version || null, containingFrameOpacity: We(e12, t3)?.opacity || 100, boundTextCanvas: E3, angle: e12.angle, imageCrop: Ye$1(e12) ? e12.crop : null };
}, H1 = 14, J1$1 = document.createElement("img");
J1$1.src = `data:${H.svg},${encodeURIComponent('<svg aria-hidden="true" focusable="false" data-prefix="fas" data-icon="image" class="svg-inline--fa fa-image fa-w-16" role="img" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><path fill="#888" d="M464 448H48c-26.51 0-48-21.49-48-48V112c0-26.51 21.49-48 48-48h416c26.51 0 48 21.49 48 48v288c0 26.51-21.49 48-48 48zM112 120c-30.928 0-56 25.072-56 56s25.072 56 56 56 56-25.072 56-56-25.072-56-56-56zM64 384h384V272l-87.515-87.515c-4.686-4.686-12.284-4.686-16.971 0L208 320l-55.515-55.515c-4.686-4.686-12.284-4.686-16.971 0L64 336v48z"></path></svg>')}`;
var Y1$1 = document.createElement("img");
Y1$1.src = `data:${H.svg},${encodeURIComponent('<svg viewBox="0 0 668 668" xmlns="http://www.w3.org/2000/svg" xml:space="preserve" style="fill-rule:evenodd;clip-rule:evenodd;stroke-linejoin:round;stroke-miterlimit:2"><path d="M464 448H48c-26.51 0-48-21.49-48-48V112c0-26.51 21.49-48 48-48h416c26.51 0 48 21.49 48 48v288c0 26.51-21.49 48-48 48ZM112 120c-30.928 0-56 25.072-56 56s25.072 56 56 56 56-25.072 56-56-25.072-56-56-56ZM64 384h384V272l-87.515-87.515c-4.686-4.686-12.284-4.686-16.971 0L208 320l-55.515-55.515c-4.686-4.686-12.284-4.686-16.971 0L64 336v48Z" style="fill:#888;fill-rule:nonzero" transform="matrix(.81709 0 0 .81709 124.825 145.825)"/><path d="M256 8C119.034 8 8 119.033 8 256c0 136.967 111.034 248 248 248s248-111.034 248-248S392.967 8 256 8Zm130.108 117.892c65.448 65.448 70 165.481 20.677 235.637L150.47 105.216c70.204-49.356 170.226-44.735 235.638 20.676ZM125.892 386.108c-65.448-65.448-70-165.481-20.677-235.637L361.53 406.784c-70.203 49.356-170.226 44.736-235.638-20.676Z" style="fill:#888;fill-rule:nonzero" transform="matrix(.30366 0 0 .30366 506.822 60.065)"/></svg>')}`;
var Fm = (e12, t3) => {
  t3.fillStyle = "#E7E7E7", t3.fillRect(0, 0, e12.width, e12.height);
  let n3 = Math.min(e12.width, e12.height), r3 = Math.min(n3, Math.min(n3 * 0.4, 100));
  t3.drawImage(e12.status === "error" ? Y1$1 : J1$1, e12.width / 2 - r3 / 2, e12.height / 2 - r3 / 2, r3, r3);
}, ni = (e12, t3, n3, r3, o3) => {
  switch (e12.type) {
    case "rectangle":
    case "iframe":
    case "embeddable":
    case "diamond":
    case "ellipse": {
      n3.lineJoin = "round", n3.lineCap = "round", t3.draw(he.get(e12));
      break;
    }
    case "arrow":
    case "line": {
      n3.lineJoin = "round", n3.lineCap = "round", he.get(e12).forEach((i3) => {
        t3.draw(i3);
      });
      break;
    }
    case "freedraw": {
      n3.save(), n3.fillStyle = e12.strokeColor;
      let i3 = Bm(e12), a3 = he.get(e12);
      a3 && t3.draw(a3), n3.fillStyle = e12.strokeColor, n3.fill(i3), n3.restore();
      break;
    }
    case "image": {
      let i3 = At(e12) ? r3.imageCache.get(e12.fileId)?.image : void 0;
      if (i3 != null && !(i3 instanceof Promise)) {
        e12.roundness && n3.roundRect && (n3.beginPath(), n3.roundRect(0, 0, e12.width, e12.height, it$1(Math.min(e12.width, e12.height), e12)), n3.clip());
        let { x: a3, y: s3, width: d3, height: c3 } = e12.crop ? e12.crop : { x: 0, y: 0, width: i3.naturalWidth, height: i3.naturalHeight };
        n3.drawImage(i3, a3, s3, d3, c3, 0, 0, e12.width, e12.height);
      } else Fm(e12, n3);
      break;
    }
    default:
      if (k$2(e12)) {
        let i3 = Po(e12.text), a3 = i3 && !n3.canvas.isConnected;
        a3 && document.body.appendChild(n3.canvas), n3.canvas.setAttribute("dir", i3 ? "rtl" : "ltr"), n3.save(), n3.font = Ee(e12), n3.fillStyle = e12.strokeColor, n3.textAlign = e12.textAlign;
        let s3 = e12.text.replace(/\r\n?/g, `
`).split(`
`), d3 = e12.textAlign === "center" ? e12.width / 2 : e12.textAlign === "right" ? e12.width : 0, c3 = Zn(e12.fontSize, e12.lineHeight), l3 = Go(e12.fontFamily, e12.fontSize, c3);
        for (let U3 = 0; U3 < s3.length; U3++) n3.fillText(s3[U3], d3, U3 * c3 + l3);
        n3.restore(), a3 && n3.canvas.remove();
      } else throw new Error(`Unimplemented type ${e12.type}`);
  }
}, Jo = /* @__PURE__ */ new WeakMap(), F1$1 = (e12, t3, n3, r3) => {
  let o3 = n3 ? r3.zoom : $m.zoom, i3 = Jo.get(e12), a3 = i3 && i3.zoomValue !== o3.value && !r3?.shouldCacheIgnoreZoom, s3 = oe(e12, t3), d3 = s3?.version || null, c3 = Ye$1(e12) ? e12.crop : null, l3 = We(e12, t3)?.opacity || 100;
  if (!i3 || a3 || i3.theme !== r3.theme || i3.boundTextElementVersion !== d3 || i3.imageCrop !== c3 || i3.containingFrameOpacity !== l3 || ee(e12) && s3 && e12.angle !== i3.angle) {
    let U3 = K1$1(e12, t3, o3, n3, r3);
    return U3 ? (Jo.set(e12, U3), U3) : null;
  }
  return i3;
}, ya = (e12, t3, n3, r3, o3) => {
  let i3 = e12.element, a3 = ri(i3), s3 = e12.scale, [d3, c3, l3, U3] = C$1(i3, o3), p3 = ((d3 + l3) / 2 + r3.scrollX) * window.devicePixelRatio, m3 = ((c3 + U3) / 2 + r3.scrollY) * window.devicePixelRatio;
  t3.save(), t3.scale(1 / window.devicePixelRatio, 1 / window.devicePixelRatio);
  let b3 = oe(i3, o3);
  if (ee(i3) && b3) {
    let E3 = (e12.boundTextCanvas.width - e12.canvas.width) / 2, g3 = (e12.boundTextCanvas.height - e12.canvas.height) / 2;
    t3.translate(p3, m3), t3.drawImage(e12.boundTextCanvas, -(l3 - d3) / 2 * window.devicePixelRatio - E3 / s3 - a3, -(U3 - c3) / 2 * window.devicePixelRatio - g3 / s3 - a3, e12.boundTextCanvas.width / s3, e12.boundTextCanvas.height / s3);
  } else if (t3.translate(p3, m3), t3.rotate(i3.angle), "scale" in e12.element && !O1$1(i3, n3) && t3.scale(e12.element.scale[0], e12.element.scale[1]), t3.translate(-p3, -m3), t3.drawImage(e12.canvas, (d3 + r3.scrollX) * window.devicePixelRatio - a3 * e12.scale / e12.scale, (c3 + r3.scrollY) * window.devicePixelRatio - a3 * e12.scale / e12.scale, e12.canvas.width / e12.scale, e12.canvas.height / e12.scale), c$1.VITE_APP_DEBUG_ENABLE_TEXT_CONTAINER_BOUNDING_BOX === "true") ;
  t3.restore();
}, vP = (e12, t3, n3, r3) => {
  t3.save(), t3.translate(e12.x + n3.scrollX, e12.y + n3.scrollY), t3.fillStyle = "rgba(0, 0, 200, 0.04)";
  let o3 = 0.5 / n3.zoom.value;
  t3.fillRect(o3, o3, e12.width, e12.height), t3.lineWidth = 1 / n3.zoom.value, t3.strokeStyle = r3, t3.strokeRect(o3, o3, e12.width, e12.height), t3.restore();
}, Fn = (e12, t3, n3, r3, o3, i3, a3) => {
  let s3 = a3.openDialog?.name === "elementLinkSelector" && !a3.selectedElementIds[e12.id] && !a3.hoveredElementIds[e12.id];
  switch (o3.globalAlpha = Pm(e12, We(e12, t3), i3.elementsPendingErasure, i3.pendingFlowchartNodes, s3 ? zs : 1), e12.type) {
    case "magicframe":
    case "frame": {
      a3.frameRendering.enabled && a3.frameRendering.outline && (o3.save(), o3.translate(e12.x + a3.scrollX, e12.y + a3.scrollY), o3.fillStyle = "rgba(0, 0, 200, 0.04)", o3.lineWidth = Pe$1.strokeWidth / a3.zoom.value, o3.strokeStyle = Pe$1.strokeColor, yd$1(e12) && (o3.strokeStyle = a3.theme === ke.LIGHT ? "#7affd7" : "#1d8264"), o3.roundRect ? (o3.beginPath(), o3.roundRect(0, 0, e12.width, e12.height, Pe$1.radius / a3.zoom.value), o3.stroke(), o3.closePath()) : o3.strokeRect(0, 0, e12.width, e12.height), o3.restore());
      break;
    }
    case "freedraw": {
      if (he.generateElementShape(e12, null), i3.isExporting) {
        let [d3, c3, l3, U3] = C$1(e12, t3), p3 = (d3 + l3) / 2 + a3.scrollX, m3 = (c3 + U3) / 2 + a3.scrollY, b3 = (l3 - d3) / 2 - (e12.x - d3), E3 = (U3 - c3) / 2 - (e12.y - c3);
        o3.save(), o3.translate(p3, m3), o3.rotate(e12.angle), o3.translate(-b3, -E3), ni(e12, r3, o3, i3), o3.restore();
      } else {
        let d3 = F1$1(e12, n3, i3, a3);
        if (!d3) return;
        ya(d3, o3, i3, a3, n3);
      }
      break;
    }
    case "rectangle":
    case "diamond":
    case "ellipse":
    case "line":
    case "arrow":
    case "image":
    case "text":
    case "iframe":
    case "embeddable": {
      if (he.generateElementShape(e12, i3), i3.isExporting) {
        let [d3, c3, l3, U3] = C$1(e12, t3), p3 = (d3 + l3) / 2 + a3.scrollX, m3 = (c3 + U3) / 2 + a3.scrollY, b3 = (l3 - d3) / 2 - (e12.x - d3), E3 = (U3 - c3) / 2 - (e12.y - c3);
        if (k$2(e12)) {
          let h3 = qe(e12, t3);
          if (ee(h3)) {
            let x3 = z$1.getBoundTextElementPosition(h3, e12, t3);
            b3 = (l3 - d3) / 2 - (x3.x - d3), E3 = (U3 - c3) / 2 - (x3.y - c3);
          }
        }
        o3.save(), o3.translate(p3, m3), A1$1(e12, i3, a3) && (o3.filter = "none");
        let g3 = oe(e12, t3);
        if (ee(e12) && g3) {
          let h3 = document.createElement("canvas"), x3 = h3.getContext("2d"), y3 = Math.max(dt(d3, l3), dt(c3, U3)), w3 = ri(e12);
          h3.width = y3 * a3.exportScale + w3 * 10 * a3.exportScale, h3.height = y3 * a3.exportScale + w3 * 10 * a3.exportScale, x3.translate(h3.width / 2, h3.height / 2), x3.scale(a3.exportScale, a3.exportScale), b3 = e12.width / 2 - (e12.x - d3), E3 = e12.height / 2 - (e12.y - c3), x3.rotate(e12.angle);
          let I3 = q5.canvas(h3);
          x3.translate(-b3, -E3), ni(e12, I3, x3, i3), x3.translate(b3, E3), x3.rotate(-e12.angle);
          let [, , , , S3, v3] = C$1(g3, t3), D3 = (d3 + l3) / 2 - S3, $3 = (c3 + U3) / 2 - v3;
          x3.translate(-D3, -$3), x3.clearRect(-g3.width / 2, -g3.height / 2, g3.width, g3.height), o3.scale(1 / a3.exportScale, 1 / a3.exportScale), o3.drawImage(h3, -h3.width / 2, -h3.height / 2, h3.width, h3.height);
        } else o3.rotate(e12.angle), e12.type === "image" && o3.scale(e12.scale[0], e12.scale[1]), o3.translate(-b3, -E3), ni(e12, r3, o3, i3);
        o3.restore();
      } else {
        let d3 = F1$1(e12, n3, i3, a3);
        if (!d3) return;
        let c3 = o3.imageSmoothingEnabled;
        if (!a3?.shouldCacheIgnoreZoom && (!e12.angle || od$1(e12.angle)) && (o3.imageSmoothingEnabled = false), e12.id === a3.croppingElementId && Ye$1(d3.element) && d3.element.crop !== null) {
          o3.save(), o3.globalAlpha = 0.1;
          let l3 = K1$1(N1$1(d3.element, t3), n3, a3.zoom, i3, a3);
          l3 && ya(l3, o3, i3, a3, n3), o3.restore();
        }
        ya(d3, o3, i3, a3, n3), o3.imageSmoothingEnabled = c3;
      }
      break;
    }
    default:
      throw new Error(`Unimplemented type ${e12.type}`);
  }
  o3.globalAlpha = 1;
}, C1$1 = /* @__PURE__ */ new WeakMap([]);
function V1$1(e12) {
  let t3 = wa(e12), n3 = new Path2D(t3);
  return C1$1.set(e12, n3), n3;
}
function Bm(e12) {
  return C1$1.get(e12);
}
function wa(e12) {
  let t3 = e12.simulatePressure ? e12.points : e12.points.length ? e12.points.map(([r3, o3], i3) => [r3, o3, e12.pressures[i3]]) : [[0, 0, 0.5]], n3 = { simulatePressure: e12.simulatePressure, size: e12.strokeWidth * 4.25, thinning: 0.6, smoothing: 0.5, streamline: 0.5, easing: (r3) => Math.sin(r3 * Math.PI / 2), last: !!e12.lastCommittedPoint };
  return Om(ae$1(t3, n3));
}
function B1(e12, t3) {
  return [(e12[0] + t3[0]) / 2, (e12[1] + t3[1]) / 2];
}
var _m = /(\s?[A-Z]?,?-?[0-9]*\.[0-9]{0,2})(([0-9]|e|-)*)/g;
function Om(e12) {
  if (!e12.length) return "";
  let t3 = e12.length - 1;
  return e12.reduce((n3, r3, o3, i3) => (o3 === t3 ? n3.push(r3, B1(r3, i3[0]), "L", i3[0], "Z") : n3.push(r3, B1(r3, i3[o3 + 1])), n3), ["M", e12[0], "Q"]).join(" ").replace(_m, "$1");
}
var Am = (e12) => e12 === "rectangle" || e12 === "iframe" || e12 === "embeddable" || e12 === "ellipse" || e12 === "diamond" || e12 === "line" || e12 === "freedraw", NP = (e12) => e12 !== "image" && e12 !== "frame" && e12 !== "magicframe", Km = (e12) => e12 === "rectangle" || e12 === "iframe" || e12 === "embeddable" || e12 === "ellipse" || e12 === "diamond" || e12 === "freedraw" || e12 === "arrow" || e12 === "line", Hm = (e12) => e12 === "rectangle" || e12 === "iframe" || e12 === "embeddable" || e12 === "ellipse" || e12 === "diamond" || e12 === "arrow" || e12 === "line", Ta = (e12) => e12 === "rectangle" || e12 === "iframe" || e12 === "embeddable" || e12 === "line" || e12 === "diamond" || e12 === "image", FP = (e12) => e12 === "arrow", Jm = (e12) => e12 === "arrow";
var Re = [1, 0], Fe$1 = [0, 1], nt = [-1, 0], ze$1 = [0, -1], oi = (e12, t3) => {
  let n3 = rd$1(Math.atan2(t3[1] - e12[1], t3[0] - e12[0]));
  return n3 >= 315 || n3 < 45 ? ze$1 : n3 >= 45 && n3 < 135 ? Re : n3 >= 135 && n3 < 225 ? Fe$1 : nt;
}, Ht$1 = (e12) => {
  let [t3, n3] = e12, r3 = Math.abs(t3), o3 = Math.abs(n3);
  return t3 > o3 ? Re : t3 <= -o3 ? nt : n3 > r3 ? Fe$1 : ze$1;
}, tr = (e12, t3) => Ht$1(O(e12, t3)), Mt = (e12, t3) => Lt(tr(e12, t3)), ve$1 = (e12, t3) => e12[0] === t3[0] && e12[1] === t3[1], Lt = (e12) => ve$1(e12, Re) || ve$1(e12, nt);
var q1 = (e12, t3, n3) => {
  let o3 = Kr(t3);
  if (e12.type === "diamond") {
    if (n3[0] < e12.x) return nt;
    if (n3[1] < e12.y) return ze$1;
    if (n3[0] > e12.x + e12.width) return Re;
    if (n3[1] > e12.y + e12.height) return Fe$1;
    let c3 = T$1(bt(u$1(e12.x + e12.width / 2, e12.y), o3, 2), o3, e12.angle), l3 = T$1(bt(u$1(e12.x + e12.width, e12.y + e12.height / 2), o3, 2), o3, e12.angle), U3 = T$1(bt(u$1(e12.x + e12.width / 2, e12.y + e12.height), o3, 2), o3, e12.angle), p3 = T$1(bt(u$1(e12.x, e12.y + e12.height / 2), o3, 2), o3, e12.angle);
    return Ln$1([c3, l3, o3], n3) ? oi(c3, l3) : Ln$1([l3, U3, o3], n3) ? oi(l3, U3) : Ln$1([U3, p3, o3], n3) ? oi(U3, p3) : oi(p3, c3);
  }
  let i3 = bt(u$1(t3[0], t3[1]), o3, 2), a3 = bt(u$1(t3[2], t3[1]), o3, 2), s3 = bt(u$1(t3[0], t3[3]), o3, 2), d3 = bt(u$1(t3[2], t3[3]), o3, 2);
  return Ln$1([i3, a3, o3], n3) ? ze$1 : Ln$1([a3, d3, o3], n3) ? Re : Ln$1([d3, s3, o3], n3) ? Fe$1 : nt;
}, Ma$1 = (e12) => [e12[0] === 0 ? 0 : e12[0] > 0 ? -1 : 1, e12[1] === 0 ? 0 : e12[1] > 0 ? -1 : 1];
var Cm = (e12) => [8, 8 + e12], k1 = (e12) => [1.5, 6 + e12];
function Vm(e12) {
  let t3 = e12.roughness, n3 = Math.max(e12.width, e12.height), r3 = Math.min(e12.width, e12.height);
  return r3 >= 20 && n3 >= 50 || r3 >= 15 && e12.roundness && Ta(e12.type) || ae(e12) && n3 >= 50 ? t3 : Math.min(t3 / (n3 < 10 ? 3 : 2), 2.5);
}
var rt = (e12, t3 = false) => {
  let n3 = { seed: e12.seed, strokeLineDash: e12.strokeStyle === "dashed" ? Cm(e12.strokeWidth) : e12.strokeStyle === "dotted" ? k1(e12.strokeWidth) : void 0, disableMultiStroke: e12.strokeStyle !== "solid", strokeWidth: e12.strokeStyle !== "solid" ? e12.strokeWidth + 0.5 : e12.strokeWidth, fillWeight: e12.strokeWidth / 2, hachureGap: e12.strokeWidth * 4, roughness: Vm(e12), stroke: e12.strokeColor, preserveVertices: t3 || e12.roughness < Gi.cartoonist };
  switch (e12.type) {
    case "rectangle":
    case "iframe":
    case "embeddable":
    case "diamond":
    case "ellipse":
      return n3.fillStyle = e12.fillStyle, n3.fill = Wt(e12.backgroundColor) ? void 0 : e12.backgroundColor, e12.type === "ellipse" && (n3.curveFitting = 1), n3;
    case "line":
    case "freedraw":
      return Kt(e12.points) && (n3.fillStyle = e12.fillStyle, n3.fill = e12.backgroundColor === "transparent" ? void 0 : e12.backgroundColor), n3;
    case "arrow":
      return n3;
    default:
      throw new Error(`Unimplemented type ${e12.type}`);
  }
}, X1$1 = (e12, t3, n3) => gt$1(e12) && (t3 || Bo(e12) && n3?.get(e12.id) !== true) && Wt(e12.backgroundColor) && Wt(e12.strokeColor) ? { ...e12, roughness: 0, backgroundColor: "#d3d3d3", fillStyle: "solid" } : _o$1(e12) ? { ...e12, strokeColor: Wt(e12.strokeColor) ? "#000000" : e12.strokeColor, backgroundColor: Wt(e12.backgroundColor) ? "#f4f4f6" : e12.backgroundColor } : e12, G1$1 = (e12, t3, n3, r3, o3, i3, a3) => {
  let s3 = ii(e12, t3, n3, r3);
  if (s3 === null) return [];
  let d3 = (c3, l3) => {
    if (c3 === null) return [];
    let [, , U3, p3, m3, b3] = c3;
    return [o3.line(U3, p3, m3, b3, l3)];
  };
  switch (r3) {
    case "dot":
    case "circle":
    case "circle_outline": {
      let [c3, l3, U3] = s3;
      return delete i3.strokeLineDash, [o3.circle(c3, l3, U3, { ...i3, fill: r3 === "circle_outline" ? a3 : e12.strokeColor, fillStyle: "solid", stroke: e12.strokeColor, roughness: Math.min(0.5, i3.roughness || 0) })];
    }
    case "triangle":
    case "triangle_outline": {
      let [c3, l3, U3, p3, m3, b3] = s3;
      return delete i3.strokeLineDash, [o3.polygon([[c3, l3], [U3, p3], [m3, b3], [c3, l3]], { ...i3, fill: r3 === "triangle_outline" ? a3 : e12.strokeColor, fillStyle: "solid", roughness: Math.min(1, i3.roughness || 0) })];
    }
    case "diamond":
    case "diamond_outline": {
      let [c3, l3, U3, p3, m3, b3, E3, g3] = s3;
      return delete i3.strokeLineDash, [o3.polygon([[c3, l3], [U3, p3], [m3, b3], [E3, g3], [c3, l3]], { ...i3, fill: r3 === "diamond_outline" ? a3 : e12.strokeColor, fillStyle: "solid", roughness: Math.min(1, i3.roughness || 0) })];
    }
    case "crowfoot_one":
      return d3(s3, i3);
    case "bar":
    case "arrow":
    case "crowfoot_many":
    case "crowfoot_one_or_many":
    default: {
      let [c3, l3, U3, p3, m3, b3] = s3;
      if (e12.strokeStyle === "dotted") {
        let E3 = k1(e12.strokeWidth - 1);
        i3.strokeLineDash = [E3[0], E3[1] - 1];
      } else delete i3.strokeLineDash;
      return i3.roughness = Math.min(1, i3.roughness || 0), [o3.line(U3, p3, c3, l3, i3), o3.line(m3, b3, c3, l3, i3), ...r3 === "crowfoot_one_or_many" ? d3(ii(e12, t3, n3, "crowfoot_one"), i3) : []];
    }
  }
}, vd$1 = (e12, t3, { isExporting: n3, canvasBackgroundColor: r3, embedsValidationStatus: o3 }) => {
  switch (e12.type) {
    case "rectangle":
    case "iframe":
    case "embeddable": {
      let i3;
      if (e12.roundness) {
        let a3 = e12.width, s3 = e12.height, d3 = it$1(Math.min(a3, s3), e12);
        i3 = t3.path(`M ${d3} 0 L ${a3 - d3} 0 Q ${a3} 0, ${a3} ${d3} L ${a3} ${s3 - d3} Q ${a3} ${s3}, ${a3 - d3} ${s3} L ${d3} ${s3} Q 0 ${s3}, 0 ${s3 - d3} L 0 ${d3} Q 0 0, ${d3} 0`, rt(X1$1(e12, n3, o3), true));
      } else i3 = t3.rectangle(0, 0, e12.width, e12.height, rt(X1$1(e12, n3, o3), false));
      return i3;
    }
    case "diamond": {
      let i3, [a3, s3, d3, c3, l3, U3, p3, m3] = Or(e12);
      if (e12.roundness) {
        let b3 = it$1(Math.abs(a3 - p3), e12), E3 = it$1(Math.abs(c3 - s3), e12);
        i3 = t3.path(`M ${a3 + b3} ${s3 + E3} L ${d3 - b3} ${c3 - E3}
            C ${d3} ${c3}, ${d3} ${c3}, ${d3 - b3} ${c3 + E3}
            L ${l3 + b3} ${U3 - E3}
            C ${l3} ${U3}, ${l3} ${U3}, ${l3 - b3} ${U3 - E3}
            L ${p3 + b3} ${m3 + E3}
            C ${p3} ${m3}, ${p3} ${m3}, ${p3 + b3} ${m3 - E3}
            L ${a3 - b3} ${s3 + E3}
            C ${a3} ${s3}, ${a3} ${s3}, ${a3 + b3} ${s3 + E3}`, rt(e12, true));
      } else i3 = t3.polygon([[a3, s3], [d3, c3], [l3, U3], [p3, m3]], rt(e12));
      return i3;
    }
    case "ellipse":
      return t3.ellipse(e12.width / 2, e12.height / 2, e12.width, e12.height, rt(e12));
    case "line":
    case "arrow": {
      let i3, a3 = rt(e12), s3 = e12.points.length ? e12.points : [u$1(0, 0)];
      if (X$1(e12) ? s3.every((d3) => Math.abs(d3[0]) <= 1e6 && Math.abs(d3[1]) <= 1e6) ? i3 = [t3.path(qm(s3, 16), rt(e12, true))] : (console.error("Elbow arrow with extreme point positions detected. Arrow not rendered.", e12.id, JSON.stringify(s3)), i3 = []) : e12.roundness ? i3 = [t3.curve(s3, a3)] : a3.fill ? i3 = [t3.polygon(s3, a3)] : i3 = [t3.linearPath(s3, a3)], e12.type === "arrow") {
        let { startArrowhead: d3 = null, endArrowhead: c3 = "arrow" } = e12;
        if (d3 !== null) {
          let l3 = G1$1(e12, i3, "start", d3, t3, a3, r3);
          i3.push(...l3);
        }
        if (c3 !== null) {
          let l3 = G1$1(e12, i3, "end", c3, t3, a3, r3);
          i3.push(...l3);
        }
      }
      return i3;
    }
    case "freedraw": {
      let i3;
      if (V1$1(e12), Kt(e12.points)) {
        let a3 = simplify(e12.points, 0.75);
        i3 = t3.curve(a3, { ...rt(e12), stroke: "none" });
      } else i3 = null;
      return i3;
    }
    case "frame":
    case "magicframe":
    case "text":
    case "image":
      return null;
    default:
      return Sn$1(e12, `generateElementShape(): Unimplemented type ${e12?.type}`), null;
  }
}, qm = (e12, t3) => {
  let n3 = [];
  for (let o3 = 1; o3 < e12.length - 1; o3 += 1) {
    let i3 = e12[o3 - 1], a3 = e12[o3 + 1], s3 = e12[o3], d3 = Mt(s3, i3), c3 = Mt(a3, s3), l3 = Math.min(t3, ie(e12[o3], a3) / 2, ie(e12[o3], i3) / 2);
    d3 ? i3[0] < s3[0] ? n3.push([e12[o3][0] - l3, e12[o3][1]]) : n3.push([e12[o3][0] + l3, e12[o3][1]]) : i3[1] < s3[1] ? n3.push([e12[o3][0], e12[o3][1] - l3]) : n3.push([e12[o3][0], e12[o3][1] + l3]), n3.push(e12[o3]), c3 ? a3[0] < s3[0] ? n3.push([e12[o3][0] - l3, e12[o3][1]]) : n3.push([e12[o3][0] + l3, e12[o3][1]]) : a3[1] < s3[1] ? n3.push([e12[o3][0], e12[o3][1] - l3]) : n3.push([e12[o3][0], e12[o3][1] + l3]);
  }
  let r3 = [`M ${e12[0][0]} ${e12[0][1]}`];
  for (let o3 = 0; o3 < n3.length; o3 += 3) r3.push(`L ${n3[o3][0]} ${n3[o3][1]}`), r3.push(`Q ${n3[o3 + 1][0]} ${n3[o3 + 1][1]}, ${n3[o3 + 2][0]} ${n3[o3 + 2][1]}`);
  return r3.push(`L ${e12[e12.length - 1][0]} ${e12[e12.length - 1][1]}`), r3.join(" ");
};
var xn = (e12) => {
  let t3 = e12.map((r3) => r3[0]), n3 = e12.map((r3) => r3[1]);
  return { width: Math.max(...t3) - Math.min(...t3), height: Math.max(...n3) - Math.min(...n3) };
}, nr = (e12, t3, n3, r3) => {
  let o3 = n3.map((m3) => m3[e12]), i3 = Math.max(...o3), a3 = Math.min(...o3), s3 = i3 - a3, d3 = s3 === 0 ? 1 : t3 / s3, c3 = 1 / 0, l3 = n3.map((m3) => {
    let b3 = m3[e12] * d3, E3 = [...m3];
    return E3[e12] = b3, b3 < c3 && (c3 = b3), E3;
  });
  if (!r3 || l3.length === 2) return l3;
  let U3 = a3 - c3;
  return l3.map((m3) => m3.map((b3, E3) => E3 === e12 ? b3 + U3 : b3));
};
var rr$1 = class rr {
  static getBounds(t3, n3) {
    let r3 = rr.boundsCache.get(t3);
    if (r3?.version && r3.version === t3.version && !Ne(t3)) return r3.bounds;
    let o3 = rr.calculateBounds(t3, n3);
    return rr.boundsCache.set(t3, { version: t3.version, bounds: o3 }), o3;
  }
  static calculateBounds(t3, n3) {
    let r3, [o3, i3, a3, s3, d3, c3] = C$1(t3, n3);
    if (Ce$1(t3)) {
      let [l3, U3, p3, m3] = va(t3.points.map(([b3, E3]) => T$1(u$1(b3, E3), u$1(d3 - t3.x, c3 - t3.y), t3.angle)));
      return [l3 + t3.x, U3 + t3.y, p3 + t3.x, m3 + t3.y];
    } else if (ae(t3)) r3 = zm(t3, d3, c3, n3);
    else if (t3.type === "diamond") {
      let [l3, U3] = T$1(u$1(d3, i3), u$1(d3, c3), t3.angle), [p3, m3] = T$1(u$1(d3, s3), u$1(d3, c3), t3.angle), [b3, E3] = T$1(u$1(o3, c3), u$1(d3, c3), t3.angle), [g3, h3] = T$1(u$1(a3, c3), u$1(d3, c3), t3.angle), x3 = Math.min(l3, p3, b3, g3), y3 = Math.min(U3, m3, E3, h3), w3 = Math.max(l3, p3, b3, g3), I3 = Math.max(U3, m3, E3, h3);
      r3 = [x3, y3, w3, I3];
    } else if (t3.type === "ellipse") {
      let l3 = (a3 - o3) / 2, U3 = (s3 - i3) / 2, p3 = Math.cos(t3.angle), m3 = Math.sin(t3.angle), b3 = Math.hypot(l3 * p3, U3 * m3), E3 = Math.hypot(U3 * p3, l3 * m3);
      r3 = [d3 - b3, c3 - E3, d3 + b3, c3 + E3];
    } else {
      let [l3, U3] = T$1(u$1(o3, i3), u$1(d3, c3), t3.angle), [p3, m3] = T$1(u$1(o3, s3), u$1(d3, c3), t3.angle), [b3, E3] = T$1(u$1(a3, s3), u$1(d3, c3), t3.angle), [g3, h3] = T$1(u$1(a3, i3), u$1(d3, c3), t3.angle), x3 = Math.min(l3, p3, b3, g3), y3 = Math.min(U3, m3, E3, h3), w3 = Math.max(l3, p3, b3, g3), I3 = Math.max(U3, m3, E3, h3);
      r3 = [x3, y3, w3, I3];
    }
    return r3;
  }
};
i$1(rr$1, "boundsCache", /* @__PURE__ */ new WeakMap());
var La = rr$1, C$1 = (e12, t3, n3 = false) => {
  if (Ce$1(e12)) return Gm(e12);
  if (ae(e12)) return z$1.getElementAbsoluteCoords(e12, t3, n3);
  if (k$2(e12)) {
    let r3 = t3 ? qe(e12, t3) : null;
    if (ee(r3)) {
      let { x: o3, y: i3 } = z$1.getBoundTextElementPosition(r3, e12, t3);
      return [o3, i3, o3 + e12.width, i3 + e12.height, o3 + e12.width / 2, i3 + e12.height / 2];
    }
  }
  return [e12.x, e12.y, e12.x + e12.width, e12.y + e12.height, e12.x + e12.width / 2, e12.y + e12.height / 2];
}, Sa = (e12, t3) => {
  let [n3, r3, o3, i3, a3, s3] = C$1(e12, t3), d3 = u$1(a3, s3);
  if (ae(e12) || Ce$1(e12)) {
    let h3 = [], x3 = 0;
    for (; x3 < e12.points.length - 1; ) h3.push(A$1(T$1(u$1(e12.points[x3][0] + e12.x, e12.points[x3][1] + e12.y), d3, e12.angle), T$1(u$1(e12.points[x3 + 1][0] + e12.x, e12.points[x3 + 1][1] + e12.y), d3, e12.angle))), x3++;
    return h3;
  }
  let [c3, l3, U3, p3, m3, b3, E3, g3] = [[n3, r3], [o3, r3], [n3, i3], [o3, i3], [a3, r3], [a3, i3], [n3, s3], [o3, s3]].map((h3) => T$1(h3, d3, e12.angle));
  return e12.type === "diamond" ? [A$1(m3, E3), A$1(m3, g3), A$1(b3, E3), A$1(b3, g3)] : e12.type === "ellipse" ? [A$1(m3, E3), A$1(m3, g3), A$1(b3, E3), A$1(b3, g3), A$1(m3, E3), A$1(m3, g3), A$1(b3, E3), A$1(b3, g3)] : [A$1(c3, l3), A$1(U3, p3), A$1(c3, U3), A$1(l3, p3), A$1(c3, g3), A$1(U3, g3), A$1(l3, E3), A$1(p3, E3)];
};
var Or = (e12) => {
  let t3 = Math.floor(e12.width / 2) + 1, n3 = 0, r3 = e12.width, o3 = Math.floor(e12.height / 2) + 1, i3 = t3, a3 = e12.height;
  return [t3, n3, r3, o3, i3, a3, 0, o3];
}, Z1$1 = (e12, t3, n3, r3, o3) => {
  let i3 = 1 - e12;
  return Math.pow(i3, 3) * t3 + 3 * Math.pow(i3, 2) * e12 * n3 + 3 * i3 * Math.pow(e12, 2) * r3 + Math.pow(e12, 3) * o3;
}, W1$1 = (e12, t3, n3, r3) => {
  let o3 = t3 - e12, i3 = n3 - t3, a3 = r3 - n3, s3 = 3 * o3 - 6 * i3 + 3 * a3, d3 = 6 * i3 - 6 * o3, c3 = 3 * o3, l3 = d3 * d3 - 4 * s3 * c3;
  if (!(l3 >= 0)) return false;
  let p3 = null, m3 = null, b3 = 1 / 0, E3 = 1 / 0;
  return s3 === 0 ? b3 = E3 = -c3 / d3 : (b3 = (-d3 + Math.sqrt(l3)) / (2 * s3), E3 = (-d3 - Math.sqrt(l3)) / (2 * s3)), b3 >= 0 && b3 <= 1 && (p3 = Z1$1(b3, e12, t3, n3, r3)), E3 >= 0 && E3 <= 1 && (m3 = Z1$1(E3, e12, t3, n3, r3)), [p3, m3];
}, Xm = (e12, t3, n3, r3) => {
  let o3 = W1$1(e12[0], t3[0], n3[0], r3[0]), i3 = W1$1(e12[1], t3[1], n3[1], r3[1]), a3 = Math.min(e12[0], r3[0]), s3 = Math.max(e12[0], r3[0]);
  if (o3) {
    let l3 = o3.filter((U3) => U3 !== null);
    a3 = Math.min(a3, ...l3), s3 = Math.max(s3, ...l3);
  }
  let d3 = Math.min(e12[1], r3[1]), c3 = Math.max(e12[1], r3[1]);
  if (i3) {
    let l3 = i3.filter((U3) => U3 !== null);
    d3 = Math.min(d3, ...l3), c3 = Math.max(c3, ...l3);
  }
  return [a3, d3, s3, c3];
}, Hr = (e12, t3) => {
  let n3 = u$1(0, 0), { minX: r3, minY: o3, maxX: i3, maxY: a3 } = e12.reduce((s3, { op: d3, data: c3 }) => {
    if (d3 === "move") {
      let l3 = Ir$1(c3);
      Ae(l3 != null, "Op data is not a point"), n3 = l3;
    } else if (d3 === "bcurveTo") {
      let l3 = u$1(c3[0], c3[1]), U3 = u$1(c3[2], c3[3]), p3 = u$1(c3[4], c3[5]), m3 = t3 ? t3(l3) : l3, b3 = t3 ? t3(U3) : U3, E3 = t3 ? t3(p3) : p3, g3 = t3 ? t3(n3) : n3;
      n3 = p3;
      let [h3, x3, y3, w3] = Xm(g3, m3, b3, E3);
      s3.minX = Math.min(s3.minX, h3), s3.minY = Math.min(s3.minY, x3), s3.maxX = Math.max(s3.maxX, y3), s3.maxY = Math.max(s3.maxY, w3);
    }
    return s3;
  }, { minX: 1 / 0, minY: 1 / 0, maxX: -1 / 0, maxY: -1 / 0 });
  return [r3, o3, i3, a3];
}, va = (e12) => {
  let t3 = 1 / 0, n3 = 1 / 0, r3 = -1 / 0, o3 = -1 / 0;
  for (let [i3, a3] of e12) t3 = Math.min(t3, i3), n3 = Math.min(n3, a3), r3 = Math.max(r3, i3), o3 = Math.max(o3, a3);
  return [t3, n3, r3, o3];
}, Gm = (e12) => {
  let [t3, n3, r3, o3] = va(e12.points), i3 = t3 + e12.x, a3 = n3 + e12.y, s3 = r3 + e12.x, d3 = o3 + e12.y;
  return [i3, a3, s3, d3, (i3 + s3) / 2, (a3 + d3) / 2];
}, km = (e12) => {
  switch (e12) {
    case "arrow":
      return 25;
    case "diamond":
    case "diamond_outline":
      return 12;
    case "crowfoot_many":
    case "crowfoot_one":
    case "crowfoot_one_or_many":
      return 20;
    default:
      return 15;
  }
}, Zm = (e12) => {
  switch (e12) {
    case "bar":
      return 90;
    case "arrow":
      return 20;
    default:
      return 25;
  }
}, ii = (e12, t3, n3, r3) => {
  if (t3.length < 1) return null;
  let o3 = It(t3[0]);
  if (o3.length < 1) return null;
  let i3 = n3 === "start" ? 1 : o3.length - 1, a3 = o3[i3].data;
  Ae(a3.length === 6, "Op data length is not 6");
  let s3 = u$1(a3[4], a3[5]), d3 = u$1(a3[2], a3[3]), c3 = u$1(a3[0], a3[1]), l3 = o3[i3 - 1], U3 = u$1(0, 0);
  if (l3.op === "move") {
    let V3 = Ir$1(l3.data);
    Ae(V3 != null, "Op data is not a point"), U3 = V3;
  } else l3.op === "bcurveTo" && (U3 = u$1(l3.data[4], l3.data[5]));
  let p3 = (V3, ce2) => Math.pow(1 - V3, 3) * s3[ce2] + 3 * V3 * Math.pow(1 - V3, 2) * d3[ce2] + 3 * Math.pow(V3, 2) * (1 - V3) * c3[ce2] + U3[ce2] * Math.pow(V3, 3), [m3, b3] = n3 === "start" ? U3 : s3, [E3, g3] = [p3(0.3, 0), p3(0.3, 1)], h3 = Math.hypot(m3 - E3, b3 - g3), x3 = (m3 - E3) / h3, y3 = (b3 - g3) / h3, w3 = km(r3), I3 = 0;
  {
    let [V3, ce2] = n3 === "end" ? e12.points[e12.points.length - 1] : e12.points[0], [J, j] = e12.points.length > 1 ? n3 === "end" ? e12.points[e12.points.length - 2] : e12.points[1] : [0, 0];
    I3 = Math.hypot(V3 - J, ce2 - j);
  }
  let v3 = Math.min(w3, I3 * (r3 === "diamond" || r3 === "diamond_outline" ? 0.25 : 0.5)), D3 = m3 - x3 * v3, $3 = b3 - y3 * v3;
  if (r3 === "dot" || r3 === "circle" || r3 === "circle_outline") {
    let V3 = Math.hypot($3 - b3, D3 - m3) + e12.strokeWidth - 2;
    return [m3, b3, V3];
  }
  let N3 = Zm(r3);
  if (r3 === "crowfoot_many" || r3 === "crowfoot_one_or_many") {
    let [V3, ce2] = T$1(u$1(m3, b3), u$1(D3, $3), yr(-N3)), [J, j] = T$1(u$1(m3, b3), u$1(D3, $3), yr(N3));
    return [D3, $3, V3, ce2, J, j];
  }
  let [B3, _3] = T$1(u$1(D3, $3), u$1(m3, b3), -N3 * Math.PI / 180), [W, be] = T$1(u$1(D3, $3), u$1(m3, b3), yr(N3));
  if (r3 === "diamond" || r3 === "diamond_outline") {
    let V3, ce2;
    if (n3 === "start") {
      let [J, j] = e12.points.length > 1 ? e12.points[1] : [0, 0];
      [V3, ce2] = T$1(u$1(m3 + v3 * 2, b3), u$1(m3, b3), Math.atan2(j - b3, J - m3));
    } else {
      let [J, j] = e12.points.length > 1 ? e12.points[e12.points.length - 2] : [0, 0];
      [V3, ce2] = T$1(u$1(m3 - v3 * 2, b3), u$1(m3, b3), Math.atan2(b3 - j, m3 - J));
    }
    return [m3, b3, B3, _3, V3, ce2, W, be];
  }
  return [m3, b3, B3, _3, W, be];
}, Wm = (e12) => {
  let t3 = q5.generator(), n3 = rt(e12), r3 = e12.roundness ? "curve" : n3.fill ? "polygon" : "linearPath";
  return t3[r3](e12.points, n3);
}, zm = (e12, t3, n3, r3) => {
  let o3 = oe(e12, r3);
  if (e12.points.length < 2) {
    let [U3, p3] = e12.points[0], [m3, b3] = T$1(u$1(e12.x + U3, e12.y + p3), u$1(t3, n3), e12.angle), E3 = [m3, b3, m3, b3];
    if (o3) {
      let g3 = z$1.getMinMaxXYWithBoundText(e12, r3, [m3, b3, m3, b3], o3);
      E3 = [g3[0], g3[1], g3[2], g3[3]];
    }
    return E3;
  }
  let a3 = he.get(e12)?.[0] ?? Wm(e12), s3 = It(a3), c3 = Hr(s3, ([U3, p3]) => T$1(u$1(e12.x + U3, e12.y + p3), u$1(t3, n3), e12.angle)), l3 = [c3[0], c3[1], c3[2], c3[3]];
  if (o3) {
    let U3 = z$1.getMinMaxXYWithBoundText(e12, r3, l3, o3);
    l3 = [U3[0], U3[1], U3[2], U3[3]];
  }
  return l3;
}, Ke$1 = (e12, t3) => La.getBounds(e12, t3), $e$1 = (e12, t3) => {
  if (!e12.length) return [0, 0, 0, 0];
  let n3 = 1 / 0, r3 = -1 / 0, o3 = 1 / 0, i3 = -1 / 0, a3 = t3 || te(e12);
  return e12.forEach((s3) => {
    let [d3, c3, l3, U3] = Ke$1(s3, a3);
    n3 = Math.min(n3, d3), o3 = Math.min(o3, c3), r3 = Math.max(r3, l3), i3 = Math.max(i3, U3);
  }), [n3, o3, r3, i3];
}, ai = (e12, t3) => {
  let [n3, r3, o3, i3] = $e$1(e12);
  return [n3 + t3.x, r3 + t3.y, o3 + t3.x, i3 + t3.y];
}, Rt = (e12, t3, n3, r3) => {
  if (!(ae(e12) || Ce$1(e12))) return [e12.x, e12.y, e12.x + t3, e12.y + n3];
  let o3 = nr(0, t3, nr(1, n3, e12.points, r3), r3), i3;
  if (Ce$1(e12)) i3 = va(o3);
  else {
    let l3 = q5.generator(), U3 = e12.roundness ? l3.curve(o3, rt(e12)) : l3.linearPath(o3, rt(e12)), p3 = It(U3);
    i3 = Hr(p3);
  }
  let [a3, s3, d3, c3] = i3;
  return [a3 + e12.x, s3 + e12.y, d3 + e12.x, c3 + e12.y];
}, $a$1 = (e12, t3) => {
  let n3 = q5.generator(), r3 = e12.roundness == null ? n3.linearPath(t3, rt(e12)) : n3.curve(t3, rt(e12)), o3 = It(r3), [i3, a3, s3, d3] = Hr(o3);
  return [i3 + e12.x, a3 + e12.y, s3 + e12.x, d3 + e12.y];
}, Pa$1 = (e12, t3) => {
  if (!e12.length) return [0, 0, 0, 0];
  let n3 = 1 / 0, r3 = e12[0], o3 = te(e12);
  return e12.forEach((i3) => {
    let [a3, s3, d3, c3] = Ke$1(i3, o3), l3 = ie(u$1((a3 + d3) / 2, (s3 + c3) / 2), u$1(t3.x, t3.y));
    l3 < n3 && (n3 = l3, r3 = i3);
  }), Ke$1(r3, o3);
}, Na$1 = (e12) => {
  let [t3, n3, r3, o3] = $e$1(e12);
  return { minX: t3, minY: n3, maxX: r3, maxY: o3, width: r3 - t3, height: o3 - n3, midX: (t3 + r3) / 2, midY: (n3 + o3) / 2 };
}, fN = ({ scrollX: e12, scrollY: t3, width: n3, height: r3, zoom: o3 }) => [-e12, -t3, -e12 + n3 / o3.value, -t3 + r3 / o3.value], Kr = (e12) => u$1(e12[0] + (e12[2] - e12[0]) / 2, e12[1] + (e12[3] - e12[1]) / 2), z1$1 = (e12, t3) => {
  if (e12 == null || t3 == null) return false;
  let [n3, r3, o3, i3] = e12, [a3, s3, d3, c3] = t3;
  return n3 < d3 && o3 > a3 && r3 < c3 && i3 > s3;
};
var or$1 = (e12, t3) => {
  switch (e12.type) {
    case "rectangle":
    case "image":
    case "text":
    case "iframe":
    case "embeddable":
    case "frame":
    case "magicframe":
      return Qm(e12, t3);
    case "diamond":
      return jm(e12, t3);
    case "ellipse":
      return eb(e12, t3);
  }
}, Qm = (e12, t3) => {
  let n3 = u$1(e12.x + e12.width / 2, e12.y + e12.height / 2), r3 = T$1(t3, n3, -e12.angle), [o3, i3] = Qo$1(e12);
  return Math.min(...o3.map((a3) => vo(r3, a3)), ...i3.map((a3) => zi$1(a3, r3)).filter((a3) => a3 !== null));
}, jm = (e12, t3) => {
  let n3 = u$1(e12.x + e12.width / 2, e12.y + e12.height / 2), r3 = T$1(t3, n3, -e12.angle), [o3, i3] = jo(e12);
  return Math.min(...o3.map((a3) => vo(r3, a3)), ...i3.map((a3) => zi$1(a3, r3)).filter((a3) => a3 !== null));
}, eb = (e12, t3) => {
  let n3 = u$1(e12.x + e12.width / 2, e12.y + e12.height / 2);
  return T1$1(T$1(t3, n3, -e12.angle), zo(n3, e12.width / 2, e12.height / 2));
};
var FN = (e12) => !e12[Q.CTRL_OR_CMD], Fa$1 = (e12) => e12.isBindingEnabled, me$1 = 5, t2 = 10, n2 = 4, tb = (e12, t3) => {
  let n3 = [];
  return t3.forEach((r3) => {
    let o3 = e12.getNonDeletedElement(r3);
    o3 != null && n3.push(o3);
  }), n3;
}, Ba = (e12, t3, n3, r3, o3) => {
  let i3 = /* @__PURE__ */ new Set(), a3 = /* @__PURE__ */ new Set();
  Q1$1(e12, t3, n3, "start", i3, a3, r3), Q1$1(e12, n3, t3, "end", i3, a3, r3);
  let s3 = Array.from(a3).filter((d3) => !i3.has(d3));
  tb(o3, s3).forEach((d3) => {
    Y(d3, { boundElements: d3.boundElements?.filter((c3) => c3.type !== "arrow" || c3.id !== e12.id) });
  });
}, Q1$1 = (e12, t3, n3, r3, o3, i3, a3) => {
  if (t3 !== "keep") {
    if (t3 === null) {
      let s3 = sb(e12, r3);
      s3 != null && i3.add(s3);
      return;
    }
    i2$1(e12) ? (n3 == null || (n3 === "keep" ? !o2$1(e12, t3, r3) : r3 === "start" || n3.id !== t3.id)) && (di(e12, t3, r3, a3), o3.add(t3.id)) : (di(e12, t3, r3, a3), o3.add(t3.id));
  }
}, nb = (e12, t3, n3, r3) => {
  let o3 = c2$1(e12, t3, n3), i3 = t3 === "start" ? e12.startBinding?.elementId : e12.endBinding?.elementId;
  if (i3) {
    let a3 = n3.get(i3);
    if (xt(a3) && si(a3, o3, n3, r3)) return a3;
  }
  return null;
}, r2$1 = (e12, t3, n3) => ["start", "end"].map((r3) => nb(e12, r3, t3, n3)), rb = (e12, t3, n3, r3, o3, i3) => {
  let s3 = e12.points.length - 1, d3 = n3.findIndex((p3) => p3 === 0) > -1, c3 = n3.findIndex((p3) => p3 === s3) > -1, l3 = d3 ? t3 ? ir(e12, "start", r3, o3, i3) : null : X$1(e12) ? "keep" : ir(e12, "start", r3, o3, i3), U3 = c3 ? t3 ? ir(e12, "end", r3, o3, i3) : null : X$1(e12) ? "keep" : ir(e12, "end", r3, o3, i3);
  return [l3, U3];
}, ob = (e12, t3, n3, r3, o3) => {
  if (X$1(e12)) return ["keep", "keep"];
  let [i3, a3] = r2$1(e12, t3, o3), s3 = i3 && r3 ? ir(e12, "start", t3, n3, o3) : null, d3 = a3 && r3 ? ir(e12, "end", t3, n3, o3) : null;
  return [s3, d3];
}, BN = (e12, t3, n3, r3, o3, i3, a3) => {
  e12.forEach((s3) => {
    let [d3, c3] = i3?.length ? rb(s3, o3, i3 ?? [], t3, n3, a3) : ob(s3, t3, n3, o3, a3);
    Ba(s3, d3, c3, t3, r3);
  });
}, _N = (e12, t3, n3) => e12.length > 50 ? [] : e12.filter(ae).flatMap((r3) => r2$1(r3, t3, n3)).filter((r3) => r3 !== null).filter((r3) => e12.filter((o3) => o3.id === r3?.id).length === 0), ON = (e12, t3, n3, r3, o3) => {
  t3.startBoundElement != null && di(e12, t3.startBoundElement, "start", r3);
  let i3 = Bn(n3, o3, r3, t3.zoom, X$1(e12), X$1(e12));
  i3 !== null && (o2$1(e12, i3, "end") || di(e12, i3, "end", r3));
}, ib = (e12, t3) => {
  let n3 = e12.gap, r3 = pi(t3, t3.width, t3.height);
  return n3 > r3 && (n3 = t2 + n2), { ...e12, gap: n3 };
}, di = (e12, t3, n3, r3) => {
  if (!ee(e12)) return;
  let o3 = { elementId: t3.id, ...X$1(e12) ? { ...d2$1(e12, t3, n3), focus: 0, gap: 0 } : { ...ib(lb(e12, t3, n3, r3), t3) } };
  Y(e12, { [n3 === "start" ? "startBinding" : "endBinding"]: o3 }), te(t3.boundElements || []).has(e12.id) || Y(t3, { boundElements: (t3.boundElements || []).concat({ id: e12.id, type: "arrow" }) });
}, o2$1 = (e12, t3, n3) => {
  let r3 = e12[n3 === "start" ? "endBinding" : "startBinding"];
  return ab(e12, r3?.elementId, t3);
}, ab = (e12, t3, n3) => t3 === n3.id && i2$1(e12), i2$1 = (e12) => e12.points.length < 3, sb = (e12, t3) => {
  let n3 = t3 === "start" ? "startBinding" : "endBinding", r3 = e12[n3];
  return r3 == null ? null : (Y(e12, { [n3]: null }), r3.elementId);
}, Bn = (e12, t3, n3, r3, o3, i3) => {
  if (i3) {
    let s3 = false, d3 = cb(t3, (l3) => xt(l3, false) && si(l3, e12, n3, r3, (o3 || !No(l3)) && !de(l3))).filter((l3) => s3 ? false : (No(l3) || (s3 = true), true));
    if (!d3 || d3.length === 0) return null;
    if (d3.length === 1) return d3[0];
    let c3 = d3.filter((l3) => si(l3, e12, n3, r3, false));
    return c3.length === 1 ? c3[0] : d3.sort((l3, U3) => U3.width ** 2 + U3.height ** 2 - (l3.width ** 2 + l3.height ** 2)).pop();
  }
  return db(t3, (s3) => xt(s3, false) && si(s3, e12, n3, r3, (o3 || !No(s3)) && !de(s3)));
}, db = (e12, t3) => {
  let n3 = null;
  for (let r3 = e12.length - 1; r3 >= 0; --r3) {
    let o3 = e12[r3];
    if (!o3.isDeleted && t3(o3)) {
      n3 = o3;
      break;
    }
  }
  return n3;
}, cb = (e12, t3) => {
  let n3 = [];
  for (let r3 = e12.length - 1; r3 >= 0; --r3) {
    let o3 = e12[r3];
    o3.isDeleted || t3(o3) && n3.push(o3);
  }
  return n3;
}, lb = (e12, t3, n3, r3) => {
  let o3 = n3 === "start" ? -1 : 1, i3 = o3 === -1 ? 0 : e12.points.length - 1, a3 = i3 - o3, s3 = z$1.getPointAtIndexGlobalCoordinates(e12, i3, r3), d3 = z$1.getPointAtIndexGlobalCoordinates(e12, a3, r3);
  return { focus: Eb(t3, d3, s3), gap: Math.max(1, or$1(t3, s3)) };
}, Jt = (e12, t3, n3) => {
  let { newSize: r3, simultaneouslyUpdated: o3 } = n3 ?? {}, i3 = fb(o3);
  xt(e12) && ci(t3, e12, (a3) => {
    if (!ae(a3) || a3.isDeleted || !Ub(a3, e12)) return;
    let s3 = a3.startBinding ? t3.get(a3.startBinding.elementId) : null, d3 = a3.endBinding ? t3.get(a3.endBinding.elementId) : null, c3 = null, l3 = null;
    s3 && d3 && (c3 = Ke$1(s3, t3), l3 = Ke$1(d3, t3));
    let U3 = { startBinding: j1$1(e12, a3.startBinding, r3), endBinding: j1$1(e12, a3.endBinding, r3) };
    if (i3.has(a3.id)) {
      Y(a3, U3, true);
      return;
    }
    let p3 = li(t3, a3, (b3, E3) => {
      if (b3 && xt(b3) && (E3 === "startBinding" || E3 === "endBinding") && (e12.id === a3[E3]?.elementId || e12.id === a3[E3 === "startBinding" ? "endBinding" : "startBinding"]?.elementId && !z1$1(c3, l3))) {
        let g3 = bb(a3, E3, U3[E3], b3, t3);
        if (g3) return { index: E3 === "startBinding" ? 0 : a3.points.length - 1, point: g3 };
      }
      return null;
    }).filter((b3) => b3 !== null);
    z$1.movePoints(a3, p3, { ...e12.id === a3.startBinding?.elementId ? { startBinding: U3.startBinding } : {}, ...e12.id === a3.endBinding?.elementId ? { endBinding: U3.endBinding } : {} });
    let m3 = oe(a3, t3);
    m3 && !m3.isDeleted && _n(a3, t3, false);
  });
}, Ub = (e12, t3) => e12.startBinding?.elementId === t3.id || e12.endBinding?.elementId === t3.id, fb = (e12) => new Set((e12 || []).map((t3) => t3.id)), a2 = (e12, t3, n3, r3, o3, i3, a3) => {
  let s3 = Ht$1(O(t3, e12));
  return !n3 || !r3 ? s3 : pb(i3, n3, o3, a3) ? q1(n3, r3, e12) : Ht$1(O(e12, u$1(n3.x + n3.width / 2, n3.y + n3.height / 2)));
}, pb = (e12, t3, n3, r3) => {
  let o3 = or$1(t3, e12), i3 = pi(t3, t3.width, t3.height, r3);
  return o3 > i3 ? null : o3;
}, fi = (e12, t3, n3) => {
  let r3 = t3 && wt$1(t3), o3 = e12.points[n3 === "start" ? 0 : e12.points.length - 1], i3 = u$1(e12.x + o3[0], e12.y + o3[1]), a3 = Id(t3) ? mb(t3, i3) : i3;
  if (t3 && r3) {
    let s3 = Kr(r3), d3 = Ea(t3, A$1(s3, q(ue(Je(O(a3, s3)), Math.max(t3.width, t3.height)), s3)))[0], c3 = ie(a3, s3), l3 = Math.max(ie(d3 ?? a3, s3), 1e-4), U3 = To(c3 / l3, 6);
    switch (true) {
      case U3 > 0.9:
        return c3 - l3 > me$1 || Xn(a3, d3) < 1e-4 ? a3 : q(ue(Je(O(a3, d3 ?? s3)), U3 > 1 ? me$1 : -me$1), d3 ?? s3);
      default:
        return ub(a3, t3, r3);
    }
  }
  return a3;
}, ub = (e12, t3, n3) => {
  let r3 = Kr(n3), o3 = Ht$1(O(e12, r3));
  switch (true) {
    case ve$1(o3, ze$1):
      return T$1(u$1((n3[0] + n3[2]) / 2 + 0.1, n3[1]), r3, t3.angle);
    case ve$1(o3, Re):
      return T$1(u$1(n3[2], (n3[1] + n3[3]) / 2 + 0.1), r3, t3.angle);
    case ve$1(o3, Fe$1):
      return T$1(u$1((n3[0] + n3[2]) / 2 - 0.1, n3[3]), r3, t3.angle);
    default:
      return T$1(u$1(n3[0], (n3[1] + n3[3]) / 2 - 0.1), r3, t3.angle);
  }
}, mb = (e12, t3) => {
  let n3 = u$1(e12.x + e12.width / 2, e12.y + e12.height / 2), r3 = T$1(t3, n3, -e12.angle);
  return r3[0] < e12.x && r3[1] < e12.y ? r3[1] - e12.y > -me$1 ? T$1(u$1(e12.x - me$1, e12.y), n3, e12.angle) : T$1(u$1(e12.x, e12.y - me$1), n3, e12.angle) : r3[0] < e12.x && r3[1] > e12.y + e12.height ? r3[0] - e12.x > -me$1 ? T$1(u$1(e12.x, e12.y + e12.height + me$1), n3, e12.angle) : T$1(u$1(e12.x - me$1, e12.y + e12.height), n3, e12.angle) : r3[0] > e12.x + e12.width && r3[1] > e12.y + e12.height ? r3[0] - e12.x < e12.width + me$1 ? T$1(u$1(e12.x + e12.width, e12.y + e12.height + me$1), n3, e12.angle) : T$1(u$1(e12.x + e12.width + me$1, e12.y + e12.height), n3, e12.angle) : r3[0] > e12.x + e12.width && r3[1] < e12.y ? r3[0] - e12.x < e12.width + me$1 ? T$1(u$1(e12.x + e12.width, e12.y - me$1), n3, e12.angle) : T$1(u$1(e12.x + e12.width + me$1, e12.y), n3, e12.angle) : t3;
}, s2 = (e12, t3, n3 = 0.05) => {
  let { x: r3, y: o3, width: i3, height: a3, angle: s3 } = e12, d3 = u$1(r3 + i3 / 2 - 0.1, o3 + a3 / 2 - 0.1), c3 = T$1(t3, d3, -s3), l3 = se(n3 * a3, 5, 80), U3 = se(n3 * i3, 5, 80);
  return c3[0] <= r3 + i3 / 2 && c3[1] > d3[1] - l3 && c3[1] < d3[1] + l3 ? T$1(u$1(r3 - me$1, d3[1]), d3, s3) : c3[1] <= o3 + a3 / 2 && c3[0] > d3[0] - U3 && c3[0] < d3[0] + U3 ? T$1(u$1(d3[0], o3 - me$1), d3, s3) : c3[0] >= r3 + i3 / 2 && c3[1] > d3[1] - l3 && c3[1] < d3[1] + l3 ? T$1(u$1(r3 + i3 + me$1, d3[1]), d3, s3) : c3[1] >= o3 + a3 / 2 && c3[0] > d3[0] - U3 && c3[0] < d3[0] + U3 ? T$1(u$1(d3[0], o3 + a3 + me$1), d3, s3) : t3;
}, bb = (e12, t3, n3, r3, o3) => {
  if (n3 == null || n3.elementId !== r3.id && e12.points.length > 2) return null;
  let i3 = t3 === "startBinding" ? -1 : 1, a3 = i3 === -1 ? 0 : e12.points.length - 1;
  if (X$1(e12) && vn$1(n3)) {
    let U3 = Yr(n3.fixedPoint) ?? d2$1(e12, r3, t3 === "startBinding" ? "start" : "end").fixedPoint, p3 = u$1(r3.x + r3.width / 2, r3.y + r3.height / 2), m3 = u$1(r3.x + U3[0] * r3.width, r3.y + U3[1] * r3.height), b3 = T$1(m3, p3, r3.angle);
    return z$1.pointFromAbsoluteCoords(e12, b3, o3);
  }
  let s3 = a3 - i3, d3 = z$1.getPointAtIndexGlobalCoordinates(e12, s3, o3), c3 = gb(r3, n3.focus, d3), l3;
  if (n3.gap === 0) l3 = c3;
  else {
    let U3 = z$1.getPointAtIndexGlobalCoordinates(e12, a3, o3), p3 = u$1(r3.x + r3.width / 2, r3.y + r3.height / 2), m3 = ie(d3, U3) + ie(d3, p3) + Math.max(r3.width, r3.height) * 2, b3 = Ea(r3, A$1(d3, q(ue(Je(O(c3, d3)), m3), d3)), n3.gap).sort((E3, g3) => Xn(E3, d3) - Xn(g3, d3));
    b3.length > 1 ? l3 = b3[0] : b3.length === 1 ? l3 = c3 : l3 = U3;
  }
  return z$1.pointFromAbsoluteCoords(e12, l3, o3);
}, d2$1 = (e12, t3, n3, r3) => {
  let o3 = [t3.x, t3.y, t3.x + t3.width, t3.y + t3.height], i3 = fi(e12, t3, n3), a3 = u$1(o3[0] + (o3[2] - o3[0]) / 2, o3[1] + (o3[3] - o3[1]) / 2), s3 = T$1(i3, a3, -t3.angle);
  return { fixedPoint: Yr([(s3[0] - t3.x) / t3.width, (s3[1] - t3.y) / t3.height]) };
}, j1$1 = (e12, t3, n3) => {
  if (t3 == null || n3 == null) return t3;
  let { width: r3, height: o3 } = n3, { width: i3, height: a3 } = e12, s3 = Math.max(1, Math.min(pi(e12, r3, o3), t3.gap * (r3 < o3 ? r3 / i3 : o3 / a3)));
  return { ...t3, gap: s3 };
}, ir = (e12, t3, n3, r3, o3) => Bn(c2$1(e12, t3, n3), r3, n3, o3, X$1(e12), X$1(e12)), c2$1 = (e12, t3, n3) => {
  let r3 = t3 === "start" ? 0 : -1;
  return un(z$1.getPointAtIndexGlobalCoordinates(e12, r3, n3));
}, AN = (e12, t3, n3, r3) => {
  let o3 = /* @__PURE__ */ new Set(), i3 = /* @__PURE__ */ new Set(), a3 = r3 === "duplicatesServeAsOld", s3 = new Map([...n3].map(([d3, c3]) => [c3, d3]));
  t3.forEach((d3) => {
    let { boundElements: c3 } = d3;
    if (c3 != null && c3.length > 0 && (c3.forEach((l3) => {
      a3 && !n3.has(l3.id) && o3.add(l3.id);
    }), i3.add(n3.get(d3.id))), Pr(d3)) {
      if (d3.startBinding != null) {
        let { elementId: l3 } = d3.startBinding;
        a3 && !n3.has(l3) && i3.add(l3);
      }
      if (d3.endBinding != null) {
        let { elementId: l3 } = d3.endBinding;
        a3 && !n3.has(l3) && i3.add(l3);
      }
      (d3.startBinding != null || d3.endBinding != null) && o3.add(n3.get(d3.id));
    }
  }), e12.filter(({ id: d3 }) => o3.has(d3)).forEach((d3) => {
    let { startBinding: c3, endBinding: l3 } = d3;
    Y(d3, { startBinding: e22(c3, n3), endBinding: e22(l3, n3) });
  }), e12.filter(({ id: d3 }) => i3.has(d3)).forEach((d3) => {
    let c3 = s3.get(d3.id), l3 = e12.find(({ id: U3 }) => U3 === c3)?.boundElements;
    l3 && l3.length > 0 && Y(d3, { boundElements: l3.map((U3) => n3.has(U3.id) ? { id: n3.get(U3.id), type: U3.type } : U3) });
  });
}, e22 = (e12, t3) => e12 == null ? null : { ...e12, elementId: t3.get(e12.elementId) ?? e12.elementId }, KN = (e12, t3) => {
  let n3 = te(e12);
  for (let r3 of t3) rn.unbindAffected(n3, r3, Y), on.unbindAffected(n3, r3, Y);
}, Jr = (e12, t3, n3 = []) => {
  if (!e12) return null;
  let r3 = e12.filter((o3) => !t3.has(o3.id));
  return r3.push(...n3.map((o3) => ({ id: o3.id, type: o3.type }))), r3;
}, si = (e12, { x: t3, y: n3 }, r3, o3, i3) => {
  let a3 = pi(e12, e12.width, e12.height, o3), s3 = ti(e12, r3);
  return _r$1(u$1(t3, n3), s3, a3) || i3 === true && gn(u$1(t3, n3), wt$1(e12));
}, pi = (e12, t3, n3, r3) => {
  let o3 = r3?.value && r3.value < 1 ? r3.value : 1, a3 = (e12.type === "diamond" ? 1 / Math.sqrt(2) : 1) * Math.min(t3, n3);
  return Math.max(16, Math.min(0.25 * a3, 32), t2 / o3 + n2);
}, Eb = (e12, t3, n3) => {
  let r3 = u$1(e12.x + e12.width / 2, e12.y + e12.height / 2);
  if (_e$1(t3, n3)) return 0;
  let o3 = T$1(t3, r3, -e12.angle), i3 = T$1(n3, r3, -e12.angle), a3 = Math.sign(Me(O(i3, t3), O(i3, r3))) * -1, s3 = A$1(i3, q(ue(Je(O(i3, o3)), Math.max(e12.width * 2, e12.height * 2)), i3)), d3 = e12.type === "diamond" ? [A$1(u$1(e12.x + e12.width / 2, e12.y), u$1(e12.x + e12.width / 2, e12.y + e12.height)), A$1(u$1(e12.x, e12.y + e12.height / 2), u$1(e12.x + e12.width, e12.y + e12.height / 2))] : [A$1(u$1(e12.x, e12.y), u$1(e12.x + e12.width, e12.y + e12.height)), A$1(u$1(e12.x + e12.width, e12.y), u$1(e12.x, e12.y + e12.height))], c3 = e12.type === "diamond" ? [A$1(u$1(e12.x + e12.width / 2, e12.y - e12.height), u$1(e12.x + e12.width / 2, e12.y + e12.height * 2)), A$1(u$1(e12.x - e12.width, e12.y + e12.height / 2), u$1(e12.x + e12.width * 2, e12.y + e12.height / 2))] : [A$1(u$1(e12.x - e12.width, e12.y - e12.height), u$1(e12.x + e12.width * 2, e12.y + e12.height * 2)), A$1(u$1(e12.x + e12.width * 2, e12.y - e12.height), u$1(e12.x - e12.width, e12.y + e12.height * 2))];
  return [pn(s3, c3[0]), pn(s3, c3[1])].filter((p3) => p3 !== null).sort((p3, m3) => Xn(p3, n3) - Xn(m3, n3)).map((p3, m3) => a3 * ie(r3, p3) / (e12.type === "diamond" ? ie(d3[m3][0], d3[m3][1]) / 2 : Math.sqrt(e12.width ** 2 + e12.height ** 2) / 2)).sort((p3, m3) => Math.abs(p3) - Math.abs(m3))[0] ?? 0;
}, gb = (e12, t3, n3) => {
  let r3 = u$1(e12.x + e12.width / 2, e12.y + e12.height / 2);
  if (t3 === 0) return r3;
  let o3 = (e12.type === "diamond" ? [u$1(e12.x, e12.y + e12.height / 2), u$1(e12.x + e12.width / 2, e12.y), u$1(e12.x + e12.width, e12.y + e12.height / 2), u$1(e12.x + e12.width / 2, e12.y + e12.height)] : [u$1(e12.x, e12.y), u$1(e12.x + e12.width, e12.y), u$1(e12.x + e12.width, e12.y + e12.height), u$1(e12.x, e12.y + e12.height)]).map((s3) => q(ue(O(s3, r3), Math.abs(t3)), r3)).map((s3) => T$1(s3, r3, e12.angle)), i3 = [Me(O(n3, o3[0]), O(o3[1], o3[0])) > 0 && (t3 > 0 ? Me(O(n3, o3[1]), O(o3[2], o3[1])) < 0 : Me(O(n3, o3[3]), O(o3[0], o3[3])) < 0), Me(O(n3, o3[1]), O(o3[2], o3[1])) > 0 && (t3 > 0 ? Me(O(n3, o3[2]), O(o3[3], o3[2])) < 0 : Me(O(n3, o3[0]), O(o3[1], o3[0])) < 0), Me(O(n3, o3[2]), O(o3[3], o3[2])) > 0 && (t3 > 0 ? Me(O(n3, o3[3]), O(o3[0], o3[3])) < 0 : Me(O(n3, o3[1]), O(o3[2], o3[1])) < 0), Me(O(n3, o3[3]), O(o3[0], o3[3])) > 0 && (t3 > 0 ? Me(O(n3, o3[0]), O(o3[1], o3[0])) < 0 : Me(O(n3, o3[2]), O(o3[3], o3[2])) < 0)];
  return i3[0] ? t3 > 0 ? o3[1] : o3[0] : i3[1] ? t3 > 0 ? o3[2] : o3[1] : i3[2] ? t3 > 0 ? o3[3] : o3[2] : t3 > 0 ? o3[0] : o3[3];
}, l2 = /* @__PURE__ */ new Set(["boundElements", "frameId", "containerId", "startBinding", "endBinding"]), ci = (e12, t3, n3) => {
  xt(t3) && (t3.boundElements?.slice() ?? []).forEach(({ id: o3 }) => {
    n3(e12.get(o3), "boundElements", o3);
  });
}, li = (e12, t3, n3) => {
  let r3 = [];
  if (t3.frameId) {
    let o3 = t3.frameId;
    r3.push(n3(e12.get(o3), "frameId", o3));
  }
  if (Ne(t3)) {
    let o3 = t3.containerId;
    r3.push(n3(e12.get(o3), "containerId", o3));
  }
  if (ee(t3)) {
    if (t3.startBinding) {
      let o3 = t3.startBinding.elementId;
      r3.push(n3(e12.get(o3), "startBinding", o3));
    }
    if (t3.endBinding) {
      let o3 = t3.endBinding.elementId;
      r3.push(n3(e12.get(o3), "endBinding", o3));
    }
  }
  return r3;
}, rn = class {
  static unbindAffected(t3, n3, r3) {
    n3 && li(t3, n3, (o3) => {
      !o3 || o3.isDeleted || ci(t3, o3, (i3, a3, s3) => {
        s3 === n3.id && r3(o3, { boundElements: Jr(o3.boundElements, /* @__PURE__ */ new Set([s3])) });
      });
    });
  }
};
i$1(rn, "rebindAffected", (t3, n3, r3) => {
  !n3 || n3.isDeleted || li(t3, n3, (o3, i3) => {
    if (!o3 || o3.isDeleted) {
      r3(n3, { [i3]: null });
      return;
    }
    i3 !== "frameId" && (o3.boundElements?.find((a3) => a3.id === n3.id) || (ee(n3) && r3(o3, { boundElements: Jr(o3.boundElements, /* @__PURE__ */ new Set(), new Array(n3)) }), k$2(n3) && (o3.boundElements?.find((a3) => a3.type === "text") ? r3(n3, { [i3]: null }) : r3(o3, { boundElements: Jr(o3.boundElements, /* @__PURE__ */ new Set(), new Array(n3)) }))));
  });
});
var on = class {
  static unbindAffected(t3, n3, r3) {
    n3 && ci(t3, n3, (o3) => {
      !o3 || o3.isDeleted || li(t3, o3, (i3, a3, s3) => {
        s3 === n3.id && r3(o3, { [a3]: null });
      });
    });
  }
};
i$1(on, "rebindAffected", (t3, n3, r3) => {
  !n3 || n3.isDeleted || ci(t3, n3, (o3, i3, a3) => {
    if (!o3 || o3.isDeleted) {
      r3(n3, { boundElements: Jr(n3.boundElements, /* @__PURE__ */ new Set([a3])) });
      return;
    }
    k$2(o3) && ((n3.boundElements?.slice() ?? []).reverse().find((d3) => d3.type === "text")?.id === o3.id ? o3.containerId !== n3.id && r3(o3, { containerId: n3.id }) : (o3.containerId !== null && r3(o3, { containerId: null }), r3(n3, { boundElements: Jr(n3.boundElements, /* @__PURE__ */ new Set([o3.id])) })));
  });
});
var Ui = (e12, t3) => {
  let [n3, r3] = Yr(e12);
  return T$1(u$1(t3.x + t3.width * n3, t3.y + t3.height * r3), u$1(t3.x + t3.width / 2, t3.y + t3.height / 2), t3.angle);
}, xb = (e12, t3) => {
  let n3 = e12.startBinding && t3.get(e12.startBinding.elementId), r3 = e12.endBinding && t3.get(e12.endBinding.elementId), o3 = n3 && e12.startBinding ? Ui(e12.startBinding.fixedPoint, n3) : u$1(e12.x + e12.points[0][0], e12.y + e12.points[0][1]), i3 = r3 && e12.endBinding ? Ui(e12.endBinding.fixedPoint, r3) : u$1(e12.x + e12.points[e12.points.length - 1][0], e12.y + e12.points[e12.points.length - 1][1]);
  return [o3, i3];
}, U2 = (e12, t3) => {
  let [n3, r3] = xb(e12, t3);
  return [z$1.pointFromAbsoluteCoords(e12, n3, t3), z$1.pointFromAbsoluteCoords(e12, r3, t3)];
}, Yr = (e12) => e12 && (Math.abs(e12[0] - 0.5) < 1e-4 || Math.abs(e12[1] - 0.5) < 1e-4) ? e12.map((t3) => Math.abs(t3 - 0.5) < 1e-4 ? 0.5001 : t3) : e12;
var hb = (e12, t3) => {
  let [n3, r3, o3, i3] = t3, { x: a3, y: s3 } = ta({ sceneX: n3, sceneY: r3 }, e12), { x: d3, y: c3 } = ta({ sceneX: o3, sceneY: i3 }, e12);
  return d3 - a3 > e12.width || c3 - s3 > e12.height;
}, yb = ({ scenePoint: e12, viewportDimensions: t3, zoom: n3, offsets: r3 }) => {
  let o3 = (t3.width - (r3?.right ?? 0)) / 2 / n3.value - e12.x;
  o3 += (r3?.left ?? 0) / 2 / n3.value;
  let i3 = (t3.height - (r3?.bottom ?? 0)) / 2 / n3.value - e12.y;
  return i3 += (r3?.top ?? 0) / 2 / n3.value, { scrollX: o3, scrollY: i3 };
}, _a$1 = (e12, t3) => {
  if (e12 = f2(e12), !e12.length) return { scrollX: 0, scrollY: 0 };
  let [n3, r3, o3, i3] = $e$1(e12);
  hb(t3, [n3, r3, o3, i3]) && ([n3, r3, o3, i3] = Pa$1(e12, Dn({ clientX: t3.scrollX, clientY: t3.scrollY }, t3)));
  let a3 = (n3 + o3) / 2, s3 = (r3 + i3) / 2;
  return yb({ scenePoint: { x: a3, y: s3 }, viewportDimensions: { width: t3.width, height: t3.height }, zoom: t3.zoom });
};
var Oa = (e12) => se(To(e12, 6), Js$1, Ys), Aa = (e12) => se(Math.round(e12), 1, 100), Ka$1 = (e12) => se(Math.round(e12), 1, 100);
var Tb = (e12, t3, n3) => {
  let r3 = n3.reduce((o3, i3) => (i3.groupIds.includes(e12) && (o3[i3.id] = true), o3), {});
  return Object.keys(r3).length < 2 ? t3.selectedGroupIds[e12] || t3.editingGroupId === e12 ? { selectedElementIds: t3.selectedElementIds, selectedGroupIds: { ...t3.selectedGroupIds, [e12]: false }, editingGroupId: null } : t3 : { editingGroupId: t3.editingGroupId, selectedGroupIds: { ...t3.selectedGroupIds, [e12]: true }, selectedElementIds: { ...t3.selectedElementIds, ...r3 } };
}, aF = (function() {
  let e12 = null, t3 = null, n3 = null, r3 = (i3, a3, s3, d3) => {
    if (n3 !== void 0 && a3 === t3 && i3 === e12 && s3.editingGroupId === n3?.editingGroupId) return n3;
    let c3 = {};
    for (let p3 of i3) {
      let m3 = p3.groupIds;
      if (s3.editingGroupId) {
        let b3 = m3.indexOf(s3.editingGroupId);
        b3 > -1 && (m3 = m3.slice(0, b3));
      }
      if (m3.length > 0) {
        let b3 = m3[m3.length - 1];
        c3[b3] = true;
      }
    }
    let l3 = {}, U3 = a3.reduce((p3, m3) => {
      if (m3.isDeleted) return p3;
      let b3 = m3.groupIds.find((E3) => c3[E3]);
      return b3 && (p3[m3.id] = true, Array.isArray(l3[b3]) ? l3[b3].push(m3.id) : l3[b3] = [m3.id]), p3;
    }, {});
    for (let p3 of Object.keys(l3)) l3[p3].length < 2 && c3[p3] && (c3[p3] = false);
    return t3 = a3, e12 = i3, n3 = { editingGroupId: s3.editingGroupId, selectedGroupIds: c3, selectedElementIds: Ha$1({ ...s3.selectedElementIds, ...U3 }, d3) }, n3;
  }, o3 = (i3, a3, s3, d3) => {
    let c3 = d3 ? d3.scene.getSelectedElements({ selectedElementIds: i3.selectedElementIds, elements: a3 }) : at$1(a3, i3);
    return c3.length ? r3(c3, a3, i3, s3) : { selectedGroupIds: {}, editingGroupId: null, selectedElementIds: Ha$1(i3.selectedElementIds, s3) };
  };
  return o3.clearCache = () => {
    t3 = null, e12 = null, n3 = null;
  }, o3;
})(), sF = (e12, t3) => Mb(e12, t3) != null, Mb = (e12, t3) => t3.groupIds.filter((n3) => n3 !== e12.editingGroupId).find((n3) => e12.selectedGroupIds[n3]), dF = (e12) => Object.entries(e12.selectedGroupIds).filter(([t3, n3]) => n3).map(([t3, n3]) => t3), p2 = (e12, t3) => {
  let n3 = { ...t3, selectedGroupIds: {} };
  for (let r3 of e12) {
    let o3 = r3.groupIds;
    if (t3.editingGroupId) {
      let i3 = o3.indexOf(t3.editingGroupId);
      i3 > -1 && (o3 = o3.slice(0, i3));
    }
    if (o3.length > 0) {
      let i3 = o3[o3.length - 1];
      n3 = { ...n3, ...Tb(i3, n3, e12) };
    }
  }
  return n3.selectedGroupIds;
}, cF = (e12, t3) => ({ ...e12, editingGroupId: t3.groupIds.length ? t3.groupIds[0] : null, selectedGroupIds: {}, selectedElementIds: { [t3.id]: true } }), Lb = (e12, t3) => e12.groupIds.includes(t3), an = (e12, t3) => {
  let n3 = [];
  for (let r3 of e12.values()) Lb(r3, t3) && n3.push(r3);
  return n3;
}, lF = (e12, t3) => e12.groupIds.find((n3) => t3[n3]), u2 = (e12, t3, n3) => {
  let r3 = [...e12], o3 = t3 ? e12.indexOf(t3) : -1, i3 = o3 > -1 ? o3 : e12.length;
  for (let a3 = 0; a3 < i3; a3++) r3[a3] = n3(r3[a3]);
  return r3;
}, UF = (e12, t3, n3) => {
  let r3 = [...e12], o3 = n3 ? r3.indexOf(n3) : -1, i3 = o3 > -1 ? o3 : r3.length;
  return r3.splice(i3, 0, t3), r3;
}, fF = (e12, t3) => e12.filter((n3) => !t3[n3]), Ja$1 = (e12, t3) => {
  let n3 = /* @__PURE__ */ new Map();
  return e12.forEach((r3) => {
    let o3 = r3.groupIds.length === 0 ? r3.id : r3.groupIds[r3.groupIds.length - 1], i3 = n3.get(o3) || [], a3 = oe(r3, t3);
    a3 && i3.push(a3), n3.set(o3, [...i3, r3]);
  }), Array.from(n3.values());
}, m2 = (e12) => {
  let t3 = /* @__PURE__ */ new Set();
  for (let [, n3] of e12) if (!n3.isDeleted) for (let r3 of n3.groupIds ?? []) t3.add(r3);
  return t3;
}, b2 = (e12) => {
  let t3 = e12.flatMap((o3) => o3.groupIds), n3 = /* @__PURE__ */ new Map(), r3 = 0;
  for (let o3 of t3) n3.set(o3, (n3.get(o3) ?? 0) + 1), n3.get(o3) > r3 && (r3 = n3.get(o3));
  return r3 === e12.length;
}, E2 = (e12) => e12.groupIds.length > 0;
var Db = 8, g2 = 99999, bi$1 = (e12) => Db / e12, Qe$1 = class Qe {
};
i$1(Qe$1, "referenceSnapPoints", null), i$1(Qe$1, "visibleGaps", null), i$1(Qe$1, "setReferenceSnapPoints", (t3) => {
  Qe$1.referenceSnapPoints = t3;
}), i$1(Qe$1, "getReferenceSnapPoints", () => Qe$1.referenceSnapPoints), i$1(Qe$1, "setVisibleGaps", (t3) => {
  Qe$1.visibleGaps = t3;
}), i$1(Qe$1, "getVisibleGaps", () => Qe$1.visibleGaps), i$1(Qe$1, "destroy", () => {
  Qe$1.referenceSnapPoints = null, Qe$1.visibleGaps = null;
});
var mi = Qe$1, Sb = (e12) => e12.props.gridModeEnabled ?? e12.state.gridModeEnabled, sr = ({ event: e12, app: t3, selectedElements: n3 }) => e12 ? t3.state.objectsSnapModeEnabled && !e12[Q.CTRL_OR_CMD] || !t3.state.objectsSnapModeEnabled && e12[Q.CTRL_OR_CMD] && !Sb(t3) : n3.length === 1 && n3[0].type === "arrow" ? false : t3.state.objectsSnapModeEnabled, vb = (e12, t3, n3 = 0.01) => Math.abs(e12 - t3) <= n3, Cr$1 = (e12, t3, { omitCenter: n3, boundingBoxCorners: r3, dragOffset: o3 } = { omitCenter: false, boundingBoxCorners: false }) => {
  let i3 = [];
  if (e12.length === 1) {
    let a3 = e12[0], [s3, d3, c3, l3, U3, p3] = C$1(a3, t3);
    o3 && (s3 += o3.x, c3 += o3.x, U3 += o3.x, d3 += o3.y, l3 += o3.y, p3 += o3.y);
    let m3 = (c3 - s3) / 2, b3 = (l3 - d3) / 2;
    if ((a3.type === "diamond" || a3.type === "ellipse") && !r3) {
      let E3 = T$1(u$1(s3, d3 + b3), u$1(U3, p3), a3.angle), g3 = T$1(u$1(s3 + m3, d3), u$1(U3, p3), a3.angle), h3 = T$1(u$1(c3, d3 + b3), u$1(U3, p3), a3.angle), x3 = T$1(u$1(s3 + m3, l3), u$1(U3, p3), a3.angle), y3 = u$1(U3, p3);
      i3 = n3 ? [E3, g3, h3, x3] : [E3, g3, h3, x3, y3];
    } else {
      let E3 = T$1(u$1(s3, d3), u$1(U3, p3), a3.angle), g3 = T$1(u$1(c3, d3), u$1(U3, p3), a3.angle), h3 = T$1(u$1(s3, l3), u$1(U3, p3), a3.angle), x3 = T$1(u$1(c3, l3), u$1(U3, p3), a3.angle), y3 = u$1(U3, p3);
      i3 = n3 ? [E3, g3, h3, x3] : [E3, g3, h3, x3, y3];
    }
  } else if (e12.length > 1) {
    let [a3, s3, d3, c3] = ai(e12, o3 ?? { x: 0, y: 0 }), l3 = d3 - a3, U3 = c3 - s3, p3 = u$1(a3, s3), m3 = u$1(d3, s3), b3 = u$1(a3, c3), E3 = u$1(d3, c3), g3 = u$1(a3 + l3 / 2, s3 + U3 / 2);
    i3 = n3 ? [p3, m3, b3, E3] : [p3, m3, b3, E3, g3];
  }
  return i3.map((a3) => u$1(Te(a3[0]), Te(a3[1])));
}, y2 = (e12, t3, n3, r3) => {
  let o3 = t3.filter((i3) => de(i3)).map((i3) => i3.id);
  return Ca(e12, t3, n3, r3).filter((i3) => !(i3.frameId && o3.includes(i3.frameId)));
}, IF = (e12, t3, n3, r3) => {
  let o3 = y2(e12, t3, n3, r3), i3 = Ja$1(o3, r3).filter((U3) => !(U3.length === 1 && Ne(U3[0]))).map((U3) => $e$1(U3).map((p3) => Te(p3))), a3 = i3.sort((U3, p3) => U3[0] - p3[0]), s3 = [], d3 = 0;
  e: for (let U3 = 0; U3 < a3.length; U3++) {
    let p3 = a3[U3];
    for (let m3 = U3 + 1; m3 < a3.length; m3++) {
      if (++d3 > g2) break e;
      let b3 = a3[m3], [, E3, g3, h3] = p3, [x3, y3, , w3] = b3;
      g3 < x3 && Lr$1(Oe$1(E3, h3), Oe$1(y3, w3)) && s3.push({ startBounds: p3, endBounds: b3, startSide: [u$1(g3, E3), u$1(g3, h3)], endSide: [u$1(x3, y3), u$1(x3, w3)], length: x3 - g3, overlap: Dr$1(Oe$1(E3, h3), Oe$1(y3, w3)) });
    }
  }
  let c3 = i3.sort((U3, p3) => U3[1] - p3[1]), l3 = [];
  d3 = 0;
  e: for (let U3 = 0; U3 < c3.length; U3++) {
    let p3 = c3[U3];
    for (let m3 = U3 + 1; m3 < c3.length; m3++) {
      if (++d3 > g2) break e;
      let b3 = c3[m3], [E3, , g3, h3] = p3, [x3, y3, w3] = b3;
      h3 < y3 && Lr$1(Oe$1(E3, g3), Oe$1(x3, w3)) && l3.push({ startBounds: p3, endBounds: b3, startSide: [u$1(E3, h3), u$1(g3, h3)], endSide: [u$1(x3, y3), u$1(w3, y3)], length: y3 - h3, overlap: Dr$1(Oe$1(E3, g3), Oe$1(x3, w3)) });
    }
  }
  return { horizontalGaps: s3, verticalGaps: l3 };
}, x2 = (e12, t3, n3, r3, o3, i3, a3) => {
  if (!sr({ app: n3, event: r3, selectedElements: e12 })) return [];
  if (e12.length === 0) return [];
  let s3 = mi.getVisibleGaps();
  if (s3) {
    let { horizontalGaps: d3, verticalGaps: c3 } = s3, [l3, U3, p3, m3] = ai(e12, t3).map((g3) => Te(g3)), b3 = (l3 + p3) / 2, E3 = (U3 + m3) / 2;
    for (let g3 of d3) {
      if (!Lr$1(Oe$1(U3, m3), g3.overlap)) continue;
      let h3 = g3.startSide[0][0] + g3.length / 2, x3 = Te(h3 - b3);
      if (g3.length > p3 - l3 && Math.abs(x3) <= a3.x) {
        Math.abs(x3) < a3.x && (o3.length = 0), a3.x = Math.abs(x3);
        let N3 = { type: "gap", direction: "center_horizontal", gap: g3, offset: x3 };
        o3.push(N3);
        continue;
      }
      let [, , w3] = g3.endBounds, I3 = l3 - w3, S3 = Te(g3.length - I3);
      if (Math.abs(S3) <= a3.x) {
        Math.abs(S3) < a3.x && (o3.length = 0), a3.x = Math.abs(S3);
        let N3 = { type: "gap", direction: "side_right", gap: g3, offset: S3 };
        o3.push(N3);
        continue;
      }
      let [v3, , ,] = g3.startBounds, D3 = v3 - p3, $3 = Te(D3 - g3.length);
      if (Math.abs($3) <= a3.x) {
        Math.abs($3) < a3.x && (o3.length = 0), a3.x = Math.abs($3);
        let N3 = { type: "gap", direction: "side_left", gap: g3, offset: $3 };
        o3.push(N3);
        continue;
      }
    }
    for (let g3 of c3) {
      if (!Lr$1(Oe$1(l3, p3), g3.overlap)) continue;
      let h3 = g3.startSide[0][1] + g3.length / 2, x3 = Te(h3 - E3);
      if (g3.length > m3 - U3 && Math.abs(x3) <= a3.y) {
        Math.abs(x3) < a3.y && (i3.length = 0), a3.y = Math.abs(x3);
        let N3 = { type: "gap", direction: "center_vertical", gap: g3, offset: x3 };
        i3.push(N3);
        continue;
      }
      let [, w3, ,] = g3.startBounds, I3 = w3 - m3, S3 = Te(I3 - g3.length);
      if (Math.abs(S3) <= a3.y) {
        Math.abs(S3) < a3.y && (i3.length = 0), a3.y = Math.abs(S3);
        let N3 = { type: "gap", direction: "side_top", gap: g3, offset: S3 };
        i3.push(N3);
        continue;
      }
      let [, , , v3] = g3.endBounds, D3 = Te(U3 - v3), $3 = g3.length - D3;
      if (Math.abs($3) <= a3.y) {
        Math.abs($3) < a3.y && (i3.length = 0), a3.y = Math.abs($3);
        let N3 = { type: "gap", direction: "side_bottom", gap: g3, offset: $3 };
        i3.push(N3);
        continue;
      }
    }
  }
}, wF = (e12, t3, n3, r3) => {
  let o3 = y2(e12, t3, n3, r3);
  return Ja$1(o3, r3).filter((i3) => !(i3.length === 1 && Ne(i3[0]))).flatMap((i3) => Cr$1(i3, r3));
}, ar$1 = (e12, t3, n3, r3, o3, i3, a3) => {
  if (!sr({ app: n3, event: r3, selectedElements: e12 }) || e12.length === 0 && t3.length === 0) return [];
  let s3 = mi.getReferenceSnapPoints();
  if (s3) for (let d3 of t3) for (let c3 of s3) {
    let l3 = c3[0] - d3[0], U3 = c3[1] - d3[1];
    Math.abs(l3) <= a3.x && (Math.abs(l3) < a3.x && (o3.length = 0), o3.push({ type: "point", points: [d3, c3], offset: l3 }), a3.x = Math.abs(l3)), Math.abs(U3) <= a3.y && (Math.abs(U3) < a3.y && (i3.length = 0), i3.push({ type: "point", points: [d3, c3], offset: U3 }), a3.y = Math.abs(U3));
  }
}, RF = (e12, t3, n3, r3, o3) => {
  let i3 = n3.state, a3 = at$1(e12, i3);
  if (!sr({ app: n3, event: r3, selectedElements: a3 }) || a3.length === 0) return { snapOffset: { x: 0, y: 0 }, snapLines: [] };
  t3.x = Te(t3.x), t3.y = Te(t3.y);
  let s3 = [], d3 = [], c3 = bi$1(i3.zoom.value), l3 = { x: c3, y: c3 }, U3 = Cr$1(a3, o3, { dragOffset: t3 });
  ar$1(a3, U3, n3, r3, s3, d3, l3), x2(a3, t3, n3, r3, s3, d3, l3);
  let p3 = { x: s3[0]?.offset ?? 0, y: d3[0]?.offset ?? 0 };
  l3.x = 0, l3.y = 0, s3.length = 0, d3.length = 0;
  let m3 = { x: Te(t3.x + p3.x), y: Te(t3.y + p3.y) };
  ar$1(a3, Cr$1(a3, o3, { dragOffset: m3 }), n3, r3, s3, d3, l3), x2(a3, m3, n3, r3, s3, d3, l3);
  let b3 = Ya$1(s3, d3), E3 = Pb(a3, m3, [...s3, ...d3].filter((g3) => g3.type === "gap"));
  return { snapOffset: p3, snapLines: [...b3, ...E3] };
}, Te = (e12) => Math.round(e12 * 10 ** 6) / 10 ** 6, h2 = (e12) => {
  let t3 = /* @__PURE__ */ new Map();
  for (let n3 of e12) {
    let r3 = n3.join(",");
    t3.has(r3) || t3.set(r3, n3);
  }
  return Array.from(t3.values());
}, Ya$1 = (e12, t3) => {
  let n3 = {}, r3 = {};
  if (e12.length > 0) {
    for (let o3 of e12) if (o3.type === "point") {
      let i3 = Te(o3.points[0][0]);
      n3[i3] || (n3[i3] = []), n3[i3].push(...o3.points.map((a3) => u$1(Te(a3[0]), Te(a3[1]))));
    }
  }
  if (t3.length > 0) {
    for (let o3 of t3) if (o3.type === "point") {
      let i3 = Te(o3.points[0][1]);
      r3[i3] || (r3[i3] = []), r3[i3].push(...o3.points.map((a3) => u$1(Te(a3[0]), Te(a3[1]))));
    }
  }
  return Object.entries(n3).map(([o3, i3]) => ({ type: "points", points: h2(i3.map((a3) => u$1(Number(o3), a3[1])).sort((a3, s3) => a3[1] - s3[1])) })).concat(Object.entries(r3).map(([o3, i3]) => ({ type: "points", points: h2(i3.map((a3) => u$1(a3[0], Number(o3))).sort((a3, s3) => a3[0] - s3[0])) })));
}, $b = (e12) => {
  let t3 = /* @__PURE__ */ new Map();
  for (let n3 of e12) {
    let r3 = n3.points.flat().map((o3) => [Te(o3)]).join(",");
    t3.has(r3) || t3.set(r3, n3);
  }
  return Array.from(t3.values());
}, Pb = (e12, t3, n3) => {
  let [r3, o3, i3, a3] = ai(e12, t3), s3 = [];
  for (let d3 of n3) {
    let [c3, l3, U3, p3] = d3.gap.startBounds, [m3, b3, E3, g3] = d3.gap.endBounds, h3 = Dr$1(Oe$1(o3, a3), d3.gap.overlap), x3 = Dr$1(Oe$1(r3, i3), d3.gap.overlap);
    switch (d3.direction) {
      case "center_horizontal": {
        if (h3) {
          let y3 = (h3[0] + h3[1]) / 2;
          s3.push({ type: "gap", direction: "horizontal", points: [u$1(d3.gap.startSide[0][0], y3), u$1(r3, y3)] }, { type: "gap", direction: "horizontal", points: [u$1(i3, y3), u$1(d3.gap.endSide[0][0], y3)] });
        }
        break;
      }
      case "center_vertical": {
        if (x3) {
          let y3 = (x3[0] + x3[1]) / 2;
          s3.push({ type: "gap", direction: "vertical", points: [u$1(y3, d3.gap.startSide[0][1]), u$1(y3, o3)] }, { type: "gap", direction: "vertical", points: [u$1(y3, a3), u$1(y3, d3.gap.endSide[0][1])] });
        }
        break;
      }
      case "side_right": {
        if (h3) {
          let y3 = (h3[0] + h3[1]) / 2;
          s3.push({ type: "gap", direction: "horizontal", points: [u$1(U3, y3), u$1(m3, y3)] }, { type: "gap", direction: "horizontal", points: [u$1(E3, y3), u$1(r3, y3)] });
        }
        break;
      }
      case "side_left": {
        if (h3) {
          let y3 = (h3[0] + h3[1]) / 2;
          s3.push({ type: "gap", direction: "horizontal", points: [u$1(i3, y3), u$1(c3, y3)] }, { type: "gap", direction: "horizontal", points: [u$1(U3, y3), u$1(m3, y3)] });
        }
        break;
      }
      case "side_top": {
        if (x3) {
          let y3 = (x3[0] + x3[1]) / 2;
          s3.push({ type: "gap", direction: "vertical", points: [u$1(y3, a3), u$1(y3, l3)] }, { type: "gap", direction: "vertical", points: [u$1(y3, p3), u$1(y3, b3)] });
        }
        break;
      }
      case "side_bottom": {
        if (x3) {
          let y3 = (x3[0] + x3[1]) / 2;
          s3.push({ type: "gap", direction: "vertical", points: [u$1(y3, p3), u$1(y3, b3)] }, { type: "gap", direction: "vertical", points: [u$1(y3, g3), u$1(y3, o3)] });
        }
        break;
      }
    }
  }
  return $b(s3.map((d3) => ({ ...d3, points: d3.points.map((c3) => u$1(Te(c3[0]), Te(c3[1]))) })));
}, TF = (e12, t3, n3, r3, o3, i3) => {
  if (!sr({ event: r3, selectedElements: e12, app: n3 }) || e12.length === 0 || e12.length === 1 && !vb(e12[0].angle, 0)) return { snapOffset: { x: 0, y: 0 }, snapLines: [] };
  let [a3, s3, d3, c3] = $e$1(t3);
  i3 && (i3.includes("e") ? d3 += o3.x : i3.includes("w") && (a3 += o3.x), i3.includes("n") ? s3 += o3.y : i3.includes("s") && (c3 += o3.y));
  let l3 = [];
  if (i3) switch (i3) {
    case "e": {
      l3.push(u$1(d3, s3), u$1(d3, c3));
      break;
    }
    case "w": {
      l3.push(u$1(a3, s3), u$1(a3, c3));
      break;
    }
    case "n": {
      l3.push(u$1(a3, s3), u$1(d3, s3));
      break;
    }
    case "s": {
      l3.push(u$1(a3, c3), u$1(d3, c3));
      break;
    }
    case "ne": {
      l3.push(u$1(d3, s3));
      break;
    }
    case "nw": {
      l3.push(u$1(a3, s3));
      break;
    }
    case "se": {
      l3.push(u$1(d3, c3));
      break;
    }
    case "sw": {
      l3.push(u$1(a3, c3));
      break;
    }
  }
  let U3 = bi$1(n3.state.zoom.value), p3 = { x: U3, y: U3 }, m3 = [], b3 = [];
  ar$1(t3, l3, n3, r3, m3, b3, p3);
  let E3 = { x: m3[0]?.offset ?? 0, y: b3[0]?.offset ?? 0 };
  p3.x = 0, p3.y = 0, m3.length = 0, b3.length = 0;
  let [g3, h3, x3, y3] = $e$1(e12).map((S3) => Te(S3)), w3 = [u$1(g3, h3), u$1(g3, y3), u$1(x3, h3), u$1(x3, y3)];
  ar$1(e12, w3, n3, r3, m3, b3, p3);
  let I3 = Ya$1(m3, b3);
  return { snapOffset: E3, snapLines: I3 };
}, MF = (e12, t3, n3, r3, o3, i3) => {
  if (!sr({ event: n3, selectedElements: [e12], app: t3 })) return { snapOffset: { x: 0, y: 0 }, snapLines: [] };
  let a3 = [u$1(r3.x + o3.x, r3.y + o3.y)], s3 = bi$1(t3.state.zoom.value), d3 = { x: s3, y: s3 }, c3 = [], l3 = [];
  ar$1([e12], a3, t3, n3, c3, l3, d3);
  let U3 = { x: c3[0]?.offset ?? 0, y: l3[0]?.offset ?? 0 };
  d3.x = 0, d3.y = 0, c3.length = 0, l3.length = 0;
  let p3 = Cr$1([e12], i3, { boundingBoxCorners: true, omitCenter: true });
  ar$1([e12], p3, t3, n3, c3, l3, d3);
  let m3 = Ya$1(c3, l3);
  return { snapOffset: U3, snapLines: m3 };
}, LF = (e12, t3, n3, r3, o3) => {
  if (!sr({ event: r3, selectedElements: [], app: t3 })) return { originOffset: { x: 0, y: 0 }, snapLines: [] };
  let i3 = Ca(e12, [], t3.state, o3), a3 = bi$1(t3.state.zoom.value), s3 = { x: a3, y: a3 }, d3 = [], c3 = [];
  for (let l3 of i3) {
    let U3 = Cr$1([l3], o3);
    for (let p3 of U3) {
      let m3 = p3[0] - n3.x;
      Math.abs(m3) <= Math.abs(s3.x) && (Math.abs(m3) < Math.abs(s3.x) && (c3.length = 0), c3.push({ type: "pointer", points: [p3, u$1(p3[0], n3.y)], direction: "vertical" }), s3.x = m3);
      let b3 = p3[1] - n3.y;
      Math.abs(b3) <= Math.abs(s3.y) && (Math.abs(b3) < Math.abs(s3.y) && (d3.length = 0), d3.push({ type: "pointer", points: [p3, u$1(n3.x, p3[1])], direction: "horizontal" }), s3.y = b3);
    }
  }
  return { originOffset: { x: c3.length > 0 ? c3[0].points[0][0] - n3.x : 0, y: d3.length > 0 ? d3[0].points[0][1] - n3.y : 0 }, snapLines: [...c3, ...d3] };
}, DF = (e12) => e12 === fn.rectangle || e12 === fn.ellipse || e12 === fn.diamond || e12 === fn.frame || e12 === fn.magicframe || e12 === fn.image || e12 === fn.text, Vr = (e12, t3, n3) => n3 ? [Math.round(e12 / n3) * n3, Math.round(t3 / n3) * n3] : [e12, t3];
var sn = { version: null, points: [], zoom: null }, K = class K2 {
  constructor(t3) {
    i$1(this, "elementId");
    i$1(this, "selectedPointsIndices");
    i$1(this, "pointerDownState");
    i$1(this, "isDragging");
    i$1(this, "lastUncommittedPoint");
    i$1(this, "pointerOffset");
    i$1(this, "startBindingElement");
    i$1(this, "endBindingElement");
    i$1(this, "hoverPointIndex");
    i$1(this, "segmentMidPointHoveredCoords");
    i$1(this, "elbowed");
    this.elementId = t3.id, _e$1(t3.points[0], u$1(0, 0)) || console.error("Linear element is not normalized", Error().stack), this.selectedPointsIndices = null, this.lastUncommittedPoint = null, this.isDragging = false, this.pointerOffset = { x: 0, y: 0 }, this.startBindingElement = "keep", this.endBindingElement = "keep", this.pointerDownState = { prevSelectedPointsIndices: null, lastClickedPoint: -1, lastClickedIsEndPoint: false, origin: null, segmentMidpoint: { value: null, index: null, added: false } }, this.hoverPointIndex = -1, this.segmentMidPointHoveredCoords = null, this.elbowed = X$1(t3) && t3.elbowed;
  }
  static getElement(t3, n3) {
    let r3 = n3.get(t3);
    return r3 || null;
  }
  static handleBoxSelection(t3, n3, r3, o3) {
    if (!n3.editingLinearElement || !n3.selectionElement) return false;
    let { editingLinearElement: i3 } = n3, { selectedPointsIndices: a3, elementId: s3 } = i3, d3 = K2.getElement(s3, o3);
    if (!d3) return false;
    let [c3, l3, U3, p3] = C$1(n3.selectionElement, o3), b3 = K2.getPointsGlobalCoordinates(d3, o3).reduce((E3, g3, h3) => ((g3[0] >= c3 && g3[0] <= U3 && g3[1] >= l3 && g3[1] <= p3 || t3.shiftKey && a3?.includes(h3)) && E3.push(h3), E3), []).filter((E3) => !(X$1(d3) && E3 !== 0 && E3 !== d3.points.length - 1));
    r3({ editingLinearElement: { ...i3, selectedPointsIndices: b3.length ? b3 : null } });
  }
  static handlePointDragging(t3, n3, r3, o3, i3, a3, s3) {
    if (!a3) return false;
    let { elementId: d3 } = a3, c3 = s3.getNonDeletedElementsMap(), l3 = K2.getElement(d3, c3);
    if (!l3 || X$1(l3) && !a3.pointerDownState.lastClickedIsEndPoint && a3.pointerDownState.lastClickedPoint !== 0) return false;
    let U3 = X$1(l3) ? a3.selectedPointsIndices?.reduce((b3, E3) => E3 === 0 ? [0, b3[1]] : [b3[0], l3.points.length - 1], [false, false]).filter((b3) => typeof b3 == "number") : a3.selectedPointsIndices, p3 = X$1(l3) ? a3.pointerDownState.lastClickedPoint > 0 ? l3.points.length - 1 : 0 : a3.pointerDownState.lastClickedPoint, m3 = l3.points[p3];
    if (U3 && m3) {
      if (ga(t3) && U3.length === 1 && l3.points.length > 1) {
        let E3 = U3[0], g3 = l3.points[E3 === 0 ? 1 : E3 - 1], [h3, x3] = K2._getShiftLockedDelta(l3, c3, g3, u$1(r3, o3), t3[Q.CTRL_OR_CMD] ? null : n3.getEffectiveGridSize());
        K2.movePoints(l3, [{ index: E3, point: u$1(h3 + g3[0], x3 + g3[1]), isDragging: E3 === p3 }]);
      } else {
        let E3 = K2.createPointAt(l3, c3, r3 - a3.pointerOffset.x, o3 - a3.pointerOffset.y, t3[Q.CTRL_OR_CMD] ? null : n3.getEffectiveGridSize()), g3 = E3[0] - m3[0], h3 = E3[1] - m3[1];
        K2.movePoints(l3, U3.map((x3) => {
          let y3 = x3 === p3 ? K2.createPointAt(l3, c3, r3 - a3.pointerOffset.x, o3 - a3.pointerOffset.y, t3[Q.CTRL_OR_CMD] ? null : n3.getEffectiveGridSize()) : u$1(l3.points[x3][0] + g3, l3.points[x3][1] + h3);
          return { index: x3, point: y3, isDragging: x3 === p3 };
        }));
      }
      if (oe(l3, c3) && _n(l3, c3, false), Pr(l3, false)) {
        let E3 = [];
        U3[0] === 0 && E3.push(un(K2.getPointGlobalCoordinates(l3, l3.points[0], c3)));
        let h3 = U3[U3.length - 1];
        h3 === l3.points.length - 1 && E3.push(un(K2.getPointGlobalCoordinates(l3, l3.points[h3], c3))), E3.length && i3(l3, E3);
      }
      return true;
    }
    return false;
  }
  static handlePointerUp(t3, n3, r3, o3) {
    let i3 = o3.getNonDeletedElementsMap(), a3 = o3.getNonDeletedElements(), { elementId: s3, selectedPointsIndices: d3, isDragging: c3, pointerDownState: l3 } = n3, U3 = K2.getElement(s3, i3);
    if (!U3) return n3;
    let p3 = {};
    if (c3 && d3) {
      for (let m3 of d3) if (m3 === 0 || m3 === U3.points.length - 1) {
        Kt(U3.points, r3.zoom.value) && K2.movePoints(U3, [{ index: m3, point: m3 === 0 ? U3.points[U3.points.length - 1] : U3.points[0] }]);
        let b3 = Fa$1(r3) ? Bn(un(K2.getPointAtIndexGlobalCoordinates(U3, m3, i3)), a3, i3, r3.zoom, X$1(U3), X$1(U3)) : null;
        p3[m3 === 0 ? "startBindingElement" : "endBindingElement"] = b3;
      }
    }
    return { ...n3, ...p3, selectedPointsIndices: c3 || t3.shiftKey ? !c3 && t3.shiftKey && l3.prevSelectedPointsIndices?.includes(l3.lastClickedPoint) ? d3 && d3.filter((m3) => m3 !== l3.lastClickedPoint) : d3 : d3?.includes(l3.lastClickedPoint) ? [l3.lastClickedPoint] : d3, isDragging: false, pointerOffset: { x: 0, y: 0 } };
  }
  static isSegmentTooShort(t3, n3, r3, o3, i3) {
    if (X$1(t3)) return o3 >= 0 && o3 < t3.points.length ? ie(n3, r3) * i3.value < K2.POINT_HANDLE_SIZE / 2 : false;
    let a3 = ie(n3, r3);
    return t3.points.length > 2 && t3.roundness && (a3 = $1$1(t3, r3)), a3 * i3.value < K2.POINT_HANDLE_SIZE * 4;
  }
  static getSegmentMidPoint(t3, n3, r3, o3, i3) {
    let a3 = Zt(n3, r3);
    if (t3.points.length > 2 && t3.roundness) {
      let s3 = xa(t3, t3.points[o3]);
      if (s3) {
        let d3 = P1$1(t3, t3.points[o3], 0.5);
        a3 = K2.getPointGlobalCoordinates(t3, ha(s3[0], s3[1], s3[2], s3[3], d3), i3);
      }
    }
    return a3;
  }
  static getSegmentMidPointIndex(t3, n3, r3, o3) {
    let i3 = K2.getElement(t3.elementId, o3);
    if (!i3) return -1;
    let a3 = K2.getEditorMidPoints(i3, o3, n3), s3 = 0;
    for (; s3 < a3.length; ) {
      if (K2.arePointsEqual(r3, a3[s3])) return s3 + 1;
      s3++;
    }
    return -1;
  }
  static handlePointerDown(t3, n3, r3, o3, i3, a3) {
    let s3 = n3.state, d3 = a3.getNonDeletedElementsMap(), c3 = a3.getNonDeletedElements(), l3 = { didAddPoint: false, hitElement: null, linearElementEditor: null };
    if (!i3) return l3;
    let { elementId: U3 } = i3, p3 = K2.getElement(U3, d3);
    if (!p3) return l3;
    let m3 = K2.getSegmentMidpointHitCoords(i3, o3, s3, d3), b3 = null;
    if (m3) b3 = K2.getSegmentMidPointIndex(i3, s3, m3, d3);
    else if (t3.altKey && s3.editingLinearElement) return i3.lastUncommittedPoint == null && (Y(p3, { points: [...p3.points, K2.createPointAt(p3, d3, o3.x, o3.y, t3[Q.CTRL_OR_CMD] ? null : n3.getEffectiveGridSize())] }), l3.didAddPoint = true), r3.shouldCaptureIncrement(), l3.linearElementEditor = { ...i3, pointerDownState: { prevSelectedPointsIndices: i3.selectedPointsIndices, lastClickedPoint: -1, lastClickedIsEndPoint: false, origin: { x: o3.x, y: o3.y }, segmentMidpoint: { value: m3, index: b3, added: false } }, selectedPointsIndices: [p3.points.length - 1], lastUncommittedPoint: null, endBindingElement: Bn(o3, c3, d3, n3.state.zoom, i3.elbowed) }, l3.didAddPoint = true, l3;
    let E3 = K2.getPointIndexUnderCursor(p3, d3, s3.zoom, o3.x, o3.y);
    if (E3 >= 0 || m3) l3.hitElement = p3;
    else {
      let { startBindingElement: D3, endBindingElement: $3 } = i3;
      Fa$1(s3) && Pr(p3) && Ba(p3, D3, $3, d3, a3);
    }
    let [g3, h3, x3, y3] = C$1(p3, d3), w3 = (g3 + x3) / 2, I3 = (h3 + y3) / 2, S3 = E3 > -1 && T$1(u$1(p3.x + p3.points[E3][0], p3.y + p3.points[E3][1]), u$1(w3, I3), p3.angle), v3 = E3 > -1 || t3.shiftKey ? t3.shiftKey || i3.selectedPointsIndices?.includes(E3) ? Nb([...i3.selectedPointsIndices || [], E3]) : [E3] : null;
    return l3.linearElementEditor = { ...i3, pointerDownState: { prevSelectedPointsIndices: i3.selectedPointsIndices, lastClickedPoint: E3, lastClickedIsEndPoint: E3 === p3.points.length - 1, origin: { x: o3.x, y: o3.y }, segmentMidpoint: { value: m3, index: b3, added: false } }, selectedPointsIndices: v3, pointerOffset: S3 ? { x: o3.x - S3[0], y: o3.y - S3[1] } : { x: 0, y: 0 } }, l3;
  }
  static arePointsEqual(t3, n3) {
    return !t3 && !n3 ? true : !t3 || !n3 ? false : _e$1(t3, n3);
  }
  static handlePointerMove(t3, n3, r3, o3, i3) {
    let a3 = o3.state;
    if (!a3.editingLinearElement) return null;
    let { elementId: s3, lastUncommittedPoint: d3 } = a3.editingLinearElement, c3 = K2.getElement(s3, i3);
    if (!c3) return a3.editingLinearElement;
    let { points: l3 } = c3, U3 = l3[l3.length - 1];
    if (!t3.altKey) return U3 === d3 && K2.deletePoints(c3, [l3.length - 1]), { ...a3.editingLinearElement, lastUncommittedPoint: null };
    let p3;
    if (ga(t3) && l3.length >= 2) {
      let m3 = l3[l3.length - 2], [b3, E3] = K2._getShiftLockedDelta(c3, i3, m3, u$1(n3, r3), t3[Q.CTRL_OR_CMD] ? null : o3.getEffectiveGridSize());
      p3 = u$1(b3 + m3[0], E3 + m3[1]);
    } else p3 = K2.createPointAt(c3, i3, n3 - a3.editingLinearElement.pointerOffset.x, r3 - a3.editingLinearElement.pointerOffset.y, t3[Q.CTRL_OR_CMD] || X$1(c3) ? null : o3.getEffectiveGridSize());
    return U3 === d3 ? K2.movePoints(c3, [{ index: c3.points.length - 1, point: p3 }]) : K2.addPoints(c3, [{ point: p3 }]), { ...a3.editingLinearElement, lastUncommittedPoint: c3.points[c3.points.length - 1] };
  }
  static getPointGlobalCoordinates(t3, n3, r3) {
    let [o3, i3, a3, s3] = C$1(t3, r3), d3 = (o3 + a3) / 2, c3 = (i3 + s3) / 2, { x: l3, y: U3 } = t3;
    return T$1(u$1(l3 + n3[0], U3 + n3[1]), u$1(d3, c3), t3.angle);
  }
  static getPointsGlobalCoordinates(t3, n3) {
    let [r3, o3, i3, a3] = C$1(t3, n3), s3 = (r3 + i3) / 2, d3 = (o3 + a3) / 2;
    return t3.points.map((c3) => {
      let { x: l3, y: U3 } = t3;
      return T$1(u$1(l3 + c3[0], U3 + c3[1]), u$1(s3, d3), t3.angle);
    });
  }
  static getPointAtIndexGlobalCoordinates(t3, n3, r3) {
    let o3 = n3 < 0 ? t3.points.length + n3 : n3, [i3, a3, s3, d3] = C$1(t3, r3), c3 = (i3 + s3) / 2, l3 = (a3 + d3) / 2, U3 = t3.points[o3], { x: p3, y: m3 } = t3;
    return U3 ? T$1(u$1(p3 + U3[0], m3 + U3[1]), u$1(c3, l3), t3.angle) : T$1(u$1(p3, m3), u$1(c3, l3), t3.angle);
  }
  static pointFromAbsoluteCoords(t3, n3, r3) {
    if (X$1(t3)) return u$1(n3[0] - t3.x, n3[1] - t3.y);
    let [o3, i3, a3, s3] = C$1(t3, r3), d3 = (o3 + a3) / 2, c3 = (i3 + s3) / 2, [l3, U3] = T$1(u$1(n3[0], n3[1]), u$1(d3, c3), -t3.angle);
    return u$1(l3 - t3.x, U3 - t3.y);
  }
  static getPointIndexUnderCursor(t3, n3, r3, o3, i3) {
    let a3 = K2.getPointsGlobalCoordinates(t3, n3), s3 = a3.length;
    for (; --s3 > -1; ) {
      let d3 = a3[s3];
      if (ie(u$1(o3, i3), u$1(d3[0], d3[1])) * r3.value < K2.POINT_HANDLE_SIZE + 1) return s3;
    }
    return -1;
  }
  static createPointAt(t3, n3, r3, o3, i3) {
    let a3 = Vr(r3, o3, i3), [s3, d3, c3, l3] = C$1(t3, n3), U3 = (s3 + c3) / 2, p3 = (d3 + l3) / 2, [m3, b3] = T$1(u$1(a3[0], a3[1]), u$1(U3, p3), -t3.angle);
    return u$1(m3 - t3.x, b3 - t3.y);
  }
  static getNormalizedPoints(t3) {
    let { points: n3 } = t3, r3 = n3[0][0], o3 = n3[0][1];
    return { points: n3.map((i3) => u$1(i3[0] - r3, i3[1] - o3)), x: t3.x + r3, y: t3.y + o3 };
  }
  static normalizePoints(t3) {
    Y(t3, K2.getNormalizedPoints(t3));
  }
  static duplicateSelectedPoints(t3, n3) {
    Ae(t3.editingLinearElement, "Not currently editing a linear element");
    let { selectedPointsIndices: r3, elementId: o3 } = t3.editingLinearElement, i3 = K2.getElement(o3, n3);
    Ae(i3, "The linear element does not exist in the provided Scene"), Ae(r3 != null, "There are no selected points to duplicate");
    let { points: a3 } = i3, s3 = [], d3 = false, c3 = -1, l3 = a3.reduce((U3, p3, m3) => {
      if (++c3, U3.push(p3), r3.includes(m3)) {
        let E3 = a3[m3 + 1];
        E3 || (d3 = true), U3.push(E3 ? u$1((p3[0] + E3[0]) / 2, (p3[1] + E3[1]) / 2) : u$1(p3[0], p3[1])), s3.push(c3 + 1), ++c3;
      }
      return U3;
    }, []);
    if (Y(i3, { points: l3 }), d3) {
      let U3 = i3.points[i3.points.length - 1];
      K2.movePoints(i3, [{ index: i3.points.length - 1, point: u$1(U3[0] + 30, U3[1] + 30) }]);
    }
    return { ...t3, editingLinearElement: { ...t3.editingLinearElement, selectedPointsIndices: s3 } };
  }
  static deletePoints(t3, n3) {
    let r3 = 0, o3 = 0;
    if (n3.includes(0)) {
      let s3 = t3.points.find((d3, c3) => !n3.includes(c3));
      s3 && (r3 = s3[0], o3 = s3[1]);
    }
    let a3 = t3.points.reduce((s3, d3, c3) => (n3.includes(c3) || s3.push(s3.length ? u$1(d3[0] - r3, d3[1] - o3) : u$1(0, 0)), s3), []);
    K2._updatePoints(t3, a3, r3, o3);
  }
  static addPoints(t3, n3) {
    let i3 = [...t3.points, ...n3.map((a3) => a3.point)];
    K2._updatePoints(t3, i3, 0, 0);
  }
  static movePoints(t3, n3, r3) {
    let { points: o3 } = t3, [i3, a3] = n3.find(({ index: l3 }) => l3 === 0)?.point ?? u$1(0, 0), [s3, d3] = u$1(i3 - o3[0][0], a3 - o3[0][1]), c3 = X$1(t3) ? [n3.find((l3) => l3.index === 0)?.point ?? o3[0], n3.find((l3) => l3.index === o3.length - 1)?.point ?? o3[o3.length - 1]] : o3.map((l3, U3) => {
      let p3 = n3.find((m3) => m3.index === U3)?.point ?? l3;
      return u$1(p3[0] - s3, p3[1] - d3);
    });
    K2._updatePoints(t3, c3, s3, d3, r3, { isDragging: n3.reduce((l3, U3) => l3 || U3.isDragging === true, false) });
  }
  static shouldAddMidpoint(t3, n3, r3, o3) {
    let i3 = K2.getElement(t3.elementId, o3);
    if (i3 && X$1(i3) || !i3) return false;
    let { segmentMidpoint: a3 } = t3.pointerDownState;
    if (a3.added || a3.value === null || a3.index === null || t3.pointerDownState.origin === null) return false;
    let s3 = t3.pointerDownState.origin, d3 = ie(u$1(s3.x, s3.y), u$1(n3.x, n3.y));
    return !(!r3.editingLinearElement && d3 < As / r3.zoom.value);
  }
  static addMidpoint(t3, n3, r3, o3, i3) {
    let a3 = K2.getElement(t3.elementId, i3);
    if (!a3) return;
    let { segmentMidpoint: s3 } = t3.pointerDownState, d3 = { pointerDownState: t3.pointerDownState, selectedPointsIndices: t3.selectedPointsIndices }, c3 = K2.createPointAt(a3, i3, n3.x, n3.y, o3 && !X$1(a3) ? r3.getEffectiveGridSize() : null), l3 = [...a3.points.slice(0, s3.index), c3, ...a3.points.slice(s3.index)];
    return Y(a3, { points: l3 }), d3.pointerDownState = { ...t3.pointerDownState, segmentMidpoint: { ...t3.pointerDownState.segmentMidpoint, added: true }, lastClickedPoint: s3.index }, d3.selectedPointsIndices = [s3.index], d3;
  }
  static _updatePoints(t3, n3, r3, o3, i3, a3) {
    if (X$1(t3)) {
      let s3 = {};
      i3?.startBinding !== void 0 && (s3.startBinding = i3.startBinding !== null && vn$1(i3.startBinding) ? i3.startBinding : null), i3?.endBinding !== void 0 && (s3.endBinding = i3.endBinding !== null && vn$1(i3.endBinding) ? i3.endBinding : null), s3.points = Array.from(n3), Y(t3, s3, true, { isDragging: a3?.isDragging });
    } else {
      let s3 = $a$1(t3, n3), d3 = $a$1(t3, t3.points), c3 = (s3[0] + s3[2]) / 2, l3 = (s3[1] + s3[3]) / 2, U3 = (d3[0] + d3[2]) / 2, p3 = (d3[1] + d3[3]) / 2, m3 = U3 - c3, b3 = p3 - l3, E3 = T$1(u$1(r3, o3), u$1(m3, b3), t3.angle);
      Y(t3, { ...i3, points: n3, x: t3.x + E3[0], y: t3.y + E3[1] });
    }
  }
  static _getShiftLockedDelta(t3, n3, r3, o3, i3) {
    let a3 = K2.getPointGlobalCoordinates(t3, r3, n3);
    if (X$1(t3)) return [o3[0] - a3[0], o3[1] - a3[1]];
    let [s3, d3] = Vr(o3[0], o3[1], i3), { width: c3, height: l3 } = Va(a3[0], a3[1], s3, d3);
    return T$1(u$1(c3, l3), u$1(0, 0), -t3.angle);
  }
  static moveFixedSegment(t3, n3, r3, o3, i3) {
    let a3 = K2.getElement(t3.elementId, i3);
    if (!a3 || !X$1(a3)) return t3;
    if (n3 && n3 > 0 && n3 < a3.points.length) {
      let s3 = Lt(Ht$1(O(a3.points[n3], a3.points[n3 - 1]))), d3 = (a3.fixedSegments ?? []).reduce((p3, m3) => (p3[m3.index] = m3, p3), {});
      d3[n3] = { index: n3, start: u$1(s3 ? a3.points[n3 - 1][0] : r3 - a3.x, s3 ? o3 - a3.y : a3.points[n3 - 1][1]), end: u$1(s3 ? a3.points[n3][0] : r3 - a3.x, s3 ? o3 - a3.y : a3.points[n3][1]) };
      let c3 = Object.values(d3).sort((p3, m3) => p3.index - m3.index), l3 = c3.map((p3) => p3.index).reduce((p3, m3) => m3 < n3 ? p3 + 1 : p3, 0);
      Y(a3, { fixedSegments: c3 });
      let U3 = u$1(a3.x + (a3.fixedSegments[l3].start[0] + a3.fixedSegments[l3].end[0]) / 2, a3.y + (a3.fixedSegments[l3].start[1] + a3.fixedSegments[l3].end[1]) / 2);
      return { ...t3, segmentMidPointHoveredCoords: U3, pointerDownState: { ...t3.pointerDownState, segmentMidpoint: { added: false, index: a3.fixedSegments[l3].index, value: U3 } } };
    }
    return t3;
  }
  static deleteFixedSegment(t3, n3) {
    Y(t3, { fixedSegments: t3.fixedSegments?.filter((r3) => r3.index !== n3) }), Y(t3, {}, true);
  }
};
i$1(K, "POINT_HANDLE_SIZE", 10), i$1(K, "getEditorMidPoints", (t3, n3, r3) => {
  let o3 = oe(t3, n3);
  return !X$1(t3) && !r3.editingLinearElement && t3.points.length > 2 && !o3 ? [] : (sn.version === t3.version && sn.zoom === r3.zoom.value || K.updateEditorMidPointsCache(t3, n3, r3), sn.points);
}), i$1(K, "updateEditorMidPointsCache", (t3, n3, r3) => {
  let o3 = K.getPointsGlobalCoordinates(t3, n3), i3 = 0, a3 = [];
  for (; i3 < o3.length - 1; ) {
    if (K.isSegmentTooShort(t3, t3.points[i3], t3.points[i3 + 1], i3, r3.zoom)) {
      a3.push(null), i3++;
      continue;
    }
    let s3 = K.getSegmentMidPoint(t3, o3[i3], o3[i3 + 1], i3 + 1, n3);
    a3.push(s3), i3++;
  }
  sn.points = a3, sn.version = t3.version, sn.zoom = r3.zoom.value;
}), i$1(K, "getSegmentMidpointHitCoords", (t3, n3, r3, o3) => {
  let { elementId: i3 } = t3, a3 = K.getElement(i3, o3);
  if (!a3) return null;
  let s3 = K.getPointIndexUnderCursor(a3, o3, r3.zoom, n3.x, n3.y);
  if (!X$1(a3) && s3 >= 0 || K.getPointsGlobalCoordinates(a3, o3).length >= 3 && !r3.editingLinearElement && !X$1(a3)) return null;
  let c3 = (K.POINT_HANDLE_SIZE + 1) / r3.zoom.value, l3 = t3.segmentMidPointHoveredCoords;
  if (l3 && ie(u$1(l3[0], l3[1]), u$1(n3.x, n3.y)) <= c3) return l3;
  let U3 = 0, p3 = K.getEditorMidPoints(a3, o3, r3);
  for (; U3 < p3.length; ) {
    if (p3[U3] !== null && ie(p3[U3], u$1(n3.x, n3.y)) <= c3) return p3[U3];
    U3++;
  }
  return null;
}), i$1(K, "getBoundTextElementPosition", (t3, n3, r3) => {
  let o3 = K.getPointsGlobalCoordinates(t3, r3);
  o3.length < 2 && Y(n3, { isDeleted: true });
  let i3 = 0, a3 = 0;
  if (t3.points.length % 2 === 1) {
    let s3 = Math.floor(t3.points.length / 2), d3 = K.getPointGlobalCoordinates(t3, t3.points[s3], r3);
    i3 = d3[0] - n3.width / 2, a3 = d3[1] - n3.height / 2;
  } else {
    let s3 = t3.points.length / 2 - 1, d3 = sn.points[s3];
    t3.points.length === 2 && (d3 = Zt(o3[0], o3[1])), (!d3 || sn.version !== t3.version) && (d3 = K.getSegmentMidPoint(t3, o3[s3], o3[s3 + 1], s3 + 1, r3)), i3 = d3[0] - n3.width / 2, a3 = d3[1] - n3.height / 2;
  }
  return { x: i3, y: a3 };
}), i$1(K, "getMinMaxXYWithBoundText", (t3, n3, r3, o3) => {
  let [i3, a3, s3, d3] = r3, c3 = (i3 + s3) / 2, l3 = (a3 + d3) / 2, { x: U3, y: p3 } = K.getBoundTextElementPosition(t3, o3, n3), m3 = U3 + o3.width, b3 = p3 + o3.height, E3 = u$1(c3, l3), g3 = T$1(u$1(i3, a3), E3, t3.angle), h3 = T$1(u$1(s3, a3), E3, t3.angle), x3 = T$1(u$1(U3, p3), E3, -t3.angle), y3 = T$1(u$1(m3, p3), E3, -t3.angle), w3 = T$1(u$1(U3, b3), E3, -t3.angle), I3 = T$1(u$1(m3, b3), E3, -t3.angle);
  return g3[0] < h3[0] && g3[1] >= h3[1] ? (i3 = Math.min(i3, w3[0]), s3 = Math.max(s3, Math.max(y3[0], I3[0])), a3 = Math.min(a3, x3[1]), d3 = Math.max(d3, I3[1])) : g3[0] >= h3[0] && g3[1] > h3[1] ? (i3 = Math.min(i3, I3[0]), s3 = Math.max(s3, Math.max(x3[0], y3[0])), a3 = Math.min(a3, w3[1]), d3 = Math.max(d3, y3[1])) : g3[0] >= h3[0] ? (i3 = Math.min(i3, y3[0]), s3 = Math.max(s3, w3[0]), a3 = Math.min(a3, I3[1]), d3 = Math.max(d3, x3[1])) : g3[1] <= h3[1] && (i3 = Math.min(i3, Math.min(y3[0], x3[0])), s3 = Math.max(s3, I3[0]), a3 = Math.min(a3, y3[1]), d3 = Math.max(d3, w3[1])), [i3, a3, s3, d3, c3, l3];
}), i$1(K, "getElementAbsoluteCoords", (t3, n3, r3 = false) => {
  let o3, i3, a3, s3, d3;
  if (t3.points.length < 2 || !he.get(t3)) {
    let { minX: p3, minY: m3, maxX: b3, maxY: E3 } = t3.points.reduce((g3, [h3, x3]) => (g3.minY = Math.min(g3.minY, x3), g3.minX = Math.min(g3.minX, h3), g3.maxX = Math.max(g3.maxX, h3), g3.maxY = Math.max(g3.maxY, x3), g3), { minX: 1 / 0, minY: 1 / 0, maxX: -1 / 0, maxY: -1 / 0 });
    i3 = p3 + t3.x, a3 = m3 + t3.y, s3 = b3 + t3.x, d3 = E3 + t3.y;
  } else {
    let p3 = he.generateElementShape(t3, null), m3 = It(p3[0]), [b3, E3, g3, h3] = Hr(m3);
    i3 = b3 + t3.x, a3 = E3 + t3.y, s3 = g3 + t3.x, d3 = h3 + t3.y;
  }
  let c3 = (i3 + s3) / 2, l3 = (a3 + d3) / 2;
  if (o3 = [i3, a3, s3, d3, c3, l3], !r3) return o3;
  let U3 = oe(t3, n3);
  return U3 && (o3 = K.getMinMaxXYWithBoundText(t3, n3, [i3, a3, s3, d3], U3)), o3;
});
var z$1 = K, Nb = (e12) => {
  let t3 = [...new Set(e12.filter((n3) => n3 !== null && n3 !== -1))];
  return t3 = t3.sort((n3, r3) => n3 - r3), t3.length ? t3 : null;
};
var qr = {}, I2 = (e12, t3) => {
  let n3 = qr[e12] || (qr[e12] = { height: t3 });
  return n3.height = t3, n3;
}, w2 = (e12) => {
  qr[e12] && delete qr[e12];
}, WF = (e12) => qr[e12]?.height ?? null;
var Xa$1 = (e12, t3, n3, r3 = true) => {
  let o3, i3 = { x: e12.x, y: e12.y, text: e12.text, width: e12.width, height: e12.height, angle: t3?.angle ?? e12.angle };
  i3.text = e12.text, (t3 || !e12.autoResize) && (o3 = t3 ? Tt$1(t3, e12) : e12.width, i3.text = en(e12.originalText, Ee(e12), o3));
  let a3 = ht(i3.text, Ee(e12), e12.lineHeight);
  if (e12.autoResize && (i3.width = a3.width), i3.height = a3.height, t3) {
    let s3 = Ar(t3, e12), d3 = Tt$1(t3, e12);
    if (!ee(t3) && a3.height > s3) {
      let p3 = qa(a3.height, t3.type);
      Y(t3, { height: p3 }, r3), I2(t3.id, p3);
    }
    if (a3.width > d3) {
      let p3 = qa(a3.width, t3.type);
      Y(t3, { width: p3 }, r3);
    }
    let c3 = { ...e12, ...i3 }, { x: l3, y: U3 } = R2(t3, c3, n3);
    i3.x = l3, i3.y = U3;
  }
  Y(e12, i3, r3);
}, dB = (e12, t3, n3) => {
  let r3 = te(e12);
  t3.forEach((o3) => {
    let i3 = n3.get(o3.id), a3 = Yt(o3);
    if (a3) {
      let s3 = n3.get(a3);
      if (s3) {
        let d3 = r3.get(i3);
        d3 && Y(d3, { boundElements: (o3.boundElements || []).filter((l3) => l3.id !== s3 && l3.id !== a3).concat({ type: "text", id: s3 }) });
        let c3 = r3.get(s3);
        c3 && k$2(c3) && Y(c3, { containerId: d3 ? i3 : null });
      }
    }
  });
}, _n = (e12, t3, n3, r3 = false) => {
  if (!Yt(e12)) return;
  w2(e12.id);
  let i3 = oe(e12, t3);
  if (i3 && i3.text) {
    if (!e12) return;
    let a3 = i3.text, s3 = i3.height, d3 = i3.width, c3 = Tt$1(e12, i3), l3 = Ar(e12, i3), U3 = e12.height;
    if (r3 || n3 !== "n" && n3 !== "s") {
      a3 && (a3 = en(i3.originalText, Ee(i3), c3));
      let p3 = ht(a3, Ee(i3), i3.lineHeight);
      s3 = p3.height, d3 = p3.width;
    }
    if (s3 > l3) {
      U3 = qa(s3, e12.type);
      let p3 = U3 - e12.height, m3 = !ee(e12) && (n3 === "ne" || n3 === "nw" || n3 === "n") ? e12.y - p3 : e12.y;
      Y(e12, { height: U3, y: m3 });
    }
    Y(i3, { text: a3, width: d3, height: s3 }), ee(e12) || Y(i3, R2(e12, i3, t3));
  }
}, R2 = (e12, t3, n3) => {
  if (ee(e12)) return z$1.getBoundTextElementPosition(e12, t3, n3);
  let r3 = Ra$1(e12), o3 = Ar(e12, t3), i3 = Tt$1(e12, t3), a3, s3;
  return t3.verticalAlign === kt.TOP ? s3 = r3.y : t3.verticalAlign === kt.BOTTOM ? s3 = r3.y + (o3 - t3.height) : s3 = r3.y + (o3 / 2 - t3.height / 2), t3.textAlign === Xi$1.LEFT ? a3 = r3.x : t3.textAlign === Xi$1.RIGHT ? a3 = r3.x + (i3 - t3.width) : a3 = r3.x + (i3 / 2 - t3.width / 2), { x: a3, y: s3 };
}, Yt = (e12) => e12?.boundElements?.length && e12?.boundElements?.find((t3) => t3.type === "text")?.id || null, oe = (e12, t3) => {
  if (!e12) return null;
  let n3 = Yt(e12);
  return n3 && t3.get(n3) || null;
}, qe = (e12, t3) => e12 && e12.containerId && t3.get(e12.containerId) || null, cB = (e12, t3, n3) => {
  if (!ee(e12)) return { x: e12.x + e12.width / 2, y: e12.y + e12.height / 2 };
  let r3 = z$1.getPointsGlobalCoordinates(e12, n3);
  if (r3.length % 2 === 1) {
    let a3 = Math.floor(e12.points.length / 2), s3 = z$1.getPointGlobalCoordinates(e12, e12.points[a3], n3);
    return { x: s3[0], y: s3[1] };
  }
  let o3 = e12.points.length / 2 - 1, i3 = z$1.getEditorMidPoints(e12, n3, t3)[o3];
  return i3 || (i3 = z$1.getSegmentMidPoint(e12, r3[o3], r3[o3 + 1], o3 + 1, n3)), { x: i3[0], y: i3[1] };
}, Ra$1 = (e12) => {
  let t3 = Se, n3 = Se;
  return e12.type === "ellipse" && (t3 += e12.width / 2 * (1 - Math.sqrt(2) / 2), n3 += e12.height / 2 * (1 - Math.sqrt(2) / 2)), e12.type === "diamond" && (t3 += e12.width / 4, n3 += e12.height / 4), { x: e12.x + t3, y: e12.y + n3 };
}, lB = (e12, t3) => !t3 || ee(t3) ? e12.angle : t3.angle;
var UB = (e12, t3) => e12.some((n3) => {
  if (Ne(n3)) {
    let r3 = qe(n3, t3);
    return !ee(r3);
  }
  return false;
}), fB = (e12, t3) => e12.some((n3) => {
  if (Ne(n3)) {
    let r3 = qe(n3, t3);
    return !ee(r3);
  }
  return k$2(n3);
}), Fb = /* @__PURE__ */ new Set(["rectangle", "ellipse", "diamond", "arrow"]), pB = (e12) => Fb.has(e12.type), qa = (e12, t3) => {
  e12 = Math.ceil(e12);
  let n3 = Se * 2;
  return t3 === "ellipse" ? Math.round((e12 + n3) / Math.sqrt(2) * 2) : t3 === "arrow" ? e12 + n3 * 8 : t3 === "diamond" ? 2 * (e12 + n3) : e12 + n3;
}, Tt$1 = (e12, t3) => {
  let { width: n3 } = e12;
  if (ee(e12)) {
    let r3 = (t3?.fontSize ?? ut) * qs$1;
    return Math.max(Vs * n3, r3);
  }
  return e12.type === "ellipse" ? Math.round(n3 / 2 * Math.sqrt(2)) - Se * 2 : e12.type === "diamond" ? Math.round(n3 / 2) - Se * 2 : n3 - Se * 2;
}, Ar = (e12, t3) => {
  let { height: n3 } = e12;
  return ee(e12) ? n3 - Se * 8 * 2 <= 0 ? t3.height : n3 : e12.type === "ellipse" ? Math.round(n3 / 2 * Math.sqrt(2)) - Se * 2 : e12.type === "diamond" ? Math.round(n3 / 2) - Se * 2 : n3 - Se * 2;
}, Bb = (e12, t3 = `

`) => e12.reduce((r3, o3) => (k$2(o3) && r3.push(o3.text), r3), []).join(t3);
var dn = (e12) => (e12 = e12.trim(), e12 && distExports.sanitizeUrl(kn$1(e12))), gB = (e12) => !!(e12?.includes(location.origin) || e12?.startsWith("/")), T2 = (e12) => {
  if (e12 = dn(e12), e12.startsWith("/")) return `${location.origin}${e12}`;
  try {
    new URL(e12);
  } catch {
    return "about:blank";
  }
  return e12;
};
var M2 = [], L2 = (e12) => (M2 = M2.concat(e12), e12);
var S2 = '<svg viewBox="0 0 24 24" stroke-width="1" width="28" height="28" xmlns="http://www.w3.org/2000/svg">', Ob = '<path d="M6.164 11.755a5.314 5.314 0 0 1-4.932-5.298 5.314 5.314 0 0 1 5.311-5.311 5.314 5.314 0 0 1 5.307 5.113l8.773 8.773a3.322 3.322 0 0 1 0 4.696l-.895.895a3.322 3.322 0 0 1-4.696 0l-8.868-8.868Z" style="fill:#fff"/>', v2$1 = '<path stroke="#1b1b1f" fill="#fff" d="m7.868 11.113 7.773 7.774a2.359 2.359 0 0 0 1.667.691 2.368 2.368 0 0 0 2.357-2.358c0-.625-.248-1.225-.69-1.667L11.201 7.78 9.558 9.469l-1.69 1.643v.001Zm10.273 3.606-3.333 3.333m-3.25-6.583 2 2m-7-7 3 3M3.664 3.625l1 1M2.529 6.922l1.407-.144m5.735-2.932-1.118.866M4.285 9.823l.758-1.194m1.863-6.207-.13 1.408"/>', Ab = `data:${H.svg},${encodeURIComponent(`${S2}${v2$1}</svg>`)}`, Kb = `data:${H.svg},${encodeURIComponent(`${S2}${Ob}${v2$1}</svg>`)}`, Hb = (e12) => {
  e12 && (e12.style.cursor = "");
}, Jb = (e12, t3) => {
  e12 && (e12.style.cursor = t3);
}, Ct, D2, Yb = (e12, t3) => {
  let r3 = () => {
    let o3 = t3 === ke.DARK;
    Ct = document.createElement("canvas"), Ct.theme = t3, Ct.height = 20, Ct.width = 20;
    let i3 = Ct.getContext("2d");
    i3.lineWidth = 1, i3.beginPath(), i3.arc(Ct.width / 2, Ct.height / 2, 5, 0, 2 * Math.PI), i3.fillStyle = o3 ? _d$1.black : _d$1.white, i3.fill(), i3.strokeStyle = o3 ? _d$1.white : _d$1.black, i3.stroke(), D2 = Ct.toDataURL(H.svg);
  };
  (!Ct || Ct.theme !== t3) && r3(), Jb(e12, `url(${D2}) ${20 / 2} ${20 / 2}, auto`);
}, $2 = (e12, t3) => {
  if (e12) if (t3.activeTool.type === "selection") Hb(e12);
  else if (nd(t3)) e12.style.cursor = mo.GRAB;
  else if (td$1(t3)) Yb(e12, t3.theme);
  else if (t3.activeTool.type === "laser") {
    let n3 = t3.theme === ke.LIGHT ? Ab : Kb;
    e12.style.cursor = `url(${n3}), auto`;
  } else ["image", "custom"].includes(t3.activeTool.type) ? t3.activeTool.type !== "image" && (e12.style.cursor = mo.AUTO) : e12.style.cursor = mo.CROSSHAIR;
};
var qb = new Random(Date.now()), Xb = 0, Vt = () => Math.floor(qb.next() * 2 ** 31);
var Dt = () => Ot() ? `id${Xb++}` : nanoid();
var St = (e12, { x: t3, y: n3, strokeColor: r3 = we.strokeColor, backgroundColor: o3 = we.backgroundColor, fillStyle: i3 = we.fillStyle, strokeWidth: a3 = we.strokeWidth, strokeStyle: s3 = we.strokeStyle, roughness: d3 = we.roughness, opacity: c3 = we.opacity, width: l3 = 0, height: U3 = 0, angle: p3 = 0, groupIds: m3 = [], frameId: b3 = null, index: E3 = null, roundness: g3 = null, boundElements: h3 = null, link: x3 = null, locked: y3 = we.locked, ...w3 }) => ((t3 < -1e6 || t3 > 1e6 || n3 < -1e6 || n3 > 1e6 || l3 < -1e6 || l3 > 1e6 || U3 < -1e6 || U3 > 1e6) && console.error("New element size or position is too large", { x: t3, y: n3, width: l3, height: U3, points: w3.points }), { id: w3.id || Dt(), type: e12, x: t3, y: n3, width: l3, height: U3, angle: p3, strokeColor: r3, backgroundColor: o3, fillStyle: i3, strokeWidth: a3, strokeStyle: s3, roughness: d3, opacity: c3, groupIds: m3, frameId: b3, index: E3, roundness: g3, seed: w3.seed ?? Vt(), version: w3.version || 1, versionNonce: w3.versionNonce ?? 0, isDeleted: false, boundElements: h3, updated: zt(), link: x3, locked: y3, customData: w3.customData }), Xr = (e12) => St(e12.type, e12), VB = (e12) => St("embeddable", e12), qB = (e12) => ({ ...St("iframe", e12) }), XB = (e12) => vt$1({ ...St("frame", e12), type: "frame", name: e12?.name || null }, {}), GB = (e12) => vt$1({ ...St("magicframe", e12), type: "magicframe", name: e12?.name || null }, {}), P2 = (e12, t3) => ({ x: e12.textAlign === "center" ? t3.width / 2 : e12.textAlign === "right" ? t3.width : 0, y: e12.verticalAlign === "middle" ? t3.height / 2 : 0 }), qt = (e12) => {
  let t3 = e12.fontFamily || Ft, n3 = e12.fontSize || ut, r3 = e12.lineHeight || ko(t3), o3 = ia(e12.text), i3 = ht(o3, Ee({ fontFamily: t3, fontSize: n3 }), r3), a3 = e12.textAlign || Vn, s3 = e12.verticalAlign || go, d3 = P2({ textAlign: a3, verticalAlign: s3 }, i3), c3 = { ...St("text", e12), text: o3, fontSize: n3, fontFamily: t3, textAlign: a3, verticalAlign: s3, x: e12.x - d3.x, y: e12.y - d3.y, width: i3.width, height: i3.height, containerId: e12.containerId || null, originalText: e12.originalText ?? o3, autoResize: e12.autoResize ?? true, lineHeight: r3 };
  return vt$1(c3, {});
}, Gb = (e12, t3, n3) => {
  let { width: r3, height: o3 } = ht(n3, Ee(e12), e12.lineHeight);
  e12.autoResize || (r3 = e12.width);
  let { textAlign: i3, verticalAlign: a3 } = e12, s3, d3;
  if (i3 === "center" && a3 === kt.MIDDLE && !e12.containerId && e12.autoResize) {
    let c3 = ht(e12.text, Ee(e12), e12.lineHeight), l3 = P2(e12, { width: r3 - c3.width, height: o3 - c3.height });
    s3 = e12.x - l3.x, d3 = e12.y - l3.y;
  } else {
    let [c3, l3, U3, p3] = C$1(e12, t3), [m3, b3, E3, g3] = Rt(e12, r3, o3, false), h3 = (c3 - m3) / 2, x3 = (l3 - b3) / 2, y3 = (U3 - E3) / 2, w3 = (p3 - g3) / 2;
    [s3, d3] = kb({ s: true, e: i3 === "center" || i3 === "left", w: i3 === "center" || i3 === "right" }, e12.x, e12.y, e12.angle, h3, x3, y3, w3);
  }
  return { width: r3, height: o3, x: Number.isFinite(s3) ? s3 : e12.x, y: Number.isFinite(d3) ? d3 : e12.y };
}, kb = (e12, t3, n3, r3, o3, i3, a3, s3) => {
  let d3 = Math.cos(r3), c3 = Math.sin(r3);
  return e12.e && e12.w ? t3 += o3 + a3 : e12.e ? (t3 += o3 * (1 + d3), n3 += o3 * c3, t3 += a3 * (1 - d3), n3 += a3 * -c3) : e12.w && (t3 += o3 * (1 - d3), n3 += o3 * -c3, t3 += a3 * (1 + d3), n3 += a3 * c3), e12.n && e12.s ? n3 += i3 + s3 : e12.n ? (t3 += i3 * c3, n3 += i3 * (1 - d3), t3 += s3 * -c3, n3 += s3 * (1 + d3)) : (t3 += i3 * -c3, n3 += i3 * (1 + d3), t3 += s3 * c3, n3 += s3 * (1 - d3)), [t3, n3];
}, Ga$1 = (e12, t3, n3, r3 = e12.text) => {
  if (e12.isDeleted) return;
  (t3 || !e12.autoResize) && (r3 = en(r3, Ee(e12), t3 ? Tt$1(t3, e12) : e12.width));
  let o3 = Gb(e12, n3, r3);
  return { text: r3, ...o3 };
}, kB = (e12) => ({ ...St(e12.type, e12), points: e12.points || [], pressures: e12.pressures || [], simulatePressure: e12.simulatePressure, lastCommittedPoint: null }), On = (e12) => ({ ...St(e12.type, e12), points: e12.points || [], lastCommittedPoint: null, startBinding: null, endBinding: null, startArrowhead: null, endArrowhead: null }), Zb = (e12) => e12.elbowed ? { ...St(e12.type, e12), points: e12.points || [], lastCommittedPoint: null, startBinding: null, endBinding: null, startArrowhead: e12.startArrowhead || null, endArrowhead: e12.endArrowhead || null, elbowed: true, fixedSegments: e12.fixedSegments || [], startIsSpecial: false, endIsSpecial: false } : { ...St(e12.type, e12), points: e12.points || [], lastCommittedPoint: null, startBinding: null, endBinding: null, startArrowhead: e12.startArrowhead || null, endArrowhead: e12.endArrowhead || null, elbowed: false }, Wb = (e12) => ({ ...St("image", e12), strokeColor: "transparent", status: e12.status ?? "pending", fileId: e12.fileId ?? null, scale: e12.scale ?? [1, 1], crop: e12.crop ?? null }), gi = (e12, t3 = 0) => {
  if (e12 == null || typeof e12 != "object") return e12;
  let n3 = Object.prototype.toString.call(e12);
  if (n3 === "[object Object]") {
    let r3 = typeof e12.constructor == "function" ? Object.create(Object.getPrototypeOf(e12)) : {};
    for (let o3 in e12) if (e12.hasOwnProperty(o3)) {
      if (t3 === 0 && (o3 === "shape" || o3 === "canvas")) continue;
      r3[o3] = gi(e12[o3], t3 + 1);
    }
    return r3;
  }
  if (Array.isArray(e12)) {
    let r3 = e12.length, o3 = new Array(r3);
    for (; r3--; ) o3[r3] = gi(e12[r3], t3 + 1);
    return o3;
  }
  return c$1.DEV && n3 !== "[object Object]" && n3 !== "[object Array]" && n3.startsWith("[object ") && console.warn(`_deepCloneElement: unexpected object type ${n3}. This value will not be cloned!`), e12;
}, Gr = (e12) => gi(e12), N2$1 = (e12, t3) => {
  Object.defineProperty(e12, Qs, { value: t3, writable: false, enumerable: false });
}, xi$1 = () => Dt(), zb = (e12, t3, n3, r3) => {
  let o3 = Gr(n3);
  return Ot() && N2$1(o3, n3.id), o3.id = xi$1(), o3.boundElements = null, o3.updated = zt(), o3.seed = Vt(), o3.groupIds = u2(o3.groupIds, e12, (i3) => (t3.has(i3) || t3.set(i3, xi$1()), t3.get(i3))), r3 && (o3 = Object.assign(o3, r3)), o3;
}, ZB = (e12, t3) => {
  let n3 = [], r3 = te(e12), o3 = /* @__PURE__ */ new Map(), i3 = (s3) => {
    if (o3.has(s3)) return o3.get(s3);
    if (r3.has(s3)) {
      let d3 = xi$1();
      return o3.set(s3, d3), d3;
    }
    return null;
  }, a3 = /* @__PURE__ */ new Map();
  for (let s3 of e12) {
    let d3 = gi(s3);
    if (d3.id = i3(s3.id), Ot() && N2$1(d3, s3.id), t3?.randomizeSeed && (d3.seed = Vt(), kr$1(d3)), d3.groupIds && (d3.groupIds = d3.groupIds.map((c3) => (a3.has(c3) || a3.set(c3, xi$1()), a3.get(c3)))), "containerId" in d3 && d3.containerId) {
      let c3 = i3(d3.containerId);
      d3.containerId = c3;
    }
    if ("boundElements" in d3 && d3.boundElements && (d3.boundElements = d3.boundElements.reduce((c3, l3) => {
      let U3 = i3(l3.id);
      return U3 && c3.push({ ...l3, id: U3 }), c3;
    }, [])), "endBinding" in d3 && d3.endBinding) {
      let c3 = i3(d3.endBinding.elementId);
      d3.endBinding = c3 ? { ...d3.endBinding, elementId: c3 } : null;
    }
    if ("startBinding" in d3 && d3.startBinding) {
      let c3 = i3(d3.startBinding.elementId);
      d3.startBinding = c3 ? { ...d3.startBinding, elementId: c3 } : null;
    }
    d3.frameId && (d3.frameId = i3(d3.frameId)), n3.push(d3);
  }
  return n3;
};
var Za$1 = (e12, { shouldThrow: t3 = false, includeBoundTextValidation: n3 = false, ignoreLogs: r3, reconciliationContext: o3 }) => {
  let i3 = [], a3 = (d3) => `${d3?.index}:${d3?.id}:${d3?.type}:${d3?.isDeleted}:${d3?.version}:${d3?.versionNonce}`, s3 = e12.map((d3) => d3.index);
  for (let [d3, c3] of s3.entries()) {
    let l3 = s3[d3 - 1], U3 = s3[d3 + 1];
    if (ka(c3, l3, U3) || i3.push(`Fractional indices invariant has been compromised: "${a3(e12[d3 - 1])}", "${a3(e12[d3])}", "${a3(e12[d3 + 1])}"`), n3 && bn(e12[d3])) {
      let p3 = e12[d3], m3 = oe(p3, te(e12));
      m3 && m3.index <= p3.index && i3.push(`Fractional indices invariant for bound elements has been compromised: "${a3(m3)}", "${a3(p3)}"`);
    }
  }
  if (i3.length) {
    let d3 = new Vo(), c3 = [];
    if (o3 && (c3.push("Additional reconciliation context:"), c3.push(o3.localElements.map((l3) => a3(l3))), c3.push(o3.remoteElements.map((l3) => a3(l3)))), r3 || console.error(i3.join(`

`), d3.stack, e12.map((l3) => a3(l3)), ...c3), t3) throw d3;
  }
}, B2 = (e12) => e12.sort((t3, n3) => F2(t3) && F2(n3) ? t3.index < n3.index ? -1 : t3.index > n3.index ? 1 : t3.id < n3.id ? -1 : 1 : 1), Zr = (e12, t3) => {
  try {
    let n3 = jb(e12, t3), r3 = _2(e12, n3), o3 = e12.map((i3) => r3.has(i3) ? { ...i3, ...r3.get(i3) } : i3);
    Za$1(o3, { includeBoundTextValidation: false, shouldThrow: true, ignoreLogs: true });
    for (let [i3, a3] of r3) Y(i3, a3, false);
  } catch {
    An$1(e12);
  }
  return e12;
}, An$1 = (e12) => {
  let t3 = e7(e12), n3 = _2(e12, t3);
  for (let [r3, o3] of n3) Y(r3, o3, false);
  return e12;
}, jb = (e12, t3) => {
  let n3 = [], r3 = 0;
  for (; r3 < e12.length; ) if (t3.has(e12[r3].id)) {
    let o3 = [r3 - 1, r3];
    for (; ++r3 < e12.length && t3.has(e12[r3].id); ) o3.push(r3);
    o3.push(r3), n3.push(o3);
  } else r3++;
  return n3;
}, e7 = (e12) => {
  let t3 = [], n3, r3, o3 = -1, i3 = 0, a3 = (c3) => {
    let l3 = e12[o3] ? e12[o3].index : void 0, U3 = e12[c3 - 1]?.index;
    return !l3 && U3 || l3 && U3 && U3 > l3 ? [U3, c3 - 1] : [l3, o3];
  }, s3 = (c3) => {
    let l3 = e12[i3] ? e12[i3].index : void 0;
    if (l3 && c3 < i3) return [l3, i3];
    let U3 = i3;
    for (; ++U3 < e12.length; ) {
      let p3 = e12[U3]?.index;
      if (!l3 && p3 || l3 && p3 && p3 > l3) return [p3, U3];
    }
    return [void 0, U3];
  }, d3 = 0;
  for (; d3 < e12.length; ) {
    let c3 = e12[d3].index;
    if ([n3, o3] = a3(d3), [r3, i3] = s3(d3), ka(c3, n3, r3)) d3++;
    else {
      let l3 = [o3, d3];
      for (; ++d3 < e12.length; ) {
        let U3 = e12[d3].index, [p3, m3] = a3(d3), [b3, E3] = s3(d3);
        if (ka(U3, p3, b3)) break;
        [n3, o3] = [p3, m3], [r3, i3] = [b3, E3], l3.push(d3);
      }
      l3.push(i3), t3.push(l3);
    }
  }
  return t3;
}, ka = (e12, t3, n3) => e12 ? t3 && n3 ? t3 < e12 && e12 < n3 : !t3 && n3 ? e12 < n3 : t3 && !n3 ? t3 < e12 : !!e12 : false, _2 = (e12, t3) => {
  let n3 = /* @__PURE__ */ new Map();
  for (let r3 of t3) {
    let o3 = r3.shift(), i3 = r3.pop(), a3 = generateNKeysBetween(e12[o3]?.index, e12[i3]?.index, r3.length);
    for (let s3 = 0; s3 < r3.length; s3++) {
      let d3 = e12[r3[s3]];
      n3.set(d3, { index: a3[s3] });
    }
  }
  return n3;
}, F2 = (e12) => !!e12.index;
var Le = class e3 {
  constructor(t3, n3) {
    this.deleted = t3;
    this.inserted = n3;
  }
  static create(t3, n3, r3, o3) {
    let i3 = r3 && o3 !== "inserted" ? r3(t3) : t3, a3 = r3 && o3 !== "deleted" ? r3(n3) : n3;
    return new e3(i3, a3);
  }
  static calculate(t3, n3, r3, o3) {
    if (t3 === n3) return e3.empty();
    let i3 = {}, a3 = {};
    for (let c3 of this.distinctKeysIterator("full", t3, n3)) i3[c3] = t3[c3], a3[c3] = n3[c3];
    let [s3, d3] = o3 ? o3(i3, a3) : [i3, a3];
    return e3.create(s3, d3, r3);
  }
  static empty() {
    return new e3({}, {});
  }
  static isEmpty(t3) {
    return !Object.keys(t3.deleted).length && !Object.keys(t3.inserted).length;
  }
  static mergeObjects(t3, n3, r3) {
    let o3 = { ...t3 };
    for (let i3 of Object.keys(r3)) delete o3[i3];
    return { ...o3, ...n3 };
  }
  static mergeArrays(t3, n3, r3, o3) {
    return Object.values(e3.mergeObjects(_t$1(t3 ?? [], o3), _t$1(n3 ?? [], o3), _t$1(r3 ?? [], o3)));
  }
  static diffObjects(t3, n3, r3, o3) {
    if (!(!t3[r3] && !n3[r3]) && (typeof t3[r3] == "object" || typeof n3[r3] == "object")) {
      let i3 = t3[r3] ?? {}, a3 = n3[r3] ?? {}, s3 = e3.getLeftDifferences(i3, a3).reduce((c3, l3) => (c3[l3] = o3(i3[l3]), c3), {}), d3 = e3.getRightDifferences(i3, a3).reduce((c3, l3) => (c3[l3] = o3(a3[l3]), c3), {});
      Object.keys(s3).length || Object.keys(d3).length ? (Reflect.set(t3, r3, s3), Reflect.set(n3, r3, d3)) : (Reflect.deleteProperty(t3, r3), Reflect.deleteProperty(n3, r3));
    }
  }
  static diffArrays(t3, n3, r3, o3) {
    if (!(!t3[r3] && !n3[r3]) && (Array.isArray(t3[r3]) || Array.isArray(n3[r3]))) {
      let i3 = Array.isArray(t3[r3]) ? t3[r3] : [], a3 = Array.isArray(n3[r3]) ? n3[r3] : [], s3 = _t$1(e3.getLeftDifferences(_t$1(i3, o3), _t$1(a3, o3))), d3 = _t$1(e3.getRightDifferences(_t$1(i3, o3), _t$1(a3, o3)));
      if (Object.keys(s3).length || Object.keys(d3).length) {
        let c3 = i3.filter((U3) => s3[o3 ? o3(U3) : String(U3)]), l3 = a3.filter((U3) => d3[o3 ? o3(U3) : String(U3)]);
        Reflect.set(t3, r3, c3), Reflect.set(n3, r3, l3);
      } else Reflect.deleteProperty(t3, r3), Reflect.deleteProperty(n3, r3);
    }
  }
  static isLeftDifferent(t3, n3, r3 = false) {
    return !!this.distinctKeysIterator("left", t3, n3, r3).next().value;
  }
  static isRightDifferent(t3, n3, r3 = false) {
    return !!this.distinctKeysIterator("right", t3, n3, r3).next().value;
  }
  static getLeftDifferences(t3, n3, r3 = false) {
    return Array.from(this.distinctKeysIterator("left", t3, n3, r3));
  }
  static getRightDifferences(t3, n3, r3 = false) {
    return Array.from(this.distinctKeysIterator("right", t3, n3, r3));
  }
  static *distinctKeysIterator(t3, n3, r3, o3 = false) {
    if (n3 === r3) return;
    let i3 = [];
    t3 === "left" ? i3 = Object.keys(n3) : t3 === "right" ? i3 = Object.keys(r3) : t3 === "full" ? i3 = Array.from(/* @__PURE__ */ new Set([...Object.keys(n3), ...Object.keys(r3)])) : Sn$1(t3, `Unknown distinctKeysIterator's join param "${t3}"`, true);
    for (let a3 of i3) {
      let s3 = n3[a3], d3 = r3[a3];
      if (s3 !== d3) {
        if (!o3 && typeof s3 == "object" && typeof d3 == "object" && s3 !== null && d3 !== null && Qt(s3, d3)) continue;
        yield a3;
      }
    }
  }
}, Wr = class e5 {
  constructor(t3) {
    this.delta = t3;
  }
  static calculate(t3, n3) {
    let r3 = Le.calculate(t3, n3, void 0, e5.postProcess);
    return new e5(r3);
  }
  static empty() {
    return new e5(Le.create({}, {}));
  }
  inverse() {
    let t3 = Le.create(this.delta.inserted, this.delta.deleted);
    return new e5(t3);
  }
  applyTo(t3, n3) {
    try {
      let { selectedElementIds: r3 = {}, selectedGroupIds: o3 = {} } = this.delta.deleted, { selectedElementIds: i3 = {}, selectedGroupIds: a3 = {}, selectedLinearElementId: s3, editingLinearElementId: d3, ...c3 } = this.delta.inserted, l3 = Le.mergeObjects(t3.selectedElementIds, i3, r3), U3 = Le.mergeObjects(t3.selectedGroupIds, a3, o3), p3 = s3 && n3.has(s3) ? new z$1(n3.get(s3)) : null, m3 = d3 && n3.has(d3) ? new z$1(n3.get(d3)) : null, b3 = { ...t3, ...c3, selectedElementIds: l3, selectedGroupIds: U3, selectedLinearElement: typeof s3 < "u" ? p3 : t3.selectedLinearElement, editingLinearElement: typeof d3 < "u" ? m3 : t3.editingLinearElement }, E3 = this.filterInvisibleChanges(t3, b3, n3);
      return [b3, E3];
    } catch (r3) {
      if (console.error("Couldn't apply appstate change", r3), c$1.DEV || c$1.MODE === je.TEST) throw r3;
      return [t3, false];
    }
  }
  isEmpty() {
    return Le.isEmpty(this.delta);
  }
  static postProcess(t3, n3) {
    try {
      Le.diffObjects(t3, n3, "selectedElementIds", (r3) => true), Le.diffObjects(t3, n3, "selectedGroupIds", (r3) => r3 ?? false);
    } catch (r3) {
      if (console.error("Couldn't postprocess appstate change deltas."), c$1.DEV || c$1.MODE === je.TEST) throw r3;
    } finally {
      return [t3, n3];
    }
  }
  filterInvisibleChanges(t3, n3, r3) {
    let o3 = Qr(t3), i3 = Qr(n3), a3 = Le.isRightDifferent(e5.stripElementsProps(o3), e5.stripElementsProps(i3)), s3 = Le.isRightDifferent(e5.stripStandaloneProps(o3), e5.stripStandaloneProps(i3));
    if (!a3 && !s3) return false;
    let d3 = { value: a3 };
    if (s3) {
      let c3 = Le.getRightDifferences(e5.stripStandaloneProps(o3), e5.stripStandaloneProps(i3)), l3 = /* @__PURE__ */ new Set();
      (c3.includes("editingGroupId") || c3.includes("selectedGroupIds")) && (l3 = m2(r3));
      for (let U3 of c3) switch (U3) {
        case "selectedElementIds":
          n3[U3] = e5.filterSelectedElements(n3[U3], r3, d3);
          break;
        case "selectedGroupIds":
          n3[U3] = e5.filterSelectedGroups(n3[U3], l3, d3);
          break;
        case "croppingElementId": {
          let E3 = n3[U3], g3 = E3 && r3.get(E3);
          g3 && !g3.isDeleted ? d3.value = true : n3[U3] = null;
          break;
        }
        case "editingGroupId":
          let p3 = n3[U3];
          p3 ? l3.has(p3) ? d3.value = true : n3[U3] = null : d3.value = true;
          break;
        case "selectedLinearElementId":
        case "editingLinearElementId":
          let m3 = e5.convertToAppStateKey(U3), b3 = n3[m3];
          if (!b3) d3.value = true;
          else {
            let E3 = r3.get(b3.elementId);
            E3 && !E3.isDeleted ? d3.value = true : n3[m3] = null;
          }
          break;
        default:
          Sn$1(U3, `Unknown ObservedElementsAppState's key "${U3}"`, true);
      }
    }
    return d3.value;
  }
  static convertToAppStateKey(t3) {
    switch (t3) {
      case "selectedLinearElementId":
        return "selectedLinearElement";
      case "editingLinearElementId":
        return "editingLinearElement";
    }
  }
  static filterSelectedElements(t3, n3, r3) {
    let o3 = Object.keys(t3);
    if (!o3.length) return r3.value = true, t3;
    let i3 = { ...t3 };
    for (let a3 of o3) {
      let s3 = n3.get(a3);
      s3 && !s3.isDeleted ? r3.value = true : delete i3[a3];
    }
    return i3;
  }
  static filterSelectedGroups(t3, n3, r3) {
    if (!Object.keys(t3).length) return r3.value = true, t3;
    let i3 = { ...t3 };
    for (let a3 of Object.keys(i3)) n3.has(a3) ? r3.value = true : delete i3[a3];
    return i3;
  }
  static stripElementsProps(t3) {
    let { editingGroupId: n3, selectedGroupIds: r3, selectedElementIds: o3, editingLinearElementId: i3, selectedLinearElementId: a3, croppingElementId: s3, ...d3 } = t3;
    return d3;
  }
  static stripStandaloneProps(t3) {
    let { name: n3, viewBackgroundColor: r3, ...o3 } = t3;
    return o3;
  }
}, Ue = class Ue2 {
  constructor(t3, n3, r3) {
    this.added = t3;
    this.removed = n3;
    this.updated = r3;
  }
  static create(t3, n3, r3, o3 = { shouldRedistribute: false }) {
    let i3;
    if (o3.shouldRedistribute) {
      let a3 = /* @__PURE__ */ new Map(), s3 = /* @__PURE__ */ new Map(), d3 = /* @__PURE__ */ new Map(), c3 = [...t3, ...n3, ...r3];
      for (let [l3, U3] of c3) this.satisfiesAddition(U3) ? a3.set(l3, U3) : this.satisfiesRemoval(U3) ? s3.set(l3, U3) : d3.set(l3, U3);
      i3 = new Ue2(a3, s3, d3);
    } else i3 = new Ue2(t3, n3, r3);
    return (c$1.DEV || c$1.MODE === je.TEST) && (Ue2.validate(i3, "added", this.satisfiesAddition), Ue2.validate(i3, "removed", this.satisfiesRemoval), Ue2.validate(i3, "updated", this.satisfiesUpdate)), i3;
  }
  static validate(t3, n3, r3) {
    for (let [o3, i3] of t3[n3].entries()) if (!r3(i3)) throw console.error(`Broken invariant for "${n3}" delta, element "${o3}", delta:`, i3), new Error(`ElementsChange invariant broken for element "${o3}".`);
  }
  static calculate(t3, n3) {
    if (t3 === n3) return Ue2.empty();
    let r3 = /* @__PURE__ */ new Map(), o3 = /* @__PURE__ */ new Map(), i3 = /* @__PURE__ */ new Map();
    for (let a3 of t3.values()) if (!n3.get(a3.id)) {
      let d3 = { ...a3, isDeleted: false }, c3 = { isDeleted: true }, l3 = Le.create(d3, c3, Ue2.stripIrrelevantProps);
      o3.set(a3.id, l3);
    }
    for (let a3 of n3.values()) {
      let s3 = t3.get(a3.id);
      if (!s3) {
        let d3 = { isDeleted: true }, c3 = { ...a3, isDeleted: false }, l3 = Le.create(d3, c3, Ue2.stripIrrelevantProps);
        r3.set(a3.id, l3);
        continue;
      }
      if (s3.versionNonce !== a3.versionNonce) {
        let d3 = Le.calculate(s3, a3, Ue2.stripIrrelevantProps, Ue2.postProcess);
        if (typeof s3.isDeleted == "boolean" && typeof a3.isDeleted == "boolean" && s3.isDeleted !== a3.isDeleted) {
          s3.isDeleted && !a3.isDeleted ? r3.set(a3.id, d3) : o3.set(a3.id, d3);
          continue;
        }
        Le.isEmpty(d3) || i3.set(a3.id, d3);
      }
    }
    return Ue2.create(r3, o3, i3);
  }
  static empty() {
    return Ue2.create(/* @__PURE__ */ new Map(), /* @__PURE__ */ new Map(), /* @__PURE__ */ new Map());
  }
  inverse() {
    let t3 = (i3) => {
      let a3 = /* @__PURE__ */ new Map();
      for (let [s3, d3] of i3.entries()) a3.set(s3, Le.create(d3.inserted, d3.deleted));
      return a3;
    }, n3 = t3(this.added), r3 = t3(this.removed), o3 = t3(this.updated);
    return Ue2.create(r3, n3, o3);
  }
  isEmpty() {
    return this.added.size === 0 && this.removed.size === 0 && this.updated.size === 0;
  }
  applyLatestChanges(t3) {
    let n3 = (s3) => (d3) => {
      let c3 = {};
      for (let l3 of Object.keys(d3)) switch (l3) {
        case "boundElements":
          c3[l3] = d3[l3];
          break;
        default:
          c3[l3] = s3[l3];
      }
      return c3;
    }, r3 = (s3) => {
      let d3 = /* @__PURE__ */ new Map();
      for (let [c3, l3] of s3.entries()) {
        let U3 = t3.get(c3);
        if (U3) {
          let p3 = Le.create(l3.deleted, l3.inserted, n3(U3), "inserted");
          d3.set(c3, p3);
        } else d3.set(c3, l3);
      }
      return d3;
    }, o3 = r3(this.added), i3 = r3(this.removed), a3 = r3(this.updated);
    return Ue2.create(o3, i3, a3, { shouldRedistribute: true });
  }
  applyTo(t3, n3) {
    let r3 = tt(new Map(t3)), o3, i3 = { containsVisibleDifference: false, containsZindexDifference: false };
    try {
      let a3 = Ue2.createApplier(r3, n3, i3), s3 = a3(this.added), d3 = a3(this.removed), c3 = a3(this.updated), l3 = this.resolveConflicts(t3, r3);
      o3 = new Map([...s3, ...d3, ...c3, ...l3]);
    } catch (a3) {
      if (console.error("Couldn't apply elements change", a3), c$1.DEV || c$1.MODE === je.TEST) throw a3;
      return [t3, true];
    }
    try {
      Ue2.redrawTextBoundingBoxes(r3, o3), r3 = Ue2.reorderElements(r3, o3, i3), Ue2.redrawBoundArrows(r3, o3);
    } catch (a3) {
      if (console.error("Couldn't mutate elements after applying elements change", a3), c$1.DEV || c$1.MODE === je.TEST) throw a3;
    } finally {
      return [r3, i3.containsVisibleDifference];
    }
  }
  static applyDelta(t3, n3, r3 = { containsVisibleDifference: true, containsZindexDifference: true }) {
    let { boundElements: o3, ...i3 } = n3.inserted;
    if (n3.deleted.boundElements?.length || n3.inserted.boundElements?.length) {
      let a3 = Le.mergeArrays(t3.boundElements, n3.inserted.boundElements, n3.deleted.boundElements, (s3) => s3.id);
      Object.assign(i3, { boundElements: a3 });
    }
    if (Ye$1(t3)) {
      let a3 = n3;
      (a3.deleted.crop || a3.inserted.crop) && Object.assign(i3, { crop: a3.inserted.crop ?? null });
    }
    if (!r3.containsVisibleDifference) {
      let { index: a3, ...s3 } = i3, d3 = Ue2.checkForVisibleDifference(t3, s3);
      r3.containsVisibleDifference = d3;
    }
    return r3.containsZindexDifference || (r3.containsZindexDifference = n3.deleted.index !== n3.inserted.index), vt$1(t3, i3);
  }
  static checkForVisibleDifference(t3, n3) {
    return t3.isDeleted && n3.isDeleted !== false ? false : t3.isDeleted && n3.isDeleted === false || t3.isDeleted === false && n3.isDeleted ? true : Le.isRightDifferent(t3, n3);
  }
  resolveConflicts(t3, n3) {
    let r3 = /* @__PURE__ */ new Map(), o3 = (c3, l3) => {
      let U3 = n3.get(c3.id);
      if (!U3) return;
      let p3;
      t3.get(c3.id) === U3 ? p3 = vt$1(U3, l3) : p3 = Y(U3, l3), r3.set(p3.id, p3), n3.set(p3.id, p3);
    };
    for (let [c3] of this.removed) Ue2.unbindAffected(t3, n3, c3, o3);
    for (let [c3] of this.added) Ue2.rebindAffected(t3, n3, c3, o3);
    for (let [c3] of Array.from(this.updated).filter(([l3, U3]) => Object.keys({ ...U3.deleted, ...U3.inserted }).find((p3) => l2.has(p3)))) {
      let l3 = n3.get(c3);
      !l3 || l3.isDeleted || Ue2.rebindAffected(t3, n3, c3, o3);
    }
    let i3 = new Map(Array.from(t3).filter(([c3]) => r3.has(c3))), { added: a3, removed: s3, updated: d3 } = Ue2.calculate(i3, r3);
    for (let [c3, l3] of a3) this.added.set(c3, l3);
    for (let [c3, l3] of s3) this.removed.set(c3, l3);
    for (let [c3, l3] of d3) this.updated.set(c3, l3);
    return r3;
  }
  static unbindAffected(t3, n3, r3, o3) {
    let i3 = () => t3.get(r3), a3 = () => n3.get(r3);
    rn.unbindAffected(n3, i3(), o3), rn.unbindAffected(n3, a3(), o3), on.unbindAffected(n3, i3(), o3), on.unbindAffected(n3, a3(), o3);
  }
  static rebindAffected(t3, n3, r3, o3) {
    let i3 = () => t3.get(r3), a3 = () => n3.get(r3);
    rn.unbindAffected(n3, i3(), o3), rn.rebindAffected(n3, a3(), o3), on.unbindAffected(n3, i3(), (s3, d3) => {
      k$2(s3) && o3(s3, d3);
    }), on.rebindAffected(n3, a3(), o3);
  }
  static redrawTextBoundingBoxes(t3, n3) {
    let r3 = /* @__PURE__ */ new Map();
    for (let o3 of n3.values()) {
      if (Ne(o3)) {
        let { containerId: i3 } = o3, a3 = i3 ? t3.get(i3) : void 0;
        a3 && r3.set(a3.id, { container: a3, boundText: o3 });
      }
      if (bn(o3)) {
        let i3 = Yt(o3), a3 = i3 ? t3.get(i3) : void 0;
        a3 && r3.set(o3.id, { container: o3, boundText: a3 });
      }
    }
    for (let { container: o3, boundText: i3 } of r3.values()) o3.isDeleted || i3.isDeleted || Xa$1(i3, o3, t3, false);
  }
  static redrawBoundArrows(t3, n3) {
    for (let r3 of n3.values()) !r3.isDeleted && xt(r3) && Jt(r3, t3, {});
  }
  static reorderElements(t3, n3, r3) {
    if (!r3.containsZindexDifference) return t3;
    let o3 = Array.from(t3.values()), i3 = B2([...o3]), a3 = Le.getRightDifferences(o3, i3, true).reduce((s3, d3) => {
      let c3 = o3[Number(d3)];
      return c3 && n3.has(c3.id) && s3.set(c3.id, c3), s3;
    }, /* @__PURE__ */ new Map());
    return !r3.containsVisibleDifference && a3.size && (r3.containsVisibleDifference = true), te(Zr(i3, a3));
  }
  static postProcess(t3, n3) {
    try {
      Le.diffArrays(t3, n3, "boundElements", (r3) => r3.id);
    } catch (r3) {
      if (console.error("Couldn't postprocess elements change deltas."), c$1.DEV || c$1.MODE === je.TEST) throw r3;
    } finally {
      return [t3, n3];
    }
  }
  static stripIrrelevantProps(t3) {
    let { id: n3, updated: r3, version: o3, versionNonce: i3, seed: a3, ...s3 } = t3;
    return s3;
  }
};
i$1(Ue, "satisfiesAddition", ({ deleted: t3, inserted: n3 }) => t3.isDeleted === true && !n3.isDeleted), i$1(Ue, "satisfiesRemoval", ({ deleted: t3, inserted: n3 }) => !t3.isDeleted && n3.isDeleted === true), i$1(Ue, "satisfiesUpdate", ({ deleted: t3, inserted: n3 }) => !!t3.isDeleted == !!n3.isDeleted), i$1(Ue, "createApplier", (t3, n3, r3) => {
  let o3 = Ue.createGetter(t3, n3, r3);
  return (i3) => Array.from(i3.entries()).reduce((a3, [s3, d3]) => {
    let c3 = o3(s3, d3.inserted);
    if (c3) {
      let l3 = Ue.applyDelta(c3, d3, r3);
      t3.set(l3.id, l3), a3.set(l3.id, l3);
    }
    return a3;
  }, /* @__PURE__ */ new Map());
}), i$1(Ue, "createGetter", (t3, n3, r3) => (o3, i3) => {
  let a3 = t3.get(o3);
  return a3 || (a3 = n3.get(o3), a3 && (r3.containsZindexDifference = true, (i3.isDeleted === false || i3.isDeleted !== true && a3.isDeleted === false) && (r3.containsVisibleDifference = true))), a3;
});
var zr$1 = Ue;
var hi = class {
  constructor() {
    i$1(this, "subscribers", []);
  }
  on(...t3) {
    let n3 = t3.flat().filter((r3) => typeof r3 == "function");
    return this.subscribers.push(...n3), () => this.off(n3);
  }
  once(...t3) {
    let n3 = t3.flat().filter((o3) => typeof o3 == "function");
    n3.push(() => r3());
    let r3 = this.on(...n3);
    return r3;
  }
  off(...t3) {
    let n3 = t3.flat();
    this.subscribers = this.subscribers.filter((r3) => !n3.includes(r3));
  }
  trigger(...t3) {
    for (let n3 of this.subscribers) n3(...t3);
    return this;
  }
  clear() {
    this.subscribers = [];
  }
};
var A2 = "__observedAppState", Qr = (e12) => {
  let t3 = { name: e12.name, editingGroupId: e12.editingGroupId, viewBackgroundColor: e12.viewBackgroundColor, selectedElementIds: e12.selectedElementIds, selectedGroupIds: e12.selectedGroupIds, editingLinearElementId: e12.editingLinearElement?.elementId || null, selectedLinearElementId: e12.selectedLinearElement?.elementId || null, croppingElementId: e12.croppingElementId };
  return Reflect.defineProperty(t3, A2, { value: true, enumerable: false }), t3;
}, t7 = (e12) => !!Reflect.get(e12, A2), dr = { IMMEDIATELY: "IMMEDIATELY", NEVER: "NEVER", EVENTUALLY: "EVENTUALLY" }, Wa = class {
  constructor(t3, n3) {
    this.elementsChange = t3;
    this.appStateChange = n3;
  }
}, O2 = class {
  constructor() {
    i$1(this, "onStoreIncrementEmitter", new hi());
    i$1(this, "scheduledActions", /* @__PURE__ */ new Set());
    i$1(this, "_snapshot", yi$1.empty());
    i$1(this, "shouldCaptureIncrement", () => {
      this.scheduleAction(dr.IMMEDIATELY);
    });
    i$1(this, "shouldUpdateSnapshot", () => {
      this.scheduleAction(dr.NEVER);
    });
    i$1(this, "scheduleAction", (t3) => {
      this.scheduledActions.add(t3), this.satisfiesScheduledActionsInvariant();
    });
    i$1(this, "commit", (t3, n3) => {
      try {
        this.scheduledActions.has(dr.IMMEDIATELY) ? this.captureIncrement(t3, n3) : this.scheduledActions.has(dr.NEVER) && this.updateSnapshot(t3, n3);
      } finally {
        this.satisfiesScheduledActionsInvariant(), this.scheduledActions = /* @__PURE__ */ new Set();
      }
    });
    i$1(this, "captureIncrement", (t3, n3) => {
      let r3 = this.snapshot, o3 = this.snapshot.maybeClone(t3, n3);
      if (r3 !== o3) {
        let i3 = o3.meta.didElementsChange ? zr$1.calculate(r3.elements, o3.elements) : zr$1.empty(), a3 = o3.meta.didAppStateChange ? Wr.calculate(r3.appState, o3.appState) : Wr.empty();
        (!i3.isEmpty() || !a3.isEmpty()) && this.onStoreIncrementEmitter.trigger(new Wa(i3, a3)), this.snapshot = o3;
      }
    });
    i$1(this, "updateSnapshot", (t3, n3) => {
      let r3 = this.snapshot.maybeClone(t3, n3);
      this.snapshot !== r3 && (this.snapshot = r3);
    });
    i$1(this, "filterUncomittedElements", (t3, n3) => {
      for (let [r3, o3] of t3.entries()) {
        if (!n3.get(r3)) continue;
        let a3 = this.snapshot.elements.get(r3);
        a3 ? a3.version < o3.version && n3.set(r3, a3) : n3.delete(r3);
      }
      return n3;
    });
    i$1(this, "clear", () => {
      this.snapshot = yi$1.empty(), this.scheduledActions = /* @__PURE__ */ new Set();
    });
    i$1(this, "satisfiesScheduledActionsInvariant", () => {
      if (!(this.scheduledActions.size >= 0 && this.scheduledActions.size <= 3)) {
        let t3 = `There can be at most three store actions scheduled at the same time, but there are "${this.scheduledActions.size}".`;
        if (console.error(t3, this.scheduledActions.values()), c$1.DEV || c$1.MODE === je.TEST) throw new Error(t3);
      }
    });
  }
  get snapshot() {
    return this._snapshot;
  }
  set snapshot(t3) {
    this._snapshot = t3;
  }
}, yi$1 = class e6 {
  constructor(t3, n3, r3 = { didElementsChange: false, didAppStateChange: false, isEmpty: false }) {
    this.elements = t3;
    this.appState = n3;
    this.meta = r3;
  }
  static empty() {
    return new e6(/* @__PURE__ */ new Map(), Qr(mt()), { didElementsChange: false, didAppStateChange: false, isEmpty: true });
  }
  isEmpty() {
    return this.meta.isEmpty;
  }
  maybeClone(t3, n3) {
    let r3 = this.maybeCreateElementsSnapshot(t3), o3 = this.maybeCreateAppStateSnapshot(n3), i3 = false, a3 = false;
    return this.elements !== r3 && (i3 = true), this.appState !== o3 && (a3 = true), !i3 && !a3 ? this : new e6(r3, o3, { didElementsChange: i3, didAppStateChange: a3 });
  }
  maybeCreateAppStateSnapshot(t3) {
    if (!t3) return this.appState;
    let n3 = t7(t3) ? t3 : Qr(t3);
    return this.detectChangedAppState(n3) ? n3 : this.appState;
  }
  detectChangedAppState(t3) {
    return !Qt(this.appState, t3, { selectedElementIds: Qt, selectedGroupIds: Qt });
  }
  maybeCreateElementsSnapshot(t3) {
    return t3 ? this.detectChangedElements(t3) ? this.createElementsSnapshot(t3) : this.elements : this.elements;
  }
  detectChangedElements(t3) {
    if (this.elements === t3) return false;
    if (this.elements.size !== t3.size) return true;
    let n3 = Array.from(t3.keys());
    for (let r3 = n3.length - 1; r3 >= 0; r3--) {
      let o3 = this.elements.get(n3[r3]), i3 = t3.get(n3[r3]);
      if (!o3 || !i3 || o3.id !== i3.id || o3.versionNonce !== i3.versionNonce) return true;
    }
    return false;
  }
  createElementsSnapshot(t3) {
    let n3 = /* @__PURE__ */ new Map();
    for (let [r3, o3] of this.elements.entries()) t3.get(r3) ? n3.set(r3, o3) : n3.set(r3, vt$1(o3, { isDeleted: true }));
    for (let [r3, o3] of t3.entries()) {
      let i3 = n3.get(r3);
      (!i3 || i3 && i3.versionNonce !== o3.versionNonce) && n3.set(r3, Gr(o3));
    }
    return n3;
  }
};
var Xt = /* @__PURE__ */ new Map(), n7 = /^(?:http(?:s)?:\/\/)?(?:www\.)?youtu(?:be\.com|\.be)\/(embed\/|watch\?v=|shorts\/|playlist\?list=|embed\/videoseries\?list=)?([a-zA-Z0-9_-]+)(?:\?t=|&t=|\?start=|&start=)?([a-zA-Z0-9_-]+)?[^\s]*$/, r7 = /^(?:http(?:s)?:\/\/)?(?:(?:w){3}\.)?(?:player\.)?vimeo\.com\/(?:video\/)?([^?\s]+)(?:\?.*)?$/, o7 = /^https:\/\/(?:www\.)?figma\.com/, K22 = /^https:\/\/gist\.github\.com\/([\w_-]+)\/([\w_-]+)/, i7 = /^<script[\s\S]*?\ssrc=["'](https:\/\/gist\.github\.com\/.*?)\.js["']/i, H2 = /(?:https?:\/\/)?(?:(?:w){3}\.)?(?:twitter|x)\.com\/[^/]+\/status\/(\d+)/, a7 = /^<blockquote[\s\S]*?\shref=["'](https?:\/\/(?:twitter|x)\.com\/[^"']*)/i, s7 = /^https:\/\/(?:www\.)?val\.town\/(v|embed)\/[a-zA-Z_$][0-9a-zA-Z_$]+\.[a-zA-Z_$][0-9a-zA-Z_$]+/, d7 = /^<(?:iframe|blockquote)[\s\S]*?\s(?:src|href)=["']([^"']*)["'][\s\S]*?>$/i, J2$1 = /giphy.com\/(?:clips|embed|gifs)\/[a-zA-Z0-9]*?-?([a-zA-Z0-9]+)(?:[^a-zA-Z0-9]|$)/, Y2 = /^(?:http(?:s)?:\/\/)?(?:www\.)?reddit\.com\/r\/([a-zA-Z0-9_]+)\/comments\/([a-zA-Z0-9_]+)\/([a-zA-Z0-9_]+)\/?(?:\?[^#\s]*)?(?:#[^\s]*)?$/, c7 = /^<blockquote[\s\S]*?\shref=["'](https?:\/\/(?:www\.)?reddit\.com\/[^"']*)/i, Qa = /* @__PURE__ */ new Set(["youtube.com", "youtu.be", "vimeo.com", "player.vimeo.com", "figma.com", "link.excalidraw.com", "gist.github.com", "twitter.com", "x.com", "*.simplepdf.eu", "stackblitz.com", "val.town", "giphy.com", "reddit.com"]), C2 = /* @__PURE__ */ new Set(["youtube.com", "youtu.be", "vimeo.com", "player.vimeo.com", "figma.com", "twitter.com", "x.com", "*.simplepdf.eu", "stackblitz.com", "reddit.com"]), za$1 = (e12) => `<html><body>${e12}</body></html>`, V2 = (e12) => {
  if (!e12) return null;
  if (Xt.has(e12)) return Xt.get(e12);
  let t3 = e12, n3 = C2.has(ja(e12, C2) || ""), r3 = "generic", o3 = { w: 560, h: 840 }, i3 = e12.match(n7);
  if (i3?.[2]) {
    let c3 = i3[3] ? `&start=${i3[3]}` : "", l3 = e12.includes("shorts");
    switch (r3 = "video", i3[1]) {
      case "embed/":
      case "watch?v=":
      case "shorts/":
        e12 = `https://www.youtube.com/embed/${i3[2]}?enablejsapi=1${c3}`;
        break;
      case "playlist?list=":
      case "embed/videoseries?list=":
        e12 = `https://www.youtube.com/embed/videoseries?list=${i3[2]}&enablejsapi=1${c3}`;
        break;
      default:
        e12 = `https://www.youtube.com/embed/${i3[2]}?enablejsapi=1${c3}`;
        break;
    }
    return o3 = l3 ? { w: 315, h: 560 } : { w: 560, h: 315 }, Xt.set(t3, { link: e12, intrinsicSize: o3, type: r3, sandbox: { allowSameOrigin: n3 } }), { link: e12, intrinsicSize: o3, type: r3, sandbox: { allowSameOrigin: n3 } };
  }
  let a3 = e12.match(r7);
  if (a3?.[1]) {
    let c3 = a3?.[1], l3 = /^\d+$/.test(c3) ? void 0 : new URIError("Invalid embed link format");
    return r3 = "video", e12 = `https://player.vimeo.com/video/${c3}?api=1`, o3 = { w: 560, h: 315 }, Xt.set(t3, { link: e12, intrinsicSize: o3, type: r3, sandbox: { allowSameOrigin: n3 } }), { link: e12, intrinsicSize: o3, type: r3, error: l3, sandbox: { allowSameOrigin: n3 } };
  }
  if (e12.match(o7)) return r3 = "generic", e12 = `https://www.figma.com/embed?embed_host=share&url=${encodeURIComponent(e12)}`, o3 = { w: 550, h: 550 }, Xt.set(t3, { link: e12, intrinsicSize: o3, type: r3, sandbox: { allowSameOrigin: n3 } }), { link: e12, intrinsicSize: o3, type: r3, sandbox: { allowSameOrigin: n3 } };
  let d3 = e12.match(s7);
  if (d3) return e12 = d3[1] === "embed" ? d3[0] : d3[0].replace("/v", "/embed"), Xt.set(t3, { link: e12, intrinsicSize: o3, type: r3, sandbox: { allowSameOrigin: n3 } }), { link: e12, intrinsicSize: o3, type: r3, sandbox: { allowSameOrigin: n3 } };
  if (H2.test(e12)) {
    let c3 = e12.match(H2)[1], l3 = kn$1(`https://twitter.com/x/status/${c3}`), U3 = { type: "document", srcdoc: (p3) => za$1(`<blockquote class="twitter-tweet" data-dnt="true" data-theme="${p3}"><a href="${l3}"></a></blockquote> <script async src="https://platform.twitter.com/widgets.js" charset="utf-8"><\/script>`), intrinsicSize: { w: 480, h: 480 }, sandbox: { allowSameOrigin: n3 } };
    return Xt.set(t3, U3), U3;
  }
  if (Y2.test(e12)) {
    let [, c3, l3, U3] = e12.match(Y2), p3 = kn$1(`https://reddit.com/r/${c3}/comments/${l3}/${U3}`), m3 = { type: "document", srcdoc: (b3) => za$1(`<blockquote class="reddit-embed-bq" data-embed-theme="${b3}"><a href="${p3}"></a><br></blockquote><script async="" src="https://embed.reddit.com/widgets.js" charset="UTF-8"><\/script>`), intrinsicSize: { w: 480, h: 480 }, sandbox: { allowSameOrigin: n3 } };
    return Xt.set(t3, m3), m3;
  }
  if (K22.test(e12)) {
    let [, c3, l3] = e12.match(K22), U3 = kn$1(`https://gist.github.com/${c3}/${l3}`), p3 = { type: "document", srcdoc: () => za$1(`
          <script src="${U3}.js"><\/script>
          <style type="text/css">
            * { margin: 0px; }
            table, .gist { height: 100%; }
            .gist .gist-file { height: calc(100vh - 2px); padding: 0px; display: grid; grid-template-rows: 1fr auto; }
          </style>
        `), intrinsicSize: { w: 550, h: 720 }, sandbox: { allowSameOrigin: n3 } };
    return Xt.set(e12, p3), p3;
  }
  return Xt.set(e12, { link: e12, intrinsicSize: o3, type: r3, sandbox: { allowSameOrigin: n3 } }), { link: e12, intrinsicSize: o3, type: r3, sandbox: { allowSameOrigin: n3 } };
}, Ii$1 = (e12) => {
  let t3;
  _o$1(e12) ? t3 = "IFrame element" : t3 = !e12.link || e12?.link === "" ? "Empty Web-Embed" : e12.link;
  let n3 = Math.max(Math.min(e12.width / 2, e12.width / t3.length), e12.width / 30), r3 = Ie.Helvetica, o3 = Ee({ fontSize: n3, fontFamily: r3 });
  return qt({ x: e12.x + e12.width / 2, y: e12.y + e12.height / 2, strokeColor: e12.strokeColor !== "transparent" ? e12.strokeColor : "black", backgroundColor: "transparent", fontFamily: r3, fontSize: n3, text: en(t3, o3, e12.width - 20), textAlign: "center", verticalAlign: kt.MIDDLE, angle: e12.angle ?? 0 });
};
L2({ name: "setEmbeddableAsActiveTool", trackEvent: { category: "toolbar" }, target: "Tool", label: "toolBar.embeddable", perform: (e12, t3, n3, r3) => {
  let o3 = $r(t3, { type: "embeddable" });
  return $2(r3.canvas, { ...t3, activeTool: o3 }), { elements: e12, appState: { ...t3, activeTool: $r(t3, { type: "embeddable" }) }, captureUpdate: dr.EVENTUALLY };
} });
var ja = (e12, t3) => {
  try {
    let { hostname: n3 } = new URL(e12), r3 = n3.replace(/^www\./, "");
    if (t3 instanceof Set) {
      if (Qa.has(r3)) return r3;
      let i3 = r3.replace(/^([^.]+)/, "*");
      return Qa.has(i3) ? i3 : null;
    }
    let o3 = t3.replace(/^www\./, "");
    if (r3 === o3) return o3;
  } catch {
  }
  return null;
}, J_$1 = (e12) => {
  let t3 = e12.match(a7);
  if (t3 && t3.length === 2) return t3[1];
  let n3 = e12.match(c7);
  if (n3 && n3.length === 2) return n3[1];
  let r3 = e12.match(i7);
  if (r3 && r3.length === 2) return r3[1];
  if (J2$1.test(e12)) return `https://giphy.com/embed/${J2$1.exec(e12)[1]}`;
  let o3 = e12.match(d7);
  return o3 && o3.length === 2 ? o3[1] : e12;
}, Y_ = (e12, t3) => {
  if (!e12) return false;
  if (t3 != null) if (typeof t3 == "function") {
    let n3 = t3(e12);
    if (typeof n3 == "boolean") return n3;
  } else {
    if (typeof t3 == "boolean") return t3;
    if (t3 instanceof RegExp) return t3.test(e12);
    if (Array.isArray(t3)) {
      for (let n3 of t3) if (n3 instanceof RegExp) {
        if (e12.match(n3)) return true;
      } else if (ja(e12, n3)) return true;
      return false;
    }
  }
  return !!ja(e12, Qa);
};
var jr = (e12, t3, n3) => {
  let r3 = { sets: t3.sets, shape: t3.shape, options: { ...t3.options, fixedDecimalPlaceDigits: n3 } };
  return e12.draw(r3);
}, eo$1 = (e12, t3, n3, r3, o3) => {
  if (!r3.enabled || !r3.clip) return null;
  let i3 = We(e12, o3);
  if (i3) {
    let a3 = t3.ownerDocument.createElementNS(re, "g");
    return a3.setAttributeNS(re, "clip-path", `url(#${i3.id})`), n3.forEach((s3) => a3.appendChild(s3)), a3;
  }
  return null;
}, wi = (e12, t3, n3, r3, o3, i3, a3, s3) => {
  let d3 = { x: i3, y: a3 }, [c3, l3, U3, p3] = C$1(e12, t3), m3 = (U3 - c3) / 2 - (e12.x - c3), b3 = (p3 - l3) / 2 - (e12.y - l3);
  if (k$2(e12)) {
    let y3 = qe(e12, t3);
    if (ee(y3)) {
      let [w3, I3, S3, v3] = C$1(y3, t3), D3 = z$1.getBoundTextElementPosition(y3, e12, t3);
      m3 = (S3 - w3) / 2 - (D3.x - w3), b3 = (v3 - I3) / 2 - (D3.y - I3), i3 = i3 + D3.x - e12.x, a3 = a3 + D3.y - e12.y;
    }
  }
  let E3 = 180 * e12.angle / Math.PI, g3 = r3;
  if (e12.link) {
    let y3 = r3.ownerDocument.createElementNS(re, "a");
    y3.setAttribute("href", dn(e12.link)), g3.appendChild(y3), g3 = y3;
  }
  let h3 = (y3, w3) => {
    Ot() && y3.setAttribute("data-id", w3.id), g3.appendChild(y3);
  }, x3 = (We(e12, t3)?.opacity ?? 100) * e12.opacity / 1e4;
  switch (e12.type) {
    case "selection":
      throw new Error("Selection rendering is not supported for SVG");
    case "rectangle":
    case "diamond":
    case "ellipse": {
      let y3 = he.generateElementShape(e12, null), w3 = jr(n3, y3, qn);
      x3 !== 1 && (w3.setAttribute("stroke-opacity", `${x3}`), w3.setAttribute("fill-opacity", `${x3}`)), w3.setAttribute("stroke-linecap", "round"), w3.setAttribute("transform", `translate(${i3 || 0} ${a3 || 0}) rotate(${E3} ${m3} ${b3})`);
      let I3 = eo$1(e12, g3, [w3], s3.frameRendering, t3);
      h3(I3 || w3, e12);
      break;
    }
    case "iframe":
    case "embeddable": {
      let y3 = he.generateElementShape(e12, s3), w3 = jr(n3, y3, qn), I3 = e12.opacity / 100;
      I3 !== 1 && (w3.setAttribute("stroke-opacity", `${I3}`), w3.setAttribute("fill-opacity", `${I3}`)), w3.setAttribute("stroke-linecap", "round"), w3.setAttribute("transform", `translate(${i3 || 0} ${a3 || 0}) rotate(${E3} ${m3} ${b3})`), h3(w3, e12);
      let S3 = Ii$1(e12);
      wi(S3, t3, n3, g3, o3, S3.x + d3.x - e12.x, S3.y + d3.y - e12.y, s3);
      let v3 = jr(n3, y3, qn);
      for (v3.setAttribute("stroke-linecap", "round"), v3.setAttribute("transform", `translate(${i3 || 0} ${a3 || 0}) rotate(${E3} ${m3} ${b3})`); v3.firstChild; ) v3.removeChild(v3.firstChild);
      let D3 = it$1(Math.min(e12.width, e12.height), e12), $3 = V2(T2(e12.link || ""));
      if (s3.renderEmbeddables === false || $3?.type === "document") {
        let N3 = r3.ownerDocument.createElementNS(re, "a");
        N3.setAttribute("href", dn(e12.link || "")), N3.setAttribute("target", "_blank"), N3.setAttribute("rel", "noopener noreferrer"), N3.style.borderRadius = `${D3}px`, v3.appendChild(N3);
      } else {
        let N3 = r3.ownerDocument.createElementNS(re, "foreignObject");
        N3.style.width = `${e12.width}px`, N3.style.height = `${e12.height}px`, N3.style.border = "none";
        let B3 = N3.ownerDocument.createElementNS(re, "div");
        B3.setAttribute("xmlns", "http://www.w3.org/1999/xhtml"), B3.style.width = "100%", B3.style.height = "100%";
        let _3 = B3.ownerDocument.createElement("iframe");
        _3.src = $3?.link ?? "", _3.style.width = "100%", _3.style.height = "100%", _3.style.border = "none", _3.style.borderRadius = `${D3}px`, _3.style.top = "0", _3.style.left = "0", _3.allowFullscreen = true, B3.appendChild(_3), N3.appendChild(B3), v3.appendChild(N3);
      }
      h3(v3, e12);
      break;
    }
    case "line":
    case "arrow": {
      let y3 = oe(e12, t3), w3 = r3.ownerDocument.createElementNS(re, "mask");
      if (y3) {
        w3.setAttribute("id", `mask-${e12.id}`);
        let D3 = r3.ownerDocument.createElementNS(re, "rect");
        i3 = i3 || 0, a3 = a3 || 0, D3.setAttribute("x", "0"), D3.setAttribute("y", "0"), D3.setAttribute("fill", "#fff"), D3.setAttribute("width", `${e12.width + 100 + i3}`), D3.setAttribute("height", `${e12.height + 100 + a3}`), w3.appendChild(D3);
        let $3 = r3.ownerDocument.createElementNS(re, "rect"), N3 = z$1.getBoundTextElementPosition(e12, y3, t3), B3 = i3 + N3.x - e12.x, _3 = a3 + N3.y - e12.y;
        $3.setAttribute("x", B3.toString()), $3.setAttribute("y", _3.toString()), $3.setAttribute("fill", "#000"), $3.setAttribute("width", `${y3.width}`), $3.setAttribute("height", `${y3.height}`), $3.setAttribute("opacity", "1"), w3.appendChild($3);
      }
      let I3 = r3.ownerDocument.createElementNS(re, "g");
      y3 && I3.setAttribute("mask", `url(#mask-${e12.id})`), I3.setAttribute("stroke-linecap", "round"), he.generateElementShape(e12, s3).forEach((D3) => {
        let $3 = jr(n3, D3, qn);
        x3 !== 1 && ($3.setAttribute("stroke-opacity", `${x3}`), $3.setAttribute("fill-opacity", `${x3}`)), $3.setAttribute("transform", `translate(${i3 || 0} ${a3 || 0}) rotate(${E3} ${m3} ${b3})`), e12.type === "line" && Kt(e12.points) && e12.backgroundColor !== "transparent" && $3.setAttribute("fill-rule", "evenodd"), I3.appendChild($3);
      });
      let v3 = eo$1(e12, g3, [I3, w3], s3.frameRendering, t3);
      v3 ? (h3(v3, e12), g3.appendChild(v3)) : (h3(I3, e12), g3.append(w3));
      break;
    }
    case "freedraw": {
      let y3 = he.generateElementShape(e12, s3), w3 = y3 ? jr(n3, y3, qn) : r3.ownerDocument.createElementNS(re, "g");
      x3 !== 1 && (w3.setAttribute("stroke-opacity", `${x3}`), w3.setAttribute("fill-opacity", `${x3}`)), w3.setAttribute("transform", `translate(${i3 || 0} ${a3 || 0}) rotate(${E3} ${m3} ${b3})`), w3.setAttribute("stroke", "none");
      let I3 = r3.ownerDocument.createElementNS(re, "path");
      I3.setAttribute("fill", e12.strokeColor), I3.setAttribute("d", wa(e12)), w3.appendChild(I3);
      let S3 = eo$1(e12, g3, [w3], s3.frameRendering, t3);
      h3(S3 || w3, e12);
      break;
    }
    case "image": {
      let y3 = Math.round(e12.width), w3 = Math.round(e12.height), I3 = At(e12) && o3[e12.fileId];
      if (I3) {
        let { reuseImages: S3 = true } = s3, v3 = `image-${I3.id}`, D3 = e12.width, $3 = e12.height;
        e12.crop && ({ width: D3, height: $3 } = er$1(e12), v3 = `image-crop-${I3.id}-${X2(`${D3}x${$3}`)}`), S3 || (v3 = `image-${e12.id}`);
        let N3 = r3.querySelector(`#${v3}`);
        if (!N3) {
          N3 = r3.ownerDocument.createElementNS(re, "symbol"), N3.id = v3;
          let j = r3.ownerDocument.createElementNS(re, "image");
          j.setAttribute("href", I3.dataURL), j.setAttribute("preserveAspectRatio", "none"), e12.crop || !S3 ? (j.setAttribute("width", `${D3}`), j.setAttribute("height", `${$3}`)) : (j.setAttribute("width", "100%"), j.setAttribute("height", "100%")), N3.appendChild(j), (g3.querySelector("defs") || g3).prepend(N3);
        }
        let B3 = r3.ownerDocument.createElementNS(re, "use");
        B3.setAttribute("href", `#${v3}`), s3.exportWithDarkMode && I3.mimeType !== H.svg && B3.setAttribute("filter", Ia);
        let _3 = 0, W = 0;
        if (e12.crop) {
          let { width: j, height: ye } = er$1(e12);
          _3 = e12.crop.x / (e12.crop.naturalWidth / j), W = e12.crop.y / (e12.crop.naturalHeight / ye);
        }
        let be = m3 + _3, V3 = b3 + W;
        B3.setAttribute("width", `${y3 + _3}`), B3.setAttribute("height", `${w3 + W}`), B3.setAttribute("opacity", `${x3}`), (e12.scale[0] !== 1 || e12.scale[1] !== 1) && B3.setAttribute("transform", `translate(${be} ${V3}) scale(${e12.scale[0]} ${e12.scale[1]}) translate(${-be} ${-V3})`);
        let ce2 = r3.ownerDocument.createElementNS(re, "g");
        if (e12.crop) {
          let j = r3.ownerDocument.createElementNS(re, "mask");
          j.setAttribute("id", `mask-image-crop-${e12.id}`), j.setAttribute("fill", "#fff");
          let ye = r3.ownerDocument.createElementNS(re, "rect");
          ye.setAttribute("x", `${_3}`), ye.setAttribute("y", `${W}`), ye.setAttribute("width", `${y3}`), ye.setAttribute("height", `${w3}`), j.appendChild(ye), g3.appendChild(j), ce2.setAttribute("mask", `url(#${j.id})`);
        }
        if (ce2.appendChild(B3), ce2.setAttribute("transform", `translate(${i3 - _3} ${a3 - W}) rotate(${E3} ${be} ${V3})`), e12.roundness) {
          let j = r3.ownerDocument.createElementNS(re, "clipPath");
          j.id = `image-clipPath-${e12.id}`;
          let ye = r3.ownerDocument.createElementNS(re, "rect"), He2 = it$1(Math.min(e12.width, e12.height), e12);
          ye.setAttribute("width", `${e12.width}`), ye.setAttribute("height", `${e12.height}`), ye.setAttribute("rx", `${He2}`), ye.setAttribute("ry", `${He2}`), j.appendChild(ye), h3(j, e12), ce2.setAttributeNS(re, "clip-path", `url(#${j.id})`);
        }
        let J = eo$1(e12, g3, [ce2], s3.frameRendering, t3);
        h3(J || ce2, e12);
      }
      break;
    }
    case "frame":
    case "magicframe": {
      if (s3.frameRendering.enabled && s3.frameRendering.outline) {
        let y3 = document.createElementNS(re, "rect");
        y3.setAttribute("transform", `translate(${i3 || 0} ${a3 || 0}) rotate(${E3} ${m3} ${b3})`), y3.setAttribute("width", `${e12.width}px`), y3.setAttribute("height", `${e12.height}px`), y3.setAttribute("rx", Pe$1.radius.toString()), y3.setAttribute("ry", Pe$1.radius.toString()), y3.setAttribute("fill", "none"), y3.setAttribute("stroke", Pe$1.strokeColor), y3.setAttribute("stroke-width", Pe$1.strokeWidth.toString()), h3(y3, e12);
      }
      break;
    }
    default:
      if (k$2(e12)) {
        let y3 = r3.ownerDocument.createElementNS(re, "g");
        x3 !== 1 && (y3.setAttribute("stroke-opacity", `${x3}`), y3.setAttribute("fill-opacity", `${x3}`)), y3.setAttribute("transform", `translate(${i3 || 0} ${a3 || 0}) rotate(${E3} ${m3} ${b3})`);
        let w3 = e12.text.replace(/\r\n?/g, `
`).split(`
`), I3 = Zn(e12.fontSize, e12.lineHeight), S3 = e12.textAlign === "center" ? e12.width / 2 : e12.textAlign === "right" ? e12.width : 0, v3 = Go(e12.fontFamily, e12.fontSize, I3), D3 = Po(e12.text) ? "rtl" : "ltr", $3 = e12.textAlign === "center" ? "middle" : e12.textAlign === "right" || D3 === "rtl" ? "end" : "start";
        for (let B3 = 0; B3 < w3.length; B3++) {
          let _3 = r3.ownerDocument.createElementNS(re, "text");
          _3.textContent = w3[B3], _3.setAttribute("x", `${S3}`), _3.setAttribute("y", `${B3 * I3 + v3}`), _3.setAttribute("font-family", ea(e12)), _3.setAttribute("font-size", `${e12.fontSize}px`), _3.setAttribute("fill", e12.strokeColor), _3.setAttribute("text-anchor", $3), _3.setAttribute("style", "white-space: pre;"), _3.setAttribute("direction", D3), _3.setAttribute("dominant-baseline", "alphabetic"), y3.appendChild(_3);
        }
        let N3 = eo$1(e12, g3, [y3], s3.frameRendering, t3);
        h3(N3 || y3, e12);
      } else throw new Error(`Unimplemented type ${e12.type}`);
  }
}, q2 = (e12, t3, n3, r3, o3, i3) => {
  r3 && (e12.filter((a3) => !gt$1(a3)).forEach((a3) => {
    if (!a3.isDeleted) {
      if (k$2(a3) && a3.containerId && t3.has(a3.containerId)) return;
      try {
        wi(a3, t3, n3, r3, o3, a3.x + i3.offsetX, a3.y + i3.offsetY, i3);
        let s3 = oe(a3, t3);
        s3 && wi(s3, t3, n3, r3, o3, s3.x + i3.offsetX, s3.y + i3.offsetY, i3);
      } catch (s3) {
        console.error(s3);
      }
    }
  }), e12.filter((a3) => gt$1(a3)).forEach((a3) => {
    if (!a3.isDeleted) try {
      wi(a3, t3, n3, r3, o3, a3.x + i3.offsetX, a3.y + i3.offsetY, i3);
    } catch (s3) {
      console.error(s3);
    }
  }));
};
var G2 = 500, Z2 = (e12) => {
  let t3 = e12.extensions?.reduce((r3, o3) => (r3.push(H[o3]), r3), []), n3 = e12.extensions?.reduce((r3, o3) => o3 === "jpg" ? r3.concat(".jpg", ".jpeg") : r3.concat(`.${o3}`), []);
  return n$1({ description: e12.description, extensions: n3, mimeTypes: t3, multiple: e12.multiple ?? false, legacySetup: (r3, o3, i3) => {
    let a3 = $o(o3, G2), s3 = () => {
      d3(), document.addEventListener("keyup", a3), document.addEventListener("pointerup", a3), a3();
    }, d3 = () => {
      if (i3.files?.length) {
        let l3 = e12.multiple ? [...i3.files] : i3.files[0];
        r3(l3);
      }
    };
    requestAnimationFrame(() => {
      window.addEventListener("focus", s3);
    });
    let c3 = window.setInterval(() => {
      d3();
    }, G2);
    return (l3) => {
      clearInterval(c3), a3.cancel(), window.removeEventListener("focus", s3), document.removeEventListener("keyup", a3), document.removeEventListener("pointerup", a3), l3 && (console.warn("Opening the file was canceled (legacy-fs)."), l3(new Co()));
    };
  } });
}, es = (e12, t3) => s$1(e12, { fileName: `${t3.name}.${t3.extension}`, description: t3.description, extensions: [`.${t3.extension}`], mimeTypes: t3.mimeTypes }, t3.fileHandle);
var f7 = (e12, t3) => {
  let n3 = {};
  for (let r3 of e12) !r3.isDeleted && "fileId" in r3 && r3.fileId && t3[r3.fileId] && (n3[r3.fileId] = t3[r3.fileId]);
  return n3;
}, to$1 = (e12, t3, n3, r3) => {
  let o3 = { type: Ze.excalidraw, version: qi.excalidraw, source: Ci$1, elements: Ri(e12), appState: Ro(t3), files: f7(e12, n3) };
  return JSON.stringify(o3, null, 2);
}, hO = async (e12, t3, n3, r3 = t3.name || Zs$1) => {
  let o3 = to$1(e12, t3, n3), i3 = new Blob([o3], { type: H.excalidraw });
  return { fileHandle: await es(i3, { name: r3, extension: "excalidraw", description: "Excalidraw file", fileHandle: W2(t3.fileHandle) ? null : t3.fileHandle }) };
}, yO = async (e12, t3) => {
  let n3 = await Z2({ description: "Excalidraw files" });
  return z2$1(await ts(n3), e12, t3, n3.handle);
}, Q2 = (e12) => e12?.type === Ze.excalidraw && (!e12.elements || Array.isArray(e12.elements) && (!e12.appState || typeof e12.appState == "object")), ns = (e12) => typeof e12 == "object" && e12 && e12.type === Ze.excalidrawLibrary && (e12.version === 1 || e12.version === 2), p7 = (e12) => {
  let t3 = { type: Ze.excalidrawLibrary, version: qi.excalidrawLibrary, source: Ci$1, libraryItems: e12 };
  return JSON.stringify(t3, null, 2);
}, IO = async (e12) => {
  let t3 = p7(e12);
  await es(new Blob([t3], { type: H.excalidrawlib }), { name: "library", extension: "excalidrawlib", description: "Excalidraw library file" });
};
var u7 = (e12) => new Promise((t3, n3) => {
  let r3 = new Image();
  r3.onload = () => {
    t3(r3);
  }, r3.onerror = (o3) => {
    n3(o3);
  }, r3.src = e12;
}), ep = async ({ fileIds: e12, files: t3, imageCache: n3 }) => {
  let r3 = /* @__PURE__ */ new Map(), o3 = /* @__PURE__ */ new Map();
  return await Promise.all(e12.reduce((i3, a3) => {
    let s3 = t3[a3];
    return s3 && !r3.has(a3) ? (r3.set(a3, true), i3.concat((async () => {
      try {
        if (s3.mimeType === H.binary) throw new Error("Only images can be added to ImageCache");
        let d3 = u7(s3.dataURL), c3 = { image: d3, mimeType: s3.mimeType };
        n3.set(a3, c3);
        let l3 = await d3;
        n3.set(a3, { ...c3, image: l3 });
      } catch {
        o3.set(a3, true);
      }
    })())) : i3;
  }, [])), { imageCache: n3, updatedFiles: r3, erroredFiles: o3 };
}, tp = (e12) => e12.filter((t3) => At(t3)), m7 = (e12) => e12?.nodeName.toLowerCase() === "svg", LO = (e12) => {
  let t3 = new DOMParser().parseFromString(e12, H.svg), n3 = t3.querySelector("svg");
  if (t3.querySelector("parsererror") || !m7(n3)) throw new Error("Invalid SVG");
  {
    n3.hasAttribute("xmlns") || n3.setAttribute("xmlns", re);
    let o3 = n3.getAttribute("width"), i3 = n3.getAttribute("height");
    (o3?.includes("%") || o3 === "auto") && (o3 = null), (i3?.includes("%") || i3 === "auto") && (i3 = null);
    let a3 = n3.getAttribute("viewBox");
    if (!o3 || !i3) {
      if (o3 = o3 || "50", i3 = i3 || "50", a3) {
        let s3 = a3.match(/\d+ +\d+ +(\d+(?:\.\d+)?) +(\d+(?:\.\d+)?)/);
        s3 && ([, o3, i3] = s3);
      }
      n3.setAttribute("width", o3), n3.setAttribute("height", i3);
    }
    return a3 || n3.setAttribute("viewBox", `0 0 ${o3} ${i3}`), n3.outerHTML;
  }
};
var rs = document.createElement("img");
rs.src = `data:${H.svg}, ${encodeURIComponent('<svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="#1971c2" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-external-link"><path d="M18 13v6a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2V8a2 2 0 0 1 2-2h6"></path><polyline points="15 3 21 3 21 9"></polyline><line x1="10" y1="14" x2="21" y2="3"></line></svg>')}`;
var os = document.createElement("img");
os.src = `data:${H.svg}, ${encodeURIComponent('<svg  xmlns="http://www.w3.org/2000/svg"  width="16"  height="16"  viewBox="0 0 24 24"  fill="none"  stroke="#1971c2"  stroke-width="2"  stroke-linecap="round"  stroke-linejoin="round"  class="icon icon-tabler icons-tabler-outline icon-tabler-arrow-big-right-line"><path stroke="none" d="M0 0h24v24H0z" fill="none"/><path d="M12 9v-3.586a1 1 0 0 1 1.707 -.707l6.586 6.586a1 1 0 0 1 0 1.414l-6.586 6.586a1 1 0 0 1 -1.707 -.707v-3.586h-6v-6h6z" /><path d="M3 9v6" /></svg>')}`;
var is = ([e12, t3, n3, r3], o3, i3) => {
  let a3 = H1, s3 = a3 / i3.zoom.value, d3 = a3 / i3.zoom.value, c3 = a3 / i3.zoom.value, l3 = (e12 + n3) / 2, U3 = (t3 + r3) / 2, p3 = (a3 - 8) / (2 * i3.zoom.value), m3 = 4 / i3.zoom.value, b3 = n3 + m3 - p3, E3 = t3 - m3 - c3 + p3, [g3, h3] = T$1(u$1(b3 + s3 / 2, E3 + d3 / 2), u$1(l3, U3), o3);
  return [g3 - s3 / 2, h3 - d3 / 2, s3, d3];
}, b7 = (e12, t3, n3, [r3, o3]) => {
  let i3 = 4 / n3.zoom.value, [a3, s3, d3, c3] = C$1(e12, t3), [l3, U3, p3, m3] = is([a3, s3, d3, c3], e12.angle, n3);
  return r3 > l3 - i3 && r3 < l3 + i3 + p3 && o3 > U3 - i3 && o3 < U3 + m3 + i3;
}, BO = (e12, t3, n3, [r3, o3], i3) => !e12.link || n3.selectedElementIds[e12.id] ? false : !i3 && n3.viewModeEnabled && ba(r3, o3, e12, t3) ? true : b7(e12, t3, n3, u$1(r3, o3));
var KO = (e12, t3, n3, r3, o3 = true) => {
  e12.beginPath(), e12.arc(t3, n3, r3, 0, Math.PI * 2), e12.fill(), o3 && e12.stroke();
}, np = (e12, t3) => [e12.width / t3, e12.height / t3], rp = ({ canvas: e12, scale: t3, normalizedWidth: n3, normalizedHeight: r3, theme: o3, isExporting: i3, viewBackgroundColor: a3 }) => {
  let s3 = e12.getContext("2d");
  return s3.setTransform(1, 0, 0, 1, 0, 0), s3.scale(t3, t3), i3 && o3 === ke.DARK && (s3.filter = Io), typeof a3 == "string" ? ((a3 === "transparent" || a3.length === 5 || a3.length === 9 || /(hsla|rgba)\(/.test(a3)) && s3.clearRect(0, 0, n3, r3), s3.save(), s3.fillStyle = a3, s3.fillRect(0, 0, n3, r3), s3.restore()) : s3.clearRect(0, 0, n3, r3), s3;
};
var qO = (e12, t3) => {
  let n3 = window.location.href;
  try {
    let r3 = new URL(n3);
    return r3.searchParams.set(gr, e12), dn(r3.toString());
  } catch (r3) {
    console.error(r3);
  }
  return dn(n3);
}, XO = (e12, t3) => {
  if (e12.length > 0 && E7(e12)) {
    if (e12.length === 1) return { id: e12[0].id, type: "element" };
    if (e12.length > 1) {
      let n3 = Object.keys(t3.selectedGroupIds)[0];
      return n3 ? { id: n3, type: "group" } : { id: e12[0].groupIds[0], type: "group" };
    }
  }
  return null;
}, E7 = (e12) => !!(e12.length === 1 || e12.length > 1 && b2(e12)), op = (e12) => {
  try {
    let t3 = new URL(e12);
    return t3.searchParams.has(gr) && t3.host === window.location.host;
  } catch {
    return false;
  }
}, GO = (e12) => {
  try {
    let { searchParams: t3 } = new URL(e12);
    if (t3.has(gr)) return t3.get(gr);
  } catch {
  }
  return null;
};
var Ti = { Bold: "#dddddd", Regular: "#e5e5e5" }, g7 = (e12, t3, n3, r3, o3, i3, a3, s3) => {
  let d3 = r3 % t3 - t3, c3 = o3 % t3 - t3, l3 = t3 * i3.value, U3 = 1 / i3.value;
  e12.save(), i3.value === 1 && e12.translate(d3 % 1 ? 0 : 0.5, c3 % 1 ? 0 : 0.5);
  for (let p3 = d3; p3 < d3 + a3 + t3 * 2; p3 += t3) {
    let m3 = n3 > 1 && Math.round(p3 - r3) % (n3 * t3) === 0;
    if (!m3 && l3 < 10) continue;
    let b3 = Math.min(1 / i3.value, m3 ? 4 : 1);
    e12.lineWidth = b3;
    let E3 = [b3 * 3, U3 + (b3 + U3)];
    e12.beginPath(), e12.setLineDash(m3 ? [] : E3), e12.strokeStyle = m3 ? Ti.Bold : Ti.Regular, e12.moveTo(p3, c3 - t3), e12.lineTo(p3, Math.ceil(c3 + s3 + t3 * 2)), e12.stroke();
  }
  for (let p3 = c3; p3 < c3 + s3 + t3 * 2; p3 += t3) {
    let m3 = n3 > 1 && Math.round(p3 - o3) % (n3 * t3) === 0;
    if (!m3 && l3 < 10) continue;
    let b3 = Math.min(1 / i3.value, m3 ? 4 : 1);
    e12.lineWidth = b3;
    let E3 = [b3 * 3, U3 + (b3 + U3)];
    e12.beginPath(), e12.setLineDash(m3 ? [] : E3), e12.strokeStyle = m3 ? Ti.Bold : Ti.Regular, e12.moveTo(d3 - t3, p3), e12.lineTo(Math.ceil(d3 + a3 + t3 * 2), p3), e12.stroke();
  }
  e12.restore();
}, ip = (e12, t3, n3, r3) => {
  t3.translate(e12.x + r3.scrollX, e12.y + r3.scrollY), t3.beginPath(), t3.roundRect ? t3.roundRect(0, 0, e12.width, e12.height, Pe$1.radius / r3.zoom.value) : t3.rect(0, 0, e12.width, e12.height), t3.clip(), t3.translate(-(e12.x + r3.scrollX), -(e12.y + r3.scrollY));
}, ap = { regularLink: null, elementLink: null }, sp = (e12, t3, n3, r3) => {
  if (e12.link && !n3.selectedElementIds[e12.id]) {
    let [o3, i3, a3, s3] = C$1(e12, r3), [d3, c3, l3, U3] = is([o3, i3, a3, s3], e12.angle, n3), p3 = d3 + l3 / 2, m3 = c3 + U3 / 2;
    t3.save(), t3.translate(n3.scrollX + p3, n3.scrollY + m3), t3.rotate(e12.angle);
    let b3 = op(e12.link) ? "elementLink" : "regularLink", E3 = ap[b3];
    if (!E3 || E3.zoom !== n3.zoom.value) {
      E3 = Object.assign(document.createElement("canvas"), { zoom: n3.zoom.value }), E3.width = l3 * window.devicePixelRatio * n3.zoom.value, E3.height = U3 * window.devicePixelRatio * n3.zoom.value, ap[b3] = E3;
      let g3 = E3.getContext("2d");
      g3.scale(window.devicePixelRatio * n3.zoom.value, window.devicePixelRatio * n3.zoom.value), g3.fillStyle = "#fff", g3.fillRect(0, 0, l3, U3), b3 === "elementLink" ? g3.drawImage(os, 0, 0, l3, U3) : g3.drawImage(rs, 0, 0, l3, U3), g3.restore();
    }
    t3.drawImage(E3, d3 - p3, c3 - m3, l3, U3), t3.restore();
  }
}, dp = ({ canvas: e12, rc: t3, elementsMap: n3, allElementsMap: r3, visibleElements: o3, scale: i3, appState: a3, renderConfig: s3 }) => {
  if (e12 === null) return;
  let { renderGrid: d3 = true, isExporting: c3 } = s3, [l3, U3] = np(e12, i3), p3 = rp({ canvas: e12, scale: i3, normalizedWidth: l3, normalizedHeight: U3, theme: a3.theme, isExporting: c3, viewBackgroundColor: a3.viewBackgroundColor });
  p3.scale(a3.zoom.value, a3.zoom.value), d3 && g7(p3, a3.gridSize, a3.gridStep, a3.scrollX, a3.scrollY, a3.zoom, l3 / a3.zoom.value, U3 / a3.zoom.value);
  let m3 = /* @__PURE__ */ new Set();
  o3.forEach((E3) => {
    E3.groupIds.length > 0 && a3.frameToHighlight && a3.selectedElementIds[E3.id] && (hn(E3, a3.frameToHighlight, n3) || E3.groupIds.find((g3) => m3.has(g3))) && E3.groupIds.forEach((g3) => m3.add(g3));
  });
  let b3 = /* @__PURE__ */ new Map();
  o3.filter((E3) => !gt$1(E3)).forEach((E3) => {
    try {
      let g3 = E3.frameId || a3.frameToHighlight?.id;
      if (k$2(E3) && E3.containerId && n3.has(E3.containerId)) return;
      if (p3.save(), g3 && a3.frameRendering.enabled && a3.frameRendering.clip) {
        let x3 = Mi$1(E3, n3, a3);
        x3 && as(E3, x3, a3, n3, b3) && ip(x3, p3, s3, a3), Fn(E3, n3, r3, t3, p3, s3, a3);
      } else Fn(E3, n3, r3, t3, p3, s3, a3);
      let h3 = oe(E3, n3);
      h3 && Fn(h3, n3, r3, t3, p3, s3, a3), p3.restore(), c3 || sp(E3, p3, a3, n3);
    } catch (g3) {
      console.error(g3, E3.id, E3.x, E3.y, E3.width, E3.height);
    }
  }), o3.filter((E3) => gt$1(E3)).forEach((E3) => {
    try {
      let g3 = () => {
        if (Fn(E3, n3, r3, t3, p3, s3, a3), gt$1(E3) && (c3 || Bo(E3) && s3.embedsValidationStatus.get(E3.id) !== true) && E3.width && E3.height) {
          let x3 = Ii$1(E3);
          Fn(x3, n3, r3, t3, p3, s3, a3);
        }
        c3 || sp(E3, p3, a3, n3);
      };
      if ((E3.frameId || a3.frameToHighlight?.id) && a3.frameRendering.enabled && a3.frameRendering.clip) {
        p3.save();
        let x3 = Mi$1(E3, n3, a3);
        x3 && as(E3, x3, a3, n3, b3) && ip(x3, p3, s3, a3), g3(), p3.restore();
      } else g3();
    } catch (g3) {
      console.error(g3);
    }
  }), s3.pendingFlowchartNodes?.forEach((E3) => {
    try {
      Fn(E3, n3, r3, t3, p3, s3, a3);
    } catch (g3) {
      console.error(g3);
    }
  });
}, x7 = pd$1((e12) => {
  dp(e12);
}, { trailing: true }), cp = (e12, t3) => {
  if (t3) {
    x7(e12);
    return;
  }
  dp(e12);
};
var h7 = (e12, t3) => {
  if (e12.width <= t3) return e12;
  let r3 = document.createElement("canvas").getContext("2d");
  r3.font = Ee({ fontFamily: e12.fontFamily, fontSize: e12.fontSize });
  let o3 = e12.text;
  if (r3.measureText(o3).width > t3) for (let a3 = o3.length; a3 > 0; a3--) {
    let s3 = `${o3.slice(0, a3)}...`;
    if (r3.measureText(s3).width <= t3) {
      o3 = s3;
      break;
    }
  }
  return vt$1(e12, { text: o3, width: t3 });
}, y7 = (e12, t3) => {
  let n3 = [];
  for (let r3 of e12) {
    if (de(r3)) {
      let o3 = qt({ x: r3.x, y: r3.y - Pe$1.nameOffsetY, fontFamily: Ie.Helvetica, fontSize: Pe$1.nameFontSize, lineHeight: Pe$1.nameLineHeight, strokeColor: t3.exportWithDarkMode ? Pe$1.nameColorDarkTheme : Pe$1.nameColorLightTheme, text: bp$1(r3) });
      o3.y -= o3.height, o3 = h7(o3, r3.width), n3.push(o3);
    }
    n3.push(r3);
  }
  return n3;
}, Up$1 = (e12, t3) => (t3 = t3 || mt().frameRendering, { enabled: e12 ? true : t3.enabled, outline: e12 ? false : t3.outline, name: e12 ? false : t3.name, clip: e12 ? true : t3.clip }), fp$1 = ({ elements: e12, exportingFrame: t3, frameRendering: n3, exportWithDarkMode: r3 }) => {
  let o3;
  return t3 ? o3 = Ep(e12, t3) : n3.enabled && n3.name ? o3 = y7(e12, { exportWithDarkMode: r3 }) : o3 = e12, o3;
}, pp$1 = async (e12, t3, n3, { exportBackground: r3, exportPadding: o3 = Vi$1, viewBackgroundColor: i3, exportingFrame: a3 }, s3 = (c3, l3) => {
  let U3 = document.createElement("canvas");
  return U3.width = c3 * t3.exportScale, U3.height = l3 * t3.exportScale, { canvas: U3, scale: t3.exportScale };
}, d3 = async () => {
  await Nn.loadElementsFonts(e12);
}) => {
  await d3();
  let c3 = Up$1(a3 ?? null, t3.frameRendering ?? null);
  a3 && (c3.clip = false);
  let l3 = fp$1({ elements: e12, exportingFrame: a3, exportWithDarkMode: t3.exportWithDarkMode, frameRendering: c3 });
  a3 && (o3 = 0);
  let [U3, p3, m3, b3] = ss(a3 ? [a3] : cs(l3), o3), { canvas: E3, scale: g3 = 1 } = s3(m3, b3), h3 = mt(), { imageCache: x3 } = await ep({ imageCache: /* @__PURE__ */ new Map(), fileIds: tp(l3).map((y3) => y3.fileId), files: n3 });
  return cp({ canvas: E3, rc: q5.canvas(E3), elementsMap: tt(te(l3)), allElementsMap: tt(te(An$1(e12))), visibleElements: l3, scale: g3, appState: { ...t3, frameRendering: c3, viewBackgroundColor: r3 ? i3 : null, scrollX: -U3 + o3, scrollY: -p3 + o3, zoom: h3.zoom, shouldCacheIgnoreZoom: false, theme: t3.exportWithDarkMode ? ke.DARK : ke.LIGHT }, renderConfig: { canvasBackgroundColor: i3, imageCache: x3, renderGrid: false, isExporting: true, embedsValidationStatus: /* @__PURE__ */ new Map(), elementsPendingErasure: /* @__PURE__ */ new Set(), pendingFlowchartNodes: null } }), E3;
}, no$1 = (e12) => document.createComment(` ${e12} `), up$1 = async (e12, t3, n3, r3) => {
  let o3 = Up$1(r3?.exportingFrame ?? null, t3.frameRendering ?? null), { exportPadding: i3 = Vi$1, exportWithDarkMode: a3 = false, viewBackgroundColor: s3, exportScale: d3 = 1, exportEmbedScene: c3 } = t3, { exportingFrame: l3 = null } = r3 || {}, U3 = fp$1({ elements: e12, exportingFrame: l3, exportWithDarkMode: a3, frameRendering: o3 });
  l3 && (i3 = 0);
  let [p3, m3, b3, E3] = ss(l3 ? [l3] : cs(U3), i3), g3 = -p3 + i3, h3 = -m3 + i3, x3 = document.createElementNS(re, "svg");
  x3.setAttribute("version", "1.1"), x3.setAttribute("xmlns", re), x3.setAttribute("viewBox", `0 0 ${b3} ${E3}`), x3.setAttribute("width", `${b3 * d3}`), x3.setAttribute("height", `${E3 * d3}`), a3 && x3.setAttribute("filter", Io);
  let y3 = x3.ownerDocument.createElementNS(re, "defs"), w3 = x3.ownerDocument.createElementNS(re, "metadata");
  if (x3.appendChild(no$1("svg-source:excalidraw")), x3.appendChild(w3), x3.appendChild(y3), c3) try {
    I7({ metadataElement: w3, payload: to$1(e12, t3, n3 || {}, "local") });
  } catch (B3) {
    console.error(B3);
  }
  let I3 = ds(e12);
  if (I3.length) {
    let B3 = te(e12);
    for (let _3 of I3) {
      let W = x3.ownerDocument.createElementNS(re, "clipPath");
      W.setAttribute("id", _3.id);
      let [be, V3, ce2, J] = C$1(_3, B3), j = (ce2 - be) / 2 - (_3.x - be), ye = (J - V3) / 2 - (_3.y - V3), He2 = x3.ownerDocument.createElementNS(re, "rect");
      He2.setAttribute("transform", `translate(${_3.x + g3} ${_3.y + h3}) rotate(${_3.angle} ${j} ${ye})`), He2.setAttribute("width", `${_3.width}`), He2.setAttribute("height", `${_3.height}`), l3 || (He2.setAttribute("rx", `${Pe$1.radius}`), He2.setAttribute("ry", `${Pe$1.radius}`)), W.appendChild(He2), y3.appendChild(W);
    }
  }
  let S3 = r3?.skipInliningFonts ? [] : await Nn.generateFontFaceDeclarations(e12), v3 = `
      `, D3 = x3.ownerDocument.createElementNS(re, "style");
  if (D3.classList.add("style-fonts"), D3.appendChild(document.createTextNode(`${v3}${S3.join(v3)}`)), y3.appendChild(D3), t3.exportBackground && s3) {
    let B3 = x3.ownerDocument.createElementNS(re, "rect");
    B3.setAttribute("x", "0"), B3.setAttribute("y", "0"), B3.setAttribute("width", `${b3}`), B3.setAttribute("height", `${E3}`), B3.setAttribute("fill", s3), x3.appendChild(B3);
  }
  let $3 = q5.svg(x3), N3 = r3?.renderEmbeddables ?? false;
  return q2(U3, tt(te(U3)), $3, x3, n3 || {}, { offsetX: g3, offsetY: h3, isExporting: true, exportWithDarkMode: a3, renderEmbeddables: N3, frameRendering: o3, canvasBackgroundColor: s3, embedsValidationStatus: N3 ? new Map(U3.filter((B3) => de(B3)).map((B3) => [B3.id, true])) : /* @__PURE__ */ new Map(), reuseImages: r3?.reuseImages ?? true }), x3;
}, I7 = ({ payload: e12, metadataElement: t3 }) => {
  let n3 = Li$1(JSON.stringify(Si$1({ text: e12 })), true);
  t3.appendChild(no$1(`payload-type:${H.excalidraw}`)), t3.appendChild(no$1("payload-version:2")), t3.appendChild(no$1("payload-start")), t3.appendChild(document.createTextNode(n3)), t3.appendChild(no$1("payload-end"));
}, mp = ({ svg: e12 }) => {
  if (e12.includes(`payload-type:${H.excalidraw}`)) {
    let t3 = e12.match(/<!-- payload-start -->\s*(.+?)\s*<!-- payload-end -->/);
    if (!t3) throw new Error("INVALID");
    let o3 = (e12.match(/<!-- payload-version:(\d+) -->/)?.[1] || "1") !== "1";
    try {
      let i3 = Di$1(t3[1], o3), a3 = JSON.parse(i3);
      if (!("encoded" in a3)) {
        if ("type" in a3 && a3.type === Ze.excalidraw) return i3;
        throw new Error("FAILED");
      }
      return vi$1(a3);
    } catch (i3) {
      throw console.error(i3), new Error("FAILED");
    }
  }
  throw new Error("INVALID");
}, ss = (e12, t3) => {
  let [n3, r3, o3, i3] = $e$1(e12), a3 = dt(n3, o3) + t3 * 2, s3 = dt(r3, i3) + t3 * 2;
  return [n3, r3, a3, s3];
}, TA$1 = (e12, t3, n3) => {
  let [, , r3, o3] = ss(e12, t3).map((i3) => Math.trunc(i3 * n3));
  return [r3, o3];
};
var ro$1 = class ro {
  constructor(t3) {
    this.scoreFunction = t3;
    i$1(this, "content", []);
  }
  sinkDown(t3) {
    let n3 = this.content[t3];
    for (; t3 > 0; ) {
      let r3 = (t3 + 1 >> 1) - 1, o3 = this.content[r3];
      if (this.scoreFunction(n3) < this.scoreFunction(o3)) this.content[r3] = n3, this.content[t3] = o3, t3 = r3;
      else break;
    }
  }
  bubbleUp(t3) {
    let n3 = this.content.length, r3 = this.content[t3], o3 = this.scoreFunction(r3);
    for (; ; ) {
      let i3 = t3 + 1 << 1, a3 = i3 - 1, s3 = null, d3 = 0;
      if (a3 < n3) {
        let c3 = this.content[a3];
        d3 = this.scoreFunction(c3), d3 < o3 && (s3 = a3);
      }
      if (i3 < n3) {
        let c3 = this.content[i3];
        this.scoreFunction(c3) < (s3 === null ? o3 : d3) && (s3 = i3);
      }
      if (s3 !== null) this.content[t3] = this.content[s3], this.content[s3] = r3, t3 = s3;
      else break;
    }
  }
  push(t3) {
    this.content.push(t3), this.sinkDown(this.content.length - 1);
  }
  pop() {
    if (this.content.length === 0) return null;
    let t3 = this.content[0], n3 = this.content.pop();
    return this.content.length > 0 && (this.content[0] = n3, this.bubbleUp(0)), t3;
  }
  remove(t3) {
    if (this.content.length === 0) return;
    let n3 = this.content.indexOf(t3), r3 = this.content.pop();
    n3 < this.content.length && (this.content[n3] = r3, this.scoreFunction(r3) < this.scoreFunction(t3) ? this.sinkDown(n3) : this.bubbleUp(n3));
  }
  size() {
    return this.content.length;
  }
  rescoreElement(t3) {
    this.sinkDown(this.content.indexOf(t3));
  }
};
var Us = 1, pe$1 = 40, w7 = (e12, t3) => {
  let n3 = e12.fixedSegments ? e12.fixedSegments.slice() : null;
  if (n3) {
    let r3 = [];
    e12.points.map((a3) => u$1(e12.x + a3[0], e12.y + a3[1])).forEach((a3, s3, d3) => {
      if (s3 < 2) return r3.push(a3);
      let c3 = tr(a3, d3[s3 - 1]), l3 = tr(d3[s3 - 1], d3[s3 - 2]);
      if (ve$1(c3, l3)) {
        let U3 = n3?.findIndex((m3) => m3.index === s3 - 1) ?? -1, p3 = n3?.findIndex((m3) => m3.index === s3) ?? -1;
        p3 !== -1 && (n3[p3].start = u$1(d3[s3 - 2][0] - e12.x, d3[s3 - 2][1] - e12.y)), U3 !== -1 && n3.splice(U3, 1), r3.splice(-1, 1), n3.forEach((m3) => {
          m3.index > s3 - 1 && (m3.index -= 1);
        });
      }
      return r3.push(a3);
    });
    let o3 = [];
    r3.forEach((a3, s3, d3) => {
      if (s3 < 3) return o3.push(a3);
      if (ie(d3[s3 - 2], d3[s3 - 1]) < Us) {
        let c3 = n3?.findIndex((p3) => p3.index === s3 - 2) ?? -1, l3 = n3?.findIndex((p3) => p3.index === s3 - 1) ?? -1;
        l3 !== -1 && n3.splice(l3, 1), c3 !== -1 && n3.splice(c3, 1), o3.splice(-2, 2), n3.forEach((p3) => {
          p3.index > s3 - 2 && (p3.index -= 2);
        });
        let U3 = Mt(a3, d3[s3 - 1]);
        return o3.push(u$1(U3 ? a3[0] : d3[s3 - 2][0], U3 ? d3[s3 - 2][1] : a3[1]));
      }
      o3.push(a3);
    });
    let i3 = n3.filter((a3) => a3.index !== 1 && a3.index !== o3.length - 1);
    return i3.length === 0 ? In$1(us(ms(ps(e12, fs(e12, t3, o3.map((a3) => u$1(a3[0] - e12.x, a3[1] - e12.y)), e12.startBinding && cr(e12.startBinding.elementId, t3), e12.endBinding && cr(e12.endBinding.elementId, t3))) ?? [])), i3, null, null) : (c$1.DEV && Ae(Ni$1(o3), "Invalid elbow points with fixed segments"), In$1(o3, i3, e12.startIsSpecial, e12.endIsSpecial));
  }
  return { x: e12.x, y: e12.y, points: e12.points, fixedSegments: e12.fixedSegments, startIsSpecial: e12.startIsSpecial, endIsSpecial: e12.endIsSpecial };
}, R7 = (e12, t3, n3) => {
  let r3 = t3.map(($3) => $3.index), i3 = (e12.fixedSegments?.map(($3) => $3.index) ?? []).findIndex(($3) => !r3.includes($3));
  if (i3 === -1 || !e12.fixedSegments?.[i3]) return { points: e12.points };
  let a3 = e12.fixedSegments[i3].index, s3 = e12.fixedSegments[i3 - 1], d3 = e12.fixedSegments[i3 + 1], c3 = e12.x + (s3 ? s3.end[0] : 0), l3 = e12.y + (s3 ? s3.end[1] : 0), U3 = s3 ? null : e12.startBinding, p3 = d3 ? null : e12.endBinding, { startHeading: m3, endHeading: b3, startGlobalPoint: E3, endGlobalPoint: g3, hoveredStartElement: h3, hoveredEndElement: x3, ...y3 } = fs({ x: c3, y: l3, startBinding: U3, endBinding: p3, startArrowhead: null, endArrowhead: null, points: e12.points }, n3, [u$1(0, 0), u$1(e12.x + (d3?.start[0] ?? e12.points[e12.points.length - 1][0]) - c3, e12.y + (d3?.start[1] ?? e12.points[e12.points.length - 1][1]) - l3)], U3 && cr(U3.elementId, n3), p3 && cr(p3.elementId, n3), { isDragging: false }), { points: w3 } = In$1(us(ms(ps(e12, { startHeading: m3, endHeading: b3, startGlobalPoint: E3, endGlobalPoint: g3, hoveredEndElement: x3, ...y3 }) ?? [])), t3, null, null), I3 = [];
  if (s3) for (let $3 = 0; $3 < s3.index; $3++) I3.push(u$1(e12.x + e12.points[$3][0], e12.y + e12.points[$3][1]));
  if (w3.forEach(($3) => {
    I3.push(u$1(e12.x + (s3 ? s3.end[0] : 0) + $3[0], e12.y + (s3 ? s3.end[1] : 0) + $3[1]));
  }), d3) for (let $3 = d3.index; $3 < e12.points.length; $3++) I3.push(u$1(e12.x + e12.points[$3][0], e12.y + e12.points[$3][1]));
  let S3 = (d3?.index ?? e12.points.length) - (s3?.index ?? 0) - 1, v3 = t3.map(($3) => $3.index > a3 ? { ...$3, index: $3.index - S3 + (w3.length - 1) } : $3), D3 = I3.flatMap(($3, N3) => {
    let B3 = I3[N3 - 1], _3 = I3[N3 + 1];
    if (B3 && _3) {
      let W = tr($3, B3), be = tr(_3, $3);
      if (ve$1(W, be)) return v3.forEach((V3) => {
        V3.index > N3 && (V3.index -= 1);
      }), [];
      if (ve$1(W, Ma$1(be))) return v3.forEach((V3) => {
        V3.index > N3 && (V3.index += 1);
      }), [$3, $3];
    }
    return [$3];
  });
  return In$1(D3, v3, false, false);
}, T7 = (e12, t3, n3, r3, o3, i3) => {
  let a3 = t3.map((I3, S3) => e12.fixedSegments == null || e12.fixedSegments[S3] === void 0 || e12.fixedSegments[S3].index !== I3.index || (I3.start[0] !== e12.fixedSegments[S3].start[0] && I3.end[0] !== e12.fixedSegments[S3].end[0]) != (I3.start[1] !== e12.fixedSegments[S3].start[1] && I3.end[1] !== e12.fixedSegments[S3].end[1]) ? S3 : null).filter((I3) => I3 !== null).shift();
  if (a3 == null) return { points: e12.points };
  let s3 = e12.fixedSegments?.findIndex((I3) => I3.index === 1) ?? -1, d3 = e12.fixedSegments?.findIndex((I3) => I3.index === e12.points.length - 1) ?? -1, c3 = ie(t3[a3].start, t3[a3].end), l3 = c3 < pe$1 + 5;
  if (s3 === -1 && t3[a3].index === 1 && o3) {
    let I3 = Lt(n3), v3 = (I3 ? ve$1(n3, Re) : ve$1(n3, Fe$1)) ? l3 ? c3 / 2 : pe$1 : l3 ? -c3 / 2 : -pe$1;
    t3[a3].start = u$1(t3[a3].start[0] + (I3 ? v3 : 0), t3[a3].start[1] + (I3 ? 0 : v3));
  }
  if (d3 === -1 && t3[a3].index === e12.points.length - 1 && i3) {
    let I3 = Lt(r3), v3 = (I3 ? ve$1(r3, Re) : ve$1(r3, Fe$1)) ? l3 ? c3 / 2 : pe$1 : l3 ? -c3 / 2 : -pe$1;
    t3[a3].end = u$1(t3[a3].end[0] + (I3 ? v3 : 0), t3[a3].end[1] + (I3 ? 0 : v3));
  }
  let U3 = t3.map((I3) => ({ ...I3, start: u$1(e12.x + I3.start[0], e12.y + I3.start[1]), end: u$1(e12.x + I3.end[0], e12.y + I3.end[1]) })), p3 = e12.points.map((I3, S3) => u$1(e12.x + I3[0], e12.y + I3[1])), m3 = U3[a3].index - 1, b3 = U3[a3].index, E3 = U3[a3].start, g3 = U3[a3].end, h3 = p3[m3 - 1] && !_e$1(p3[m3], p3[m3 - 1]) ? Mt(p3[m3 - 1], p3[m3]) : void 0, x3 = p3[b3 + 1] && !_e$1(p3[b3], p3[b3 + 1]) ? Mt(p3[b3 + 1], p3[b3]) : void 0;
  if (h3 !== void 0) {
    let I3 = h3 ? 1 : 0;
    p3[m3 - 1][I3] = E3[I3];
  }
  if (p3[m3] = E3, p3[b3] = g3, x3 !== void 0) {
    let I3 = x3 ? 1 : 0;
    p3[b3 + 1][I3] = g3[I3];
  }
  let y3 = U3.findIndex((I3) => I3.index === m3);
  if (y3 !== -1) {
    let I3 = Mt(U3[y3].end, U3[y3].start) ? 1 : 0;
    U3[y3].start[I3] = E3[I3], U3[y3].end = E3;
  }
  let w3 = U3.findIndex((I3) => I3.index === b3 + 1);
  if (w3 !== -1) {
    let I3 = Mt(U3[w3].end, U3[w3].start) ? 1 : 0;
    U3[w3].end[I3] = g3[I3], U3[w3].start = g3;
  }
  if (s3 === -1 && m3 === 0) {
    let I3 = o3 ? Lt(n3) : Mt(p3[1], p3[0]);
    p3.unshift(u$1(I3 ? E3[0] : e12.x + e12.points[0][0], I3 ? e12.y + e12.points[0][1] : E3[1])), o3 && p3.unshift(u$1(e12.x + e12.points[0][0], e12.y + e12.points[0][1]));
    for (let S3 of U3) S3.index += o3 ? 2 : 1;
  }
  if (d3 === -1 && b3 === e12.points.length - 1) {
    let I3 = Lt(r3);
    p3.push(u$1(I3 ? g3[0] : e12.x + e12.points[e12.points.length - 1][0], I3 ? e12.y + e12.points[e12.points.length - 1][1] : g3[1])), i3 && p3.push(u$1(e12.x + e12.points[e12.points.length - 1][0], e12.y + e12.points[e12.points.length - 1][1]));
  }
  return In$1(p3, U3.map((I3) => ({ ...I3, start: u$1(I3.start[0] - e12.x, I3.start[1] - e12.y), end: u$1(I3.end[0] - e12.x, I3.end[1] - e12.y) })), false, false);
}, M7 = (e12, t3, n3, r3, o3, i3, a3, s3, d3) => {
  let c3 = e12.startIsSpecial ?? null, l3 = e12.endIsSpecial ?? null, U3 = t3.map((g3, h3) => h3 === 0 ? u$1(e12.x + g3[0], e12.y + g3[1]) : h3 === t3.length - 1 ? u$1(e12.x + g3[0], e12.y + g3[1]) : u$1(e12.x + e12.points[h3][0], e12.y + e12.points[h3][1])), p3 = n3.map((g3) => ({ ...g3, start: u$1(e12.x + (g3.start[0] - t3[0][0]), e12.y + (g3.start[1] - t3[0][1])), end: u$1(e12.x + (g3.end[0] - t3[0][0]), e12.y + (g3.end[1] - t3[0][1])) })), m3 = [], b3 = 2 + (c3 ? 1 : 0), E3 = 2 + (l3 ? 1 : 0);
  for (; m3.length + b3 < U3.length - E3; ) m3.push(U3[m3.length + b3]);
  {
    let g3 = U3[c3 ? 2 : 1], h3 = U3[c3 ? 3 : 2], x3 = Lt(r3), y3 = Lt(Ht$1(O(g3, h3)));
    if (s3 && x3 === y3) {
      let w3 = x3 ? ve$1(r3, Re) : ve$1(r3, Fe$1);
      if (m3.unshift(u$1(y3 ? i3[0] + (w3 ? pe$1 : -pe$1) : h3[0], y3 ? h3[1] : i3[1] + (w3 ? pe$1 : -pe$1))), m3.unshift(u$1(x3 ? i3[0] + (w3 ? pe$1 : -pe$1) : i3[0], x3 ? i3[1] : i3[1] + (w3 ? pe$1 : -pe$1))), !c3) {
        c3 = true;
        for (let I3 of p3) I3.index > 1 && (I3.index += 1);
      }
    } else if (m3.unshift(u$1(y3 ? i3[0] : g3[0], y3 ? g3[1] : i3[1])), c3) {
      c3 = false;
      for (let w3 of p3) w3.index > 1 && (w3.index -= 1);
    }
    m3.unshift(i3);
  }
  {
    let g3 = U3[U3.length - (l3 ? 3 : 2)], h3 = U3[U3.length - (l3 ? 4 : 3)], x3 = Lt(o3), y3 = Mt(h3, g3);
    if (d3 && x3 === y3) {
      let w3 = x3 ? ve$1(o3, Re) : ve$1(o3, Fe$1);
      m3.push(u$1(y3 ? a3[0] + (w3 ? pe$1 : -pe$1) : h3[0], y3 ? h3[1] : a3[1] + (w3 ? pe$1 : -pe$1))), m3.push(u$1(x3 ? a3[0] + (w3 ? pe$1 : -pe$1) : a3[0], x3 ? a3[1] : a3[1] + (w3 ? pe$1 : -pe$1))), l3 || (l3 = true);
    } else m3.push(u$1(y3 ? a3[0] : g3[0], y3 ? g3[1] : a3[1])), l3 && (l3 = false);
  }
  return m3.push(a3), In$1(m3, p3.map(({ index: g3 }) => ({ index: g3, start: m3[g3 - 1], end: m3[g3] })).map((g3) => ({ ...g3, start: u$1(g3.start[0] - i3[0], g3.start[1] - i3[1]), end: u$1(g3.end[0] - i3[0], g3.end[1] - i3[1]) })), c3, l3);
}, ge = 1e6, Pi = (e12, t3, n3, r3) => {
  if (e12.points.length < 2) return { points: n3.points ?? e12.points };
  (e12.x < -ge || e12.x > ge || e12.y < -ge || e12.y > ge || e12.x + (n3?.points?.[n3?.points?.length - 1]?.[0] ?? 0) < -ge || e12.x + (n3?.points?.[n3?.points?.length - 1]?.[0] ?? 0) > ge || e12.y + (n3?.points?.[n3?.points?.length - 1]?.[1] ?? 0) < -ge || e12.y + (n3?.points?.[n3?.points?.length - 1]?.[1] ?? 0) > ge || e12.x + (e12?.points?.[e12?.points?.length - 1]?.[0] ?? 0) < -ge || e12.x + (e12?.points?.[e12?.points?.length - 1]?.[0] ?? 0) > ge || e12.y + (e12?.points?.[e12?.points?.length - 1]?.[1] ?? 0) < -ge || e12.y + (e12?.points?.[e12?.points?.length - 1]?.[1] ?? 0) > ge) && console.error("Elbow arrow (or update) is outside reasonable bounds (> 1e6)", { arrow: e12, updates: n3 }), e12.x = se(e12.x, -ge, ge), e12.y = se(e12.y, -ge, ge), n3.points && (n3.points = n3.points.map(([h3, x3]) => u$1(se(h3, -ge, ge), se(x3, -ge, ge))));
  let o3 = n3.points ? n3.points && n3.points.length === 2 ? e12.points.map((h3, x3) => x3 === 0 ? n3.points[0] : x3 === e12.points.length - 1 ? n3.points[1] : h3) : n3.points.slice() : e12.points.slice(), i3 = typeof n3.startBinding < "u" ? n3.startBinding : e12.startBinding, a3 = typeof n3.endBinding < "u" ? n3.endBinding : e12.endBinding, s3 = i3 && cr(i3.elementId, t3), d3 = a3 && cr(a3.elementId, t3);
  if (t3.size === 0 && Ni$1(o3) || s3?.id !== i3?.elementId || d3?.id !== a3?.elementId) return In$1(o3.map((h3) => u$1(e12.x + h3[0], e12.y + h3[1])), e12.fixedSegments, e12.startIsSpecial, e12.endIsSpecial);
  let { startHeading: c3, endHeading: l3, startGlobalPoint: U3, endGlobalPoint: p3, hoveredStartElement: m3, hoveredEndElement: b3, ...E3 } = fs({ x: e12.x, y: e12.y, startBinding: i3, endBinding: a3, startArrowhead: e12.startArrowhead, endArrowhead: e12.endArrowhead, points: e12.points }, t3, o3, s3, d3, r3), g3 = n3.fixedSegments ?? e12.fixedSegments ?? [];
  return !n3.points && !n3.fixedSegments && !n3.startBinding && !n3.endBinding ? w7(e12, t3) : n3.startBinding === e12.startBinding && n3.endBinding === e12.endBinding && (n3.points ?? []).every((h3, x3) => _e$1(h3, e12.points[x3] ?? u$1(1 / 0, 1 / 0))) ? {} : g3.length === 0 ? In$1(us(ms(ps(e12, { startHeading: c3, endHeading: l3, startGlobalPoint: U3, endGlobalPoint: p3, hoveredEndElement: b3, ...E3 }) ?? [])), g3, null, null) : (e12.fixedSegments?.length ?? 0) > g3.length ? R7(e12, g3, t3) : n3.points ? n3.points && n3.fixedSegments ? n3 : M7(e12, o3, g3, c3, l3, U3, p3, m3, b3) : T7(e12, g3, c3, l3, m3, b3);
}, fs = (e12, t3, n3, r3, o3, i3) => {
  let a3 = wr(n3[0], Be(e12.x, e12.y)), s3 = wr(n3[n3.length - 1], Be(e12.x, e12.y)), d3 = r3, c3 = o3;
  if (i3?.isDragging) {
    let v3 = Array.from(t3.values());
    d3 = yp(a3, t3, v3, i3?.zoom) || r3, c3 = yp(s3, t3, v3, i3?.zoom) || o3;
  }
  let l3 = xp$1({ ...e12, points: n3 }, "start", e12.startBinding?.fixedPoint, a3, r3, d3, i3?.isDragging), U3 = xp$1({ ...e12, points: n3 }, "end", e12.endBinding?.fixedPoint, s3, o3, c3, i3?.isDragging), p3 = hp$1(l3, U3, t3, d3, a3), m3 = hp$1(U3, l3, t3, c3, s3), b3 = [l3[0] - 2, l3[1] - 2, l3[0] + 2, l3[1] + 2], E3 = [U3[0] - 2, U3[1] - 2, U3[0] + 2, U3[1] + 2], g3 = d3 ? wt$1(d3, yn$1(p3, e12.startArrowhead ? me$1 * 6 : me$1 * 2, 1)) : b3, h3 = c3 ? wt$1(c3, yn$1(m3, e12.endArrowhead ? me$1 * 6 : me$1 * 2, 1)) : E3, x3 = gn(l3, c3 ? wt$1(c3, yn$1(m3, pe$1, pe$1)) : E3) || gn(U3, d3 ? wt$1(d3, yn$1(p3, pe$1, pe$1)) : b3), y3 = wp(x3 ? [b3, E3] : [g3, h3]), w3 = S7(x3 ? b3 : g3, x3 ? E3 : h3, y3, x3 ? yn$1(p3, !d3 && !c3 ? 0 : pe$1, 0) : yn$1(p3, !d3 && !c3 ? 0 : pe$1 - (e12.startArrowhead ? me$1 * 6 : me$1 * 2), pe$1), x3 ? yn$1(m3, !d3 && !c3 ? 0 : pe$1, 0) : yn$1(m3, !d3 && !c3 ? 0 : pe$1 - (e12.endArrowhead ? me$1 * 6 : me$1 * 2), pe$1), x3, d3 && wt$1(d3), c3 && wt$1(c3)), I3 = gp$1(w3[0], p3, l3), S3 = gp$1(w3[1], m3, U3);
  return { dynamicAABBs: w3, startDonglePosition: I3, startGlobalPoint: l3, startHeading: p3, endDonglePosition: S3, endGlobalPoint: U3, endHeading: m3, commonBounds: y3, hoveredStartElement: d3, hoveredEndElement: c3, boundsOverlap: x3, startElementBounds: g3, endElementBounds: h3 };
}, ps = (e12, t3) => {
  let { dynamicAABBs: n3, startDonglePosition: r3, startGlobalPoint: o3, startHeading: i3, endDonglePosition: a3, endGlobalPoint: s3, endHeading: d3, commonBounds: c3, hoveredEndElement: l3 } = t3, U3 = v7(n3, r3 || o3, i3, a3 || s3, d3, c3), p3 = r3 && $i$1(r3, U3), m3 = a3 && $i$1(a3, U3), b3 = $i$1(s3, U3);
  b3 && l3 && (b3.closed = true);
  let E3 = $i$1(o3, U3);
  E3 && e12.startBinding && (E3.closed = true);
  let g3 = p3 && m3 && (gn(p3.pos, n3[1]) || gn(m3.pos, n3[0])), h3 = L7(p3 || E3, m3 || b3, U3, i3 || Re, d3 || Re, g3 ? [] : n3);
  if (h3) {
    let x3 = h3.map((y3) => [y3.pos[0], y3.pos[1]]);
    return p3 && x3.unshift(o3), m3 && x3.push(s3), x3;
  }
  return null;
}, yn$1 = (e12, t3, n3) => {
  switch (e12) {
    case ze$1:
      return [t3, n3, n3, n3];
    case Re:
      return [n3, t3, n3, n3];
    case Fe$1:
      return [n3, n3, t3, n3];
  }
  return [n3, n3, n3, t3];
}, L7 = (e12, t3, n3, r3, o3, i3) => {
  let a3 = ls(e12.pos, t3.pos), s3 = new ro$1((d3) => d3.f);
  for (s3.push(e12); s3.size() > 0; ) {
    let d3 = s3.pop();
    if (!d3 || d3.closed) continue;
    if (d3 === t3) return D7(e12, d3);
    d3.closed = true;
    let c3 = P7(d3.addr, n3);
    for (let l3 = 0; l3 < 4; l3++) {
      let U3 = c3[l3];
      if (!U3 || U3.closed) continue;
      let p3 = bt(U3.pos, d3.pos, 0.5);
      if (xd(...i3.map((w3) => gn(p3, w3)))) continue;
      let m3 = N7(l3), b3 = d3.parent ? Ht$1(O(d3.pos, d3.parent.pos)) : r3, E3 = Ma$1(b3);
      if (ve$1(E3, m3) || Ip$1(e12.addr, U3.addr) && ve$1(m3, r3) || Ip$1(t3.addr, U3.addr) && ve$1(m3, o3)) continue;
      let h3 = b3 !== m3, x3 = d3.g + ls(U3.pos, d3.pos) + (h3 ? Math.pow(a3, 3) : 0), y3 = U3.visited;
      if (!y3 || x3 < U3.g) {
        let w3 = $7(U3, t3, m3, o3);
        U3.visited = true, U3.parent = d3, U3.h = ls(t3.pos, U3.pos) + w3 * Math.pow(a3, 2), U3.g = x3, U3.f = U3.g + U3.h, y3 ? s3.rescoreElement(U3) : s3.push(U3);
      }
    }
  }
  return null;
}, D7 = (e12, t3) => {
  let n3 = t3, r3 = [];
  for (; n3.parent; ) r3.unshift(n3), n3 = n3.parent;
  return r3.unshift(e12), r3;
}, ls = (e12, t3) => Math.abs(e12[0] - t3[0]) + Math.abs(e12[1] - t3[1]), S7 = (e12, t3, n3, r3, o3, i3, a3, s3) => {
  let d3 = a3 ?? e12, c3 = s3 ?? t3, [l3, U3, p3, m3] = r3 ?? [0, 0, 0, 0], [b3, E3, g3, h3] = o3 ?? [0, 0, 0, 0], x3 = [e12[0] > t3[2] ? e12[1] > t3[3] || e12[3] < t3[1] ? Math.min((d3[0] + c3[2]) / 2, e12[0] - m3) : (d3[0] + c3[2]) / 2 : e12[0] > t3[0] ? e12[0] - m3 : n3[0] - m3, e12[1] > t3[3] ? e12[0] > t3[2] || e12[2] < t3[0] ? Math.min((d3[1] + c3[3]) / 2, e12[1] - l3) : (d3[1] + c3[3]) / 2 : e12[1] > t3[1] ? e12[1] - l3 : n3[1] - l3, e12[2] < t3[0] ? e12[1] > t3[3] || e12[3] < t3[1] ? Math.max((d3[2] + c3[0]) / 2, e12[2] + U3) : (d3[2] + c3[0]) / 2 : e12[2] < t3[2] ? e12[2] + U3 : n3[2] + U3, e12[3] < t3[1] ? e12[0] > t3[2] || e12[2] < t3[0] ? Math.max((d3[3] + c3[1]) / 2, e12[3] + p3) : (d3[3] + c3[1]) / 2 : e12[3] < t3[3] ? e12[3] + p3 : n3[3] + p3], y3 = [t3[0] > e12[2] ? t3[1] > e12[3] || t3[3] < e12[1] ? Math.min((c3[0] + d3[2]) / 2, t3[0] - h3) : (c3[0] + d3[2]) / 2 : t3[0] > e12[0] ? t3[0] - h3 : n3[0] - h3, t3[1] > e12[3] ? t3[0] > e12[2] || t3[2] < e12[0] ? Math.min((c3[1] + d3[3]) / 2, t3[1] - b3) : (c3[1] + d3[3]) / 2 : t3[1] > e12[1] ? t3[1] - b3 : n3[1] - b3, t3[2] < e12[0] ? t3[1] > e12[3] || t3[3] < e12[1] ? Math.max((c3[2] + d3[0]) / 2, t3[2] + E3) : (c3[2] + d3[0]) / 2 : t3[2] < e12[2] ? t3[2] + E3 : n3[2] + E3, t3[3] < e12[1] ? t3[0] > e12[2] || t3[2] < e12[0] ? Math.max((c3[3] + d3[1]) / 2, t3[3] + g3) : (c3[3] + d3[1]) / 2 : t3[3] < e12[3] ? t3[3] + g3 : n3[3] + g3], w3 = wp([x3, y3]);
  if (!i3 && x3[2] - x3[0] + y3[2] - y3[0] > w3[2] - w3[0] + 1e-11 && x3[3] - x3[1] + y3[3] - y3[1] > w3[3] - w3[1] + 1e-11) {
    let [I3, S3] = [(y3[0] + y3[2]) / 2, (y3[1] + y3[3]) / 2];
    if (t3[0] > e12[2] && e12[1] > t3[3]) {
      let v3 = x3[2] + (y3[0] - x3[2]) / 2, D3 = y3[3] + (x3[1] - y3[3]) / 2;
      return Me(Be(e12[2] - I3, e12[1] - S3), Be(e12[0] - I3, e12[3] - S3)) > 0 ? [[x3[0], x3[1], v3, x3[3]], [v3, y3[1], y3[2], y3[3]]] : [[x3[0], D3, x3[2], x3[3]], [y3[0], y3[1], y3[2], D3]];
    } else if (e12[2] < t3[0] && e12[3] < t3[1]) {
      let v3 = x3[2] + (y3[0] - x3[2]) / 2, D3 = x3[3] + (y3[1] - x3[3]) / 2;
      return Me(Be(e12[0] - I3, e12[1] - S3), Be(e12[2] - I3, e12[3] - S3)) > 0 ? [[x3[0], x3[1], x3[2], D3], [y3[0], D3, y3[2], y3[3]]] : [[x3[0], x3[1], v3, x3[3]], [v3, y3[1], y3[2], y3[3]]];
    } else if (e12[0] > t3[2] && e12[3] < t3[1]) {
      let v3 = y3[2] + (x3[0] - y3[2]) / 2, D3 = x3[3] + (y3[1] - x3[3]) / 2;
      return Me(Be(e12[2] - I3, e12[1] - S3), Be(e12[0] - I3, e12[3] - S3)) > 0 ? [[v3, x3[1], x3[2], x3[3]], [y3[0], y3[1], v3, y3[3]]] : [[x3[0], x3[1], x3[2], D3], [y3[0], D3, y3[2], y3[3]]];
    } else if (e12[0] > t3[2] && e12[1] > t3[3]) {
      let v3 = y3[2] + (x3[0] - y3[2]) / 2, D3 = y3[3] + (x3[1] - y3[3]) / 2;
      return Me(Be(e12[0] - I3, e12[1] - S3), Be(e12[2] - I3, e12[3] - S3)) > 0 ? [[v3, x3[1], x3[2], x3[3]], [y3[0], y3[1], v3, y3[3]]] : [[x3[0], D3, x3[2], x3[3]], [y3[0], y3[1], y3[2], D3]];
    }
  }
  return [x3, y3];
}, v7 = (e12, t3, n3, r3, o3, i3) => {
  let a3 = /* @__PURE__ */ new Set(), s3 = /* @__PURE__ */ new Set();
  n3 === nt || n3 === Re ? s3.add(t3[1]) : a3.add(t3[0]), o3 === nt || o3 === Re ? s3.add(r3[1]) : a3.add(r3[0]), e12.forEach((l3) => {
    a3.add(l3[0]), a3.add(l3[2]), s3.add(l3[1]), s3.add(l3[3]);
  }), a3.add(i3[0]), a3.add(i3[2]), s3.add(i3[1]), s3.add(i3[3]);
  let d3 = Array.from(s3).sort((l3, U3) => l3 - U3), c3 = Array.from(a3).sort((l3, U3) => l3 - U3);
  return { row: d3.length, col: c3.length, data: d3.flatMap((l3, U3) => c3.map((p3, m3) => ({ f: 0, g: 0, h: 0, closed: false, visited: false, parent: null, addr: [m3, U3], pos: [p3, l3] }))) };
}, gp$1 = (e12, t3, n3) => {
  switch (t3) {
    case ze$1:
      return u$1(n3[0], e12[1]);
    case Re:
      return u$1(e12[2], n3[1]);
    case Fe$1:
      return u$1(n3[0], e12[3]);
  }
  return u$1(e12[0], n3[1]);
}, $7 = (e12, t3, n3, r3) => {
  if (r3 === Re) switch (n3) {
    case Re:
      return e12.pos[0] >= t3.pos[0] ? 4 : e12.pos[1] === t3.pos[1] ? 0 : 2;
    case ze$1:
      return e12.pos[1] > t3.pos[1] && e12.pos[0] < t3.pos[0] ? 1 : 3;
    case Fe$1:
      return e12.pos[1] < t3.pos[1] && e12.pos[0] < t3.pos[0] ? 1 : 3;
    case nt:
      return e12.pos[1] === t3.pos[1] ? 4 : 2;
  }
  else if (r3 === nt) switch (n3) {
    case Re:
      return e12.pos[1] === t3.pos[1] ? 4 : 2;
    case ze$1:
      return e12.pos[1] > t3.pos[1] && e12.pos[0] > t3.pos[0] ? 1 : 3;
    case Fe$1:
      return e12.pos[1] < t3.pos[1] && e12.pos[0] > t3.pos[0] ? 1 : 3;
    case nt:
      return e12.pos[0] <= t3.pos[0] ? 4 : e12.pos[1] === t3.pos[1] ? 0 : 2;
  }
  else if (r3 === ze$1) switch (n3) {
    case Re:
      return e12.pos[1] > t3.pos[1] && e12.pos[0] < t3.pos[0] ? 1 : 3;
    case ze$1:
      return e12.pos[1] >= t3.pos[1] ? 4 : e12.pos[0] === t3.pos[0] ? 0 : 2;
    case Fe$1:
      return e12.pos[0] === t3.pos[0] ? 4 : 2;
    case nt:
      return e12.pos[1] > t3.pos[1] && e12.pos[0] > t3.pos[0] ? 1 : 3;
  }
  else if (r3 === Fe$1) switch (n3) {
    case Re:
      return e12.pos[1] < t3.pos[1] && e12.pos[0] < t3.pos[0] ? 1 : 3;
    case ze$1:
      return e12.pos[0] === t3.pos[0] ? 4 : 2;
    case Fe$1:
      return e12.pos[1] <= t3.pos[1] ? 4 : e12.pos[0] === t3.pos[0] ? 0 : 2;
    case nt:
      return e12.pos[1] < t3.pos[1] && e12.pos[0] > t3.pos[0] ? 1 : 3;
  }
  return 0;
}, P7 = ([e12, t3], n3) => [oo([e12, t3 - 1], n3), oo([e12 + 1, t3], n3), oo([e12, t3 + 1], n3), oo([e12 - 1, t3], n3)], oo = ([e12, t3], n3) => e12 < 0 || e12 >= n3.col || t3 < 0 || t3 >= n3.row ? null : n3.data[t3 * n3.col + e12] ?? null, $i$1 = (e12, t3) => {
  for (let n3 = 0; n3 < t3.col; n3++) for (let r3 = 0; r3 < t3.row; r3++) {
    let o3 = oo([n3, r3], t3);
    if (o3 && e12[0] === o3.pos[0] && e12[1] === o3.pos[1]) return o3;
  }
  return null;
}, wp = (e12) => [Math.min(...e12.map((t3) => t3[0])), Math.min(...e12.map((t3) => t3[1])), Math.max(...e12.map((t3) => t3[2])), Math.max(...e12.map((t3) => t3[3]))], cr = (e12, t3) => {
  let n3 = t3.get(e12);
  return n3 && xt(n3) ? n3 : null;
}, In$1 = (e12, t3, n3, r3) => {
  let o3 = e12[0][0], i3 = e12[0][1], a3 = e12.map((s3) => wr(s3, ue(O(e12[0]), -1)));
  return (o3 < -ge || o3 > ge || i3 < -ge || i3 > ge || o3 + a3[a3.length - 1][0] < -ge || i3 + a3[a3.length - 1][0] > ge || o3 + a3[a3.length - 1][1] < -ge || i3 + a3[a3.length - 1][1] > ge) && console.error("Elbow arrow normalization is outside reasonable bounds (> 1e6)", { x: o3, y: i3, points: a3, ...xn(a3) }), a3 = a3.map(([s3, d3]) => u$1(se(s3, -1e6, 1e6), se(d3, -1e6, 1e6))), { points: a3, x: se(o3, -1e6, 1e6), y: se(i3, -1e6, 1e6), fixedSegments: (t3?.length ?? 0) > 0 ? t3 : null, ...xn(a3), startIsSpecial: n3, endIsSpecial: r3 };
}, us = (e12) => {
  if (e12.length > 1) {
    let t3 = Math.abs(e12[0][1] - e12[1][1]) < Math.abs(e12[0][0] - e12[1][0]);
    return e12.filter((n3, r3) => {
      if (r3 === 0 || r3 === e12.length - 1) return true;
      let o3 = e12[r3 + 1], i3 = Math.abs(n3[1] - o3[1]) < Math.abs(n3[0] - o3[0]);
      return t3 === i3 ? (t3 = i3, false) : (t3 = i3, true);
    });
  }
  return e12;
}, ms = (e12) => e12.length >= 4 ? e12.filter((t3, n3) => {
  if (n3 === 0 || n3 === e12.length - 1) return true;
  let r3 = e12[n3 - 1];
  return ie(r3, t3) > Us;
}) : e12, N7 = (e12) => {
  switch (e12) {
    case 0:
      return ze$1;
    case 1:
      return Re;
    case 2:
      return Fe$1;
  }
  return nt;
}, xp$1 = (e12, t3, n3, r3, o3, i3, a3) => {
  if (a3) {
    if (i3) {
      let s3 = fi(e12, i3, t3);
      return s2(i3, s3);
    }
    return r3;
  }
  if (o3) {
    let s3 = Ui(n3 || [0, 0], o3);
    return Math.abs(or$1(o3, s3) - me$1) > 0.01 ? fi(e12, o3, t3) : s3;
  }
  return r3;
}, hp$1 = (e12, t3, n3, r3, o3) => a2(e12, t3, r3, r3 && wt$1(r3, Array(4).fill(or$1(r3, e12))), n3, o3), yp = (e12, t3, n3, r3) => Bn(un(e12), n3, t3, r3, true, true), Ip$1 = (e12, t3) => e12[0] === t3[0] && e12[1] === t3[1], Ni$1 = (e12, t3 = Us) => e12.slice(1).map((n3, r3) => Math.abs(n3[0] - e12[r3][0]) < t3 || Math.abs(n3[1] - e12[r3][1]) < t3).every(Boolean);
var F7 = { selection: true, text: true, rectangle: true, diamond: true, ellipse: true, line: true, image: true, arrow: true, freedraw: true, eraser: false, custom: true, frame: true, embeddable: true, hand: true, laser: false, magicframe: false }, B7 = (e12) => Object.keys(Ie).includes(e12) ? Ie[e12] : Ft, lr = (e12, t3) => {
  if (!t3) return null;
  let n3 = t3.focus || 0;
  return X$1(e12) ? vn$1(t3) ? { ...t3, focus: n3, fixedPoint: Yr(t3.fixedPoint ?? [0, 0]) } : null : { ...t3, focus: n3 };
}, wn$1 = (e12, t3) => {
  let n3 = { type: t3.type || e12.type, version: e12.version || 1, versionNonce: e12.versionNonce ?? 0, index: e12.index ?? null, isDeleted: e12.isDeleted ?? false, id: e12.id || Dt(), fillStyle: e12.fillStyle || we.fillStyle, strokeWidth: e12.strokeWidth || we.strokeWidth, strokeStyle: e12.strokeStyle ?? we.strokeStyle, roughness: e12.roughness ?? we.roughness, opacity: e12.opacity == null ? we.opacity : e12.opacity, angle: e12.angle || 0, x: t3.x ?? e12.x ?? 0, y: t3.y ?? e12.y ?? 0, strokeColor: e12.strokeColor || we.strokeColor, backgroundColor: e12.backgroundColor || we.backgroundColor, width: e12.width || 0, height: e12.height || 0, seed: e12.seed ?? 1, groupIds: e12.groupIds ?? [], frameId: e12.frameId ?? null, roundness: e12.roundness ? e12.roundness : e12.strokeSharpness === "round" ? { type: Oo$1(e12.type) ? ot.LEGACY : ot.PROPORTIONAL_RADIUS } : null, boundElements: e12.boundElementIds ? e12.boundElementIds.map((r3) => ({ type: "arrow", id: r3 })) : e12.boundElements ?? [], updated: e12.updated ?? zt(), link: e12.link ? dn(e12.link) : null, locked: e12.locked ?? false };
  return ("customData" in e12 || "customData" in t3) && (n3.customData = "customData" in t3 ? t3.customData : e12.customData), { ...e12, ...n3, ...bs(n3), ...t3 };
}, _7 = (e12) => {
  switch (e12 = { ...e12 }, e12.type) {
    case "text":
      delete e12.rawText;
      let t3 = e12.fontSize, n3 = e12.fontFamily;
      if ("font" in e12) {
        let [l3, U3] = e12.font.split(" ");
        t3 = parseFloat(l3), n3 = B7(U3);
      }
      let r3 = typeof e12.text == "string" && e12.text || "", o3 = e12.lineHeight || (e12.height ? Md$1(e12) : ko(e12.fontFamily));
      return e12 = wn$1(e12, { fontSize: t3, fontFamily: n3, text: r3, textAlign: e12.textAlign || Vn, verticalAlign: e12.verticalAlign || go, containerId: e12.containerId ?? null, originalText: e12.originalText || r3, autoResize: e12.autoResize ?? true, lineHeight: o3 }), !r3 && !e12.isDeleted && (e12 = { ...e12, originalText: r3, isDeleted: true }, e12 = kr$1(e12)), e12;
    case "freedraw":
      return wn$1(e12, { points: e12.points, lastCommittedPoint: null, simulatePressure: e12.simulatePressure, pressures: e12.pressures });
    case "image":
      return wn$1(e12, { status: e12.status || "pending", fileId: e12.fileId, scale: e12.scale || [1, 1], crop: e12.crop ?? null });
    case "line":
    case "draw":
      let { startArrowhead: i3 = null, endArrowhead: a3 = null } = e12, s3 = e12.x, d3 = e12.y, c3 = !Array.isArray(e12.points) || e12.points.length < 2 ? [u$1(0, 0), u$1(e12.width, e12.height)] : e12.points;
      return (c3[0][0] !== 0 || c3[0][1] !== 0) && ({ points: c3, x: s3, y: d3 } = z$1.getNormalizedPoints(e12)), wn$1(e12, { type: e12.type === "draw" ? "line" : e12.type, startBinding: lr(e12, e12.startBinding), endBinding: lr(e12, e12.endBinding), lastCommittedPoint: null, startArrowhead: i3, endArrowhead: a3, points: c3, x: s3, y: d3, ...xn(c3) });
    case "arrow": {
      let { startArrowhead: l3 = null, endArrowhead: U3 = "arrow" } = e12, p3 = e12.x, m3 = e12.y, b3 = !Array.isArray(e12.points) || e12.points.length < 2 ? [u$1(0, 0), u$1(e12.width, e12.height)] : e12.points;
      (b3[0][0] !== 0 || b3[0][1] !== 0) && ({ points: b3, x: p3, y: m3 } = z$1.getNormalizedPoints(e12));
      let E3 = { type: e12.type, startBinding: lr(e12, e12.startBinding), endBinding: lr(e12, e12.endBinding), lastCommittedPoint: null, startArrowhead: l3, endArrowhead: U3, points: b3, x: p3, y: m3, elbowed: e12.elbowed, ...xn(b3) };
      return X$1(e12) ? wn$1(e12, { ...E3, elbowed: true, startBinding: lr(e12, e12.startBinding), endBinding: lr(e12, e12.endBinding), fixedSegments: e12.fixedSegments, startIsSpecial: e12.startIsSpecial, endIsSpecial: e12.endIsSpecial }) : wn$1(e12, E3);
    }
    case "ellipse":
    case "rectangle":
    case "diamond":
    case "iframe":
    case "embeddable":
      return wn$1(e12, {});
    case "magicframe":
    case "frame":
      return wn$1(e12, { name: e12.name ?? null });
  }
  return null;
}, O7 = (e12, t3) => {
  if (e12.boundElements) {
    let n3 = e12.boundElements.slice(), r3 = /* @__PURE__ */ new Set();
    e12.boundElements = n3.reduce((o3, i3) => {
      let a3 = t3.get(i3.id);
      if (a3 && !r3.has(i3.id)) {
        if (r3.add(i3.id), a3.isDeleted) return o3;
        o3.push(i3), k$2(a3) && !a3.containerId && (a3.containerId = e12.id);
      }
      return o3;
    }, []);
  }
}, A7 = (e12, t3) => {
  let n3 = e12.containerId ? t3.get(e12.containerId) : null;
  if (!n3) {
    e12.containerId = null;
    return;
  }
  if (!e12.isDeleted && n3.boundElements && !n3.boundElements.find((r3) => r3.id === e12.id)) {
    let r3 = (n3.boundElements || (n3.boundElements = [])).slice();
    r3.push({ type: "text", id: e12.id }), n3.boundElements = r3;
  }
}, K7 = (e12, t3) => {
  e12.frameId && (t3.get(e12.frameId) || (e12.frameId = null));
}, Mp$1 = (e12, t3, n3) => {
  let r3 = /* @__PURE__ */ new Set(), o3 = t3 ? te(t3) : null, i3 = An$1((e12 || []).reduce((s3, d3) => {
    if (d3.type !== "selection" && !ao$1(d3)) {
      let c3 = _7(d3);
      if (c3) {
        let l3 = o3?.get(d3.id);
        l3 && l3.version > c3.version && (c3 = kr$1(c3, l3.version)), r3.has(c3.id) && (c3 = { ...c3, id: Dt() }), r3.add(c3.id), s3.push(c3);
      }
    }
    return s3;
  }, []));
  if (!n3?.repairBindings) return i3;
  let a3 = te(i3);
  for (let s3 of i3) s3.frameId && K7(s3, a3), k$2(s3) && s3.containerId ? A7(s3, a3) : s3.boundElements && O7(s3, a3), n3.refreshDimensions && k$2(s3) && Object.assign(s3, Ga$1(s3, qe(s3, a3), a3)), ae(s3) && (s3.startBinding && (!a3.has(s3.startBinding.elementId) || !ee(s3)) && (s3.startBinding = null), s3.endBinding && (!a3.has(s3.endBinding.elementId) || !ee(s3)) && (s3.endBinding = null));
  return i3.map((s3) => {
    if (X$1(s3) && s3.startBinding == null && s3.endBinding == null && !Ni$1(s3.points)) return { ...s3, ...Pi(s3, a3, { points: [u$1(0, 0), s3.points[s3.points.length - 1]] }), index: s3.index };
    if (X$1(s3) && s3.startBinding && s3.endBinding && s3.startBinding.elementId === s3.endBinding.elementId && s3.points.length > 1 && s3.points.some(([d3, c3]) => Math.abs(d3) > 1e6 || Math.abs(c3) > 1e6)) {
      console.error("Fixing self-bound elbow arrow", s3.id);
      let d3 = a3.get(s3.startBinding.elementId);
      return d3 ? { ...s3, x: d3.x + d3.width / 2, y: d3.y - 5, width: d3.width, height: d3.height, points: [u$1(0, 0), u$1(0, -10), u$1(d3.width / 2 + 5, -10), u$1(d3.width / 2 + 5, d3.height / 2 + 5)] } : (console.error("Bound element not found", s3.startBinding.elementId), s3);
    }
    return s3;
  });
}, H7 = (e12, t3, n3) => {
  let r3 = t3[e12];
  return r3 !== void 0 ? r3 : n3[e12];
}, Rp$1 = { isSidebarDocked: (e12, t3) => ["defaultSidebarDockedPreference", e12.isSidebarDocked ?? H7("defaultSidebarDockedPreference", e12, t3)] }, J7 = (e12, t3) => {
  e12 = e12 || {};
  let n3 = mt(), r3 = {};
  for (let o3 of Object.keys(Rp$1)) if (o3 in e12) {
    let [i3, a3] = Rp$1[o3](e12, n3);
    r3[i3] = a3;
  }
  for (let [o3, i3] of Object.entries(n3)) {
    let a3 = e12[o3], s3 = t3 ? t3[o3] : void 0;
    r3[o3] = a3 !== void 0 ? a3 : s3 !== void 0 ? s3 : i3;
  }
  return { ...r3, cursorButton: t3?.cursorButton || "up", penDetected: t3?.penDetected ?? (e12.penMode ? e12.penDetected ?? false : false), activeTool: { ...$r(n3, r3.activeTool.type && F7[r3.activeTool.type] ? r3.activeTool : { type: "selection" }), lastActiveTool: null, locked: r3.activeTool.locked ?? false }, zoom: { value: Oa(Mo$1(e12.zoom) ? e12.zoom : e12.zoom?.value ?? n3.zoom.value) }, openSidebar: typeof e12.openSidebar == "string" ? { name: ks.name } : r3.openSidebar, gridSize: Aa(Mo$1(e12.gridSize) ? e12.gridSize : xo), gridStep: Ka$1(Mo$1(e12.gridStep) ? e12.gridStep : ho), editingFrame: null };
}, io = (e12, t3, n3, r3) => ({ elements: Mp$1(e12?.elements, n3, r3), appState: J7(e12?.appState, t3 || null), files: e12?.files || {} }), Tp = (e12) => {
  let t3 = Mp$1(Es(e12.elements), null);
  return t3.length ? { ...e12, elements: t3 } : null;
}, Lp = (e12 = [], t3) => {
  let n3 = [];
  for (let r3 of e12) if (Array.isArray(r3)) {
    let o3 = Tp({ status: t3, elements: r3, id: Dt(), created: Date.now() });
    o3 && n3.push(o3);
  } else {
    let o3 = r3, i3 = Tp({ ...o3, id: o3.id || Dt(), status: o3.status || t3, created: o3.created || Date.now() });
    i3 && n3.push(i3);
  }
  return n3;
};
var $t = 32, xe = 12, Rn = 256, Sp = 50, Kn = "NOT_SPREADSHEET", Ur$1 = "VALID_SPREADSHEET", so = (e12) => {
  let t3 = /^([-+]?)[$]?([-+]?)([\d.,]+)[%]?$/.exec(e12);
  return t3 ? parseFloat(`${(t3[1] || t3[2]) + t3[3]}`.replace(/,/g, "")) : null;
}, gs = (e12, t3) => e12.slice(1).every((n3) => so(n3[t3]) !== null), Dp = (e12) => {
  let t3 = e12[0].length;
  if (t3 > 2) return { type: Kn, reason: "More than 2 columns" };
  if (t3 === 1) {
    if (!gs(e12, 0)) return { type: Kn, reason: "Value is not numeric" };
    let d3 = so(e12[0][0]) === null, c3 = (d3 ? e12.slice(1) : e12).map((l3) => so(l3[0]));
    return c3.length < 2 ? { type: Kn, reason: "Less than two rows" } : { type: Ur$1, spreadsheet: { title: d3 ? e12[0][0] : null, labels: null, values: c3 } };
  }
  let n3 = gs(e12, 0), r3 = gs(e12, 1);
  if (!n3 && !r3) return { type: Kn, reason: "Value is not numeric" };
  let [o3, i3] = r3 ? [0, 1] : [1, 0], a3 = so(e12[0][i3]) === null, s3 = a3 ? e12.slice(1) : e12;
  return s3.length < 2 ? { type: Kn, reason: "Less than 2 rows" } : { type: Ur$1, spreadsheet: { title: a3 ? e12[0][i3] : null, labels: s3.map((d3) => d3[o3]), values: s3.map((d3) => so(d3[i3])) } };
}, Y7 = (e12) => {
  let t3 = [];
  for (let n3 = 0; n3 < e12[0].length; n3++) {
    let r3 = [];
    for (let o3 = 0; o3 < e12.length; o3++) r3.push(e12[o3][n3]);
    t3.push(r3);
  }
  return t3;
}, vp$1 = (e12) => {
  let t3 = e12.trim().split(`
`).map((i3) => i3.trim().split("	"));
  if (t3.length && t3[0].length !== 2 && (t3 = e12.trim().split(`
`).map((i3) => i3.trim().split(","))), t3.length === 0) return { type: Kn, reason: "No values" };
  let n3 = t3[0].length;
  if (!t3.every((i3) => i3.length === n3)) return { type: Kn, reason: "All rows don't have same number of columns" };
  let o3 = Dp(t3);
  if (o3.type !== Ur$1) {
    let i3 = Dp(Y7(t3));
    if (i3.type === Ur$1) return i3;
  }
  return o3;
}, Fi = Fs(Ps), lt = { fillStyle: "hachure", fontFamily: Ft, fontSize: ut, opacity: 100, roughness: 1, strokeColor: Z.black, roundness: null, strokeStyle: "solid", strokeWidth: 1, verticalAlign: kt.MIDDLE, locked: false }, $p$1 = (e12) => {
  let t3 = ($t + xe) * e12.values.length + xe, n3 = Rn + xe * 2;
  return { chartWidth: t3, chartHeight: n3 };
}, C7 = (e12, t3, n3, r3, o3) => e12.labels?.map((i3, a3) => qt({ groupIds: [r3], backgroundColor: o3, ...lt, text: i3.length > 8 ? `${i3.slice(0, 5)}...` : i3, x: t3 + a3 * ($t + xe) + xe * 2, y: n3 + xe / 2, width: $t, angle: 5.87, fontSize: 16, textAlign: "center", verticalAlign: "top" })) || [], V7 = (e12, t3, n3, r3, o3) => {
  let i3 = qt({ groupIds: [r3], backgroundColor: o3, ...lt, x: t3 - xe, y: n3 - xe, text: "0", textAlign: "right" }), a3 = qt({ groupIds: [r3], backgroundColor: o3, ...lt, x: t3 - xe, y: n3 - Rn - i3.height / 2, text: Math.max(...e12.values).toLocaleString(), textAlign: "right" });
  return [i3, a3];
}, q7 = (e12, t3, n3, r3, o3) => {
  let { chartWidth: i3, chartHeight: a3 } = $p$1(e12), s3 = On({ backgroundColor: o3, groupIds: [r3], ...lt, type: "line", x: t3, y: n3, width: i3, points: [u$1(0, 0), u$1(i3, 0)] }), d3 = On({ backgroundColor: o3, groupIds: [r3], ...lt, type: "line", x: t3, y: n3, height: a3, points: [u$1(0, 0), u$1(0, -a3)] }), c3 = On({ backgroundColor: o3, groupIds: [r3], ...lt, type: "line", x: t3, y: n3 - Rn - xe, strokeStyle: "dotted", width: i3, opacity: Sp, points: [u$1(0, 0), u$1(i3, 0)] });
  return [s3, d3, c3];
}, Pp = (e12, t3, n3, r3, o3, i3) => {
  let { chartWidth: a3, chartHeight: s3 } = $p$1(e12), d3 = e12.title ? qt({ backgroundColor: o3, groupIds: [r3], ...lt, text: e12.title, x: t3 + a3 / 2, y: n3 - Rn - xe * 2 - ut, roundness: null, textAlign: "center" }) : null, c3 = i3 ? Xr({ backgroundColor: o3, groupIds: [r3], ...lt, type: "rectangle", x: t3, y: n3 - s3, width: a3, height: s3, strokeColor: Z.black, fillStyle: "solid", opacity: 6 }) : null;
  return [...c3 ? [c3] : [], ...d3 ? [d3] : [], ...C7(e12, t3, n3, r3, o3), ...V7(e12, t3, n3, r3, o3), ...q7(e12, t3, n3, r3, o3)];
}, X7 = (e12, t3, n3) => {
  let r3 = Math.max(...e12.values), o3 = Dt(), i3 = Fi[Math.floor(Math.random() * Fi.length)];
  return [...e12.values.map((s3, d3) => {
    let c3 = s3 / r3 * Rn;
    return Xr({ backgroundColor: i3, groupIds: [o3], ...lt, type: "rectangle", x: t3 + d3 * ($t + xe) + xe, y: n3 - c3 - xe, width: $t, height: c3 });
  }), ...Pp(e12, t3, n3, o3, i3, c$1.DEV)];
}, G7 = (e12, t3, n3) => {
  let r3 = Math.max(...e12.values), o3 = Dt(), i3 = Fi[Math.floor(Math.random() * Fi.length)], a3 = 0, s3 = [];
  for (let E3 of e12.values) {
    let g3 = a3 * ($t + xe), h3 = -(E3 / r3) * Rn;
    s3.push([g3, h3]), a3++;
  }
  let d3 = Math.max(...s3.map((E3) => E3[0])), c3 = Math.max(...s3.map((E3) => E3[1])), l3 = Math.min(...s3.map((E3) => E3[0])), U3 = Math.min(...s3.map((E3) => E3[1])), p3 = On({ backgroundColor: i3, groupIds: [o3], ...lt, type: "line", x: t3 + xe + $t / 2, y: n3 - xe, height: c3 - U3, width: d3 - l3, strokeWidth: 2, points: s3 }), m3 = e12.values.map((E3, g3) => {
    let h3 = g3 * ($t + xe) + xe / 2, x3 = -(E3 / r3) * Rn + xe / 2;
    return Xr({ backgroundColor: i3, groupIds: [o3], ...lt, fillStyle: "solid", strokeWidth: 2, type: "ellipse", x: t3 + h3 + $t / 2, y: n3 + x3 - xe * 2, width: xe, height: xe });
  }), b3 = e12.values.map((E3, g3) => {
    let h3 = g3 * ($t + xe) + xe / 2, x3 = E3 / r3 * Rn + xe / 2 + xe;
    return On({ backgroundColor: i3, groupIds: [o3], ...lt, type: "line", x: t3 + h3 + $t / 2 + xe / 2, y: n3 - x3, height: x3, strokeStyle: "dotted", opacity: Sp, points: [u$1(0, 0), u$1(0, x3)] });
  });
  return [...Pp(e12, t3, n3, o3, i3, c$1.DEV), p3, ...b3, ...m3];
}, uK = (e12, t3, n3, r3) => e12 === "line" ? G7(t3, n3, r3) : X7(t3, n3, r3);
var k7 = "clipboard" in navigator && "writeText" in navigator.clipboard, LK = "clipboard" in navigator && "write" in navigator.clipboard && "ClipboardItem" in window && "toBlob" in HTMLCanvasElement.prototype, Z7 = (e12) => !!([Ze.excalidraw, Ze.excalidrawClipboard, Ze.excalidrawClipboardWithAPI].includes(e12?.type) && Array.isArray(e12.elements)), DK = ({ types: e12, files: t3 }) => {
  !e12 && !t3 && console.warn("createPasteEvent: no types or files provided");
  let n3 = new ClipboardEvent("paste", { clipboardData: new DataTransfer() });
  if (e12) for (let [r3, o3] of Object.entries(e12)) {
    if (typeof o3 != "string") {
      t3 = t3 || [], t3.push(o3);
      continue;
    }
    try {
      if (n3.clipboardData?.setData(r3, o3), n3.clipboardData?.getData(r3) !== o3) throw new Error(`Failed to set "${r3}" as clipboardData item`);
    } catch (i3) {
      throw new Error(i3.message);
    }
  }
  if (t3) {
    let r3 = -1;
    for (let o3 of t3) {
      r3++;
      try {
        if (n3.clipboardData?.items.add(o3), n3.clipboardData?.files[r3] !== o3) throw new Error(`Failed to set file "${o3.name}" as clipboardData item`);
      } catch (i3) {
        throw new Error(i3.message);
      }
    }
  }
  return n3;
}, W7 = ({ elements: e12, files: t3 }) => {
  let n3 = te(e12), r3 = new Set(e12.filter((s3) => de(s3))), o3 = false, i3 = e12.reduce((s3, d3) => (At(d3) && (o3 = true, t3 && t3[d3.fileId] && (s3[d3.fileId] = t3[d3.fileId])), s3), {});
  o3 && !t3 && console.warn("copyToClipboard: attempting to file element(s) without providing associated `files` object.");
  let a3 = { type: Ze.excalidrawClipboard, elements: e12.map((s3) => {
    if (We(s3, n3) && !r3.has(We(s3, n3))) {
      let d3 = Gr(s3);
      return Y(d3, { frameId: null }), d3;
    }
    return s3;
  }), files: t3 ? i3 : void 0 };
  return JSON.stringify(a3);
}, Np = async (e12, t3, n3) => {
  await hs(W7({ elements: e12, files: t3 }), n3);
}, z7 = (e12) => {
  let t3 = vp$1(e12);
  return t3.type === Ur$1 ? { spreadsheet: t3.spreadsheet } : null;
};
function Fp(e12) {
  let t3 = [];
  for (let n3 of e12.childNodes) if (n3.nodeType === 3) {
    let r3 = n3.textContent?.trim();
    r3 && t3.push({ type: "text", value: r3 });
  } else if (n3 instanceof HTMLImageElement) {
    let r3 = n3.getAttribute("src");
    r3 && r3.startsWith("http") && t3.push({ type: "imageUrl", value: r3 });
  } else t3 = t3.concat(Fp(n3));
  return t3;
}
var Q7 = (e12) => {
  let t3 = e12.clipboardData?.getData(H.html);
  if (!t3) return null;
  try {
    let n3 = new DOMParser().parseFromString(t3, H.html), r3 = Fp(n3.body);
    if (r3.length) return { type: "mixedContent", value: r3 };
  } catch (n3) {
    console.error(`error in parseHTMLFromPaste: ${n3.message}`);
  }
  return null;
}, SK = async () => {
  let e12 = {}, t3;
  try {
    t3 = await navigator.clipboard?.read();
  } catch (n3) {
    try {
      if (navigator.clipboard?.readText) {
        console.warn(`navigator.clipboard.readText() failed (${n3.message}). Failling back to navigator.clipboard.read()`);
        let r3 = await navigator.clipboard?.readText();
        if (r3) return { [H.text]: r3 };
      }
    } catch (r3) {
      if (navigator.clipboard?.read) console.warn(`navigator.clipboard.readText() failed (${r3.message}). Failling back to navigator.clipboard.read()`);
      else {
        if (r3.name === "DataError") return console.warn(`navigator.clipboard.read() error, clipboard is probably empty: ${r3.message}`), e12;
        throw r3;
      }
    }
    throw n3;
  }
  for (let n3 of t3) for (let r3 of n3.types) if (Ed$1(Hs, r3)) try {
    if (r3 === H.text || r3 === H.html) e12[r3] = await (await n3.getType(r3)).text();
    else if (xs(r3)) {
      let o3 = await n3.getType(r3), i3 = fr(o3, r3, void 0);
      e12[r3] = i3;
    } else throw new Br(`Unsupported clipboard type: ${r3}`);
  } catch (o3) {
    console.warn(o3 instanceof Br ? o3.message : `Cannot retrieve ${r3} from clipboardItem: ${o3.message}`);
  }
  return Object.keys(e12).length === 0 && console.warn("No clipboard data found from clipboard.read()."), e12;
}, j7 = async (e12, t3 = false) => {
  try {
    let n3 = !t3 && e12 && Q7(e12);
    return n3 ? n3.value.every((o3) => o3.type === "text") ? { type: "text", value: e12.clipboardData?.getData(H.text) || n3.value.map((o3) => o3.value).join(`
`).trim() } : n3 : { type: "text", value: (e12.clipboardData?.getData(H.text) || "").trim() };
  } catch {
    return { type: "text", value: "" };
  }
}, vK = async (e12, t3 = false) => {
  let n3 = await j7(e12, t3);
  if (n3.type === "mixedContent") return { mixedContent: n3.value };
  try {
    let r3 = !t3 && z7(n3.value);
    if (r3) return r3;
  } catch (r3) {
    console.error(r3);
  }
  try {
    let r3 = JSON.parse(n3.value), o3 = r3.type === Ze.excalidrawClipboardWithAPI;
    if (Z7(r3)) return { elements: r3.elements, files: r3.files, text: t3 ? JSON.stringify(r3.elements, null, 2) : void 0, programmaticAPI: o3 };
  } catch {
  }
  return { text: n3.value };
}, Bp = async (e12) => {
  try {
    await navigator.clipboard.write([new window.ClipboardItem({ [H.png]: e12 })]);
  } catch (t3) {
    if (Fo(e12)) await navigator.clipboard.write([new window.ClipboardItem({ [H.png]: await e12 })]);
    else throw t3;
  }
}, hs = async (e12, t3) => {
  if (k7) try {
    await navigator.clipboard.writeText(e12 || "");
    return;
  } catch (n3) {
    console.error(n3);
  }
  try {
    if (t3) {
      if (t3.clipboardData?.setData(H.text, e12 || ""), t3.clipboardData?.getData(H.text) !== e12) throw new Error("Failed to setData on clipboardEvent");
      return;
    }
  } catch (n3) {
    console.error(n3);
  }
  if (!e9(e12)) throw new Error("Error copying to clipboard.");
}, e9 = (e12) => {
  e12 || (e12 = " ");
  let t3 = document.documentElement.getAttribute("dir") === "rtl", n3 = document.createElement("textarea");
  n3.style.border = "0", n3.style.padding = "0", n3.style.margin = "0", n3.style.position = "absolute", n3.style[t3 ? "right" : "left"] = "-9999px";
  let r3 = window.pageYOffset || document.documentElement.scrollTop;
  n3.style.top = `${r3}px`, n3.style.fontSize = "12pt", n3.setAttribute("readonly", ""), n3.value = e12, document.body.appendChild(n3);
  let o3 = false;
  try {
    n3.select(), n3.setSelectionRange(0, n3.value.length), o3 = document.execCommand("copy");
  } catch (i3) {
    console.error(i3);
  }
  return n3.remove(), o3;
};
var t9 = ({ elements: e12, appState: t3, files: n3, maxWidthOrHeight: r3, getDimensions: o3, exportPadding: i3, exportingFrame: a3 }) => {
  let { elements: s3, appState: d3 } = io({ elements: e12, appState: t3 }, null, null), { exportBackground: c3, viewBackgroundColor: l3 } = d3;
  return pp$1(s3, { ...d3, offsetTop: 0, offsetLeft: 0, width: 0, height: 0 }, n3 || {}, { exportBackground: c3, exportPadding: i3, viewBackgroundColor: l3, exportingFrame: a3 }, (U3, p3) => {
    let m3 = document.createElement("canvas");
    if (r3) {
      typeof o3 == "function" && console.warn("`getDimensions()` is ignored when `maxWidthOrHeight` is supplied.");
      let E3 = Math.max(U3, p3), g3 = r3 < E3 ? r3 / E3 : t3?.exportScale ?? 1;
      return m3.width = U3 * g3, m3.height = p3 * g3, { canvas: m3, scale: g3 };
    }
    let b3 = o3?.(U3, p3) || { width: U3, height: p3 };
    return m3.width = b3.width, m3.height = b3.height, { canvas: m3, scale: b3.scale ?? 1 };
  });
}, n9 = async (e12) => {
  let { mimeType: t3 = H.png, quality: n3 } = e12;
  t3 === H.png && typeof n3 == "number" && console.warn(`"quality" will be ignored for "${H.png}" mimeType`), t3 === "image/jpg" && (t3 = H.jpg), t3 === H.jpg && !e12.appState?.exportBackground && (console.warn(`Defaulting "exportBackground" to "true" for "${H.jpg}" mimeType`), e12 = { ...e12, appState: { ...e12.appState, exportBackground: true } });
  let r3 = await t9(e12);
  return n3 = n3 || (/image\/jpe?g/.test(t3) ? 0.92 : 0.8), new Promise((o3, i3) => {
    r3.toBlob(async (a3) => {
      if (!a3) return i3(new Error("couldn't export to blob"));
      a3 && t3 === H.png && e12.appState?.exportEmbedScene && (a3 = await _p$1({ blob: a3, metadata: to$1(e12.elements, e12.appState, e12.files || {}) })), o3(a3);
    }, t3, n3);
  });
}, r9 = async ({ elements: e12, appState: t3 = mt(), files: n3 = {}, exportPadding: r3, renderEmbeddables: o3, exportingFrame: i3, skipInliningFonts: a3, reuseImages: s3 }) => {
  let { elements: d3, appState: c3 } = io({ elements: e12, appState: t3 }, null, null), l3 = { ...c3, exportPadding: r3 };
  return up$1(d3, l3, n3, { exportingFrame: i3, renderEmbeddables: o3, skipInliningFonts: a3, reuseImages: s3 });
};
var o9 = (e12) => e12.type === "diamond" ? [u$1(e12.width / 2, 0), u$1(e12.width, e12.height / 2), u$1(e12.width / 2, e12.height), u$1(0, e12.height / 2)] : [u$1(0, 0), u$1(0 + e12.width, 0), u$1(0 + e12.width, e12.height), u$1(0, e12.height)], i9 = (e12) => ae(e12) || Ce$1(e12) ? e12.points : o9(e12), Op = (e12) => {
  let t3 = e12.reduce((n3, [r3, o3]) => (n3.minY = Math.min(n3.minY, o3), n3.minX = Math.min(n3.minX, r3), n3.maxX = Math.max(n3.maxX, r3), n3.maxY = Math.max(n3.maxY, o3), n3), { minX: 1 / 0, minY: 1 / 0, maxX: -1 / 0, maxY: -1 / 0, cx: 0, cy: 0 });
  return t3.cx = (t3.maxX + t3.minX) / 2, t3.cy = (t3.maxY + t3.minY) / 2, t3;
}, Kp$1 = (e12) => {
  let t3 = i9(e12), { cx: n3, cy: r3 } = Op(t3), o3 = u$1(n3, r3), i3 = t3.map((l3) => T$1(l3, o3, e12.angle)), { minX: a3, minY: s3, maxX: d3, maxY: c3 } = Op(i3);
  return [a3 + e12.x, s3 + e12.y, d3 + e12.x, c3 + e12.y];
}, a9 = (e12, t3) => {
  let n3 = Kp$1(e12);
  return (Sr$1(n3[0], Oe$1(t3[0], t3[2])) || Sr$1(t3[0], Oe$1(n3[0], n3[2]))) && (Sr$1(n3[1], Oe$1(t3[1], t3[3])) || Sr$1(t3[1], Oe$1(n3[1], n3[3])));
}, Hp$1 = ({ elements: e12, bounds: t3, type: n3, errorMargin: r3 = 0 }) => {
  ra(t3) && (t3 = Ke$1(t3, te(e12)));
  let o3 = [t3[0] - r3, t3[1] - r3, t3[2] + r3, t3[3] + r3], i3 = /* @__PURE__ */ new Set();
  for (let a3 of e12) {
    if (i3.has(a3.id)) continue;
    if (a9(a3, o3)) {
      if (i3.add(a3.id), a3.boundElements) for (let d3 of a3.boundElements) i3.add(d3.id);
      k$2(a3) && a3.containerId && i3.add(a3.containerId), ee(a3) && (a3.startBinding && i3.add(a3.startBinding.elementId), a3.endBinding && i3.add(a3.endBinding?.elementId));
    }
  }
  return e12.filter((a3) => i3.has(a3.id));
};
function Jp$1(e12) {
  return [Math.min(e12[0][0], e12[1][0]), Math.min(e12[0][1], e12[1][1]), Math.max(e12[0][0], e12[1][0]), Math.max(e12[0][1], e12[1][1])];
}
function s9(e12, t3) {
  return e12[0] <= t3[2] && e12[2] >= t3[0] && e12[1] <= t3[3] && e12[3] >= t3[1];
}
var d9 = 1e-6;
function Yp$1(e12, t3) {
  let n3 = O(e12[1], e12[0]), r3 = O(t3, e12[0]), o3 = Me(n3, r3);
  return Math.abs(o3) < d9;
}
function ys(e12, t3) {
  let n3 = O(e12[1], e12[0]), r3 = O(t3, e12[0]);
  return Me(n3, r3) < 0;
}
function Cp$1(e12, t3) {
  return Yp$1(e12, t3[0]) || Yp$1(e12, t3[1]) || (ys(e12, t3[0]) ? !ys(e12, t3[1]) : ys(e12, t3[1]));
}
function Vp$1(e12, t3) {
  return s9(Jp$1(e12), Jp$1(t3)) && Cp$1(e12, t3) && Cp$1(t3, e12);
}
var uH = (e12, t3, n3) => {
  let r3 = te(e12);
  for (let o3 of t3) if (o3.frameId) {
    let i3 = n3.get(o3.id), a3 = n3.get(o3.frameId);
    if (i3) {
      let s3 = r3.get(i3);
      s3 && Y(s3, { frameId: a3 ?? o3.frameId }, false);
    }
  }
};
function Is(e12, t3, n3) {
  let r3 = Sa(t3, n3), o3 = Sa(e12, n3);
  return r3.some((a3) => o3.some((s3) => Vp$1(a3, s3)));
}
var qp$1 = (e12, t3, n3) => _i$1(ui(e12, t3, n3, false)).filter((r3) => !de(r3) && !r3.frameId || r3.frameId === t3.id), ws = (e12, t3, n3) => ui([t3], e12, n3).some((r3) => r3.id === t3.id);
var Bi = (e12, t3, n3) => {
  let [r3, o3, i3, a3] = C$1(t3, n3), [s3, d3, c3, l3] = $e$1(e12);
  return r3 <= s3 && o3 <= d3 && i3 >= c3 && a3 >= l3;
}, hn = (e12, t3, n3) => Bi([e12], t3, n3) || Is(e12, t3, n3) || ws(e12, t3, n3), mH = (e12, t3, n3) => {
  let [r3, o3, i3, a3] = C$1(t3, n3);
  return So(u$1(r3, o3), u$1(e12.x, e12.y), u$1(i3, a3));
};
var bH = (e12) => {
  let t3 = /* @__PURE__ */ new Map();
  for (let n3 of e12) {
    let r3 = de(n3) ? n3.id : n3.frameId;
    r3 && !t3.has(r3) && t3.set(r3, co(e12, r3));
  }
  return t3;
}, co = (e12, t3) => {
  let n3 = [];
  for (let r3 of e12.values()) r3.frameId === t3 && n3.push(r3);
  return n3;
}, ds = (e12) => e12.filter((t3) => de(t3)), cs = (e12) => {
  let t3 = te(ds(e12));
  return e12.filter((n3) => t3.has(n3.id) || !n3.frameId || !t3.has(n3.frameId));
}, EH = (e12, t3, n3, r3) => {
  let o3 = co(e12, t3.id), i3 = new Set(o3), a3 = /* @__PURE__ */ new Set([...qp$1(e12, t3, r3), ...o3.filter((p3) => ws(p3, t3, r3))]), s3 = o3.filter((p3) => !a3.has(p3)), d3 = new Set(Array.from(a3).flatMap((p3) => p3.groupIds));
  for (let p3 of s3) if (!Is(p3, t3, r3)) p3.groupIds.length === 0 && i3.delete(p3);
  else if (p3.groupIds.length > 0) for (let m3 of p3.groupIds) d3.add(m3);
  for (let p3 of s3) if (p3.groupIds.length > 0) {
    let m3 = true;
    for (let b3 of p3.groupIds) d3.has(b3) && (m3 = false);
    m3 && i3.delete(p3);
  }
  let c3 = Array.from(a3).filter((p3) => p3.groupIds.length === 0);
  for (let p3 of c3) i3.add(p3);
  let l3 = Array.from(a3).filter((p3) => p3.groupIds.length > 0), U3 = p2(l3, n3);
  for (let [p3, m3] of Object.entries(U3)) if (m3) {
    let b3 = an(e12, p3);
    if (Bi(b3, t3, r3)) for (let E3 of b3) i3.add(E3);
  }
  return [...i3].filter((p3) => !(k$2(p3) && p3.containerId));
}, gH = (e12, t3, n3) => c9(_i$1(e12, qp$1(e12, t3, n3)), t3, n3), c9 = (e12, t3, n3) => {
  let r3 = [], o3 = /* @__PURE__ */ new Map();
  for (let i3 of e12) {
    let a3 = false;
    if (i3.groupIds.length > 0) {
      if (i3.groupIds.some((s3) => o3.get(s3))) a3 = true;
      else {
        let s3 = new Set(i3.groupIds.flatMap((d3) => an(n3, d3)));
        a3 = !Bi(Array.from(s3), t3, n3);
      }
      i3.groupIds.forEach((s3) => {
        o3.set(s3, a3);
      });
    }
    a3 || r3.push(i3);
  }
  return r3;
}, We = (e12, t3) => e12.frameId && t3.get(e12.frameId) || null, xH = (e12, t3) => {
  let n3 = /* @__PURE__ */ new Set(), r3 = te(e12);
  e12 = _i$1(e12);
  for (let a3 of e12) de(a3) && a3.id !== t3.id && n3.add(a3.id);
  let o3 = /* @__PURE__ */ new Set(), i3 = [];
  for (let a3 of e12) if (!(de(a3) || a3.frameId && n3.has(a3.frameId))) if (a3.groupIds.length) {
    let s3 = a3.groupIds.at(-1);
    if (!o3.has(s3)) {
      o3.add(s3);
      let d3 = an(e12, s3);
      if (d3.some((c3) => hn(c3, t3, r3))) for (let c3 of d3) i3.push(c3);
    }
  } else hn(a3, t3, r3) && i3.push(a3);
  return i3;
}, l9 = (e12, t3, n3, r3) => {
  let o3 = te(e12), i3 = /* @__PURE__ */ new Map();
  for (let c3 of e12.values()) c3.frameId === n3.id && i3.set(c3.id, true);
  let a3 = new Set(t3.map((c3) => c3.id)), s3 = [], d3 = /* @__PURE__ */ new Set();
  for (let c3 of t3) de(c3) && c3.id !== n3.id && d3.add(c3.id);
  for (let c3 of _i$1(e12, t3)) {
    if (de(c3) || c3.frameId && d3.has(c3.frameId) || c3.frameId && r3.selectedElementIds[c3.id] && r3.selectedElementIds[c3.frameId]) continue;
    i3.has(c3.id) || s3.push(c3);
    let l3 = oe(c3, o3);
    l3 && !a3.has(l3.id) && !i3.has(l3.id) && s3.push(l3);
  }
  for (let c3 of s3) Y(c3, { frameId: n3.id }, false);
  return e12;
}, Xp$1 = (e12, t3) => {
  let n3 = /* @__PURE__ */ new Map(), r3 = /* @__PURE__ */ new Map();
  for (let o3 of e12) if (o3.frameId) {
    n3.set(o3.id, o3);
    let i3 = r3.get(o3.frameId) || [];
    i3.push(o3);
    let a3 = oe(o3, t3);
    a3 && (n3.set(a3.id, a3), i3.push(a3)), r3.set(o3.frameId, i3);
  }
  for (let [, o3] of n3) Y(o3, { frameId: null }, false);
}, U9 = (e12, t3) => {
  let n3 = co(e12, t3.id);
  return Xp$1(n3, te(e12)), e12;
}, hH = (e12, t3, n3, r3) => l9(U9(e12, n3), t3, n3, r3.state).slice(), yH = (e12, t3, n3) => {
  let r3 = n3.scene.getSelectedElements({ selectedElementIds: t3.selectedElementIds, elements: e12 }), o3 = new Set(r3);
  if (t3.editingGroupId) for (let s3 of r3) s3.groupIds.length === 0 ? o3.add(s3) : s3.groupIds.flatMap((d3) => an(e12, d3)).forEach((d3) => o3.add(d3));
  let i3 = /* @__PURE__ */ new Set(), a3 = te(e12);
  return o3.forEach((s3) => {
    s3.frameId && !de(s3) && !Gp$1(s3, a3, t3) && i3.add(s3);
  }), i3.size > 0 && Xp$1(i3, a3), e12;
}, _i$1 = (e12, t3) => {
  let n3 = /* @__PURE__ */ new Set(), r3 = t3 || e12;
  for (let a3 of r3.values()) {
    let s3 = a3.groupIds[a3.groupIds.length - 1];
    s3 && n3.add(s3);
  }
  let o3 = /* @__PURE__ */ new Set();
  for (let a3 of n3) an(e12, a3).some((s3) => de(s3)) && o3.add(a3);
  let i3 = [];
  for (let a3 of r3.values()) o3.has(a3.groupIds[a3.groupIds.length - 1]) || i3.push(a3);
  return i3;
}, Mi$1 = (e12, t3, n3) => {
  let r3 = k$2(e12) && qe(e12, t3) || e12;
  return r3.frameId && n3.selectedElementIds[r3.id] && n3.selectedElementIds[r3.frameId] ? We(r3, t3) : n3.selectedElementIds[r3.id] && n3.selectedElementsAreBeingDragged ? n3.frameToHighlight : We(r3, t3);
}, Gp$1 = (e12, t3, n3, r3) => {
  let o3 = r3?.targetFrame ?? Mi$1(e12, t3, n3);
  if (!o3) return false;
  let i3 = k$2(e12) && qe(e12, t3) || e12, a3 = (d3) => {
    r3?.checkedGroups && i3.groupIds.forEach((c3) => {
      r3.checkedGroups?.set(c3, d3);
    });
  };
  if (!n3.selectedElementIds[i3.id] || !n3.selectedElementsAreBeingDragged || n3.selectedElementIds[i3.id] && n3.selectedElementIds[o3.id]) return true;
  if (i3.groupIds.length === 0) return hn(i3, o3, t3);
  for (let d3 of i3.groupIds) if (r3?.checkedGroups?.has(d3)) return r3.checkedGroups.get(d3);
  let s3 = new Set(i3.groupIds.filter((d3) => r3?.checkedGroups ? !r3.checkedGroups.has(d3) : true).flatMap((d3) => an(t3, d3)));
  if (n3.editingGroupId && n3.selectedElementsAreBeingDragged) {
    let d3 = new Set(at$1(t3, n3));
    if (n3.frameToHighlight !== null) return true;
    d3.forEach((l3) => {
      s3.delete(l3);
    });
  }
  for (let d3 of s3) if (de(d3)) return a3(false), false;
  for (let d3 of s3) if (hn(d3, o3, t3)) return a3(true), true;
  return false;
}, as = (e12, t3, n3, r3, o3) => {
  if (!n3.frameRendering || !n3.frameRendering.clip) return false;
  let i3 = Is(e12, t3, r3) || ws(e12, t3, r3);
  if (i3) {
    for (let a3 of e12.groupIds) o3?.set(a3, true);
    return true;
  }
  if (!i3 && e12.groupIds.length > 0 && !Bi([e12], t3, r3)) {
    let a3 = false;
    if (n3.selectedElementsAreBeingDragged) a3 = Gp$1(e12, r3, n3, { targetFrame: t3, checkedGroups: o3 });
    else {
      a3 = e12.frameId === t3.id;
      for (let s3 of e12.groupIds) o3?.set(s3, a3);
    }
    for (let s3 of e12.groupIds) o3?.set(s3, a3);
    return a3;
  }
  return false;
}, bp$1 = (e12) => e12.name === null ? hd$1(e12) ? "Frame" : "AI Frame" : e12.name, Ep = (e12, t3) => Hp$1({ elements: e12, bounds: t3, type: "overlap" }).filter((n3) => !n3.frameId || n3.frameId === t3.id), IH = (e12) => {
  let t3 = te(e12);
  return e12.length > 1 && e12.some((n3) => n3.frameId && t3.has(n3.frameId));
};
var f9 = (e12) => {
  let t3 = /* @__PURE__ */ new Set();
  return e12.forEach((n3) => {
    de(n3) && t3.add(n3.id);
  }), e12.filter((n3) => !(n3.frameId && t3.has(n3.frameId)));
}, ui = (e12, t3, n3, r3 = true) => {
  let [o3, i3, a3, s3] = C$1(t3, n3), d3 = e12.filter((c3) => {
    let [l3, U3, p3, m3] = Ke$1(c3, n3), b3 = We(c3, n3);
    if (b3) {
      let [E3, g3, h3, x3] = Ke$1(b3, n3);
      l3 = Math.max(E3, l3), U3 = Math.max(g3, U3), p3 = Math.min(h3, p3), m3 = Math.min(x3, m3);
    }
    return c3.locked === false && c3.type !== "selection" && !Ne(c3) && o3 <= l3 && i3 <= U3 && a3 >= p3 && s3 >= m3;
  });
  return d3 = r3 ? f9(d3) : d3, d3 = d3.filter((c3) => {
    let l3 = We(c3, n3);
    return l3 ? hn(c3, l3, n3) : true;
  }), d3;
}, Ca = (e12, t3, n3, r3) => {
  let o3 = new Set(t3.map((i3) => i3.id));
  return e12.filter((i3) => {
    let a3 = kp(i3, n3.width, n3.height, n3, r3);
    return !o3.has(i3.id) && a3;
  });
}, Ib = (function() {
  let e12 = null, t3 = null, n3 = null, r3 = (o3, i3) => (n3 != null && o3 === e12 && i3.selectedElementIds === t3 || (n3 = o3.some((a3) => i3.selectedElementIds[a3.id]), e12 = o3, t3 = i3.selectedElementIds), n3);
  return r3.clearCache = () => {
    e12 = null, t3 = null, n3 = null;
  }, r3;
})(), wb = (e12, t3, n3) => {
  let r3 = Array.from(new Set(at$1(e12, t3).map((o3) => n3(o3))));
  return r3.length === 1 ? r3[0] : null;
}, at$1 = (e12, t3, n3) => {
  let r3 = /* @__PURE__ */ new Set(), o3 = [];
  for (let i3 of e12.values()) {
    if (t3.selectedElementIds[i3.id]) {
      o3.push(i3), r3.add(i3.id);
      continue;
    }
    if (n3?.includeBoundTextElement && Ne(i3) && t3.selectedElementIds[i3?.containerId]) {
      o3.push(i3), r3.add(i3.id);
      continue;
    }
  }
  if (n3?.includeElementsInFrames) {
    let i3 = [];
    return o3.forEach((a3) => {
      de(a3) && co(e12, a3.id).forEach((s3) => !r3.has(s3.id) && i3.push(s3)), i3.push(a3);
    }), i3;
  }
  return o3;
}, Rb = (e12, t3) => t3.editingTextElement ? [t3.editingTextElement] : t3.newElement ? [t3.newElement] : at$1(e12, t3, { includeBoundTextElement: true }), Ha$1 = (e12, t3) => Qt(t3.selectedElementIds, e12) ? t3.selectedElementIds : e12;
var Zp$1 = (e12) => {
  let t3 = /* @__PURE__ */ new Map(), n3 = [];
  for (let r3 of e12) r3.isDeleted || (n3.push(r3), t3.set(r3.id, r3));
  return { elementsMap: t3, elements: n3 };
}, u9 = gM((e12) => {
  (c$1.DEV || c$1.MODE === je.TEST || window?.DEBUG_FRACTIONAL_INDICES) && Za$1(e12, { shouldThrow: c$1.DEV || c$1.MODE === je.TEST, includeBoundTextValidation: true });
}, 1e3 * 60, { leading: true, trailing: false }), m9 = (e12) => {
  let t3 = ["includeBoundTextElement", "includeElementsInFrames"], n3 = "";
  for (let r3 of t3) n3 += `${r3}:${e12[r3] ? "1" : "0"}`;
  return n3;
}, Wp$1 = (e12) => typeof e12 == "string", Hn = class Hn2 {
  constructor() {
    i$1(this, "callbacks", /* @__PURE__ */ new Set());
    i$1(this, "nonDeletedElements", []);
    i$1(this, "nonDeletedElementsMap", tt(/* @__PURE__ */ new Map()));
    i$1(this, "elements", []);
    i$1(this, "nonDeletedFramesLikes", []);
    i$1(this, "frames", []);
    i$1(this, "elementsMap", tt(/* @__PURE__ */ new Map()));
    i$1(this, "selectedElementsCache", { selectedElementIds: null, elements: null, cache: /* @__PURE__ */ new Map() });
    i$1(this, "sceneNonce");
    i$1(this, "insertElement", (t3) => {
      let n3 = t3.frameId ? this.getElementIndex(t3.frameId) : this.elements.length;
      this.insertElementAtIndex(t3, n3);
    });
    i$1(this, "insertElements", (t3) => {
      if (!t3.length) return;
      let n3 = t3[0]?.frameId ? this.getElementIndex(t3[0].frameId) : this.elements.length;
      this.insertElementsAtIndex(t3, n3);
    });
    i$1(this, "getContainerElement", (t3) => t3 && t3.containerId && this.getElement(t3.containerId) || null);
    i$1(this, "getElementsFromId", (t3) => {
      let n3 = this.getNonDeletedElementsMap(), r3 = n3.get(t3);
      return r3 ? [r3] : an(n3, t3);
    });
  }
  static mapElementToScene(t3, n3) {
    Wp$1(t3) ? this.sceneMapById.set(t3, n3) : (this.sceneMapByElement.set(t3, n3), this.sceneMapById.set(t3.id, n3));
  }
  static getScene(t3) {
    return Wp$1(t3) ? this.sceneMapById.get(t3) || null : this.sceneMapByElement.get(t3) || null;
  }
  getSceneNonce() {
    return this.sceneNonce;
  }
  getNonDeletedElementsMap() {
    return this.nonDeletedElementsMap;
  }
  getElementsIncludingDeleted() {
    return this.elements;
  }
  getElementsMapIncludingDeleted() {
    return this.elementsMap;
  }
  getNonDeletedElements() {
    return this.nonDeletedElements;
  }
  getFramesIncludingDeleted() {
    return this.frames;
  }
  getSelectedElements(t3) {
    let n3 = m9(t3), r3 = t3?.elements || this.nonDeletedElements;
    if (this.selectedElementsCache.elements === r3 && this.selectedElementsCache.selectedElementIds === t3.selectedElementIds) {
      let i3 = this.selectedElementsCache.cache.get(n3);
      if (i3) return i3;
    } else t3?.elements == null && this.selectedElementsCache.cache.clear();
    let o3 = at$1(r3, { selectedElementIds: t3.selectedElementIds }, t3);
    return t3?.elements == null && (this.selectedElementsCache.selectedElementIds = t3.selectedElementIds, this.selectedElementsCache.elements = this.nonDeletedElements, this.selectedElementsCache.cache.set(n3, o3)), o3;
  }
  getNonDeletedFramesLikes() {
    return this.nonDeletedFramesLikes;
  }
  getElement(t3) {
    return this.elementsMap.get(t3) || null;
  }
  getNonDeletedElement(t3) {
    let n3 = this.getElement(t3);
    return n3 && zp$1(n3) ? n3 : null;
  }
  mapElements(t3) {
    let n3 = false, r3 = this.elements.map((o3) => {
      let i3 = t3(o3);
      return i3 !== o3 && (n3 = true), i3;
    });
    return n3 && this.replaceAllElements(r3), n3;
  }
  replaceAllElements(t3) {
    let n3 = t3 instanceof Array ? t3 : Array.from(t3.values()), r3 = [];
    u9(n3), this.elements = An$1(n3), this.elementsMap.clear(), this.elements.forEach((i3) => {
      de(i3) && r3.push(i3), this.elementsMap.set(i3.id, i3), Hn2.mapElementToScene(i3, this);
    });
    let o3 = Zp$1(this.elements);
    this.nonDeletedElements = o3.elements, this.nonDeletedElementsMap = o3.elementsMap, this.frames = r3, this.nonDeletedFramesLikes = Zp$1(this.frames).elements, this.triggerUpdate();
  }
  triggerUpdate() {
    this.sceneNonce = Vt();
    for (let t3 of Array.from(this.callbacks)) t3();
  }
  onUpdate(t3) {
    if (this.callbacks.has(t3)) throw new Error();
    return this.callbacks.add(t3), () => {
      if (!this.callbacks.has(t3)) throw new Error();
      this.callbacks.delete(t3);
    };
  }
  destroy() {
    this.elements = [], this.nonDeletedElements = [], this.nonDeletedFramesLikes = [], this.frames = [], this.elementsMap.clear(), this.selectedElementsCache.selectedElementIds = null, this.selectedElementsCache.elements = null, this.selectedElementsCache.cache.clear(), Hn2.sceneMapById.forEach((t3, n3) => {
      t3 === this && Hn2.sceneMapById.delete(n3);
    }), this.callbacks.clear();
  }
  insertElementAtIndex(t3, n3) {
    if (!Number.isFinite(n3) || n3 < 0) throw new Error("insertElementAtIndex can only be called with index >= 0");
    let r3 = [...this.elements.slice(0, n3), t3, ...this.elements.slice(n3)];
    Zr(r3, te([t3])), this.replaceAllElements(r3);
  }
  insertElementsAtIndex(t3, n3) {
    if (!t3.length) return;
    if (!Number.isFinite(n3) || n3 < 0) throw new Error("insertElementAtIndex can only be called with index >= 0");
    let r3 = [...this.elements.slice(0, n3), ...t3, ...this.elements.slice(n3)];
    Zr(r3, te(t3)), this.replaceAllElements(r3);
  }
  getElementIndex(t3) {
    return this.elements.findIndex((n3) => n3.id === t3);
  }
};
i$1(Hn, "sceneMapByElement", /* @__PURE__ */ new WeakMap()), i$1(Hn, "sceneMapById", /* @__PURE__ */ new Map());
var Rs = Hn, Ts = Rs;
var Y = (e12, t3, n3 = true, r3) => {
  let o3 = false, { points: i3, fixedSegments: a3, fileId: s3, startBinding: d3, endBinding: c3 } = t3;
  if (X$1(e12) && (Object.keys(t3).length === 0 || typeof i3 < "u" || typeof a3 < "u" || typeof d3 < "u" || typeof c3 < "u")) {
    let l3 = tt(Ts.getScene(e12)?.getNonDeletedElementsMap() ?? /* @__PURE__ */ new Map());
    t3 = { ...t3, angle: 0, ...Pi({ ...e12, x: t3.x || e12.x, y: t3.y || e12.y }, l3, { fixedSegments: a3, points: i3, startBinding: d3, endBinding: c3 }, { isDragging: r3?.isDragging }) };
  } else typeof i3 < "u" && (t3 = { ...xn(i3), ...t3 });
  for (let l3 in t3) {
    let U3 = t3[l3];
    if (typeof U3 < "u") {
      if (e12[l3] === U3 && (typeof U3 != "object" || U3 === null || l3 === "groupIds" || l3 === "scale")) continue;
      if (l3 === "scale") {
        let p3 = e12[l3], m3 = U3;
        if (p3[0] === m3[0] && p3[1] === m3[1]) continue;
      } else if (l3 === "points") {
        let p3 = e12[l3], m3 = U3;
        if (p3.length === m3.length) {
          let b3 = false, E3 = p3.length;
          for (; --E3; ) {
            let g3 = p3[E3], h3 = m3[E3];
            if (g3[0] !== h3[0] || g3[1] !== h3[1]) {
              b3 = true;
              break;
            }
          }
          if (!b3) continue;
        }
      }
      e12[l3] = U3, o3 = true;
    }
  }
  return o3 && ((typeof t3.height < "u" || typeof t3.width < "u" || typeof s3 < "u" || typeof i3 < "u") && he.delete(e12), e12.version++, e12.versionNonce = Vt(), e12.updated = zt(), n3 && Ts.getScene(e12)?.triggerUpdate()), e12;
}, vt$1 = (e12, t3, n3 = false) => {
  let r3 = false;
  for (let o3 in t3) {
    let i3 = t3[o3];
    if (typeof i3 < "u") {
      if (e12[o3] === i3 && (typeof i3 != "object" || i3 === null)) continue;
      r3 = true;
    }
  }
  return !r3 && !n3 ? e12 : { ...e12, ...t3, updated: zt(), version: e12.version + 1, versionNonce: Vt() };
}, kr$1 = (e12, t3) => (e12.version = (t3 ?? e12.version) + 1, e12.versionNonce = Vt(), e12.updated = zt(), e12);
var ao$1 = (e12) => ae(e12) || Ce$1(e12) ? e12.points.length < 2 : e12.width === 0 && e12.height === 0, kp = (e12, t3, n3, r3, o3) => {
  let [i3, a3, s3, d3] = Ke$1(e12, o3), c3 = Dn({ clientX: r3.offsetLeft, clientY: r3.offsetTop }, r3), l3 = Dn({ clientX: r3.offsetLeft + t3, clientY: r3.offsetTop + n3 }, r3);
  return c3.x <= s3 && c3.y <= d3 && l3.x >= i3 && l3.y >= a3;
}, iJ = (e12, t3, n3, r3, o3, i3) => {
  let [a3, s3, d3, c3] = $e$1(e12, o3), l3 = Dn({ clientX: r3.offsetLeft + (i3?.left || 0), clientY: r3.offsetTop + (i3?.top || 0) }, r3), U3 = Dn({ clientX: r3.offsetLeft + t3 - (i3?.right || 0), clientY: r3.offsetTop + n3 - (i3?.bottom || 0) }, r3);
  return a3 >= l3.x && s3 >= l3.y && d3 <= U3.x && c3 <= U3.y;
}, Oi$1 = (e12, t3, n3) => {
  let r3 = Math.abs(t3), o3 = Math.abs(n3);
  if (e12 === "line" || e12 === "arrow" || e12 === "freedraw") {
    let i3 = Math.round(Math.atan(o3 / r3) / Nt) * Nt;
    i3 === 0 ? n3 = 0 : i3 === Math.PI / 2 ? t3 = 0 : n3 = r3 * Math.tan(i3) * Math.sign(n3) || n3;
  } else e12 !== "selection" && (n3 = r3 * Math.sign(n3));
  return { width: t3, height: n3 };
}, Va = (e12, t3, n3, r3) => {
  let o3 = n3 - e12, i3 = r3 - t3, a3 = Math.round(Math.atan(i3 / o3) / Nt) * Nt;
  if (a3 === 0) i3 = 0;
  else if (a3 === Math.PI / 2) o3 = 0;
  else {
    let s3 = Math.tan(a3), d3 = -1, c3 = t3 - s3 * e12, l3 = -1 / s3, U3 = -1, p3 = r3 - l3 * n3, m3 = (d3 * p3 - U3 * c3) / (s3 * U3 - l3 * d3), b3 = (c3 * l3 - p3 * s3) / (s3 * U3 - l3 * d3);
    o3 = m3 - e12, i3 = b3 - t3;
  }
  return { width: o3, height: i3 };
};
var bs = (e12) => {
  let t3 = { width: e12.width, height: e12.height, x: e12.x, y: e12.y };
  if (e12.width < 0) {
    let n3 = Math.abs(e12.width);
    t3.width = n3, t3.x = e12.x - n3;
  }
  if (e12.height < 0) {
    let n3 = Math.abs(e12.height);
    t3.height = n3, t3.y = e12.y - n3;
  }
  return t3;
};
var Qp$1 = { mouse: 8, pen: 16, touch: 28 }, b9 = 16, e62 = { e: true, s: true, n: true, w: true };
var jp$1 = { e: true, s: true, n: true, w: true, nw: true, se: true }, Ms = { e: true, s: true, n: true, w: true }, cn = (e12, t3, n3, r3, o3, i3, a3) => {
  let [s3, d3] = T$1(u$1(e12 + n3 / 2, t3 + r3 / 2), u$1(o3, i3), a3);
  return [s3 - n3 / 2, d3 - r3 / 2, n3, r3];
}, Ai = (e12) => !(e12.viewport.isMobile || e12.isTouchScreen && (Bs || _s)), Ls = (e12) => Ai(e12) ? e62 : {}, Ki$1 = ([e12, t3, n3, r3, o3, i3], a3, s3, d3, c3 = {}, l3 = 4, U3 = br) => {
  let p3 = Qp$1[d3], m3 = p3 / s3.value, b3 = p3 / s3.value, E3 = p3 / s3.value, g3 = p3 / s3.value, h3 = n3 - e12, x3 = r3 - t3, y3 = l3 / s3.value, w3 = (p3 - U3 * 2) / (2 * s3.value), I3 = { nw: c3.nw ? void 0 : cn(e12 - y3 - E3 + w3, t3 - y3 - g3 + w3, m3, b3, o3, i3, a3), ne: c3.ne ? void 0 : cn(n3 + y3 - w3, t3 - y3 - g3 + w3, m3, b3, o3, i3, a3), sw: c3.sw ? void 0 : cn(e12 - y3 - E3 + w3, r3 + y3 - w3, m3, b3, o3, i3, a3), se: c3.se ? void 0 : cn(n3 + y3 - w3, r3 + y3 - w3, m3, b3, o3, i3, a3), rotation: c3.rotation ? void 0 : cn(e12 + h3 / 2 - m3 / 2, t3 - y3 - g3 + w3 - b9 / s3.value, m3, b3, o3, i3, a3) }, S3 = 5 * Qp$1.mouse / s3.value;
  return Math.abs(h3) > S3 && (c3.n || (I3.n = cn(e12 + h3 / 2 - m3 / 2, t3 - y3 - g3 + w3, m3, b3, o3, i3, a3)), c3.s || (I3.s = cn(e12 + h3 / 2 - m3 / 2, r3 + y3 - w3, m3, b3, o3, i3, a3))), Math.abs(x3) > S3 && (c3.w || (I3.w = cn(e12 - y3 - E3 + w3, t3 + x3 / 2 - b3 / 2, m3, b3, o3, i3, a3)), c3.e || (I3.e = cn(n3 + y3 - w3, t3 + x3 / 2 - b3 / 2, m3, b3, o3, i3, a3))), I3;
}, Ds = (e12, t3, n3, r3 = "mouse", o3 = e62) => {
  if (e12.locked || X$1(e12)) return {};
  if (e12.type === "freedraw" || ae(e12)) {
    if (e12.points.length === 2) {
      let [, a3] = e12.points;
      a3[0] === 0 || a3[1] === 0 ? o3 = Ms : a3[0] > 0 && a3[1] < 0 ? o3 = jp$1 : a3[0] > 0 && a3[1] > 0 ? o3 = Ms : a3[0] < 0 && a3[1] > 0 ? o3 = jp$1 : a3[0] < 0 && a3[1] < 0 && (o3 = Ms);
    }
  } else de(e12) && (o3 = { ...o3, rotation: true });
  let i3 = ae(e12) ? br + 8 : Ye$1(e12) ? 0 : br;
  return Ki$1(C$1(e12, n3, true), e12.angle, t3, r3, o3, i3, Ye$1(e12) ? 0 : void 0);
}, fJ = (e12, t3) => {
  if (t3.editingLinearElement) return false;
  if (e12.length > 1) return true;
  let n3 = e12[0];
  return X$1(n3) ? false : ae(n3) ? n3.points.length > 2 : true;
};
var vs = (e12, t3, n3) => t3 >= e12[0] && t3 <= e12[0] + e12[2] && n3 >= e12[1] && n3 <= e12[1] + e12[3], t6 = (e12, t3, n3, r3, o3, i3, a3, s3) => {
  if (!n3.selectedElementIds[e12.id]) return false;
  let { rotation: d3, ...c3 } = Ds(e12, i3, t3, a3, Ls(s3));
  if (d3 && vs(d3, r3, o3)) return "rotation";
  let l3 = Object.keys(c3).filter((U3) => {
    let p3 = c3[U3];
    return p3 ? vs(p3, r3, o3) : false;
  });
  if (l3.length > 0) return l3[0];
  if (Ai(s3)) {
    let [U3, p3, m3, b3, E3, g3] = C$1(e12, t3);
    if (!(ae(e12) && e12.points.length <= 2)) {
      let h3 = Ye$1(e12) ? 0 : Er / i3.value, x3 = Er / i3.value, y3 = n6(u$1(U3 - h3, p3 - h3), u$1(m3 + h3, b3 + h3), u$1(E3, g3), e12.angle);
      for (let [w3, I3] of Object.entries(y3)) if (Bt(u$1(r3, o3), I3, x3)) return w3;
    }
  }
  return false;
}, E9 = (e12, t3, n3, r3, o3, i3, a3, s3) => e12.reduce((d3, c3) => {
  if (d3) return d3;
  let l3 = t6(c3, a3, t3, n3, r3, o3, i3, s3);
  return l3 ? { element: c3, transformHandleType: l3 } : null;
}, null), g9 = ([e12, t3, n3, r3], o3, i3, a3, s3, d3) => {
  let c3 = Ki$1([e12, t3, n3, r3, (e12 + n3) / 2, (t3 + r3) / 2], 0, a3, s3, Ls(d3)), l3 = Object.keys(c3).find((U3) => {
    let p3 = c3[U3];
    return p3 && vs(p3, o3, i3);
  });
  if (l3) return l3;
  if (Ai(d3)) {
    let U3 = (e12 + n3) / 2, p3 = (t3 + r3) / 2, m3 = Er / a3.value, b3 = n6(u$1(e12 - m3, t3 - m3), u$1(n3 + m3, r3 + m3), u$1(U3, p3), 0);
    for (let [E3, g3] of Object.entries(b3)) if (Bt(u$1(o3, i3), g3, m3)) return E3;
  }
  return false;
}, Ss = ["ns", "nesw", "ew", "nwse"], x9 = (e12, t3) => {
  let n3 = Ss.indexOf(e12);
  if (n3 >= 0) {
    let r3 = Math.round(t3 / (Math.PI / 4));
    e12 = Ss[(n3 + r3) % Ss.length];
  }
  return e12;
}, h9 = (e12) => {
  let { element: t3, transformHandleType: n3 } = e12, r3 = t3 && Math.sign(t3.height) * Math.sign(t3.width) === -1, o3 = null;
  switch (n3) {
    case "n":
    case "s":
      o3 = "ns";
      break;
    case "w":
    case "e":
      o3 = "ew";
      break;
    case "nw":
    case "se":
      r3 ? o3 = "nesw" : o3 = "nwse";
      break;
    case "ne":
    case "sw":
      r3 ? o3 = "nwse" : o3 = "nesw";
      break;
    case "rotation":
      return "grab";
  }
  return o3 && t3 && (o3 = x9(o3, t3.angle)), o3 ? `${o3}-resize` : "";
}, n6 = ([e12, t3], [n3, r3], o3, i3) => {
  let a3 = T$1(u$1(e12, t3), o3, i3), s3 = T$1(u$1(n3, t3), o3, i3), d3 = T$1(u$1(e12, r3), o3, i3), c3 = T$1(u$1(n3, r3), o3, i3);
  return { n: [a3, s3], e: [s3, c3], s: [c3, d3], w: [d3, a3] };
};
var y9 = (e12, t3, n3, r3, o3, i3, a3, s3, d3, c3, l3, U3) => {
  if (n3.length === 1) {
    let [p3] = n3;
    if (t3 === "rotation") X$1(p3) || (I9(p3, r3, o3, d3, c3, i3), Jt(p3, r3));
    else {
      if (k$2(p3) && t3) return w9(e12, p3, r3, t3, a3, d3, c3), Jt(p3, r3), true;
      if (t3) {
        let m3 = n3[0].id, b3 = r3.get(m3), E3 = e12.get(m3);
        if (b3 && E3) {
          let { nextWidth: g3, nextHeight: h3 } = v9(b3, E3, r3, e12, t3, d3, c3, { shouldMaintainAspectRatio: s3, shouldResizeFromCenter: a3 });
          S9(g3, h3, b3, E3, r3, e12, t3, { shouldMaintainAspectRatio: s3, shouldResizeFromCenter: a3 });
        }
      }
    }
    return true;
  } else if (n3.length > 1) {
    if (t3 === "rotation") return R9(e12, n3, r3, o3, d3, c3, i3, l3, U3), true;
    if (t3) {
      let { nextWidth: p3, nextHeight: m3, flipByX: b3, flipByY: E3, originalBoundingBox: g3 } = $9(n3, e12, r3, t3, d3, c3, { shouldMaintainAspectRatio: s3, shouldResizeFromCenter: a3 });
      return P9(n3, r3, t3, o3, e12, { shouldResizeFromCenter: a3, shouldMaintainAspectRatio: s3, flipByX: b3, flipByY: E3, nextWidth: p3, nextHeight: m3, originalBoundingBox: g3 }), true;
    }
  }
  return false;
}, I9 = (e12, t3, n3, r3, o3, i3) => {
  let [a3, s3, d3, c3] = C$1(e12, t3), l3 = (a3 + d3) / 2, U3 = (s3 + c3) / 2, p3;
  de(e12) ? p3 = 0 : (p3 = 5 * Math.PI / 2 + Math.atan2(o3 - U3, r3 - l3), i3 && (p3 = p3 + Nt / 2, p3 = p3 - p3 % Nt), p3 = hr(p3));
  let m3 = Yt(e12);
  if (Y(e12, { angle: p3 }), m3) {
    let b3 = n3.getElement(m3);
    b3 && !ee(e12) && Y(b3, { angle: p3 });
  }
}, r6 = (e12, t3, n3, r3) => ae(e12) || Ce$1(e12) ? { points: nr(0, t3, nr(1, n3, e12.points, r3), r3) } : {}, $s$1 = (e12, t3, n3) => {
  let r3 = e12.width;
  if (Ne(e12)) {
    let a3 = qe(e12, t3);
    a3 && (r3 = Tt$1(a3, e12));
  }
  let i3 = e12.fontSize * (n3 / r3);
  return i3 < Eo$1 ? null : { size: i3 };
}, w9 = (e12, t3, n3, r3, o3, i3, a3) => {
  let [s3, d3, c3, l3, U3, p3] = C$1(t3, n3), [m3, b3] = T$1(u$1(i3, a3), u$1(U3, p3), -t3.angle), E3 = 0, g3 = 0;
  r3 !== "e" && r3 !== "w" && (r3.includes("e") && (E3 = (m3 - s3) / (c3 - s3)), r3.includes("w") && (E3 = (c3 - m3) / (c3 - s3)), r3.includes("n") && (g3 = (l3 - b3) / (l3 - d3)), r3.includes("s") && (g3 = (b3 - d3) / (l3 - d3)));
  let h3 = Math.max(E3, g3);
  if (h3 > 0) {
    let x3 = t3.width * h3, y3 = t3.height * h3, w3 = $s$1(t3, n3, x3);
    if (w3 === null) return;
    let I3 = [s3, d3], S3 = [c3, l3], v3 = [U3, p3], D3 = u$1(s3, d3);
    if (["n", "w", "nw"].includes(r3) && (D3 = u$1(S3[0] - Math.abs(x3), S3[1] - Math.abs(y3))), r3 === "ne") {
      let V3 = [I3[0], S3[1]];
      D3 = u$1(V3[0], V3[1] - Math.abs(y3));
    }
    if (r3 === "sw") {
      let V3 = [S3[0], I3[1]];
      D3 = u$1(V3[0] - Math.abs(x3), V3[1]);
    }
    ["s", "n"].includes(r3) && (D3[0] = v3[0] - x3 / 2), ["e", "w"].includes(r3) && (D3[1] = v3[1] - y3 / 2), o3 && (D3[0] = v3[0] - Math.abs(x3) / 2, D3[1] = v3[1] - Math.abs(y3) / 2);
    let $3 = t3.angle, N3 = T$1(D3, u$1(U3, p3), $3), B3 = u$1(D3[0] + Math.abs(x3) / 2, D3[1] + Math.abs(y3) / 2), _3 = T$1(B3, u$1(U3, p3), $3);
    D3 = T$1(N3, _3, -$3);
    let [W, be] = D3;
    Y(t3, { fontSize: w3.size, width: x3, height: y3, x: W, y: be });
  }
  if (r3 === "e" || r3 === "w") {
    let x3 = e12.get(t3.id), [y3, w3, I3, S3] = Rt(x3, x3.width, x3.height, true), v3 = u$1(y3, w3), D3 = u$1(I3, S3), $3 = Zt(v3, D3), N3 = T$1(u$1(i3, a3), $3, -x3.angle), [B3, , _3] = Rt(t3, t3.width, t3.height, true), W = _3 - B3, be = D3[0] - v3[0], V3 = Ko(Ee({ fontSize: t3.fontSize, fontFamily: t3.fontFamily }), t3.lineHeight), ce2 = be / W;
    r3.includes("e") && (ce2 = (N3[0] - v3[0]) / W), r3.includes("w") && (ce2 = (D3[0] - N3[0]) / W);
    let J = t3.width * ce2 < V3 ? V3 : t3.width * ce2, j = en(t3.originalText, Ee(t3), Math.abs(J)), ye = ht(j, Ee(t3), t3.lineHeight), He2 = ye.height, [pr, Jn, Yn, Ji] = Rt(x3, J, He2, true), Uo = Yn - pr, Yi2 = Ji - Jn, Gt2 = [...v3];
    ["n", "w", "nw"].includes(r3) && (Gt2 = [D3[0] - Math.abs(Uo), v3[1]]);
    let ur = x3.angle, Cn2 = T$1(Gt2, $3, ur), Pt2 = u$1(Gt2[0] + Math.abs(Uo) / 2, Gt2[1] + Math.abs(Yi2) / 2), mr = T$1(Pt2, $3, ur);
    Gt2 = T$1(Cn2, mr, -ur);
    let Ut2 = { width: Math.abs(J), height: Math.abs(ye.height), x: Gt2[0], y: Gt2[1], text: j, autoResize: false };
    Y(t3, Ut2);
  }
}, R9 = (e12, t3, n3, r3, o3, i3, a3, s3, d3) => {
  let c3 = 5 * Math.PI / 2 + Math.atan2(i3 - d3, o3 - s3);
  a3 && (c3 += Nt / 2, c3 -= c3 % Nt);
  for (let l3 of t3) if (!de(l3)) {
    let [U3, p3, m3, b3] = C$1(l3, n3), E3 = (U3 + m3) / 2, g3 = (p3 + b3) / 2, h3 = e12.get(l3.id)?.angle ?? l3.angle, [x3, y3] = T$1(u$1(E3, g3), u$1(s3, d3), c3 + h3 - l3.angle);
    X$1(l3) ? Y(l3, { points: U2(l3, n3) }) : Y(l3, { x: l3.x + (x3 - E3), y: l3.y + (y3 - g3), angle: hr(c3 + h3) }, false), Jt(l3, n3, { simultaneouslyUpdated: t3 });
    let w3 = oe(l3, n3);
    w3 && !ee(l3) && Y(w3, { x: w3.x + (x3 - E3), y: w3.y + (y3 - g3), angle: hr(c3 + h3) }, false);
  }
  r3.triggerUpdate();
}, T9 = (e12, t3, n3, r3, o3) => {
  let [i3, a3, s3, d3] = t3.length === 1 ? C$1(t3[0], n3) : $e$1(t3), c3 = (i3 + s3) / 2, l3 = (a3 + d3) / 2, U3 = t3.length === 1 ? t3[0].angle : 0;
  switch ([r3, o3] = T$1(u$1(r3, o3), u$1(c3, l3), -U3), e12) {
    case "n":
      return T$1(u$1(r3 - (i3 + s3) / 2, o3 - a3), u$1(0, 0), U3);
    case "s":
      return T$1(u$1(r3 - (i3 + s3) / 2, o3 - d3), u$1(0, 0), U3);
    case "w":
      return T$1(u$1(r3 - i3, o3 - (a3 + d3) / 2), u$1(0, 0), U3);
    case "e":
      return T$1(u$1(r3 - s3, o3 - (a3 + d3) / 2), u$1(0, 0), U3);
    case "nw":
      return T$1(u$1(r3 - i3, o3 - a3), u$1(0, 0), U3);
    case "ne":
      return T$1(u$1(r3 - s3, o3 - a3), u$1(0, 0), U3);
    case "sw":
      return T$1(u$1(r3 - i3, o3 - d3), u$1(0, 0), U3);
    case "se":
      return T$1(u$1(r3 - s3, o3 - d3), u$1(0, 0), U3);
    default:
      return [0, 0];
  }
}, M9 = (e12, t3) => {
  let [, [n3, r3]] = t3.points;
  return e12 === "nw" && (n3 < 0 || r3 < 0) || e12 === "ne" && n3 >= 0 || e12 === "sw" && n3 <= 0 || e12 === "se" && (n3 > 0 || r3 > 0) ? "end" : "origin";
}, L9 = (e12, t3, n3) => {
  if (n3) return "center";
  if (t3) switch (e12) {
    case "n":
      return "south-side";
    case "e":
      return "west-side";
    case "s":
      return "north-side";
    case "w":
      return "east-side";
    case "ne":
      return "bottom-left";
    case "nw":
      return "bottom-right";
    case "se":
      return "top-left";
    case "sw":
      return "top-right";
  }
  return ["e", "se", "s"].includes(e12) ? "top-left" : ["n", "nw", "w"].includes(e12) ? "bottom-right" : e12 === "ne" ? "bottom-left" : "top-right";
}, D9 = (e12, t3, n3, r3, o3, i3, a3, s3, d3) => {
  let c3 = L9(a3, s3, d3), [l3, U3] = e12;
  switch (c3) {
    case "top-left":
      return { x: l3 + (t3 - r3) / 2 + (r3 - t3) / 2 * Math.cos(i3) + (n3 - o3) / 2 * Math.sin(i3), y: U3 + (n3 - o3) / 2 + (r3 - t3) / 2 * Math.sin(i3) + (o3 - n3) / 2 * Math.cos(i3) };
    case "top-right":
      return { x: l3 + (t3 - r3) / 2 * (Math.cos(i3) + 1) + (n3 - o3) / 2 * Math.sin(i3), y: U3 + (n3 - o3) / 2 + (t3 - r3) / 2 * Math.sin(i3) + (o3 - n3) / 2 * Math.cos(i3) };
    case "bottom-left":
      return { x: l3 + (t3 - r3) / 2 * (1 - Math.cos(i3)) + (o3 - n3) / 2 * Math.sin(i3), y: U3 + (n3 - o3) / 2 * (Math.cos(i3) + 1) + (r3 - t3) / 2 * Math.sin(i3) };
    case "bottom-right":
      return { x: l3 + (t3 - r3) / 2 * (Math.cos(i3) + 1) + (o3 - n3) / 2 * Math.sin(i3), y: U3 + (n3 - o3) / 2 * (Math.cos(i3) + 1) + (t3 - r3) / 2 * Math.sin(i3) };
    case "center":
      return { x: l3 - (r3 - t3) / 2, y: U3 - (o3 - n3) / 2 };
    case "east-side":
      return { x: l3 + (t3 - r3) / 2 * (Math.cos(i3) + 1), y: U3 + (t3 - r3) / 2 * Math.sin(i3) + (n3 - o3) / 2 };
    case "west-side":
      return { x: l3 + (t3 - r3) / 2 * (1 - Math.cos(i3)), y: U3 + (r3 - t3) / 2 * Math.sin(i3) + (n3 - o3) / 2 };
    case "north-side":
      return { x: l3 + (t3 - r3) / 2 + (n3 - o3) / 2 * Math.sin(i3), y: U3 + (o3 - n3) / 2 * (Math.cos(i3) - 1) };
    case "south-side":
      return { x: l3 + (t3 - r3) / 2 + (o3 - n3) / 2 * Math.sin(i3), y: U3 + (n3 - o3) / 2 * (Math.cos(i3) + 1) };
  }
}, S9 = (e12, t3, n3, r3, o3, i3, a3, { shouldInformMutation: s3 = true, shouldMaintainAspectRatio: d3 = false, shouldResizeFromCenter: c3 = false } = {}) => {
  let l3 = {}, U3 = oe(n3, o3);
  if (U3) {
    let E3 = i3.get(U3.id);
    if (E3 && (l3 = { fontSize: E3.fontSize }), d3) {
      let g3 = { ...n3, width: e12 }, h3 = $s$1(U3, o3, Tt$1(g3, U3));
      if (h3 === null) return;
      l3 = { fontSize: h3.size };
    } else {
      let g3 = Td(Ee(U3), U3.lineHeight), h3 = Ld$1(U3.fontSize, U3.lineHeight);
      e12 = Math.max(e12, g3), t3 = Math.max(t3, h3);
    }
  }
  let p3 = r6(r3, e12, t3, true), m3 = u$1(r3.x, r3.y);
  if (ae(r3)) {
    let [E3, g3] = Ke$1(r3, i3);
    m3 = u$1(E3, g3);
  }
  let b3 = D9(m3, r3.width, r3.height, e12, t3, r3.angle, a3, d3, c3);
  if (ae(r3) && p3.points) {
    let E3 = r3.x - m3[0], g3 = r3.y - m3[1];
    b3.x += E3, b3.y += g3;
    let h3 = p3.points[0][0], x3 = p3.points[0][1];
    b3.x += h3, b3.y += x3, p3.points = p3.points.map((y3) => u$1(y3[0] - h3, y3[1] - x3));
  }
  if (e12 < 0 && (b3.x = b3.x + e12), t3 < 0 && (b3.y = b3.y + t3), "scale" in n3 && "scale" in r3 && Y(n3, { scale: [(Math.sign(e12) || r3.scale[0]) * r3.scale[0], (Math.sign(t3) || r3.scale[1]) * r3.scale[1]] }), ee(n3) && U3 && d3) {
    let E3 = e12 / n3.width * U3.fontSize;
    if (E3 < Eo$1) return;
    l3.fontSize = E3;
  }
  if (e12 !== 0 && t3 !== 0 && Number.isFinite(b3.x) && Number.isFinite(b3.y)) {
    let E3 = { ...b3, width: Math.abs(e12), height: Math.abs(t3), ...p3 };
    Y(n3, E3, s3), Jt(n3, o3, { newSize: { width: e12, height: t3 } }), U3 && l3 != null && Y(U3, { fontSize: l3.fontSize }), _n(n3, o3, a3, d3);
  }
}, v9 = (e12, t3, n3, r3, o3, i3, a3, { shouldMaintainAspectRatio: s3 = false, shouldResizeFromCenter: d3 = false } = {}) => {
  let [c3, l3, U3, p3] = Rt(t3, t3.width, t3.height, true), m3 = u$1(c3, l3), b3 = u$1(U3, p3), E3 = Zt(m3, b3), g3 = T$1(u$1(i3, a3), E3, -t3.angle), [h3, x3, y3, w3] = Rt(e12, e12.width, e12.height, true), I3 = y3 - h3, S3 = w3 - x3, v3 = b3[0] - m3[0], D3 = b3[1] - m3[1], $3 = v3 / I3, N3 = D3 / S3;
  o3.includes("e") && ($3 = (g3[0] - m3[0]) / I3), o3.includes("s") && (N3 = (g3[1] - m3[1]) / S3), o3.includes("w") && ($3 = (b3[0] - g3[0]) / I3), o3.includes("n") && (N3 = (b3[1] - g3[1]) / S3);
  let B3 = e12.width * $3, _3 = e12.height * N3;
  if (d3 && (B3 = 2 * B3 - t3.width, _3 = 2 * _3 - t3.height), s3) {
    let W = Math.abs(B3) / t3.width, be = Math.abs(_3) / t3.height;
    if (o3.length === 1 && (_3 *= W, B3 *= be), o3.length === 2) {
      let V3 = Math.max(W, be);
      B3 = t3.width * V3 * Math.sign(B3), _3 = t3.height * V3 * Math.sign(_3);
    }
  }
  return { nextWidth: B3, nextHeight: _3 };
}, $9 = (e12, t3, n3, r3, o3, i3, { shouldMaintainAspectRatio: a3 = false, shouldResizeFromCenter: s3 = false } = {}) => {
  let d3 = e12.map((W) => t3.get(W.id)), c3 = d3.reduce((W, be) => {
    if (!ae(be)) return W;
    let V3 = Yt(be);
    if (!V3) return W;
    let ce2 = t3.get(V3) ?? null;
    return Ne(ce2) ? [...W, { ...ce2, ...z$1.getBoundTextElementPosition(be, ce2, n3) }] : W;
  }, []), l3 = Na$1(d3.map((W) => W).concat(c3)), { minX: U3, minY: p3, maxX: m3, maxY: b3, midX: E3, midY: g3 } = l3, h3 = m3 - U3, x3 = b3 - p3, y3 = { ne: [U3, b3], se: [U3, p3], sw: [m3, p3], nw: [m3, b3], e: [U3, p3 + x3 / 2], w: [m3, p3 + x3 / 2], n: [U3 + h3 / 2, b3], s: [U3 + h3 / 2, p3] }, [w3, I3] = s3 ? [E3, g3] : y3[r3], S3 = s3 ? 2 : 1, v3 = Math.max(Math.abs(o3 - w3) / h3 || 0, Math.abs(i3 - I3) / x3 || 0) * S3, D3 = r3.includes("e") || r3.includes("w") ? Math.abs(o3 - w3) * S3 : h3, $3 = r3.includes("n") || r3.includes("s") ? Math.abs(i3 - I3) * S3 : x3;
  a3 && (D3 = h3 * v3 * Math.sign(o3 - w3), $3 = x3 * v3 * Math.sign(i3 - I3));
  let N3 = { ne: [o3 < w3, i3 > I3], se: [o3 < w3, i3 < I3], sw: [o3 > w3, i3 < I3], nw: [o3 > w3, i3 > I3], e: [o3 < w3, false], w: [o3 > w3, false], n: [false, i3 > I3], s: [false, i3 < I3] }, [B3, _3] = N3[r3].map((W) => W);
  return { originalBoundingBox: l3, nextWidth: D3, nextHeight: $3, flipByX: B3, flipByY: _3 };
}, P9 = (e12, t3, n3, r3, o3, { shouldMaintainAspectRatio: i3 = false, shouldResizeFromCenter: a3 = false, flipByX: s3 = false, flipByY: d3 = false, nextHeight: c3, nextWidth: l3, originalBoundingBox: U3 } = {}) => {
  if (l3 === void 0 && c3 === void 0 && s3 === void 0 && d3 === void 0 || c3 === 0 || l3 === 0) return;
  o3 || (o3 = t3);
  let p3 = e12.reduce((S3, v3) => {
    let D3 = o3.get(v3.id);
    return D3 && S3.push({ orig: D3, latest: v3 }), S3;
  }, []), m3;
  if (U3) m3 = U3;
  else {
    let S3 = p3.reduce((v3, { orig: D3 }) => {
      if (!ae(D3)) return v3;
      let $3 = Yt(D3);
      if (!$3) return v3;
      let N3 = o3.get($3) ?? null;
      return Ne(N3) ? [...v3, { ...N3, ...z$1.getBoundTextElementPosition(D3, N3, t3) }] : v3;
    }, []);
    m3 = Na$1(p3.map(({ orig: v3 }) => v3).concat(S3));
  }
  let { minX: b3, minY: E3, maxX: g3, maxY: h3, midX: x3, midY: y3 } = m3, w3 = g3 - b3, I3 = h3 - E3;
  if (l3 === void 0 && c3 === void 0 && (l3 = w3, c3 = I3), i3 && (l3 === void 0 ? l3 = c3 * (w3 / I3) : c3 === void 0 ? c3 = l3 * (I3 / w3) : Math.abs(l3 / c3 - w3 / I3) > 1e-3 && (l3 = c3 * (w3 / I3))), l3 && c3) {
    let S3 = n3.includes("e") || n3.includes("w") ? Math.abs(l3) / w3 : 1, v3 = n3.includes("n") || n3.includes("s") ? Math.abs(c3) / I3 : 1, D3;
    n3.length === 1 ? D3 = n3.includes("e") || n3.includes("w") ? S3 : v3 : D3 = Math.max(Math.abs(l3) / w3 || 0, Math.abs(c3) / I3 || 0);
    let $3 = { ne: [b3, h3], se: [b3, E3], sw: [g3, E3], nw: [g3, h3], e: [b3, E3 + I3 / 2], w: [g3, E3 + I3 / 2], n: [b3 + w3 / 2, h3], s: [b3 + w3 / 2, E3] }, [N3, B3] = a3 ? [x3, y3] : $3[n3], _3 = i3 || p3.some((J) => J.latest.angle !== 0 || k$2(J.latest) || E2(J.latest));
    _3 && (S3 = D3, v3 = D3);
    let [W, be] = [s3 ? -1 : 1, d3 ? -1 : 1], V3 = [];
    for (let { orig: J, latest: j } of p3) {
      if (k$2(J) && Ne(J)) continue;
      let ye = J.width * S3, He2 = J.height * v3, pr = hr(J.angle * W * be), Jn = ae(J) || Ce$1(J), Yn = J.x - N3, Ji = J.y - B3, Uo = s3 && !Jn ? ye : 0, Yi2 = d3 && !Jn ? He2 : 0, Gt2 = N3 + W * (Yn * S3 + Uo), ur = B3 + be * (Ji * v3 + Yi2), Cn2 = r6(J, ye * W, He2 * be, false), Pt2 = { x: Gt2, y: ur, width: ye, height: He2, angle: pr, ...Cn2 };
      if (X$1(J) && (J.startBinding && (Pt2.startBinding = { ...J.startBinding, fixedPoint: [s3 ? -J.startBinding.fixedPoint[0] + 1 : J.startBinding.fixedPoint[0], d3 ? -J.startBinding.fixedPoint[1] + 1 : J.startBinding.fixedPoint[1]] }), J.endBinding && (Pt2.endBinding = { ...J.endBinding, fixedPoint: [s3 ? -J.endBinding.fixedPoint[0] + 1 : J.endBinding.fixedPoint[0], d3 ? -J.endBinding.fixedPoint[1] + 1 : J.endBinding.fixedPoint[1]] }), J.fixedSegments && Cn2.points && (Pt2.fixedSegments = J.fixedSegments.map((Ut2) => ({ ...Ut2, start: Cn2.points[Ut2.index - 1], end: Cn2.points[Ut2.index] })))), Ye$1(J) && (Pt2.scale = [J.scale[0] * W, J.scale[1] * be]), k$2(J)) {
        let Ut2 = $s$1(J, t3, ye);
        if (!Ut2) return;
        Pt2.fontSize = Ut2.size;
      }
      let mr = o3.get(Yt(J) ?? "");
      if (mr) if (_3) {
        let Ut2 = mr.fontSize * D3;
        if (Ut2 < Eo$1) return;
        Pt2.boundTextFontSize = Ut2;
      } else Pt2.boundTextFontSize = mr.fontSize;
      V3.push({ element: j, update: Pt2 });
    }
    let ce2 = V3.map(({ element: J }) => J);
    for (let { element: J, update: { boundTextFontSize: j, ...ye } } of V3) {
      let { width: He2, height: pr, angle: Jn } = ye;
      Y(J, ye, false, { isDragging: true }), Jt(J, t3, { simultaneouslyUpdated: ce2, newSize: { width: He2, height: pr } });
      let Yn = oe(J, t3);
      Yn && j && (Y(Yn, { fontSize: j, angle: ae(J) ? void 0 : Jn }, false), _n(J, t3, n3, true));
    }
    r3.triggerUpdate();
  }
};
var N9 = (e12, t3, n3, r3, o3, i3) => {
  if (t3.length === 1 && X$1(t3[0]) && (t3[0].startBinding || t3[0].endBinding)) return;
  let a3 = t3.filter((U3) => {
    if (X$1(U3) && U3.startBinding && U3.endBinding) {
      let p3 = t3.find((b3) => b3.id === U3.startBinding?.elementId), m3 = t3.find((b3) => b3.id === U3.endBinding?.elementId);
      return p3 && m3;
    }
    return true;
  }), s3 = new Set(a3), d3 = a3.filter((U3) => de(U3)).map((U3) => U3.id);
  if (d3.length > 0) for (let U3 of r3.getNonDeletedElements()) U3.frameId !== null && d3.includes(U3.frameId) && s3.add(U3);
  let c3 = $e$1(Array.from(s3).map((U3) => e12.originalElements.get(U3.id) ?? U3)), l3 = F9(c3, n3, o3, i3);
  s3.forEach((U3) => {
    if (o6(e12, U3, l3), !ee(U3)) {
      let p3 = oe(U3, r3.getNonDeletedElementsMap());
      p3 && o6(e12, p3, l3), Jt(U3, r3.getElementsMapIncludingDeleted(), { simultaneouslyUpdated: Array.from(s3) });
    }
  });
}, F9 = (e12, t3, n3, r3) => {
  let [o3, i3] = e12, a3 = o3 + t3.x + n3.x, s3 = i3 + t3.y + n3.y;
  if (n3.x === 0 || n3.y === 0) {
    let [d3, c3] = Vr(o3 + t3.x, i3 + t3.y, r3);
    n3.x === 0 && (a3 = d3), n3.y === 0 && (s3 = c3);
  }
  return { x: a3 - o3, y: s3 - i3 };
}, o6 = (e12, t3, n3) => {
  let r3 = e12.originalElements.get(t3.id) ?? t3, o3 = r3.x + n3.x, i3 = r3.y + n3.y;
  Y(t3, { x: o3, y: i3 });
}, B9 = (e12, t3, n3) => {
  let [r3, o3] = $e$1(e12);
  return [t3 - r3, n3 - o3];
}, _9 = ({ newElement: e12, elementType: t3, originX: n3, originY: r3, x: o3, y: i3, width: a3, height: s3, shouldMaintainAspectRatio: d3, shouldResizeFromCenter: c3, zoom: l3, widthAspectRatio: U3 = null, originOffset: p3 = null, informMutation: m3 = true }) => {
  d3 && e12.type !== "selection" && (U3 ? s3 = a3 / U3 : (Math.abs(i3 - r3) > Math.abs(o3 - n3) ? { width: a3, height: s3 } = Oi$1(t3, s3, o3 < n3 ? -a3 : a3) : { width: a3, height: s3 } = Oi$1(t3, a3, i3 < r3 ? -s3 : s3), s3 < 0 && (s3 = -s3)));
  let b3 = o3 < n3 ? n3 - a3 : n3, E3 = i3 < r3 ? r3 - s3 : r3;
  c3 && (a3 += a3, s3 += s3, b3 = n3 - a3 / 2, E3 = r3 - s3 / 2);
  let g3 = null;
  if (k$2(e12)) {
    s3 = e12.height;
    let h3 = Ko(Ee({ fontSize: e12.fontSize, fontFamily: e12.fontFamily }), e12.lineHeight);
    a3 = Math.max(a3, h3), Math.abs(o3 - n3) > Os / l3 && (g3 = { autoResize: false }), E3 = r3, c3 && (b3 = n3 - a3 / 2);
  }
  if (a3 !== 0 && s3 !== 0) {
    let h3 = null;
    Ye$1(e12) && (h3 = { initialWidth: a3, initialHeight: s3 }), Y(e12, { x: b3 + (p3?.x ?? 0), y: E3 + (p3?.y ?? 0), width: a3, height: s3, ...g3, ...h3 }, m3);
  }
};
var O9 = (e12, t3) => !!(!e12.viewModeEnabled && e12.openDialog?.name !== "elementLinkSelector" && (e12.activeTool.type !== "custom" && (e12.editingTextElement || e12.activeTool.type !== "selection" && e12.activeTool.type !== "eraser" && e12.activeTool.type !== "hand" && e12.activeTool.type !== "laser") || at$1(t3, e12).length));
var X2 = (e12) => {
  let t3 = 5381;
  for (let n3 = 0; n3 < e12.length; n3++) {
    let r3 = e12.charCodeAt(n3);
    t3 = (t3 << 5) + t3 + r3;
  }
  return t3 >>> 0;
}, f2 = (e12) => e12.filter((t3) => !t3.isDeleted && !ao$1(t3)), Es = (e12) => e12.filter((t3) => !t3.isDeleted), zp$1 = (e12) => !e12.isDeleted, i6 = (e12) => Es(e12).map((t3) => na(t3.type) ? { ...t3, lastCommittedPoint: null } : t3), Ri = (e12) => i6(e12);
var s6 = async (e12) => {
  let t3;
  if (e12.type === H.png) try {
    return await (await __vitePreload(async () => {
      const { decodePngMetadata } = await Promise.resolve().then(() => image7KUKJ7J4);
      return { decodePngMetadata };
    }, true ? void 0 : void 0, import.meta.url)).decodePngMetadata(e12);
  } catch (n3) {
    throw n3.message === "INVALID" ? new nn("Image doesn't contain scene", "IMAGE_NOT_CONTAINS_SCENE_DATA") : new nn("Error: cannot restore image");
  }
  else if ("text" in Blob ? t3 = await e12.text() : t3 = await new Promise((n3) => {
    let r3 = new FileReader();
    r3.readAsText(e12, "utf8"), r3.onloadend = () => {
      r3.readyState === FileReader.DONE && n3(r3.result);
    };
  }), e12.type === H.svg) try {
    return mp({ svg: t3 });
  } catch (n3) {
    throw n3.message === "INVALID" ? new nn("Image doesn't contain scene", "IMAGE_NOT_CONTAINS_SCENE_DATA") : new nn("Error: cannot restore image");
  }
  return t3;
};
var K9 = (e12) => e12 && e12.name.match(/\.(json|excalidraw|png|svg)$/)?.[1] || null, DY = (e12) => e12 === "png" || e12 === "svg", W2 = (e12) => {
  let t3 = K9(e12);
  return t3 === "png" || t3 === "svg";
}, xs = (e12) => !!e12 && Object.values(yo).includes(e12), Hi$1 = (e12) => {
  let { type: t3 } = e12 || {};
  return xs(t3);
}, H9 = async (e12, t3, n3, r3) => {
  let o3 = await s6(e12), i3;
  try {
    try {
      i3 = JSON.parse(o3);
    } catch (a3) {
      throw Hi$1(e12) ? new nn("Image doesn't contain scene", "IMAGE_NOT_CONTAINS_SCENE_DATA") : a3;
    }
    if (Q2(i3)) return { type: H.excalidraw, data: io({ elements: Ri(i3.elements || []), appState: { theme: t3?.theme, fileHandle: r3 || e12.handle || null, ...Ro(i3.appState || {}), ...t3 ? _a$1(i3.elements || [], t3) : {} }, files: i3.files }, t3, n3, { repairBindings: true, refreshDimensions: false }) };
    if (ns(i3)) return { type: H.excalidrawlib, data: i3 };
    throw new Error("Error: invalid file");
  } catch (a3) {
    throw a3 instanceof nn ? a3 : new Error("Error: invalid file");
  }
}, z2$1 = async (e12, t3, n3, r3) => {
  let o3 = await H9(e12, t3, n3, r3);
  if (o3.type !== H.excalidraw) throw new Error("Error: invalid file");
  return o3.data;
}, J9 = (e12, t3 = "unpublished") => {
  let n3 = JSON.parse(e12);
  if (!ns(n3)) throw new Error("Invalid library");
  let r3 = n3.libraryItems || n3.library;
  return Lp(r3, t3);
}, SY = async (e12, t3 = "unpublished") => J9(await s6(e12), t3), vY = async (e12) => new Promise(async (t3, n3) => {
  try {
    Fo(e12) && (e12 = await e12), e12.toBlob((r3) => {
      if (!r3) return n3(new Yo("Error: Canvas too big", "CANVAS_POSSIBLY_TOO_BIG"));
      t3(r3);
    });
  } catch (r3) {
    n3(r3);
  }
}), $Y = async (e12) => {
  try {
    let t3 = await window.crypto.subtle.digest("SHA-1", await ln(e12));
    return md$1(new Uint8Array(t3));
  } catch (t3) {
    return console.error(t3), nanoid(40);
  }
}, PY = async (e12) => new Promise((t3, n3) => {
  let r3 = new FileReader();
  r3.onload = () => {
    let o3 = r3.result;
    t3(o3);
  }, r3.onerror = (o3) => n3(o3), r3.readAsDataURL(e12);
}), NY = (e12, t3) => `data:${t3};base64,${Li$1(lo$1(e12), true)}`, FY = (e12, t3 = "") => {
  let n3 = e12.indexOf(","), r3 = atob(e12.slice(n3 + 1)), o3 = e12.slice(0, n3).split(":")[1].split(";")[0], i3 = new ArrayBuffer(r3.length), a3 = new Uint8Array(i3);
  for (let s3 = 0; s3 < r3.length; s3++) a3[s3] = r3.charCodeAt(s3);
  return new File([i3], t3, { type: o3 });
}, BY = (e12) => Di$1(e12.slice(e12.indexOf(",") + 1)), _Y = async (e12, t3) => {
  if (e12.type === H.svg) return e12;
  let [n3, r3] = await Promise.all([__vitePreload(() => import("./pica-BBRUF1vY.js").then((n8) => n8.p), true ? __vite__mapDeps([2,3]) : void 0, import.meta.url).then((i3) => i3.default), __vitePreload(() => import("./image-blob-reduce.esm-BJZXdeib.js"), true ? [] : void 0, import.meta.url).then((i3) => i3.default)]), o3 = r3({ pica: n3({ features: ["js", "wasm"] }) });
  if (t3.outputType) {
    let { outputType: i3 } = t3;
    o3._create_blob = function(a3) {
      return this.pica.toBlob(a3.out_canvas, i3, 0.8).then((s3) => (a3.out_blob = s3, a3));
    };
  }
  if (!Hi$1(e12)) throw new Error("Error: unsupported file type", { cause: "UNSUPPORTED" });
  return new File([await o3.toBlob(e12, { max: t3.maxWidthOrHeight, alpha: true })], e12.name, { type: t3.outputType || e12.type });
}, OY = (e12, t3 = "") => new File([new TextEncoder().encode(e12)], t3, { type: H.svg }), AY = async (e12, t3 = "") => {
  let n3;
  try {
    n3 = await fetch(e12);
  } catch {
    throw new Error("Error: failed to fetch image", { cause: "FETCH_ERROR" });
  }
  if (!n3.ok) throw new Error("Error: failed to fetch image", { cause: "FETCH_ERROR" });
  let r3 = await n3.blob();
  if (r3.type && Hi$1(r3)) {
    let o3 = t3 || r3.name || "";
    return new File([r3], o3, { type: r3.type });
  }
  throw new Error("Error: unsupported file type", { cause: "UNSUPPORTED" });
}, KY = async (e12) => {
  let t3 = e12.dataTransfer.files.item(0), n3 = await Y9(e12);
  return { file: t3 ? await ts(t3) : null, fileHandle: n3 };
}, Y9 = async (e$12) => {
  if (e) try {
    return await e$12.dataTransfer.items[0].getAsFileSystemHandle() || null;
  } catch (t3) {
    return console.warn(t3.name, t3.message), null;
  }
  return null;
}, a6 = (e12) => {
  let t3 = null, n3 = `${[...new Uint8Array(e12).slice(0, 8)].join(" ")} `, r3 = { png: "137 80 78 71 13 10 26 10 ", jpg: "255 216 255 ", gif: "71 73 70 56 57 97 " };
  return n3 === r3.png ? t3 = H.png : n3.startsWith(r3.jpg) ? t3 = H.jpg : n3.startsWith(r3.gif) && (t3 = H.gif), t3;
}, fr = (e12, t3, n3) => new File([e12], n3 || "", { type: t3 }), ts = async (e12) => {
  if (e12.type) {
    if (Hi$1(e12)) {
      let t3 = await ln(e12), n3 = a6(t3);
      n3 && n3 !== e12.type && (e12 = fr(t3, n3, e12.name));
    }
  } else if (e12?.name?.endsWith(".excalidrawlib")) e12 = fr(await ln(e12), H.excalidrawlib, e12.name);
  else if (e12?.name?.endsWith(".excalidraw")) e12 = fr(await ln(e12), H.excalidraw, e12.name);
  else {
    let t3 = await ln(e12), n3 = a6(t3);
    n3 && (e12 = fr(t3, n3, e12.name));
  }
  return e12;
}, ln = (e12) => "arrayBuffer" in e12 ? e12.arrayBuffer() : new Promise((t3, n3) => {
  let r3 = new FileReader();
  r3.onload = (o3) => {
    if (!o3.target?.result) return n3(new Error("Couldn't convert blob to ArrayBuffer"));
    t3(o3.target.result);
  }, r3.readAsArrayBuffer(e12);
});
var lo$1 = (e12) => {
  let t3 = typeof e12 == "string" ? new TextEncoder().encode(e12) : e12 instanceof Uint8Array ? e12 : new Uint8Array(e12), n3 = "";
  for (let r3 of t3) n3 += String.fromCharCode(r3);
  return n3;
}, d6 = (e12) => {
  let t3 = new ArrayBuffer(e12.length), n3 = new Uint8Array(t3);
  for (let r3 = 0, o3 = e12.length; r3 < o3; r3++) n3[r3] = e12.charCodeAt(r3);
  return t3;
}, c6 = (e12) => new TextDecoder("utf-8").decode(d6(e12)), Li$1 = (e12, t3 = false) => t3 ? window.btoa(e12) : window.btoa(lo$1(e12)), Di$1 = (e12, t3 = false) => t3 ? window.atob(e12) : c6(window.atob(e12));
var Si$1 = ({ text: e12, compress: t3 }) => {
  let n3;
  if (t3 !== false) try {
    n3 = lo$1(deflate_1$2(e12));
  } catch (r3) {
    console.error("encode: cannot deflate", r3);
  }
  return { version: "1", encoding: "bstring", compressed: !!n3, encoded: n3 || lo$1(e12) };
}, vi$1 = (e12) => {
  let t3;
  switch (e12.encoding) {
    case "bstring":
      t3 = e12.compressed ? e12.encoded : c6(e12.encoded);
      break;
    default:
      throw new Error(`decode: unknown encoding "${e12.encoding}"`);
  }
  return e12.compressed ? inflate_1$2(new Uint8Array(d6(t3)), { to: "string" }) : t3;
};
var X9 = async (e12) => {
  let n3 = l6(new Uint8Array(await ln(e12))).find((r3) => r3.name === "tEXt");
  return n3 ? U6.decode(n3.data) : null;
}, _p$1 = async ({ blob: e12, metadata: t3 }) => {
  let n3 = l6(new Uint8Array(await ln(e12))), r3 = U6.encode(H.excalidraw, JSON.stringify(Si$1({ text: t3, compress: true })));
  return n3.splice(-1, 0, r3), new Blob([q9(n3)], { type: H.png });
}, iC$1 = async (e12) => {
  let t3 = await X9(e12);
  if (t3?.keyword === H.excalidraw) try {
    let n3 = JSON.parse(t3.text);
    if (!("encoded" in n3)) {
      if ("type" in n3 && n3.type === Ze.excalidraw) return t3.text;
      throw new Error("FAILED");
    }
    return vi$1(n3);
  } catch (n3) {
    throw console.error(n3), new Error("FAILED");
  }
  throw new Error("INVALID");
};
var t = { paste: "Paste", pasteAsPlaintext: "Paste as plaintext", pasteCharts: "Paste charts", selectAll: "Select all", multiSelect: "Add element to selection", moveCanvas: "Move canvas", cut: "Cut", copy: "Copy", copyAsPng: "Copy to clipboard as PNG", copyAsSvg: "Copy to clipboard as SVG", copyText: "Copy to clipboard as text", copySource: "Copy source to clipboard", convertToCode: "Convert to code", bringForward: "Bring forward", sendToBack: "Send to back", bringToFront: "Bring to front", sendBackward: "Send backward", delete: "Delete", copyStyles: "Copy styles", pasteStyles: "Paste styles", stroke: "Stroke", changeStroke: "Change stroke color", background: "Background", changeBackground: "Change background color", fill: "Fill", strokeWidth: "Stroke width", strokeStyle: "Stroke style", strokeStyle_solid: "Solid", strokeStyle_dashed: "Dashed", strokeStyle_dotted: "Dotted", sloppiness: "Sloppiness", opacity: "Opacity", textAlign: "Text align", edges: "Edges", sharp: "Sharp", round: "Round", arrowheads: "Arrowheads", arrowhead_none: "None", arrowhead_arrow: "Arrow", arrowhead_bar: "Bar", arrowhead_circle: "Circle", arrowhead_circle_outline: "Circle (outline)", arrowhead_triangle: "Triangle", arrowhead_triangle_outline: "Triangle (outline)", arrowhead_diamond: "Diamond", arrowhead_diamond_outline: "Diamond (outline)", arrowhead_crowfoot_many: "Crow's foot (many)", arrowhead_crowfoot_one: "Crow's foot (one)", arrowhead_crowfoot_one_or_many: "Crow's foot (one or many)", more_options: "More options", arrowtypes: "Arrow type", arrowtype_sharp: "Sharp arrow", arrowtype_round: "Curved arrow", arrowtype_elbowed: "Elbow arrow", fontSize: "Font size", fontFamily: "Font family", addWatermark: 'Add "Made with Excalidraw"', handDrawn: "Hand-drawn", normal: "Normal", code: "Code", small: "Small", medium: "Medium", large: "Large", veryLarge: "Very large", solid: "Solid", hachure: "Hachure", zigzag: "Zigzag", crossHatch: "Cross-hatch", thin: "Thin", bold: "Bold", left: "Left", center: "Center", right: "Right", extraBold: "Extra bold", architect: "Architect", artist: "Artist", cartoonist: "Cartoonist", fileTitle: "File name", colorPicker: "Color picker", canvasColors: "Used on canvas", canvasBackground: "Canvas background", drawingCanvas: "Drawing canvas", clearCanvas: "Clear canvas", layers: "Layers", actions: "Actions", language: "Language", liveCollaboration: "Live collaboration...", duplicateSelection: "Duplicate", untitled: "Untitled", name: "Name", yourName: "Your name", madeWithExcalidraw: "Made with Excalidraw", group: "Group selection", ungroup: "Ungroup selection", collaborators: "Collaborators", toggleGrid: "Toggle grid", addToLibrary: "Add to library", removeFromLibrary: "Remove from library", libraryLoadingMessage: "Loading library", libraries: "Browse libraries", loadingScene: "Loading scene", loadScene: "Load scene from file", align: "Align", alignTop: "Align top", alignBottom: "Align bottom", alignLeft: "Align left", alignRight: "Align right", centerVertically: "Center vertically", centerHorizontally: "Center horizontally", distributeHorizontally: "Distribute horizontally", distributeVertically: "Distribute vertically", flipHorizontal: "Flip horizontal", flipVertical: "Flip vertical", viewMode: "View mode", share: "Share", showStroke: "Show stroke color picker", showBackground: "Show background color picker", showFonts: "Show font picker", toggleTheme: "Toggle light/dark theme", theme: "Theme", personalLib: "Personal Library", excalidrawLib: "Excalidraw Library", decreaseFontSize: "Decrease font size", increaseFontSize: "Increase font size", unbindText: "Unbind text", bindText: "Bind text to the container", createContainerFromText: "Wrap text in a container", link: { edit: "Edit link", editEmbed: "Edit embeddable link", create: "Add link", label: "Link", labelEmbed: "Link & embed", empty: "No link is set", hint: "Type or paste your link here", goToElement: "Go to target element" }, lineEditor: { edit: "Edit line", editArrow: "Edit arrow" }, elementLock: { lock: "Lock", unlock: "Unlock", lockAll: "Lock all", unlockAll: "Unlock all" }, statusPublished: "Published", sidebarLock: "Keep sidebar open", selectAllElementsInFrame: "Select all elements in frame", removeAllElementsFromFrame: "Remove all elements from frame", eyeDropper: "Pick color from canvas", textToDiagram: "Text to diagram", prompt: "Prompt", followUs: "Follow us", discordChat: "Discord chat", zoomToFitViewport: "Zoom to fit in viewport", zoomToFitSelection: "Zoom to fit selection", zoomToFit: "Zoom to fit all elements", installPWA: "Install Excalidraw locally (PWA)", autoResize: "Enable text auto-resizing", imageCropping: "Image cropping", unCroppedDimension: "Uncropped dimension", copyElementLink: "Copy link to object", linkToElement: "Link to object", wrapSelectionInFrame: "Wrap selection in frame" }, r = { title: "Link to object", desc: "Click on a shape on canvas or paste a link.", notFound: "Linked object wasn't found on canvas." }, a = { noItems: "No items added yet...", hint_emptyLibrary: "Select an item on canvas to add it here, or install a library from the public repository, below.", hint_emptyPrivateLibrary: "Select an item on canvas to add it here." }, i = { title: "Find on canvas", noMatch: "No matches found...", singleResult: "result", multipleResults: "results", placeholder: "Find text on canvas..." }, n = { clearReset: "Reset the canvas", exportJSON: "Export to file", exportImage: "Export image...", export: "Save to...", copyToClipboard: "Copy to clipboard", copyLink: "Copy link", save: "Save to current file", saveAs: "Save as", load: "Open", getShareableLink: "Get shareable link", close: "Close", selectLanguage: "Select language", scrollBackToContent: "Scroll back to content", zoomIn: "Zoom in", zoomOut: "Zoom out", resetZoom: "Reset zoom", menu: "Menu", done: "Done", edit: "Edit", undo: "Undo", redo: "Redo", resetLibrary: "Reset library", createNewRoom: "Create new room", fullScreen: "Full screen", darkMode: "Dark mode", lightMode: "Light mode", systemMode: "System mode", zenMode: "Zen mode", objectsSnapMode: "Snap to objects", exitZenMode: "Exit zen mode", cancel: "Cancel", clear: "Clear", remove: "Remove", embed: "Toggle embedding", publishLibrary: "Publish", submit: "Submit", confirm: "Confirm", embeddableInteractionButton: "Click to interact" }, l = { clearReset: "This will clear the whole canvas. Are you sure?", couldNotCreateShareableLink: "Couldn't create shareable link.", couldNotCreateShareableLinkTooBig: "Couldn't create shareable link: the scene is too big", couldNotLoadInvalidFile: "Couldn't load invalid file", importBackendFailed: "Importing from backend failed.", cannotExportEmptyCanvas: "Cannot export empty canvas.", couldNotCopyToClipboard: "Couldn't copy to clipboard.", decryptFailed: "Couldn't decrypt data.", uploadedSecurly: "The upload has been secured with end-to-end encryption, which means that Excalidraw server and third parties can't read the content.", loadSceneOverridePrompt: "Loading external drawing will replace your existing content. Do you wish to continue?", collabStopOverridePrompt: `Stopping the session will overwrite your previous, locally stored drawing. Are you sure?

(If you want to keep your local drawing, simply close the browser tab instead.)`, errorAddingToLibrary: "Couldn't add item to the library", errorRemovingFromLibrary: "Couldn't remove item from the library", confirmAddLibrary: "This will add {{numShapes}} shape(s) to your library. Are you sure?", imageDoesNotContainScene: "This image does not seem to contain any scene data. Have you enabled scene embedding during export?", cannotRestoreFromImage: "Scene couldn't be restored from this image file", invalidSceneUrl: "Couldn't import scene from the supplied URL. It's either malformed, or doesn't contain valid Excalidraw JSON data.", resetLibrary: "This will clear your library. Are you sure?", removeItemsFromsLibrary: "Delete {{count}} item(s) from library?", invalidEncryptionKey: "Encryption key must be of 22 characters. Live collaboration is disabled.", collabOfflineWarning: `No internet connection available.
Your changes will not be saved!` }, s = { unsupportedFileType: "Unsupported file type.", imageInsertError: "Couldn't insert image. Try again later...", fileTooBig: "File is too big. Maximum allowed size is {{maxSize}}.", svgImageInsertError: "Couldn't insert SVG image. The SVG markup looks invalid.", failedToFetchImage: "Failed to fetch image.", cannotResolveCollabServer: "Couldn't connect to the collab server. Please reload the page and try again.", importLibraryError: "Couldn't load library", saveLibraryError: "Couldn't save library to storage. Please save your library to a file locally to make sure you don't lose changes.", collabSaveFailed: "Couldn't save to the backend database. If problems persist, you should save your file locally to ensure you don't lose your work.", collabSaveFailed_sizeExceeded: "Couldn't save to the backend database, the canvas seems to be too big. You should save the file locally to ensure you don't lose your work.", imageToolNotSupported: "Images are disabled.", brave_measure_text_error: { line1: "Looks like you are using Brave browser with the <bold>Aggressively Block Fingerprinting</bold> setting enabled.", line2: "This could result in breaking the <bold>Text Elements</bold> in your drawings.", line3: "We strongly recommend disabling this setting. You can follow <link>these steps</link> on how to do so.", line4: "If disabling this setting doesn't fix the display of text elements, please open an <issueLink>issue</issueLink> on our GitHub, or write us on <discordLink>Discord</discordLink>" }, libraryElementTypeError: { embeddable: "Embeddable elements cannot be added to the library.", iframe: "IFrame elements cannot be added to the library.", image: "Support for adding images to the library coming soon!" }, asyncPasteFailedOnRead: "Couldn't paste (couldn't read from system clipboard).", asyncPasteFailedOnParse: "Couldn't paste.", copyToSystemClipboardFailed: "Couldn't copy to clipboard." }, d = { selection: "Selection", image: "Insert image", rectangle: "Rectangle", diamond: "Diamond", ellipse: "Ellipse", arrow: "Arrow", line: "Line", freedraw: "Draw", text: "Text", library: "Library", lock: "Keep selected tool active after drawing", penMode: "Pen mode - prevent touch", link: "Add / Update link for a selected shape", eraser: "Eraser", frame: "Frame tool", magicframe: "Wireframe to code", embeddable: "Web Embed", laser: "Laser pointer", hand: "Hand (panning tool)", extraTools: "More tools", mermaidToExcalidraw: "Mermaid to Excalidraw" }, c = { rectangle: "Rectangle", diamond: "Diamond", ellipse: "Ellipse", arrow: "Arrow", line: "Line", freedraw: "Freedraw", text: "Text", image: "Image", group: "Group", frame: "Frame", magicframe: "Wireframe to code", embeddable: "Web Embed", selection: "Selection", iframe: "IFrame" }, p = { canvasActions: "Canvas actions", selectedShapeActions: "Selected shape actions", shapes: "Shapes" }, m = { dismissSearch: "Escape to dismiss search", canvasPanning: "To move canvas, hold mouse wheel or spacebar while dragging, or use the hand tool", linearElement: "Click to start multiple points, drag for single line", arrowTool: "Click to start multiple points, drag for single line. Press {{arrowShortcut}} again to change arrow type.", freeDraw: "Click and drag, release when you're finished", text: "Tip: you can also add text by double-clicking anywhere with the selection tool", embeddable: "Click-drag to create a website embed", text_selected: "Double-click or press ENTER to edit text", text_editing: "Press Escape or CtrlOrCmd+ENTER to finish editing", linearElementMulti: "Click on last point or press Escape or Enter to finish", lockAngle: "You can constrain angle by holding SHIFT", resize: `You can constrain proportions by holding SHIFT while resizing,
hold ALT to resize from the center`, resizeImage: `You can resize freely by holding SHIFT,
hold ALT to resize from the center`, rotate: "You can constrain angles by holding SHIFT while rotating", lineEditor_info: "Hold CtrlOrCmd and Double-click or press CtrlOrCmd + Enter to edit points", lineEditor_pointSelected: `Press Delete to remove point(s),
CtrlOrCmd+D to duplicate, or drag to move`, lineEditor_nothingSelected: `Select a point to edit (hold SHIFT to select multiple),
or hold Alt and click to add new points`, placeImage: "Click to place the image, or click and drag to set its size manually", publishLibrary: "Publish your own library", bindTextToElement: "Press enter to add text", createFlowchart: "Hold CtrlOrCmd and Arrow key to create a flowchart", deepBoxSelect: "Hold CtrlOrCmd to deep select, and to prevent dragging", eraserRevert: "Hold Alt to revert the elements marked for deletion", firefox_clipboard_write: 'This feature can likely be enabled by setting the "dom.events.asyncClipboard.clipboardItem" flag to "true". To change the browser flags in Firefox, visit the "about:config" page.', disableSnapping: "Hold CtrlOrCmd to disable snapping", enterCropEditor: "Double click the image or press ENTER to crop the image", leaveCropEditor: "Click outside the image or press ENTER or ESCAPE to finish cropping" }, u = { cannotShowPreview: "Cannot show preview", canvasTooBig: "The canvas may be too big.", canvasTooBigTip: "Tip: try moving the farthest elements a bit closer together." }, h = { headingMain: "Encountered an error. Try <button>reloading the page</button>.", clearCanvasMessage: "If reloading doesn't work, try <button>clearing the canvas</button>.", clearCanvasCaveat: " This will result in loss of work ", trackedToSentry: "The error with identifier {{eventId}} was tracked on our system.", openIssueMessage: "We were very cautious not to include your scene information on the error. If your scene is not private, please consider following up on our <button>bug tracker</button>. Please include information below by copying and pasting into the GitHub issue.", sceneContent: "Scene content:" }, b = { or: "Or" }, g$1 = { desc_intro: "Invite people to collaborate on your drawing.", desc_privacy: "Don't worry, the session is end-to-end encrypted, and fully private. Not even our server can see what you draw.", button_startSession: "Start session", button_stopSession: "Stop session", desc_inProgressIntro: "Live-collaboration session is now in progress.", desc_shareLink: "Share this link with anyone you want to collaborate with:", desc_exitSession: "Stopping the session will disconnect you from the room, but you'll be able to continue working with the scene, locally. Note that this won't affect other people, and they'll still be able to collaborate on their version.", shareTitle: "Join a live collaboration session on Excalidraw" }, y = { title: "Error" }, w = { disk_title: "Save to disk", disk_details: "Export the scene data to a file from which you can import later.", disk_button: "Save to file", link_title: "Shareable link", link_details: "Export as a read-only link.", link_button: "Export to Link", excalidrawplus_description: "Save the scene to your Excalidraw+ workspace.", excalidrawplus_button: "Export", excalidrawplus_exportError: "Couldn't export to Excalidraw+ at this moment..." }, k$1 = { blog: "Read our blog", click: "click", deepSelect: "Deep select", deepBoxSelect: "Deep select within box, and prevent dragging", createFlowchart: "Create a flowchart from a generic element", navigateFlowchart: "Navigate a flowchart", curvedArrow: "Curved arrow", curvedLine: "Curved line", documentation: "Documentation", doubleClick: "double-click", drag: "drag", editor: "Editor", editLineArrowPoints: "Edit line/arrow points", editText: "Edit text / add label", github: "Found an issue? Submit", howto: "Follow our guides", or: "or", preventBinding: "Prevent arrow binding", tools: "Tools", shortcuts: "Keyboard shortcuts", textFinish: "Finish editing (text editor)", textNewLine: "Add new line (text editor)", title: "Help", view: "View", zoomToFit: "Zoom to fit all elements", zoomToSelection: "Zoom to selection", toggleElementLock: "Lock/unlock selection", movePageUpDown: "Move page up/down", movePageLeftRight: "Move page left/right", cropStart: "Crop image", cropFinish: "Finish image cropping" }, v = { title: "Clear canvas" }, f = { title: "Publish library", itemName: "Item name", authorName: "Author name", githubUsername: "GitHub username", twitterUsername: "Twitter username", libraryName: "Library name", libraryDesc: "Library description", website: "Website", placeholder: { authorName: "Your name or username", libraryName: "Name of your library", libraryDesc: "Description of your library to help people understand its usage", githubHandle: "GitHub handle (optional), so you can edit the library once submitted for review", twitterHandle: "Twitter username (optional), so we know who to credit when promoting over Twitter", website: "Link to your personal website or elsewhere (optional)" }, errors: { required: "Required", website: "Enter a valid URL" }, noteDescription: "Submit your library to be included in the <link>public library repository</link> for other people to use in their drawings.", noteGuidelines: "The library needs to be manually approved first. Please read the <link>guidelines</link> before submitting. You will need a GitHub account to communicate and make changes if requested, but it is not strictly required.", noteLicense: "By submitting, you agree the library will be published under the <link>MIT License</link>, which in short means anyone can use them without restrictions.", noteItems: "Each library item must have its own name so it's filterable. The following library items will be included:", atleastOneLibItem: "Please select at least one library item to get started", republishWarning: "Note: some of the selected items are marked as already published/submitted. You should only resubmit items when updating an existing library or submission." }, S = { title: "Library submitted", content: "Thank you {{authorName}}. Your library has been submitted for review. You can track the status <link>here</link>" }, C = { resetLibrary: "Reset library", removeItemsFromLib: "Remove selected items from library" }, x = { header: "Export image", label: { withBackground: "Background", onlySelected: "Only selected", darkMode: "Dark mode", embedScene: "Embed scene", scale: "Scale", padding: "Padding" }, tooltip: { embedScene: `Scene data will be saved into the exported PNG/SVG file so that the scene can be restored from it.
Will increase exported file size.` }, title: { exportToPng: "Export to PNG", exportToSvg: "Export to SVG", copyPngToClipboard: "Copy PNG to clipboard" }, button: { exportToPng: "PNG", exportToSvg: "SVG", copyPngToClipboard: "Copy to clipboard" } }, E = { tooltip: "Your drawings are end-to-end encrypted so Excalidraw's servers will never see them.", link: "Blog post on end-to-end encryption in Excalidraw" }, T = { angle: "Angle", shapes: "Shapes", height: "Height", scene: "Scene", selected: "Selected", storage: "Storage", fullTitle: "Canvas & Shape properties", title: "Properties", generalStats: "General", elementProperties: "Shape properties", total: "Total", version: "Version", versionCopy: "Click to copy", versionNotAvailable: "Version not available", width: "Width" }, L = { addedToLibrary: "Added to library", copyStyles: "Copied styles.", copyToClipboard: "Copied to clipboard.", copyToClipboardAsPng: `Copied {{exportSelection}} to clipboard as PNG
({{exportColorScheme}})`, copyToClipboardAsSvg: `Copied {{exportSelection}} to clipboard as SVG
({{exportColorScheme}})`, fileSaved: "File saved.", fileSavedToFilename: "Saved to {filename}", canvas: "canvas", selection: "selection", pasteAsSingleElement: `Use {{shortcut}} to paste as a single element,
or paste into an existing text editor`, unableToEmbed: "Embedding this url is currently not allowed. Raise an issue on GitHub to request the url whitelisted", unrecognizedLinkFormat: "The link you embedded does not match the expected format. Please try to paste the 'embed' string provided by the source site", elementLinkCopied: "Link copied to clipboard" }, F = { transparent: "Transparent", black: "Black", white: "White", red: "Red", pink: "Pink", grape: "Grape", violet: "Violet", gray: "Gray", blue: "Blue", cyan: "Cyan", teal: "Teal", green: "Green", yellow: "Yellow", orange: "Orange", bronze: "Bronze" }, P = { app: { center_heading: "All your data is saved locally in your browser.", center_heading_plus: "Did you want to go to the Excalidraw+ instead?", menuHint: "Export, preferences, languages, ..." }, defaults: { menuHint: "Export, preferences, and more...", center_heading: "Diagrams. Made. Simple.", toolbarHint: "Pick a tool & Start drawing!", helpHint: "Shortcuts & help" } }, A = { mostUsedCustomColors: "Most used custom colors", colors: "Colors", shades: "Shades", hexCode: "Hex code", noShades: "No shades available for this color" }, _ = { action: { exportToImage: { title: "Export as image", button: "Export as image", description: "Export the scene data as an image from which you can import later." }, saveToDisk: { title: "Save to disk", button: "Save to disk", description: "Export the scene data to a file from which you can import later." }, excalidrawPlus: { title: "Excalidraw+", button: "Export to Excalidraw+", description: "Save the scene to your Excalidraw+ workspace." } }, modal: { loadFromFile: { title: "Load from file", button: "Load from file", description: "Loading from a file will <bold>replace your existing content</bold>.<br></br>You can back up your drawing first using one of the options below." }, shareableLink: { title: "Load from link", button: "Replace my content", description: "Loading external drawing will <bold>replace your existing content</bold>.<br></br>You can back up your drawing first by using one of the options below." } } }, D = { title: "Mermaid to Excalidraw", button: "Insert", description: "Currently only <flowchartLink>Flowchart</flowchartLink>,<sequenceLink> Sequence, </sequenceLink> and <classLink>Class </classLink>Diagrams are supported. The other types will be rendered as image in Excalidraw.", syntax: "Mermaid Syntax", preview: "Preview" }, I = { placeholder: "Quick search" }, N$1 = { badge: { old: "old" }, sceneFonts: "In this scene", availableFonts: "Available fonts", empty: "No fonts found" }, z = { empty: "No users found", hint: { text: "Click on user to follow", followStatus: "You're currently following this user", inCall: "User is in a voice call", micMuted: "User's microphone is muted", isSpeaking: "User is speaking" } }, R$1 = { title: "Command palette", shortcuts: { select: "Select", confirm: "Confirm", close: "Close" }, recents: "Recently used", search: { placeholder: "Search menus, commands, and discover hidden gems", noMatch: "No matching commands..." }, itemNotAvailable: "Command is not available...", shortcutHint: "For Command palette, use {{shortcut}}" }, B = { labels: t, elementLink: r, library: a, search: i, buttons: n, alerts: l, errors: s, toolBar: d, element: c, headings: p, hints: m, canvasError: u, errorSplash: h, shareDialog: b, roomDialog: g$1, errorDialog: y, exportDialog: w, helpDialog: k$1, clearCanvasDialog: v, publishDialog: f, publishSuccessDialog: S, confirmDialog: C, imageExportDialog: x, encrypted: E, stats: T, toast: L, colors: F, welcomeScreen: P, colorPicker: A, overwriteConfirm: _, mermaid: D, quickSearch: I, fontList: N$1, userList: z, commandPalette: R$1 };
var R = 100, k = 36, N = { "ar-SA": 94, "az-AZ": 17, "bg-BG": 71, "bn-BD": 52, "ca-ES": 83, "cs-CZ": 86, "da-DK": 61, "de-DE": 100, "el-GR": 80, en: R, "es-ES": 96, "eu-ES": 97, "fa-IR": 84, "fi-FI": 76, "fr-FR": 99, "gl-ES": 86, "he-IL": 77, "hi-IN": 76, "hu-HU": 76, "id-ID": 91, "it-IT": 98, "ja-JP": 90, kaa: k, "kab-KAB": 76, "kk-KZ": 18, "km-KH": 83, "ko-KR": 100, "ku-TR": 87, "lt-LT": 48, "lv-LV": 77, "mr-IN": 98, "my-MM": 35, "nb-NO": 93, "nl-NL": 75, "nn-NO": 67, "oc-FR": 92, "pa-IN": 78, "pl-PL": 99, "pt-BR": 91, "pt-PT": 83, "ro-RO": 99, "ru-RU": 92, "si-LK": 7, "sk-SK": 100, "sl-SI": 100, "sv-SE": 100, "ta-IN": 81, "th-TH": 44, "tr-TR": 87, "uk-UA": 93, "vi-VN": 49, "zh-CN": 100, "zh-HK": 22, "zh-TW": 100 };
const __vite_import_meta_env__$3 = {};
let keyCount = 0;
function atom(read, write) {
  const key = `atom${++keyCount}`;
  const config = {
    toString() {
      return (__vite_import_meta_env__$3 ? "production" : void 0) !== "production" && this.debugLabel ? key + ":" + this.debugLabel : key;
    }
  };
  if (typeof read === "function") {
    config.read = read;
  } else {
    config.init = read;
    config.read = defaultRead$1;
    config.write = defaultWrite$1;
  }
  return config;
}
function defaultRead$1(get) {
  return get(this);
}
function defaultWrite$1(get, set, arg) {
  return set(
    this,
    typeof arg === "function" ? arg(get(this)) : arg
  );
}
const isSelfAtom = (atom2, a3) => atom2.unstable_is ? atom2.unstable_is(a3) : a3 === atom2;
const hasInitialValue = (atom2) => "init" in atom2;
const isActuallyWritableAtom = (atom2) => !!atom2.write;
const cancelablePromiseMap = /* @__PURE__ */ new WeakMap();
const isPendingPromise = (value) => {
  var _a2;
  return isPromiseLike$1(value) && !((_a2 = cancelablePromiseMap.get(value)) == null ? void 0 : _a2[1]);
};
const cancelPromise = (promise, nextValue) => {
  const promiseState = cancelablePromiseMap.get(promise);
  if (promiseState) {
    promiseState[1] = true;
    promiseState[0].forEach((fn2) => fn2(nextValue));
  } else if ((__vite_import_meta_env__$3 ? "production" : void 0) !== "production") {
    throw new Error("[Bug] cancelable promise not found");
  }
};
const patchPromiseForCancelability = (promise) => {
  if (cancelablePromiseMap.has(promise)) {
    return;
  }
  const promiseState = [/* @__PURE__ */ new Set(), false];
  cancelablePromiseMap.set(promise, promiseState);
  const settle = () => {
    promiseState[1] = true;
  };
  promise.then(settle, settle);
  promise.onCancel = (fn2) => {
    promiseState[0].add(fn2);
  };
};
const isPromiseLike$1 = (x3) => typeof (x3 == null ? void 0 : x3.then) === "function";
const isAtomStateInitialized = (atomState) => "v" in atomState || "e" in atomState;
const returnAtomValue = (atomState) => {
  if ("e" in atomState) {
    throw atomState.e;
  }
  if ((__vite_import_meta_env__$3 ? "production" : void 0) !== "production" && !("v" in atomState)) {
    throw new Error("[Bug] atom state is not initialized");
  }
  return atomState.v;
};
const addPendingPromiseToDependency = (atom2, promise, dependencyAtomState) => {
  if (!dependencyAtomState.p.has(atom2)) {
    dependencyAtomState.p.add(atom2);
    promise.then(
      () => {
        dependencyAtomState.p.delete(atom2);
      },
      () => {
        dependencyAtomState.p.delete(atom2);
      }
    );
  }
};
const addDependency = (batch, atom2, atomState, a3, aState) => {
  var _a2;
  if ((__vite_import_meta_env__$3 ? "production" : void 0) !== "production" && a3 === atom2) {
    throw new Error("[Bug] atom cannot depend on itself");
  }
  atomState.d.set(a3, aState.n);
  if (isPendingPromise(atomState.v)) {
    addPendingPromiseToDependency(atom2, atomState.v, aState);
  }
  (_a2 = aState.m) == null ? void 0 : _a2.t.add(atom2);
  if (batch) {
    addBatchAtomDependent(batch, a3, atom2);
  }
};
const createBatch = () => ({
  D: /* @__PURE__ */ new Map(),
  H: /* @__PURE__ */ new Set(),
  M: /* @__PURE__ */ new Set(),
  L: /* @__PURE__ */ new Set()
});
const addBatchFunc = (batch, priority, fn2) => {
  batch[priority].add(fn2);
};
const registerBatchAtom = (batch, atom2, atomState) => {
  if (!batch.D.has(atom2)) {
    batch.D.set(atom2, /* @__PURE__ */ new Set());
    addBatchFunc(batch, "M", () => {
      var _a2;
      (_a2 = atomState.m) == null ? void 0 : _a2.l.forEach((listener) => addBatchFunc(batch, "M", listener));
    });
  }
};
const addBatchAtomDependent = (batch, atom2, dependent) => {
  const dependents = batch.D.get(atom2);
  if (dependents) {
    dependents.add(dependent);
  }
};
const getBatchAtomDependents = (batch, atom2) => batch.D.get(atom2);
const flushBatch = (batch) => {
  let error;
  let hasError = false;
  const call = (fn2) => {
    try {
      fn2();
    } catch (e12) {
      if (!hasError) {
        error = e12;
        hasError = true;
      }
    }
  };
  while (batch.H.size || batch.M.size || batch.L.size) {
    batch.D.clear();
    batch.H.forEach(call);
    batch.H.clear();
    batch.M.forEach(call);
    batch.M.clear();
    batch.L.forEach(call);
    batch.L.clear();
  }
  if (hasError) {
    throw error;
  }
};
const buildStore = (...[getAtomState, atomRead, atomWrite, atomOnMount]) => {
  const setAtomStateValueOrPromise = (atom2, atomState, valueOrPromise) => {
    const hasPrevValue = "v" in atomState;
    const prevValue = atomState.v;
    const pendingPromise = isPendingPromise(atomState.v) ? atomState.v : null;
    if (isPromiseLike$1(valueOrPromise)) {
      patchPromiseForCancelability(valueOrPromise);
      for (const a3 of atomState.d.keys()) {
        addPendingPromiseToDependency(atom2, valueOrPromise, getAtomState(a3));
      }
      atomState.v = valueOrPromise;
    } else {
      atomState.v = valueOrPromise;
    }
    delete atomState.e;
    delete atomState.x;
    if (!hasPrevValue || !Object.is(prevValue, atomState.v)) {
      ++atomState.n;
      if (pendingPromise) {
        cancelPromise(pendingPromise, valueOrPromise);
      }
    }
  };
  const readAtomState = (batch, atom2) => {
    var _a2;
    const atomState = getAtomState(atom2);
    if (isAtomStateInitialized(atomState)) {
      if (atomState.m && !atomState.x) {
        return atomState;
      }
      if (Array.from(atomState.d).every(
        ([a3, n3]) => (
          // Recursively, read the atom state of the dependency, and
          // check if the atom epoch number is unchanged
          readAtomState(batch, a3).n === n3
        )
      )) {
        return atomState;
      }
    }
    atomState.d.clear();
    let isSync = true;
    const getter = (a3) => {
      if (isSelfAtom(atom2, a3)) {
        const aState2 = getAtomState(a3);
        if (!isAtomStateInitialized(aState2)) {
          if (hasInitialValue(a3)) {
            setAtomStateValueOrPromise(a3, aState2, a3.init);
          } else {
            throw new Error("no atom init");
          }
        }
        return returnAtomValue(aState2);
      }
      const aState = readAtomState(batch, a3);
      try {
        return returnAtomValue(aState);
      } finally {
        if (isSync) {
          addDependency(batch, atom2, atomState, a3, aState);
        } else {
          const batch2 = createBatch();
          addDependency(batch2, atom2, atomState, a3, aState);
          mountDependencies(batch2, atom2, atomState);
          flushBatch(batch2);
        }
      }
    };
    let controller;
    let setSelf;
    const options = {
      get signal() {
        if (!controller) {
          controller = new AbortController();
        }
        return controller.signal;
      },
      get setSelf() {
        if ((__vite_import_meta_env__$3 ? "production" : void 0) !== "production" && !isActuallyWritableAtom(atom2)) {
          console.warn("setSelf function cannot be used with read-only atom");
        }
        if (!setSelf && isActuallyWritableAtom(atom2)) {
          setSelf = (...args) => {
            if ((__vite_import_meta_env__$3 ? "production" : void 0) !== "production" && isSync) {
              console.warn("setSelf function cannot be called in sync");
            }
            if (!isSync) {
              return writeAtom(atom2, ...args);
            }
          };
        }
        return setSelf;
      }
    };
    try {
      const valueOrPromise = atomRead(atom2, getter, options);
      setAtomStateValueOrPromise(atom2, atomState, valueOrPromise);
      if (isPromiseLike$1(valueOrPromise)) {
        (_a2 = valueOrPromise.onCancel) == null ? void 0 : _a2.call(valueOrPromise, () => controller == null ? void 0 : controller.abort());
        const complete = () => {
          if (atomState.m) {
            const batch2 = createBatch();
            mountDependencies(batch2, atom2, atomState);
            flushBatch(batch2);
          }
        };
        valueOrPromise.then(complete, complete);
      }
      return atomState;
    } catch (error) {
      delete atomState.v;
      atomState.e = error;
      delete atomState.x;
      ++atomState.n;
      return atomState;
    } finally {
      isSync = false;
    }
  };
  const readAtom = (atom2) => returnAtomValue(readAtomState(void 0, atom2));
  const getMountedOrBatchDependents = (batch, atom2, atomState) => {
    var _a2, _b;
    const dependents = /* @__PURE__ */ new Map();
    for (const a3 of ((_a2 = atomState.m) == null ? void 0 : _a2.t) || []) {
      const aState = getAtomState(a3);
      if (aState.m) {
        dependents.set(a3, aState);
      }
    }
    for (const atomWithPendingPromise of atomState.p) {
      dependents.set(
        atomWithPendingPromise,
        getAtomState(atomWithPendingPromise)
      );
    }
    (_b = getBatchAtomDependents(batch, atom2)) == null ? void 0 : _b.forEach((dependent) => {
      dependents.set(dependent, getAtomState(dependent));
    });
    return dependents;
  };
  const recomputeDependents = (batch, atom2, atomState) => {
    const topSortedReversed = [];
    const visiting = /* @__PURE__ */ new Set();
    const visited = /* @__PURE__ */ new Set();
    const stack = [[atom2, atomState]];
    while (stack.length > 0) {
      const [a3, aState] = stack[stack.length - 1];
      if (visited.has(a3)) {
        stack.pop();
        continue;
      }
      if (visiting.has(a3)) {
        topSortedReversed.push([a3, aState, aState.n]);
        visited.add(a3);
        aState.x = true;
        stack.pop();
        continue;
      }
      visiting.add(a3);
      for (const [d3, s3] of getMountedOrBatchDependents(batch, a3, aState)) {
        if (a3 !== d3 && !visiting.has(d3)) {
          stack.push([d3, s3]);
        }
      }
    }
    addBatchFunc(batch, "H", () => {
      const changedAtoms = /* @__PURE__ */ new Set([atom2]);
      for (let i3 = topSortedReversed.length - 1; i3 >= 0; --i3) {
        const [a3, aState, prevEpochNumber] = topSortedReversed[i3];
        let hasChangedDeps = false;
        for (const dep of aState.d.keys()) {
          if (dep !== a3 && changedAtoms.has(dep)) {
            hasChangedDeps = true;
            break;
          }
        }
        if (hasChangedDeps) {
          readAtomState(batch, a3);
          mountDependencies(batch, a3, aState);
          if (prevEpochNumber !== aState.n) {
            registerBatchAtom(batch, a3, aState);
            changedAtoms.add(a3);
          }
        }
        delete aState.x;
      }
    });
  };
  const writeAtomState = (batch, atom2, ...args) => {
    let isSync = true;
    const getter = (a3) => returnAtomValue(readAtomState(batch, a3));
    const setter = (a3, ...args2) => {
      const aState = getAtomState(a3);
      try {
        if (isSelfAtom(atom2, a3)) {
          if (!hasInitialValue(a3)) {
            throw new Error("atom not writable");
          }
          const prevEpochNumber = aState.n;
          const v3 = args2[0];
          setAtomStateValueOrPromise(a3, aState, v3);
          mountDependencies(batch, a3, aState);
          if (prevEpochNumber !== aState.n) {
            registerBatchAtom(batch, a3, aState);
            recomputeDependents(batch, a3, aState);
          }
          return void 0;
        } else {
          return writeAtomState(batch, a3, ...args2);
        }
      } finally {
        if (!isSync) {
          flushBatch(batch);
        }
      }
    };
    try {
      return atomWrite(atom2, getter, setter, ...args);
    } finally {
      isSync = false;
    }
  };
  const writeAtom = (atom2, ...args) => {
    const batch = createBatch();
    try {
      return writeAtomState(batch, atom2, ...args);
    } finally {
      flushBatch(batch);
    }
  };
  const mountDependencies = (batch, atom2, atomState) => {
    if (atomState.m && !isPendingPromise(atomState.v)) {
      for (const a3 of atomState.d.keys()) {
        if (!atomState.m.d.has(a3)) {
          const aMounted = mountAtom(batch, a3, getAtomState(a3));
          aMounted.t.add(atom2);
          atomState.m.d.add(a3);
        }
      }
      for (const a3 of atomState.m.d || []) {
        if (!atomState.d.has(a3)) {
          atomState.m.d.delete(a3);
          const aMounted = unmountAtom(batch, a3, getAtomState(a3));
          aMounted == null ? void 0 : aMounted.t.delete(atom2);
        }
      }
    }
  };
  const mountAtom = (batch, atom2, atomState) => {
    if (!atomState.m) {
      readAtomState(batch, atom2);
      for (const a3 of atomState.d.keys()) {
        const aMounted = mountAtom(batch, a3, getAtomState(a3));
        aMounted.t.add(atom2);
      }
      atomState.m = {
        l: /* @__PURE__ */ new Set(),
        d: new Set(atomState.d.keys()),
        t: /* @__PURE__ */ new Set()
      };
      if (isActuallyWritableAtom(atom2)) {
        const mounted = atomState.m;
        let setAtom;
        const createInvocationContext = (batch2, fn2) => {
          let isSync = true;
          setAtom = (...args) => {
            try {
              return writeAtomState(batch2, atom2, ...args);
            } finally {
              if (!isSync) {
                flushBatch(batch2);
              }
            }
          };
          try {
            return fn2();
          } finally {
            isSync = false;
          }
        };
        addBatchFunc(batch, "L", () => {
          const onUnmount = createInvocationContext(
            batch,
            () => atomOnMount(atom2, (...args) => setAtom(...args))
          );
          if (onUnmount) {
            mounted.u = (batch2) => createInvocationContext(batch2, onUnmount);
          }
        });
      }
    }
    return atomState.m;
  };
  const unmountAtom = (batch, atom2, atomState) => {
    if (atomState.m && !atomState.m.l.size && !Array.from(atomState.m.t).some((a3) => {
      var _a2;
      return (_a2 = getAtomState(a3).m) == null ? void 0 : _a2.d.has(atom2);
    })) {
      const onUnmount = atomState.m.u;
      if (onUnmount) {
        addBatchFunc(batch, "L", () => onUnmount(batch));
      }
      delete atomState.m;
      for (const a3 of atomState.d.keys()) {
        const aMounted = unmountAtom(batch, a3, getAtomState(a3));
        aMounted == null ? void 0 : aMounted.t.delete(atom2);
      }
      return void 0;
    }
    return atomState.m;
  };
  const subscribeAtom = (atom2, listener) => {
    const batch = createBatch();
    const atomState = getAtomState(atom2);
    const mounted = mountAtom(batch, atom2, atomState);
    const listeners = mounted.l;
    listeners.add(listener);
    flushBatch(batch);
    return () => {
      listeners.delete(listener);
      const batch2 = createBatch();
      unmountAtom(batch2, atom2, atomState);
      flushBatch(batch2);
    };
  };
  const unstable_derive = (fn2) => buildStore(...fn2(getAtomState, atomRead, atomWrite, atomOnMount));
  const store = {
    get: readAtom,
    set: writeAtom,
    sub: subscribeAtom,
    unstable_derive
  };
  return store;
};
const deriveDevStoreRev4 = (store) => {
  const proxyAtomStateMap = /* @__PURE__ */ new WeakMap();
  const debugMountedAtoms = /* @__PURE__ */ new Set();
  let savedGetAtomState;
  let inRestoreAtom = 0;
  const derivedStore = store.unstable_derive(
    (getAtomState, atomRead, atomWrite, atomOnMount) => {
      savedGetAtomState = getAtomState;
      return [
        (atom2) => {
          let proxyAtomState = proxyAtomStateMap.get(atom2);
          if (!proxyAtomState) {
            const atomState = getAtomState(atom2);
            proxyAtomState = new Proxy(atomState, {
              set(target, prop, value) {
                if (prop === "m") {
                  debugMountedAtoms.add(atom2);
                }
                return Reflect.set(target, prop, value);
              },
              deleteProperty(target, prop) {
                if (prop === "m") {
                  debugMountedAtoms.delete(atom2);
                }
                return Reflect.deleteProperty(target, prop);
              }
            });
            proxyAtomStateMap.set(atom2, proxyAtomState);
          }
          return proxyAtomState;
        },
        atomRead,
        (atom2, getter, setter, ...args) => {
          if (inRestoreAtom) {
            return setter(atom2, ...args);
          }
          return atomWrite(atom2, getter, setter, ...args);
        },
        atomOnMount
      ];
    }
  );
  const savedStoreSet = derivedStore.set;
  const devStore = {
    // store dev methods (these are tentative and subject to change without notice)
    dev4_get_internal_weak_map: () => ({
      get: (atom2) => {
        const atomState = savedGetAtomState(atom2);
        if (atomState.n === 0) {
          return void 0;
        }
        return atomState;
      }
    }),
    dev4_get_mounted_atoms: () => debugMountedAtoms,
    dev4_restore_atoms: (values) => {
      const restoreAtom = {
        read: () => null,
        write: (_get, set) => {
          ++inRestoreAtom;
          try {
            for (const [atom2, value] of values) {
              if (hasInitialValue(atom2)) {
                set(atom2, value);
              }
            }
          } finally {
            --inRestoreAtom;
          }
        }
      };
      savedStoreSet(restoreAtom);
    }
  };
  return Object.assign(derivedStore, devStore);
};
const createStore$2 = () => {
  const atomStateMap = /* @__PURE__ */ new WeakMap();
  const getAtomState = (atom2) => {
    if ((__vite_import_meta_env__$3 ? "production" : void 0) !== "production" && !atom2) {
      throw new Error("Atom is undefined or null");
    }
    let atomState = atomStateMap.get(atom2);
    if (!atomState) {
      atomState = { d: /* @__PURE__ */ new Map(), p: /* @__PURE__ */ new Set(), n: 0 };
      atomStateMap.set(atom2, atomState);
    }
    return atomState;
  };
  const store = buildStore(
    getAtomState,
    (atom2, ...params) => atom2.read(...params),
    (atom2, ...params) => atom2.write(...params),
    (atom2, ...params) => {
      var _a2;
      return (_a2 = atom2.onMount) == null ? void 0 : _a2.call(atom2, ...params);
    }
  );
  if ((__vite_import_meta_env__$3 ? "production" : void 0) !== "production") {
    return deriveDevStoreRev4(store);
  }
  return store;
};
let defaultStore;
const getDefaultStore = () => {
  if (!defaultStore) {
    defaultStore = createStore$2();
    if ((__vite_import_meta_env__$3 ? "production" : void 0) !== "production") {
      globalThis.__JOTAI_DEFAULT_STORE__ || (globalThis.__JOTAI_DEFAULT_STORE__ = defaultStore);
      if (globalThis.__JOTAI_DEFAULT_STORE__ !== defaultStore) {
        console.warn(
          "Detected multiple Jotai instances. It may cause unexpected behavior with the default store. https://github.com/pmndrs/jotai/discussions/2044"
        );
      }
    }
  }
  return defaultStore;
};
const __vite_import_meta_env__$2 = {};
const StoreContext = reactExports.createContext(
  void 0
);
const useStore$2 = (options) => {
  const store = reactExports.useContext(StoreContext);
  return (options == null ? void 0 : options.store) || store || getDefaultStore();
};
const isPromiseLike = (x3) => typeof (x3 == null ? void 0 : x3.then) === "function";
const attachPromiseMeta = (promise) => {
  promise.status = "pending";
  promise.then(
    (v3) => {
      promise.status = "fulfilled";
      promise.value = v3;
    },
    (e12) => {
      promise.status = "rejected";
      promise.reason = e12;
    }
  );
};
const use = React.use || ((promise) => {
  if (promise.status === "pending") {
    throw promise;
  } else if (promise.status === "fulfilled") {
    return promise.value;
  } else if (promise.status === "rejected") {
    throw promise.reason;
  } else {
    attachPromiseMeta(promise);
    throw promise;
  }
});
const continuablePromiseMap = /* @__PURE__ */ new WeakMap();
const createContinuablePromise = (promise) => {
  let continuablePromise = continuablePromiseMap.get(promise);
  if (!continuablePromise) {
    continuablePromise = new Promise((resolve, reject) => {
      let curr = promise;
      const onFulfilled = (me2) => (v3) => {
        if (curr === me2) {
          resolve(v3);
        }
      };
      const onRejected = (me2) => (e12) => {
        if (curr === me2) {
          reject(e12);
        }
      };
      const registerCancelHandler = (p3) => {
        if ("onCancel" in p3 && typeof p3.onCancel === "function") {
          p3.onCancel((nextValue) => {
            if ((__vite_import_meta_env__$2 ? "production" : void 0) !== "production" && nextValue === p3) {
              throw new Error("[Bug] p is not updated even after cancelation");
            }
            if (isPromiseLike(nextValue)) {
              continuablePromiseMap.set(nextValue, continuablePromise);
              curr = nextValue;
              nextValue.then(onFulfilled(nextValue), onRejected(nextValue));
              registerCancelHandler(nextValue);
            } else {
              resolve(nextValue);
            }
          });
        }
      };
      promise.then(onFulfilled(promise), onRejected(promise));
      registerCancelHandler(promise);
    });
    continuablePromiseMap.set(promise, continuablePromise);
  }
  return continuablePromise;
};
function useAtomValue(atom2, options) {
  const store = useStore$2(options);
  const [[valueFromReducer, storeFromReducer, atomFromReducer], rerender] = reactExports.useReducer(
    (prev) => {
      const nextValue = store.get(atom2);
      if (Object.is(prev[0], nextValue) && prev[1] === store && prev[2] === atom2) {
        return prev;
      }
      return [nextValue, store, atom2];
    },
    void 0,
    () => [store.get(atom2), store, atom2]
  );
  let value = valueFromReducer;
  if (storeFromReducer !== store || atomFromReducer !== atom2) {
    rerender();
    value = store.get(atom2);
  }
  const delay = options == null ? void 0 : options.delay;
  reactExports.useEffect(() => {
    const unsub = store.sub(atom2, () => {
      if (typeof delay === "number") {
        const value2 = store.get(atom2);
        if (isPromiseLike(value2)) {
          attachPromiseMeta(createContinuablePromise(value2));
        }
        setTimeout(rerender, delay);
        return;
      }
      rerender();
    });
    rerender();
    return unsub;
  }, [store, atom2, delay]);
  reactExports.useDebugValue(value);
  if (isPromiseLike(value)) {
    const promise = createContinuablePromise(value);
    return use(promise);
  }
  return value;
}
function useSetAtom(atom2, options) {
  const store = useStore$2(options);
  const setAtom = reactExports.useCallback(
    (...args) => {
      if ((__vite_import_meta_env__$2 ? "production" : void 0) !== "production" && !("write" in atom2)) {
        throw new Error("not writable atom");
      }
      return store.set(atom2, ...args);
    },
    [store, atom2]
  );
  return setAtom;
}
function useAtom(atom2, options) {
  return [
    useAtomValue(atom2, options),
    // We do wrong type assertion here, which results in throwing an error.
    useSetAtom(atom2, options)
  ];
}
const hydratedMap = /* @__PURE__ */ new WeakMap();
function useHydrateAtoms(values, options) {
  const store = useStore$2(options);
  const hydratedSet = getHydratedSet(store);
  for (const [atom2, value] of values) {
    if (!hydratedSet.has(atom2) || (options == null ? void 0 : options.dangerouslyForceHydrate)) {
      hydratedSet.add(atom2);
      store.set(atom2, value);
    }
  }
}
const getHydratedSet = (store) => {
  let hydratedSet = hydratedMap.get(store);
  if (!hydratedSet) {
    hydratedSet = /* @__PURE__ */ new WeakSet();
    hydratedMap.set(store, hydratedSet);
  }
  return hydratedSet;
};
function _extends$1() {
  _extends$1 = Object.assign ? Object.assign.bind() : function(target) {
    for (var i3 = 1; i3 < arguments.length; i3++) {
      var source = arguments[i3];
      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }
    return target;
  };
  return _extends$1.apply(this, arguments);
}
function createIsolation() {
  const StoreContext2 = reactExports.createContext(null);
  function Provider2({
    store,
    initialValues = [],
    children
  }) {
    const storeRef = reactExports.useRef(store);
    if (!storeRef.current) {
      storeRef.current = createStore$2();
    }
    useHydrateAtoms(initialValues, {
      store: storeRef.current
    });
    return jsxRuntimeExports.jsx(StoreContext2.Provider, {
      value: storeRef.current,
      children
    });
  }
  const useStore$12 = (options) => {
    const store = reactExports.useContext(StoreContext2);
    if (!store) throw new Error("Missing Provider from createIsolation");
    return useStore$2(_extends$1({
      store
    }, options));
  };
  const useAtom$1 = (anAtom, options) => {
    const store = useStore$12();
    return useAtom(anAtom, _extends$1({
      store
    }, options));
  };
  const useAtomValue$1 = (anAtom, options) => {
    const store = useStore$12();
    return useAtomValue(anAtom, _extends$1({
      store
    }, options));
  };
  const useSetAtom$1 = (anAtom, options) => {
    const store = useStore$12();
    return useSetAtom(anAtom, _extends$1({
      store
    }, options));
  };
  return {
    Provider: Provider2,
    useStore: useStore$12,
    useAtom: useAtom$1,
    useAtomValue: useAtomValue$1,
    useSetAtom: useSetAtom$1
  };
}
const {
  read: defaultRead,
  write: defaultWrite
} = atom(null);
reactExports.createContext({
  scope: void 0,
  baseStore: void 0
});
var reactDomExports = requireReactDom();
const ReactDOM = /* @__PURE__ */ getDefaultExportFromCjs(reactDomExports);
function composeEventHandlers(originalEventHandler, ourEventHandler, { checkForDefaultPrevented = true } = {}) {
  return function handleEvent(event) {
    originalEventHandler?.(event);
    if (checkForDefaultPrevented === false || !event.defaultPrevented) {
      return ourEventHandler?.(event);
    }
  };
}
function setRef(ref, value) {
  if (typeof ref === "function") {
    return ref(value);
  } else if (ref !== null && ref !== void 0) {
    ref.current = value;
  }
}
function composeRefs(...refs) {
  return (node) => {
    let hasCleanup = false;
    const cleanups = refs.map((ref) => {
      const cleanup = setRef(ref, node);
      if (!hasCleanup && typeof cleanup == "function") {
        hasCleanup = true;
      }
      return cleanup;
    });
    if (hasCleanup) {
      return () => {
        for (let i3 = 0; i3 < cleanups.length; i3++) {
          const cleanup = cleanups[i3];
          if (typeof cleanup == "function") {
            cleanup();
          } else {
            setRef(refs[i3], null);
          }
        }
      };
    }
  };
}
function useComposedRefs(...refs) {
  return reactExports.useCallback(composeRefs(...refs), refs);
}
function createContextScope(scopeName, createContextScopeDeps = []) {
  let defaultContexts = [];
  function createContext3(rootComponentName, defaultContext) {
    const BaseContext = reactExports.createContext(defaultContext);
    const index2 = defaultContexts.length;
    defaultContexts = [...defaultContexts, defaultContext];
    const Provider = (props) => {
      const { scope, children, ...context } = props;
      const Context = scope?.[scopeName]?.[index2] || BaseContext;
      const value = reactExports.useMemo(() => context, Object.values(context));
      return /* @__PURE__ */ jsxRuntimeExports.jsx(Context.Provider, { value, children });
    };
    Provider.displayName = rootComponentName + "Provider";
    function useContext2(consumerName, scope) {
      const Context = scope?.[scopeName]?.[index2] || BaseContext;
      const context = reactExports.useContext(Context);
      if (context) return context;
      if (defaultContext !== void 0) return defaultContext;
      throw new Error(`\`${consumerName}\` must be used within \`${rootComponentName}\``);
    }
    return [Provider, useContext2];
  }
  const createScope = () => {
    const scopeContexts = defaultContexts.map((defaultContext) => {
      return reactExports.createContext(defaultContext);
    });
    return function useScope(scope) {
      const contexts = scope?.[scopeName] || scopeContexts;
      return reactExports.useMemo(
        () => ({ [`__scope${scopeName}`]: { ...scope, [scopeName]: contexts } }),
        [scope, contexts]
      );
    };
  };
  createScope.scopeName = scopeName;
  return [createContext3, composeContextScopes(createScope, ...createContextScopeDeps)];
}
function composeContextScopes(...scopes) {
  const baseScope = scopes[0];
  if (scopes.length === 1) return baseScope;
  const createScope = () => {
    const scopeHooks = scopes.map((createScope2) => ({
      useScope: createScope2(),
      scopeName: createScope2.scopeName
    }));
    return function useComposedScopes(overrideScopes) {
      const nextScopes = scopeHooks.reduce((nextScopes2, { useScope, scopeName }) => {
        const scopeProps = useScope(overrideScopes);
        const currentScope = scopeProps[`__scope${scopeName}`];
        return { ...nextScopes2, ...currentScope };
      }, {});
      return reactExports.useMemo(() => ({ [`__scope${baseScope.scopeName}`]: nextScopes }), [nextScopes]);
    };
  };
  createScope.scopeName = baseScope.scopeName;
  return createScope;
}
var Slot = reactExports.forwardRef((props, forwardedRef) => {
  const { children, ...slotProps } = props;
  const childrenArray = reactExports.Children.toArray(children);
  const slottable = childrenArray.find(isSlottable);
  if (slottable) {
    const newElement = slottable.props.children;
    const newChildren = childrenArray.map((child) => {
      if (child === slottable) {
        if (reactExports.Children.count(newElement) > 1) return reactExports.Children.only(null);
        return reactExports.isValidElement(newElement) ? newElement.props.children : null;
      } else {
        return child;
      }
    });
    return /* @__PURE__ */ jsxRuntimeExports.jsx(SlotClone, { ...slotProps, ref: forwardedRef, children: reactExports.isValidElement(newElement) ? reactExports.cloneElement(newElement, void 0, newChildren) : null });
  }
  return /* @__PURE__ */ jsxRuntimeExports.jsx(SlotClone, { ...slotProps, ref: forwardedRef, children });
});
Slot.displayName = "Slot";
var SlotClone = reactExports.forwardRef((props, forwardedRef) => {
  const { children, ...slotProps } = props;
  if (reactExports.isValidElement(children)) {
    const childrenRef = getElementRef$1(children);
    const props2 = mergeProps(slotProps, children.props);
    if (children.type !== reactExports.Fragment) {
      props2.ref = forwardedRef ? composeRefs(forwardedRef, childrenRef) : childrenRef;
    }
    return reactExports.cloneElement(children, props2);
  }
  return reactExports.Children.count(children) > 1 ? reactExports.Children.only(null) : null;
});
SlotClone.displayName = "SlotClone";
var Slottable = ({ children }) => {
  return /* @__PURE__ */ jsxRuntimeExports.jsx(jsxRuntimeExports.Fragment, { children });
};
function isSlottable(child) {
  return reactExports.isValidElement(child) && child.type === Slottable;
}
function mergeProps(slotProps, childProps) {
  const overrideProps = { ...childProps };
  for (const propName in childProps) {
    const slotPropValue = slotProps[propName];
    const childPropValue = childProps[propName];
    const isHandler = /^on[A-Z]/.test(propName);
    if (isHandler) {
      if (slotPropValue && childPropValue) {
        overrideProps[propName] = (...args) => {
          childPropValue(...args);
          slotPropValue(...args);
        };
      } else if (slotPropValue) {
        overrideProps[propName] = slotPropValue;
      }
    } else if (propName === "style") {
      overrideProps[propName] = { ...slotPropValue, ...childPropValue };
    } else if (propName === "className") {
      overrideProps[propName] = [slotPropValue, childPropValue].filter(Boolean).join(" ");
    }
  }
  return { ...slotProps, ...overrideProps };
}
function getElementRef$1(element) {
  let getter = Object.getOwnPropertyDescriptor(element.props, "ref")?.get;
  let mayWarn = getter && "isReactWarning" in getter && getter.isReactWarning;
  if (mayWarn) {
    return element.ref;
  }
  getter = Object.getOwnPropertyDescriptor(element, "ref")?.get;
  mayWarn = getter && "isReactWarning" in getter && getter.isReactWarning;
  if (mayWarn) {
    return element.props.ref;
  }
  return element.props.ref || element.ref;
}
var NODES = [
  "a",
  "button",
  "div",
  "form",
  "h2",
  "h3",
  "img",
  "input",
  "label",
  "li",
  "nav",
  "ol",
  "p",
  "span",
  "svg",
  "ul"
];
var Primitive = NODES.reduce((primitive, node) => {
  const Node2 = reactExports.forwardRef((props, forwardedRef) => {
    const { asChild, ...primitiveProps } = props;
    const Comp = asChild ? Slot : node;
    if (typeof window !== "undefined") {
      window[Symbol.for("radix-ui")] = true;
    }
    return /* @__PURE__ */ jsxRuntimeExports.jsx(Comp, { ...primitiveProps, ref: forwardedRef });
  });
  Node2.displayName = `Primitive.${node}`;
  return { ...primitive, [node]: Node2 };
}, {});
function dispatchDiscreteCustomEvent(target, event) {
  if (target) reactDomExports.flushSync(() => target.dispatchEvent(event));
}
function useCallbackRef$1(callback) {
  const callbackRef = reactExports.useRef(callback);
  reactExports.useEffect(() => {
    callbackRef.current = callback;
  });
  return reactExports.useMemo(() => (...args) => callbackRef.current?.(...args), []);
}
function useEscapeKeydown(onEscapeKeyDownProp, ownerDocument = globalThis?.document) {
  const onEscapeKeyDown = useCallbackRef$1(onEscapeKeyDownProp);
  reactExports.useEffect(() => {
    const handleKeyDown = (event) => {
      if (event.key === "Escape") {
        onEscapeKeyDown(event);
      }
    };
    ownerDocument.addEventListener("keydown", handleKeyDown, { capture: true });
    return () => ownerDocument.removeEventListener("keydown", handleKeyDown, { capture: true });
  }, [onEscapeKeyDown, ownerDocument]);
}
var DISMISSABLE_LAYER_NAME = "DismissableLayer";
var CONTEXT_UPDATE = "dismissableLayer.update";
var POINTER_DOWN_OUTSIDE = "dismissableLayer.pointerDownOutside";
var FOCUS_OUTSIDE = "dismissableLayer.focusOutside";
var originalBodyPointerEvents;
var DismissableLayerContext = reactExports.createContext({
  layers: /* @__PURE__ */ new Set(),
  layersWithOutsidePointerEventsDisabled: /* @__PURE__ */ new Set(),
  branches: /* @__PURE__ */ new Set()
});
var DismissableLayer = reactExports.forwardRef(
  (props, forwardedRef) => {
    const {
      disableOutsidePointerEvents = false,
      onEscapeKeyDown,
      onPointerDownOutside,
      onFocusOutside,
      onInteractOutside,
      onDismiss,
      ...layerProps
    } = props;
    const context = reactExports.useContext(DismissableLayerContext);
    const [node, setNode] = reactExports.useState(null);
    const ownerDocument = node?.ownerDocument ?? globalThis?.document;
    const [, force] = reactExports.useState({});
    const composedRefs = useComposedRefs(forwardedRef, (node2) => setNode(node2));
    const layers = Array.from(context.layers);
    const [highestLayerWithOutsidePointerEventsDisabled] = [...context.layersWithOutsidePointerEventsDisabled].slice(-1);
    const highestLayerWithOutsidePointerEventsDisabledIndex = layers.indexOf(highestLayerWithOutsidePointerEventsDisabled);
    const index2 = node ? layers.indexOf(node) : -1;
    const isBodyPointerEventsDisabled = context.layersWithOutsidePointerEventsDisabled.size > 0;
    const isPointerEventsEnabled = index2 >= highestLayerWithOutsidePointerEventsDisabledIndex;
    const pointerDownOutside = usePointerDownOutside((event) => {
      const target = event.target;
      const isPointerDownOnBranch = [...context.branches].some((branch) => branch.contains(target));
      if (!isPointerEventsEnabled || isPointerDownOnBranch) return;
      onPointerDownOutside?.(event);
      onInteractOutside?.(event);
      if (!event.defaultPrevented) onDismiss?.();
    }, ownerDocument);
    const focusOutside = useFocusOutside((event) => {
      const target = event.target;
      const isFocusInBranch = [...context.branches].some((branch) => branch.contains(target));
      if (isFocusInBranch) return;
      onFocusOutside?.(event);
      onInteractOutside?.(event);
      if (!event.defaultPrevented) onDismiss?.();
    }, ownerDocument);
    useEscapeKeydown((event) => {
      const isHighestLayer = index2 === context.layers.size - 1;
      if (!isHighestLayer) return;
      onEscapeKeyDown?.(event);
      if (!event.defaultPrevented && onDismiss) {
        event.preventDefault();
        onDismiss();
      }
    }, ownerDocument);
    reactExports.useEffect(() => {
      if (!node) return;
      if (disableOutsidePointerEvents) {
        if (context.layersWithOutsidePointerEventsDisabled.size === 0) {
          originalBodyPointerEvents = ownerDocument.body.style.pointerEvents;
          ownerDocument.body.style.pointerEvents = "none";
        }
        context.layersWithOutsidePointerEventsDisabled.add(node);
      }
      context.layers.add(node);
      dispatchUpdate();
      return () => {
        if (disableOutsidePointerEvents && context.layersWithOutsidePointerEventsDisabled.size === 1) {
          ownerDocument.body.style.pointerEvents = originalBodyPointerEvents;
        }
      };
    }, [node, ownerDocument, disableOutsidePointerEvents, context]);
    reactExports.useEffect(() => {
      return () => {
        if (!node) return;
        context.layers.delete(node);
        context.layersWithOutsidePointerEventsDisabled.delete(node);
        dispatchUpdate();
      };
    }, [node, context]);
    reactExports.useEffect(() => {
      const handleUpdate = () => force({});
      document.addEventListener(CONTEXT_UPDATE, handleUpdate);
      return () => document.removeEventListener(CONTEXT_UPDATE, handleUpdate);
    }, []);
    return /* @__PURE__ */ jsxRuntimeExports.jsx(
      Primitive.div,
      {
        ...layerProps,
        ref: composedRefs,
        style: {
          pointerEvents: isBodyPointerEventsDisabled ? isPointerEventsEnabled ? "auto" : "none" : void 0,
          ...props.style
        },
        onFocusCapture: composeEventHandlers(props.onFocusCapture, focusOutside.onFocusCapture),
        onBlurCapture: composeEventHandlers(props.onBlurCapture, focusOutside.onBlurCapture),
        onPointerDownCapture: composeEventHandlers(
          props.onPointerDownCapture,
          pointerDownOutside.onPointerDownCapture
        )
      }
    );
  }
);
DismissableLayer.displayName = DISMISSABLE_LAYER_NAME;
var BRANCH_NAME = "DismissableLayerBranch";
var DismissableLayerBranch = reactExports.forwardRef((props, forwardedRef) => {
  const context = reactExports.useContext(DismissableLayerContext);
  const ref = reactExports.useRef(null);
  const composedRefs = useComposedRefs(forwardedRef, ref);
  reactExports.useEffect(() => {
    const node = ref.current;
    if (node) {
      context.branches.add(node);
      return () => {
        context.branches.delete(node);
      };
    }
  }, [context.branches]);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(Primitive.div, { ...props, ref: composedRefs });
});
DismissableLayerBranch.displayName = BRANCH_NAME;
function usePointerDownOutside(onPointerDownOutside, ownerDocument = globalThis?.document) {
  const handlePointerDownOutside = useCallbackRef$1(onPointerDownOutside);
  const isPointerInsideReactTreeRef = reactExports.useRef(false);
  const handleClickRef = reactExports.useRef(() => {
  });
  reactExports.useEffect(() => {
    const handlePointerDown = (event) => {
      if (event.target && !isPointerInsideReactTreeRef.current) {
        let handleAndDispatchPointerDownOutsideEvent2 = function() {
          handleAndDispatchCustomEvent(
            POINTER_DOWN_OUTSIDE,
            handlePointerDownOutside,
            eventDetail,
            { discrete: true }
          );
        };
        const eventDetail = { originalEvent: event };
        if (event.pointerType === "touch") {
          ownerDocument.removeEventListener("click", handleClickRef.current);
          handleClickRef.current = handleAndDispatchPointerDownOutsideEvent2;
          ownerDocument.addEventListener("click", handleClickRef.current, { once: true });
        } else {
          handleAndDispatchPointerDownOutsideEvent2();
        }
      } else {
        ownerDocument.removeEventListener("click", handleClickRef.current);
      }
      isPointerInsideReactTreeRef.current = false;
    };
    const timerId = window.setTimeout(() => {
      ownerDocument.addEventListener("pointerdown", handlePointerDown);
    }, 0);
    return () => {
      window.clearTimeout(timerId);
      ownerDocument.removeEventListener("pointerdown", handlePointerDown);
      ownerDocument.removeEventListener("click", handleClickRef.current);
    };
  }, [ownerDocument, handlePointerDownOutside]);
  return {
    // ensures we check React component tree (not just DOM tree)
    onPointerDownCapture: () => isPointerInsideReactTreeRef.current = true
  };
}
function useFocusOutside(onFocusOutside, ownerDocument = globalThis?.document) {
  const handleFocusOutside = useCallbackRef$1(onFocusOutside);
  const isFocusInsideReactTreeRef = reactExports.useRef(false);
  reactExports.useEffect(() => {
    const handleFocus = (event) => {
      if (event.target && !isFocusInsideReactTreeRef.current) {
        const eventDetail = { originalEvent: event };
        handleAndDispatchCustomEvent(FOCUS_OUTSIDE, handleFocusOutside, eventDetail, {
          discrete: false
        });
      }
    };
    ownerDocument.addEventListener("focusin", handleFocus);
    return () => ownerDocument.removeEventListener("focusin", handleFocus);
  }, [ownerDocument, handleFocusOutside]);
  return {
    onFocusCapture: () => isFocusInsideReactTreeRef.current = true,
    onBlurCapture: () => isFocusInsideReactTreeRef.current = false
  };
}
function dispatchUpdate() {
  const event = new CustomEvent(CONTEXT_UPDATE);
  document.dispatchEvent(event);
}
function handleAndDispatchCustomEvent(name, handler, detail, { discrete }) {
  const target = detail.originalEvent.target;
  const event = new CustomEvent(name, { bubbles: false, cancelable: true, detail });
  if (handler) target.addEventListener(name, handler, { once: true });
  if (discrete) {
    dispatchDiscreteCustomEvent(target, event);
  } else {
    target.dispatchEvent(event);
  }
}
var count$1 = 0;
function useFocusGuards() {
  reactExports.useEffect(() => {
    const edgeGuards = document.querySelectorAll("[data-radix-focus-guard]");
    document.body.insertAdjacentElement("afterbegin", edgeGuards[0] ?? createFocusGuard());
    document.body.insertAdjacentElement("beforeend", edgeGuards[1] ?? createFocusGuard());
    count$1++;
    return () => {
      if (count$1 === 1) {
        document.querySelectorAll("[data-radix-focus-guard]").forEach((node) => node.remove());
      }
      count$1--;
    };
  }, []);
}
function createFocusGuard() {
  const element = document.createElement("span");
  element.setAttribute("data-radix-focus-guard", "");
  element.tabIndex = 0;
  element.style.outline = "none";
  element.style.opacity = "0";
  element.style.position = "fixed";
  element.style.pointerEvents = "none";
  return element;
}
var AUTOFOCUS_ON_MOUNT = "focusScope.autoFocusOnMount";
var AUTOFOCUS_ON_UNMOUNT = "focusScope.autoFocusOnUnmount";
var EVENT_OPTIONS = { bubbles: false, cancelable: true };
var FOCUS_SCOPE_NAME = "FocusScope";
var FocusScope = reactExports.forwardRef((props, forwardedRef) => {
  const {
    loop = false,
    trapped = false,
    onMountAutoFocus: onMountAutoFocusProp,
    onUnmountAutoFocus: onUnmountAutoFocusProp,
    ...scopeProps
  } = props;
  const [container, setContainer] = reactExports.useState(null);
  const onMountAutoFocus = useCallbackRef$1(onMountAutoFocusProp);
  const onUnmountAutoFocus = useCallbackRef$1(onUnmountAutoFocusProp);
  const lastFocusedElementRef = reactExports.useRef(null);
  const composedRefs = useComposedRefs(forwardedRef, (node) => setContainer(node));
  const focusScope = reactExports.useRef({
    paused: false,
    pause() {
      this.paused = true;
    },
    resume() {
      this.paused = false;
    }
  }).current;
  reactExports.useEffect(() => {
    if (trapped) {
      let handleFocusIn2 = function(event) {
        if (focusScope.paused || !container) return;
        const target = event.target;
        if (container.contains(target)) {
          lastFocusedElementRef.current = target;
        } else {
          focus(lastFocusedElementRef.current, { select: true });
        }
      }, handleFocusOut2 = function(event) {
        if (focusScope.paused || !container) return;
        const relatedTarget = event.relatedTarget;
        if (relatedTarget === null) return;
        if (!container.contains(relatedTarget)) {
          focus(lastFocusedElementRef.current, { select: true });
        }
      }, handleMutations2 = function(mutations) {
        const focusedElement = document.activeElement;
        if (focusedElement !== document.body) return;
        for (const mutation of mutations) {
          if (mutation.removedNodes.length > 0) focus(container);
        }
      };
      document.addEventListener("focusin", handleFocusIn2);
      document.addEventListener("focusout", handleFocusOut2);
      const mutationObserver = new MutationObserver(handleMutations2);
      if (container) mutationObserver.observe(container, { childList: true, subtree: true });
      return () => {
        document.removeEventListener("focusin", handleFocusIn2);
        document.removeEventListener("focusout", handleFocusOut2);
        mutationObserver.disconnect();
      };
    }
  }, [trapped, container, focusScope.paused]);
  reactExports.useEffect(() => {
    if (container) {
      focusScopesStack.add(focusScope);
      const previouslyFocusedElement = document.activeElement;
      const hasFocusedCandidate = container.contains(previouslyFocusedElement);
      if (!hasFocusedCandidate) {
        const mountEvent = new CustomEvent(AUTOFOCUS_ON_MOUNT, EVENT_OPTIONS);
        container.addEventListener(AUTOFOCUS_ON_MOUNT, onMountAutoFocus);
        container.dispatchEvent(mountEvent);
        if (!mountEvent.defaultPrevented) {
          focusFirst(removeLinks(getTabbableCandidates(container)), { select: true });
          if (document.activeElement === previouslyFocusedElement) {
            focus(container);
          }
        }
      }
      return () => {
        container.removeEventListener(AUTOFOCUS_ON_MOUNT, onMountAutoFocus);
        setTimeout(() => {
          const unmountEvent = new CustomEvent(AUTOFOCUS_ON_UNMOUNT, EVENT_OPTIONS);
          container.addEventListener(AUTOFOCUS_ON_UNMOUNT, onUnmountAutoFocus);
          container.dispatchEvent(unmountEvent);
          if (!unmountEvent.defaultPrevented) {
            focus(previouslyFocusedElement ?? document.body, { select: true });
          }
          container.removeEventListener(AUTOFOCUS_ON_UNMOUNT, onUnmountAutoFocus);
          focusScopesStack.remove(focusScope);
        }, 0);
      };
    }
  }, [container, onMountAutoFocus, onUnmountAutoFocus, focusScope]);
  const handleKeyDown = reactExports.useCallback(
    (event) => {
      if (!loop && !trapped) return;
      if (focusScope.paused) return;
      const isTabKey = event.key === "Tab" && !event.altKey && !event.ctrlKey && !event.metaKey;
      const focusedElement = document.activeElement;
      if (isTabKey && focusedElement) {
        const container2 = event.currentTarget;
        const [first, last] = getTabbableEdges(container2);
        const hasTabbableElementsInside = first && last;
        if (!hasTabbableElementsInside) {
          if (focusedElement === container2) event.preventDefault();
        } else {
          if (!event.shiftKey && focusedElement === last) {
            event.preventDefault();
            if (loop) focus(first, { select: true });
          } else if (event.shiftKey && focusedElement === first) {
            event.preventDefault();
            if (loop) focus(last, { select: true });
          }
        }
      }
    },
    [loop, trapped, focusScope.paused]
  );
  return /* @__PURE__ */ jsxRuntimeExports.jsx(Primitive.div, { tabIndex: -1, ...scopeProps, ref: composedRefs, onKeyDown: handleKeyDown });
});
FocusScope.displayName = FOCUS_SCOPE_NAME;
function focusFirst(candidates, { select = false } = {}) {
  const previouslyFocusedElement = document.activeElement;
  for (const candidate of candidates) {
    focus(candidate, { select });
    if (document.activeElement !== previouslyFocusedElement) return;
  }
}
function getTabbableEdges(container) {
  const candidates = getTabbableCandidates(container);
  const first = findVisible(candidates, container);
  const last = findVisible(candidates.reverse(), container);
  return [first, last];
}
function getTabbableCandidates(container) {
  const nodes = [];
  const walker = document.createTreeWalker(container, NodeFilter.SHOW_ELEMENT, {
    acceptNode: (node) => {
      const isHiddenInput = node.tagName === "INPUT" && node.type === "hidden";
      if (node.disabled || node.hidden || isHiddenInput) return NodeFilter.FILTER_SKIP;
      return node.tabIndex >= 0 ? NodeFilter.FILTER_ACCEPT : NodeFilter.FILTER_SKIP;
    }
  });
  while (walker.nextNode()) nodes.push(walker.currentNode);
  return nodes;
}
function findVisible(elements, container) {
  for (const element of elements) {
    if (!isHidden(element, { upTo: container })) return element;
  }
}
function isHidden(node, { upTo }) {
  if (getComputedStyle(node).visibility === "hidden") return true;
  while (node) {
    if (upTo !== void 0 && node === upTo) return false;
    if (getComputedStyle(node).display === "none") return true;
    node = node.parentElement;
  }
  return false;
}
function isSelectableInput(element) {
  return element instanceof HTMLInputElement && "select" in element;
}
function focus(element, { select = false } = {}) {
  if (element && element.focus) {
    const previouslyFocusedElement = document.activeElement;
    element.focus({ preventScroll: true });
    if (element !== previouslyFocusedElement && isSelectableInput(element) && select)
      element.select();
  }
}
var focusScopesStack = createFocusScopesStack();
function createFocusScopesStack() {
  let stack = [];
  return {
    add(focusScope) {
      const activeFocusScope = stack[0];
      if (focusScope !== activeFocusScope) {
        activeFocusScope?.pause();
      }
      stack = arrayRemove(stack, focusScope);
      stack.unshift(focusScope);
    },
    remove(focusScope) {
      stack = arrayRemove(stack, focusScope);
      stack[0]?.resume();
    }
  };
}
function arrayRemove(array, item) {
  const updatedArray = [...array];
  const index2 = updatedArray.indexOf(item);
  if (index2 !== -1) {
    updatedArray.splice(index2, 1);
  }
  return updatedArray;
}
function removeLinks(items) {
  return items.filter((item) => item.tagName !== "A");
}
var useLayoutEffect2 = Boolean(globalThis?.document) ? reactExports.useLayoutEffect : () => {
};
var useReactId = $2AODx$react["useId".toString()] || (() => void 0);
var count = 0;
function useId(deterministicId) {
  const [id2, setId] = reactExports.useState(useReactId());
  useLayoutEffect2(() => {
    setId((reactId) => reactId ?? String(count++));
  }, [deterministicId]);
  return deterministicId || (id2 ? `radix-${id2}` : "");
}
const sides = ["top", "right", "bottom", "left"];
const min = Math.min;
const max = Math.max;
const round = Math.round;
const floor = Math.floor;
const createCoords = (v3) => ({
  x: v3,
  y: v3
});
const oppositeSideMap = {
  left: "right",
  right: "left",
  bottom: "top",
  top: "bottom"
};
const oppositeAlignmentMap = {
  start: "end",
  end: "start"
};
function clamp(start, value, end) {
  return max(start, min(value, end));
}
function evaluate(value, param) {
  return typeof value === "function" ? value(param) : value;
}
function getSide(placement) {
  return placement.split("-")[0];
}
function getAlignment(placement) {
  return placement.split("-")[1];
}
function getOppositeAxis(axis) {
  return axis === "x" ? "y" : "x";
}
function getAxisLength(axis) {
  return axis === "y" ? "height" : "width";
}
const yAxisSides = /* @__PURE__ */ new Set(["top", "bottom"]);
function getSideAxis(placement) {
  return yAxisSides.has(getSide(placement)) ? "y" : "x";
}
function getAlignmentAxis(placement) {
  return getOppositeAxis(getSideAxis(placement));
}
function getAlignmentSides(placement, rects, rtl) {
  if (rtl === void 0) {
    rtl = false;
  }
  const alignment = getAlignment(placement);
  const alignmentAxis = getAlignmentAxis(placement);
  const length = getAxisLength(alignmentAxis);
  let mainAlignmentSide = alignmentAxis === "x" ? alignment === (rtl ? "end" : "start") ? "right" : "left" : alignment === "start" ? "bottom" : "top";
  if (rects.reference[length] > rects.floating[length]) {
    mainAlignmentSide = getOppositePlacement(mainAlignmentSide);
  }
  return [mainAlignmentSide, getOppositePlacement(mainAlignmentSide)];
}
function getExpandedPlacements(placement) {
  const oppositePlacement = getOppositePlacement(placement);
  return [getOppositeAlignmentPlacement(placement), oppositePlacement, getOppositeAlignmentPlacement(oppositePlacement)];
}
function getOppositeAlignmentPlacement(placement) {
  return placement.replace(/start|end/g, (alignment) => oppositeAlignmentMap[alignment]);
}
const lrPlacement = ["left", "right"];
const rlPlacement = ["right", "left"];
const tbPlacement = ["top", "bottom"];
const btPlacement = ["bottom", "top"];
function getSideList(side, isStart, rtl) {
  switch (side) {
    case "top":
    case "bottom":
      if (rtl) return isStart ? rlPlacement : lrPlacement;
      return isStart ? lrPlacement : rlPlacement;
    case "left":
    case "right":
      return isStart ? tbPlacement : btPlacement;
    default:
      return [];
  }
}
function getOppositeAxisPlacements(placement, flipAlignment, direction, rtl) {
  const alignment = getAlignment(placement);
  let list = getSideList(getSide(placement), direction === "start", rtl);
  if (alignment) {
    list = list.map((side) => side + "-" + alignment);
    if (flipAlignment) {
      list = list.concat(list.map(getOppositeAlignmentPlacement));
    }
  }
  return list;
}
function getOppositePlacement(placement) {
  return placement.replace(/left|right|bottom|top/g, (side) => oppositeSideMap[side]);
}
function expandPaddingObject(padding) {
  return {
    top: 0,
    right: 0,
    bottom: 0,
    left: 0,
    ...padding
  };
}
function getPaddingObject(padding) {
  return typeof padding !== "number" ? expandPaddingObject(padding) : {
    top: padding,
    right: padding,
    bottom: padding,
    left: padding
  };
}
function rectToClientRect(rect) {
  const {
    x: x3,
    y: y3,
    width,
    height
  } = rect;
  return {
    width,
    height,
    top: y3,
    left: x3,
    right: x3 + width,
    bottom: y3 + height,
    x: x3,
    y: y3
  };
}
function computeCoordsFromPlacement(_ref, placement, rtl) {
  let {
    reference,
    floating
  } = _ref;
  const sideAxis = getSideAxis(placement);
  const alignmentAxis = getAlignmentAxis(placement);
  const alignLength = getAxisLength(alignmentAxis);
  const side = getSide(placement);
  const isVertical = sideAxis === "y";
  const commonX = reference.x + reference.width / 2 - floating.width / 2;
  const commonY = reference.y + reference.height / 2 - floating.height / 2;
  const commonAlign = reference[alignLength] / 2 - floating[alignLength] / 2;
  let coords;
  switch (side) {
    case "top":
      coords = {
        x: commonX,
        y: reference.y - floating.height
      };
      break;
    case "bottom":
      coords = {
        x: commonX,
        y: reference.y + reference.height
      };
      break;
    case "right":
      coords = {
        x: reference.x + reference.width,
        y: commonY
      };
      break;
    case "left":
      coords = {
        x: reference.x - floating.width,
        y: commonY
      };
      break;
    default:
      coords = {
        x: reference.x,
        y: reference.y
      };
  }
  switch (getAlignment(placement)) {
    case "start":
      coords[alignmentAxis] -= commonAlign * (rtl && isVertical ? -1 : 1);
      break;
    case "end":
      coords[alignmentAxis] += commonAlign * (rtl && isVertical ? -1 : 1);
      break;
  }
  return coords;
}
const computePosition$1 = async (reference, floating, config) => {
  const {
    placement = "bottom",
    strategy = "absolute",
    middleware = [],
    platform: platform2
  } = config;
  const validMiddleware = middleware.filter(Boolean);
  const rtl = await (platform2.isRTL == null ? void 0 : platform2.isRTL(floating));
  let rects = await platform2.getElementRects({
    reference,
    floating,
    strategy
  });
  let {
    x: x3,
    y: y3
  } = computeCoordsFromPlacement(rects, placement, rtl);
  let statefulPlacement = placement;
  let middlewareData = {};
  let resetCount = 0;
  for (let i3 = 0; i3 < validMiddleware.length; i3++) {
    const {
      name,
      fn: fn2
    } = validMiddleware[i3];
    const {
      x: nextX,
      y: nextY,
      data,
      reset
    } = await fn2({
      x: x3,
      y: y3,
      initialPlacement: placement,
      placement: statefulPlacement,
      strategy,
      middlewareData,
      rects,
      platform: platform2,
      elements: {
        reference,
        floating
      }
    });
    x3 = nextX != null ? nextX : x3;
    y3 = nextY != null ? nextY : y3;
    middlewareData = {
      ...middlewareData,
      [name]: {
        ...middlewareData[name],
        ...data
      }
    };
    if (reset && resetCount <= 50) {
      resetCount++;
      if (typeof reset === "object") {
        if (reset.placement) {
          statefulPlacement = reset.placement;
        }
        if (reset.rects) {
          rects = reset.rects === true ? await platform2.getElementRects({
            reference,
            floating,
            strategy
          }) : reset.rects;
        }
        ({
          x: x3,
          y: y3
        } = computeCoordsFromPlacement(rects, statefulPlacement, rtl));
      }
      i3 = -1;
    }
  }
  return {
    x: x3,
    y: y3,
    placement: statefulPlacement,
    strategy,
    middlewareData
  };
};
async function detectOverflow(state, options) {
  var _await$platform$isEle;
  if (options === void 0) {
    options = {};
  }
  const {
    x: x3,
    y: y3,
    platform: platform2,
    rects,
    elements,
    strategy
  } = state;
  const {
    boundary = "clippingAncestors",
    rootBoundary = "viewport",
    elementContext = "floating",
    altBoundary = false,
    padding = 0
  } = evaluate(options, state);
  const paddingObject = getPaddingObject(padding);
  const altContext = elementContext === "floating" ? "reference" : "floating";
  const element = elements[altBoundary ? altContext : elementContext];
  const clippingClientRect = rectToClientRect(await platform2.getClippingRect({
    element: ((_await$platform$isEle = await (platform2.isElement == null ? void 0 : platform2.isElement(element))) != null ? _await$platform$isEle : true) ? element : element.contextElement || await (platform2.getDocumentElement == null ? void 0 : platform2.getDocumentElement(elements.floating)),
    boundary,
    rootBoundary,
    strategy
  }));
  const rect = elementContext === "floating" ? {
    x: x3,
    y: y3,
    width: rects.floating.width,
    height: rects.floating.height
  } : rects.reference;
  const offsetParent = await (platform2.getOffsetParent == null ? void 0 : platform2.getOffsetParent(elements.floating));
  const offsetScale = await (platform2.isElement == null ? void 0 : platform2.isElement(offsetParent)) ? await (platform2.getScale == null ? void 0 : platform2.getScale(offsetParent)) || {
    x: 1,
    y: 1
  } : {
    x: 1,
    y: 1
  };
  const elementClientRect = rectToClientRect(platform2.convertOffsetParentRelativeRectToViewportRelativeRect ? await platform2.convertOffsetParentRelativeRectToViewportRelativeRect({
    elements,
    rect,
    offsetParent,
    strategy
  }) : rect);
  return {
    top: (clippingClientRect.top - elementClientRect.top + paddingObject.top) / offsetScale.y,
    bottom: (elementClientRect.bottom - clippingClientRect.bottom + paddingObject.bottom) / offsetScale.y,
    left: (clippingClientRect.left - elementClientRect.left + paddingObject.left) / offsetScale.x,
    right: (elementClientRect.right - clippingClientRect.right + paddingObject.right) / offsetScale.x
  };
}
const arrow$3 = (options) => ({
  name: "arrow",
  options,
  async fn(state) {
    const {
      x: x3,
      y: y3,
      placement,
      rects,
      platform: platform2,
      elements,
      middlewareData
    } = state;
    const {
      element,
      padding = 0
    } = evaluate(options, state) || {};
    if (element == null) {
      return {};
    }
    const paddingObject = getPaddingObject(padding);
    const coords = {
      x: x3,
      y: y3
    };
    const axis = getAlignmentAxis(placement);
    const length = getAxisLength(axis);
    const arrowDimensions = await platform2.getDimensions(element);
    const isYAxis = axis === "y";
    const minProp = isYAxis ? "top" : "left";
    const maxProp = isYAxis ? "bottom" : "right";
    const clientProp = isYAxis ? "clientHeight" : "clientWidth";
    const endDiff = rects.reference[length] + rects.reference[axis] - coords[axis] - rects.floating[length];
    const startDiff = coords[axis] - rects.reference[axis];
    const arrowOffsetParent = await (platform2.getOffsetParent == null ? void 0 : platform2.getOffsetParent(element));
    let clientSize = arrowOffsetParent ? arrowOffsetParent[clientProp] : 0;
    if (!clientSize || !await (platform2.isElement == null ? void 0 : platform2.isElement(arrowOffsetParent))) {
      clientSize = elements.floating[clientProp] || rects.floating[length];
    }
    const centerToReference = endDiff / 2 - startDiff / 2;
    const largestPossiblePadding = clientSize / 2 - arrowDimensions[length] / 2 - 1;
    const minPadding = min(paddingObject[minProp], largestPossiblePadding);
    const maxPadding = min(paddingObject[maxProp], largestPossiblePadding);
    const min$1 = minPadding;
    const max2 = clientSize - arrowDimensions[length] - maxPadding;
    const center = clientSize / 2 - arrowDimensions[length] / 2 + centerToReference;
    const offset2 = clamp(min$1, center, max2);
    const shouldAddOffset = !middlewareData.arrow && getAlignment(placement) != null && center !== offset2 && rects.reference[length] / 2 - (center < min$1 ? minPadding : maxPadding) - arrowDimensions[length] / 2 < 0;
    const alignmentOffset = shouldAddOffset ? center < min$1 ? center - min$1 : center - max2 : 0;
    return {
      [axis]: coords[axis] + alignmentOffset,
      data: {
        [axis]: offset2,
        centerOffset: center - offset2 - alignmentOffset,
        ...shouldAddOffset && {
          alignmentOffset
        }
      },
      reset: shouldAddOffset
    };
  }
});
const flip$2 = function(options) {
  if (options === void 0) {
    options = {};
  }
  return {
    name: "flip",
    options,
    async fn(state) {
      var _middlewareData$arrow, _middlewareData$flip;
      const {
        placement,
        middlewareData,
        rects,
        initialPlacement,
        platform: platform2,
        elements
      } = state;
      const {
        mainAxis: checkMainAxis = true,
        crossAxis: checkCrossAxis = true,
        fallbackPlacements: specifiedFallbackPlacements,
        fallbackStrategy = "bestFit",
        fallbackAxisSideDirection = "none",
        flipAlignment = true,
        ...detectOverflowOptions
      } = evaluate(options, state);
      if ((_middlewareData$arrow = middlewareData.arrow) != null && _middlewareData$arrow.alignmentOffset) {
        return {};
      }
      const side = getSide(placement);
      const initialSideAxis = getSideAxis(initialPlacement);
      const isBasePlacement = getSide(initialPlacement) === initialPlacement;
      const rtl = await (platform2.isRTL == null ? void 0 : platform2.isRTL(elements.floating));
      const fallbackPlacements = specifiedFallbackPlacements || (isBasePlacement || !flipAlignment ? [getOppositePlacement(initialPlacement)] : getExpandedPlacements(initialPlacement));
      const hasFallbackAxisSideDirection = fallbackAxisSideDirection !== "none";
      if (!specifiedFallbackPlacements && hasFallbackAxisSideDirection) {
        fallbackPlacements.push(...getOppositeAxisPlacements(initialPlacement, flipAlignment, fallbackAxisSideDirection, rtl));
      }
      const placements = [initialPlacement, ...fallbackPlacements];
      const overflow = await detectOverflow(state, detectOverflowOptions);
      const overflows = [];
      let overflowsData = ((_middlewareData$flip = middlewareData.flip) == null ? void 0 : _middlewareData$flip.overflows) || [];
      if (checkMainAxis) {
        overflows.push(overflow[side]);
      }
      if (checkCrossAxis) {
        const sides2 = getAlignmentSides(placement, rects, rtl);
        overflows.push(overflow[sides2[0]], overflow[sides2[1]]);
      }
      overflowsData = [...overflowsData, {
        placement,
        overflows
      }];
      if (!overflows.every((side2) => side2 <= 0)) {
        var _middlewareData$flip2, _overflowsData$filter;
        const nextIndex = (((_middlewareData$flip2 = middlewareData.flip) == null ? void 0 : _middlewareData$flip2.index) || 0) + 1;
        const nextPlacement = placements[nextIndex];
        if (nextPlacement) {
          const ignoreCrossAxisOverflow = checkCrossAxis === "alignment" ? initialSideAxis !== getSideAxis(nextPlacement) : false;
          if (!ignoreCrossAxisOverflow || // We leave the current main axis only if every placement on that axis
          // overflows the main axis.
          overflowsData.every((d3) => getSideAxis(d3.placement) === initialSideAxis ? d3.overflows[0] > 0 : true)) {
            return {
              data: {
                index: nextIndex,
                overflows: overflowsData
              },
              reset: {
                placement: nextPlacement
              }
            };
          }
        }
        let resetPlacement = (_overflowsData$filter = overflowsData.filter((d3) => d3.overflows[0] <= 0).sort((a3, b3) => a3.overflows[1] - b3.overflows[1])[0]) == null ? void 0 : _overflowsData$filter.placement;
        if (!resetPlacement) {
          switch (fallbackStrategy) {
            case "bestFit": {
              var _overflowsData$filter2;
              const placement2 = (_overflowsData$filter2 = overflowsData.filter((d3) => {
                if (hasFallbackAxisSideDirection) {
                  const currentSideAxis = getSideAxis(d3.placement);
                  return currentSideAxis === initialSideAxis || // Create a bias to the `y` side axis due to horizontal
                  // reading directions favoring greater width.
                  currentSideAxis === "y";
                }
                return true;
              }).map((d3) => [d3.placement, d3.overflows.filter((overflow2) => overflow2 > 0).reduce((acc, overflow2) => acc + overflow2, 0)]).sort((a3, b3) => a3[1] - b3[1])[0]) == null ? void 0 : _overflowsData$filter2[0];
              if (placement2) {
                resetPlacement = placement2;
              }
              break;
            }
            case "initialPlacement":
              resetPlacement = initialPlacement;
              break;
          }
        }
        if (placement !== resetPlacement) {
          return {
            reset: {
              placement: resetPlacement
            }
          };
        }
      }
      return {};
    }
  };
};
function getSideOffsets(overflow, rect) {
  return {
    top: overflow.top - rect.height,
    right: overflow.right - rect.width,
    bottom: overflow.bottom - rect.height,
    left: overflow.left - rect.width
  };
}
function isAnySideFullyClipped(overflow) {
  return sides.some((side) => overflow[side] >= 0);
}
const hide$2 = function(options) {
  if (options === void 0) {
    options = {};
  }
  return {
    name: "hide",
    options,
    async fn(state) {
      const {
        rects
      } = state;
      const {
        strategy = "referenceHidden",
        ...detectOverflowOptions
      } = evaluate(options, state);
      switch (strategy) {
        case "referenceHidden": {
          const overflow = await detectOverflow(state, {
            ...detectOverflowOptions,
            elementContext: "reference"
          });
          const offsets = getSideOffsets(overflow, rects.reference);
          return {
            data: {
              referenceHiddenOffsets: offsets,
              referenceHidden: isAnySideFullyClipped(offsets)
            }
          };
        }
        case "escaped": {
          const overflow = await detectOverflow(state, {
            ...detectOverflowOptions,
            altBoundary: true
          });
          const offsets = getSideOffsets(overflow, rects.floating);
          return {
            data: {
              escapedOffsets: offsets,
              escaped: isAnySideFullyClipped(offsets)
            }
          };
        }
        default: {
          return {};
        }
      }
    }
  };
};
const originSides = /* @__PURE__ */ new Set(["left", "top"]);
async function convertValueToCoords(state, options) {
  const {
    placement,
    platform: platform2,
    elements
  } = state;
  const rtl = await (platform2.isRTL == null ? void 0 : platform2.isRTL(elements.floating));
  const side = getSide(placement);
  const alignment = getAlignment(placement);
  const isVertical = getSideAxis(placement) === "y";
  const mainAxisMulti = originSides.has(side) ? -1 : 1;
  const crossAxisMulti = rtl && isVertical ? -1 : 1;
  const rawValue = evaluate(options, state);
  let {
    mainAxis,
    crossAxis,
    alignmentAxis
  } = typeof rawValue === "number" ? {
    mainAxis: rawValue,
    crossAxis: 0,
    alignmentAxis: null
  } : {
    mainAxis: rawValue.mainAxis || 0,
    crossAxis: rawValue.crossAxis || 0,
    alignmentAxis: rawValue.alignmentAxis
  };
  if (alignment && typeof alignmentAxis === "number") {
    crossAxis = alignment === "end" ? alignmentAxis * -1 : alignmentAxis;
  }
  return isVertical ? {
    x: crossAxis * crossAxisMulti,
    y: mainAxis * mainAxisMulti
  } : {
    x: mainAxis * mainAxisMulti,
    y: crossAxis * crossAxisMulti
  };
}
const offset$2 = function(options) {
  if (options === void 0) {
    options = 0;
  }
  return {
    name: "offset",
    options,
    async fn(state) {
      var _middlewareData$offse, _middlewareData$arrow;
      const {
        x: x3,
        y: y3,
        placement,
        middlewareData
      } = state;
      const diffCoords = await convertValueToCoords(state, options);
      if (placement === ((_middlewareData$offse = middlewareData.offset) == null ? void 0 : _middlewareData$offse.placement) && (_middlewareData$arrow = middlewareData.arrow) != null && _middlewareData$arrow.alignmentOffset) {
        return {};
      }
      return {
        x: x3 + diffCoords.x,
        y: y3 + diffCoords.y,
        data: {
          ...diffCoords,
          placement
        }
      };
    }
  };
};
const shift$2 = function(options) {
  if (options === void 0) {
    options = {};
  }
  return {
    name: "shift",
    options,
    async fn(state) {
      const {
        x: x3,
        y: y3,
        placement
      } = state;
      const {
        mainAxis: checkMainAxis = true,
        crossAxis: checkCrossAxis = false,
        limiter = {
          fn: (_ref) => {
            let {
              x: x8,
              y: y4
            } = _ref;
            return {
              x: x8,
              y: y4
            };
          }
        },
        ...detectOverflowOptions
      } = evaluate(options, state);
      const coords = {
        x: x3,
        y: y3
      };
      const overflow = await detectOverflow(state, detectOverflowOptions);
      const crossAxis = getSideAxis(getSide(placement));
      const mainAxis = getOppositeAxis(crossAxis);
      let mainAxisCoord = coords[mainAxis];
      let crossAxisCoord = coords[crossAxis];
      if (checkMainAxis) {
        const minSide = mainAxis === "y" ? "top" : "left";
        const maxSide = mainAxis === "y" ? "bottom" : "right";
        const min2 = mainAxisCoord + overflow[minSide];
        const max2 = mainAxisCoord - overflow[maxSide];
        mainAxisCoord = clamp(min2, mainAxisCoord, max2);
      }
      if (checkCrossAxis) {
        const minSide = crossAxis === "y" ? "top" : "left";
        const maxSide = crossAxis === "y" ? "bottom" : "right";
        const min2 = crossAxisCoord + overflow[minSide];
        const max2 = crossAxisCoord - overflow[maxSide];
        crossAxisCoord = clamp(min2, crossAxisCoord, max2);
      }
      const limitedCoords = limiter.fn({
        ...state,
        [mainAxis]: mainAxisCoord,
        [crossAxis]: crossAxisCoord
      });
      return {
        ...limitedCoords,
        data: {
          x: limitedCoords.x - x3,
          y: limitedCoords.y - y3,
          enabled: {
            [mainAxis]: checkMainAxis,
            [crossAxis]: checkCrossAxis
          }
        }
      };
    }
  };
};
const limitShift$2 = function(options) {
  if (options === void 0) {
    options = {};
  }
  return {
    options,
    fn(state) {
      const {
        x: x3,
        y: y3,
        placement,
        rects,
        middlewareData
      } = state;
      const {
        offset: offset2 = 0,
        mainAxis: checkMainAxis = true,
        crossAxis: checkCrossAxis = true
      } = evaluate(options, state);
      const coords = {
        x: x3,
        y: y3
      };
      const crossAxis = getSideAxis(placement);
      const mainAxis = getOppositeAxis(crossAxis);
      let mainAxisCoord = coords[mainAxis];
      let crossAxisCoord = coords[crossAxis];
      const rawOffset = evaluate(offset2, state);
      const computedOffset = typeof rawOffset === "number" ? {
        mainAxis: rawOffset,
        crossAxis: 0
      } : {
        mainAxis: 0,
        crossAxis: 0,
        ...rawOffset
      };
      if (checkMainAxis) {
        const len = mainAxis === "y" ? "height" : "width";
        const limitMin = rects.reference[mainAxis] - rects.floating[len] + computedOffset.mainAxis;
        const limitMax = rects.reference[mainAxis] + rects.reference[len] - computedOffset.mainAxis;
        if (mainAxisCoord < limitMin) {
          mainAxisCoord = limitMin;
        } else if (mainAxisCoord > limitMax) {
          mainAxisCoord = limitMax;
        }
      }
      if (checkCrossAxis) {
        var _middlewareData$offse, _middlewareData$offse2;
        const len = mainAxis === "y" ? "width" : "height";
        const isOriginSide = originSides.has(getSide(placement));
        const limitMin = rects.reference[crossAxis] - rects.floating[len] + (isOriginSide ? ((_middlewareData$offse = middlewareData.offset) == null ? void 0 : _middlewareData$offse[crossAxis]) || 0 : 0) + (isOriginSide ? 0 : computedOffset.crossAxis);
        const limitMax = rects.reference[crossAxis] + rects.reference[len] + (isOriginSide ? 0 : ((_middlewareData$offse2 = middlewareData.offset) == null ? void 0 : _middlewareData$offse2[crossAxis]) || 0) - (isOriginSide ? computedOffset.crossAxis : 0);
        if (crossAxisCoord < limitMin) {
          crossAxisCoord = limitMin;
        } else if (crossAxisCoord > limitMax) {
          crossAxisCoord = limitMax;
        }
      }
      return {
        [mainAxis]: mainAxisCoord,
        [crossAxis]: crossAxisCoord
      };
    }
  };
};
const size$2 = function(options) {
  if (options === void 0) {
    options = {};
  }
  return {
    name: "size",
    options,
    async fn(state) {
      var _state$middlewareData, _state$middlewareData2;
      const {
        placement,
        rects,
        platform: platform2,
        elements
      } = state;
      const {
        apply = () => {
        },
        ...detectOverflowOptions
      } = evaluate(options, state);
      const overflow = await detectOverflow(state, detectOverflowOptions);
      const side = getSide(placement);
      const alignment = getAlignment(placement);
      const isYAxis = getSideAxis(placement) === "y";
      const {
        width,
        height
      } = rects.floating;
      let heightSide;
      let widthSide;
      if (side === "top" || side === "bottom") {
        heightSide = side;
        widthSide = alignment === (await (platform2.isRTL == null ? void 0 : platform2.isRTL(elements.floating)) ? "start" : "end") ? "left" : "right";
      } else {
        widthSide = side;
        heightSide = alignment === "end" ? "top" : "bottom";
      }
      const maximumClippingHeight = height - overflow.top - overflow.bottom;
      const maximumClippingWidth = width - overflow.left - overflow.right;
      const overflowAvailableHeight = min(height - overflow[heightSide], maximumClippingHeight);
      const overflowAvailableWidth = min(width - overflow[widthSide], maximumClippingWidth);
      const noShift = !state.middlewareData.shift;
      let availableHeight = overflowAvailableHeight;
      let availableWidth = overflowAvailableWidth;
      if ((_state$middlewareData = state.middlewareData.shift) != null && _state$middlewareData.enabled.x) {
        availableWidth = maximumClippingWidth;
      }
      if ((_state$middlewareData2 = state.middlewareData.shift) != null && _state$middlewareData2.enabled.y) {
        availableHeight = maximumClippingHeight;
      }
      if (noShift && !alignment) {
        const xMin = max(overflow.left, 0);
        const xMax = max(overflow.right, 0);
        const yMin = max(overflow.top, 0);
        const yMax = max(overflow.bottom, 0);
        if (isYAxis) {
          availableWidth = width - 2 * (xMin !== 0 || xMax !== 0 ? xMin + xMax : max(overflow.left, overflow.right));
        } else {
          availableHeight = height - 2 * (yMin !== 0 || yMax !== 0 ? yMin + yMax : max(overflow.top, overflow.bottom));
        }
      }
      await apply({
        ...state,
        availableWidth,
        availableHeight
      });
      const nextDimensions = await platform2.getDimensions(elements.floating);
      if (width !== nextDimensions.width || height !== nextDimensions.height) {
        return {
          reset: {
            rects: true
          }
        };
      }
      return {};
    }
  };
};
function hasWindow() {
  return typeof window !== "undefined";
}
function getNodeName(node) {
  if (isNode(node)) {
    return (node.nodeName || "").toLowerCase();
  }
  return "#document";
}
function getWindow(node) {
  var _node$ownerDocument;
  return (node == null || (_node$ownerDocument = node.ownerDocument) == null ? void 0 : _node$ownerDocument.defaultView) || window;
}
function getDocumentElement(node) {
  var _ref;
  return (_ref = (isNode(node) ? node.ownerDocument : node.document) || window.document) == null ? void 0 : _ref.documentElement;
}
function isNode(value) {
  if (!hasWindow()) {
    return false;
  }
  return value instanceof Node || value instanceof getWindow(value).Node;
}
function isElement(value) {
  if (!hasWindow()) {
    return false;
  }
  return value instanceof Element || value instanceof getWindow(value).Element;
}
function isHTMLElement(value) {
  if (!hasWindow()) {
    return false;
  }
  return value instanceof HTMLElement || value instanceof getWindow(value).HTMLElement;
}
function isShadowRoot(value) {
  if (!hasWindow() || typeof ShadowRoot === "undefined") {
    return false;
  }
  return value instanceof ShadowRoot || value instanceof getWindow(value).ShadowRoot;
}
const invalidOverflowDisplayValues = /* @__PURE__ */ new Set(["inline", "contents"]);
function isOverflowElement(element) {
  const {
    overflow,
    overflowX,
    overflowY,
    display
  } = getComputedStyle$1(element);
  return /auto|scroll|overlay|hidden|clip/.test(overflow + overflowY + overflowX) && !invalidOverflowDisplayValues.has(display);
}
const tableElements = /* @__PURE__ */ new Set(["table", "td", "th"]);
function isTableElement(element) {
  return tableElements.has(getNodeName(element));
}
const topLayerSelectors = [":popover-open", ":modal"];
function isTopLayer(element) {
  return topLayerSelectors.some((selector) => {
    try {
      return element.matches(selector);
    } catch (_e2) {
      return false;
    }
  });
}
const transformProperties = ["transform", "translate", "scale", "rotate", "perspective"];
const willChangeValues = ["transform", "translate", "scale", "rotate", "perspective", "filter"];
const containValues = ["paint", "layout", "strict", "content"];
function isContainingBlock(elementOrCss) {
  const webkit = isWebKit();
  const css = isElement(elementOrCss) ? getComputedStyle$1(elementOrCss) : elementOrCss;
  return transformProperties.some((value) => css[value] ? css[value] !== "none" : false) || (css.containerType ? css.containerType !== "normal" : false) || !webkit && (css.backdropFilter ? css.backdropFilter !== "none" : false) || !webkit && (css.filter ? css.filter !== "none" : false) || willChangeValues.some((value) => (css.willChange || "").includes(value)) || containValues.some((value) => (css.contain || "").includes(value));
}
function getContainingBlock(element) {
  let currentNode = getParentNode(element);
  while (isHTMLElement(currentNode) && !isLastTraversableNode(currentNode)) {
    if (isContainingBlock(currentNode)) {
      return currentNode;
    } else if (isTopLayer(currentNode)) {
      return null;
    }
    currentNode = getParentNode(currentNode);
  }
  return null;
}
function isWebKit() {
  if (typeof CSS === "undefined" || !CSS.supports) return false;
  return CSS.supports("-webkit-backdrop-filter", "none");
}
const lastTraversableNodeNames = /* @__PURE__ */ new Set(["html", "body", "#document"]);
function isLastTraversableNode(node) {
  return lastTraversableNodeNames.has(getNodeName(node));
}
function getComputedStyle$1(element) {
  return getWindow(element).getComputedStyle(element);
}
function getNodeScroll(element) {
  if (isElement(element)) {
    return {
      scrollLeft: element.scrollLeft,
      scrollTop: element.scrollTop
    };
  }
  return {
    scrollLeft: element.scrollX,
    scrollTop: element.scrollY
  };
}
function getParentNode(node) {
  if (getNodeName(node) === "html") {
    return node;
  }
  const result = (
    // Step into the shadow DOM of the parent of a slotted node.
    node.assignedSlot || // DOM Element detected.
    node.parentNode || // ShadowRoot detected.
    isShadowRoot(node) && node.host || // Fallback.
    getDocumentElement(node)
  );
  return isShadowRoot(result) ? result.host : result;
}
function getNearestOverflowAncestor(node) {
  const parentNode = getParentNode(node);
  if (isLastTraversableNode(parentNode)) {
    return node.ownerDocument ? node.ownerDocument.body : node.body;
  }
  if (isHTMLElement(parentNode) && isOverflowElement(parentNode)) {
    return parentNode;
  }
  return getNearestOverflowAncestor(parentNode);
}
function getOverflowAncestors(node, list, traverseIframes) {
  var _node$ownerDocument2;
  if (list === void 0) {
    list = [];
  }
  if (traverseIframes === void 0) {
    traverseIframes = true;
  }
  const scrollableAncestor = getNearestOverflowAncestor(node);
  const isBody = scrollableAncestor === ((_node$ownerDocument2 = node.ownerDocument) == null ? void 0 : _node$ownerDocument2.body);
  const win = getWindow(scrollableAncestor);
  if (isBody) {
    const frameElement = getFrameElement(win);
    return list.concat(win, win.visualViewport || [], isOverflowElement(scrollableAncestor) ? scrollableAncestor : [], frameElement && traverseIframes ? getOverflowAncestors(frameElement) : []);
  }
  return list.concat(scrollableAncestor, getOverflowAncestors(scrollableAncestor, [], traverseIframes));
}
function getFrameElement(win) {
  return win.parent && Object.getPrototypeOf(win.parent) ? win.frameElement : null;
}
function getCssDimensions(element) {
  const css = getComputedStyle$1(element);
  let width = parseFloat(css.width) || 0;
  let height = parseFloat(css.height) || 0;
  const hasOffset = isHTMLElement(element);
  const offsetWidth = hasOffset ? element.offsetWidth : width;
  const offsetHeight = hasOffset ? element.offsetHeight : height;
  const shouldFallback = round(width) !== offsetWidth || round(height) !== offsetHeight;
  if (shouldFallback) {
    width = offsetWidth;
    height = offsetHeight;
  }
  return {
    width,
    height,
    $: shouldFallback
  };
}
function unwrapElement(element) {
  return !isElement(element) ? element.contextElement : element;
}
function getScale(element) {
  const domElement = unwrapElement(element);
  if (!isHTMLElement(domElement)) {
    return createCoords(1);
  }
  const rect = domElement.getBoundingClientRect();
  const {
    width,
    height,
    $: $3
  } = getCssDimensions(domElement);
  let x3 = ($3 ? round(rect.width) : rect.width) / width;
  let y3 = ($3 ? round(rect.height) : rect.height) / height;
  if (!x3 || !Number.isFinite(x3)) {
    x3 = 1;
  }
  if (!y3 || !Number.isFinite(y3)) {
    y3 = 1;
  }
  return {
    x: x3,
    y: y3
  };
}
const noOffsets = /* @__PURE__ */ createCoords(0);
function getVisualOffsets(element) {
  const win = getWindow(element);
  if (!isWebKit() || !win.visualViewport) {
    return noOffsets;
  }
  return {
    x: win.visualViewport.offsetLeft,
    y: win.visualViewport.offsetTop
  };
}
function shouldAddVisualOffsets(element, isFixed, floatingOffsetParent) {
  if (isFixed === void 0) {
    isFixed = false;
  }
  if (!floatingOffsetParent || isFixed && floatingOffsetParent !== getWindow(element)) {
    return false;
  }
  return isFixed;
}
function getBoundingClientRect(element, includeScale, isFixedStrategy, offsetParent) {
  if (includeScale === void 0) {
    includeScale = false;
  }
  if (isFixedStrategy === void 0) {
    isFixedStrategy = false;
  }
  const clientRect = element.getBoundingClientRect();
  const domElement = unwrapElement(element);
  let scale = createCoords(1);
  if (includeScale) {
    if (offsetParent) {
      if (isElement(offsetParent)) {
        scale = getScale(offsetParent);
      }
    } else {
      scale = getScale(element);
    }
  }
  const visualOffsets = shouldAddVisualOffsets(domElement, isFixedStrategy, offsetParent) ? getVisualOffsets(domElement) : createCoords(0);
  let x3 = (clientRect.left + visualOffsets.x) / scale.x;
  let y3 = (clientRect.top + visualOffsets.y) / scale.y;
  let width = clientRect.width / scale.x;
  let height = clientRect.height / scale.y;
  if (domElement) {
    const win = getWindow(domElement);
    const offsetWin = offsetParent && isElement(offsetParent) ? getWindow(offsetParent) : offsetParent;
    let currentWin = win;
    let currentIFrame = getFrameElement(currentWin);
    while (currentIFrame && offsetParent && offsetWin !== currentWin) {
      const iframeScale = getScale(currentIFrame);
      const iframeRect = currentIFrame.getBoundingClientRect();
      const css = getComputedStyle$1(currentIFrame);
      const left = iframeRect.left + (currentIFrame.clientLeft + parseFloat(css.paddingLeft)) * iframeScale.x;
      const top2 = iframeRect.top + (currentIFrame.clientTop + parseFloat(css.paddingTop)) * iframeScale.y;
      x3 *= iframeScale.x;
      y3 *= iframeScale.y;
      width *= iframeScale.x;
      height *= iframeScale.y;
      x3 += left;
      y3 += top2;
      currentWin = getWindow(currentIFrame);
      currentIFrame = getFrameElement(currentWin);
    }
  }
  return rectToClientRect({
    width,
    height,
    x: x3,
    y: y3
  });
}
function getWindowScrollBarX(element, rect) {
  const leftScroll = getNodeScroll(element).scrollLeft;
  if (!rect) {
    return getBoundingClientRect(getDocumentElement(element)).left + leftScroll;
  }
  return rect.left + leftScroll;
}
function getHTMLOffset(documentElement, scroll) {
  const htmlRect = documentElement.getBoundingClientRect();
  const x3 = htmlRect.left + scroll.scrollLeft - getWindowScrollBarX(documentElement, htmlRect);
  const y3 = htmlRect.top + scroll.scrollTop;
  return {
    x: x3,
    y: y3
  };
}
function convertOffsetParentRelativeRectToViewportRelativeRect(_ref) {
  let {
    elements,
    rect,
    offsetParent,
    strategy
  } = _ref;
  const isFixed = strategy === "fixed";
  const documentElement = getDocumentElement(offsetParent);
  const topLayer = elements ? isTopLayer(elements.floating) : false;
  if (offsetParent === documentElement || topLayer && isFixed) {
    return rect;
  }
  let scroll = {
    scrollLeft: 0,
    scrollTop: 0
  };
  let scale = createCoords(1);
  const offsets = createCoords(0);
  const isOffsetParentAnElement = isHTMLElement(offsetParent);
  if (isOffsetParentAnElement || !isOffsetParentAnElement && !isFixed) {
    if (getNodeName(offsetParent) !== "body" || isOverflowElement(documentElement)) {
      scroll = getNodeScroll(offsetParent);
    }
    if (isHTMLElement(offsetParent)) {
      const offsetRect = getBoundingClientRect(offsetParent);
      scale = getScale(offsetParent);
      offsets.x = offsetRect.x + offsetParent.clientLeft;
      offsets.y = offsetRect.y + offsetParent.clientTop;
    }
  }
  const htmlOffset = documentElement && !isOffsetParentAnElement && !isFixed ? getHTMLOffset(documentElement, scroll) : createCoords(0);
  return {
    width: rect.width * scale.x,
    height: rect.height * scale.y,
    x: rect.x * scale.x - scroll.scrollLeft * scale.x + offsets.x + htmlOffset.x,
    y: rect.y * scale.y - scroll.scrollTop * scale.y + offsets.y + htmlOffset.y
  };
}
function getClientRects(element) {
  return Array.from(element.getClientRects());
}
function getDocumentRect(element) {
  const html = getDocumentElement(element);
  const scroll = getNodeScroll(element);
  const body = element.ownerDocument.body;
  const width = max(html.scrollWidth, html.clientWidth, body.scrollWidth, body.clientWidth);
  const height = max(html.scrollHeight, html.clientHeight, body.scrollHeight, body.clientHeight);
  let x3 = -scroll.scrollLeft + getWindowScrollBarX(element);
  const y3 = -scroll.scrollTop;
  if (getComputedStyle$1(body).direction === "rtl") {
    x3 += max(html.clientWidth, body.clientWidth) - width;
  }
  return {
    width,
    height,
    x: x3,
    y: y3
  };
}
const SCROLLBAR_MAX = 25;
function getViewportRect(element, strategy) {
  const win = getWindow(element);
  const html = getDocumentElement(element);
  const visualViewport = win.visualViewport;
  let width = html.clientWidth;
  let height = html.clientHeight;
  let x3 = 0;
  let y3 = 0;
  if (visualViewport) {
    width = visualViewport.width;
    height = visualViewport.height;
    const visualViewportBased = isWebKit();
    if (!visualViewportBased || visualViewportBased && strategy === "fixed") {
      x3 = visualViewport.offsetLeft;
      y3 = visualViewport.offsetTop;
    }
  }
  const windowScrollbarX = getWindowScrollBarX(html);
  if (windowScrollbarX <= 0) {
    const doc = html.ownerDocument;
    const body = doc.body;
    const bodyStyles = getComputedStyle(body);
    const bodyMarginInline = doc.compatMode === "CSS1Compat" ? parseFloat(bodyStyles.marginLeft) + parseFloat(bodyStyles.marginRight) || 0 : 0;
    const clippingStableScrollbarWidth = Math.abs(html.clientWidth - body.clientWidth - bodyMarginInline);
    if (clippingStableScrollbarWidth <= SCROLLBAR_MAX) {
      width -= clippingStableScrollbarWidth;
    }
  } else if (windowScrollbarX <= SCROLLBAR_MAX) {
    width += windowScrollbarX;
  }
  return {
    width,
    height,
    x: x3,
    y: y3
  };
}
const absoluteOrFixed = /* @__PURE__ */ new Set(["absolute", "fixed"]);
function getInnerBoundingClientRect(element, strategy) {
  const clientRect = getBoundingClientRect(element, true, strategy === "fixed");
  const top2 = clientRect.top + element.clientTop;
  const left = clientRect.left + element.clientLeft;
  const scale = isHTMLElement(element) ? getScale(element) : createCoords(1);
  const width = element.clientWidth * scale.x;
  const height = element.clientHeight * scale.y;
  const x3 = left * scale.x;
  const y3 = top2 * scale.y;
  return {
    width,
    height,
    x: x3,
    y: y3
  };
}
function getClientRectFromClippingAncestor(element, clippingAncestor, strategy) {
  let rect;
  if (clippingAncestor === "viewport") {
    rect = getViewportRect(element, strategy);
  } else if (clippingAncestor === "document") {
    rect = getDocumentRect(getDocumentElement(element));
  } else if (isElement(clippingAncestor)) {
    rect = getInnerBoundingClientRect(clippingAncestor, strategy);
  } else {
    const visualOffsets = getVisualOffsets(element);
    rect = {
      x: clippingAncestor.x - visualOffsets.x,
      y: clippingAncestor.y - visualOffsets.y,
      width: clippingAncestor.width,
      height: clippingAncestor.height
    };
  }
  return rectToClientRect(rect);
}
function hasFixedPositionAncestor(element, stopNode) {
  const parentNode = getParentNode(element);
  if (parentNode === stopNode || !isElement(parentNode) || isLastTraversableNode(parentNode)) {
    return false;
  }
  return getComputedStyle$1(parentNode).position === "fixed" || hasFixedPositionAncestor(parentNode, stopNode);
}
function getClippingElementAncestors(element, cache) {
  const cachedResult = cache.get(element);
  if (cachedResult) {
    return cachedResult;
  }
  let result = getOverflowAncestors(element, [], false).filter((el2) => isElement(el2) && getNodeName(el2) !== "body");
  let currentContainingBlockComputedStyle = null;
  const elementIsFixed = getComputedStyle$1(element).position === "fixed";
  let currentNode = elementIsFixed ? getParentNode(element) : element;
  while (isElement(currentNode) && !isLastTraversableNode(currentNode)) {
    const computedStyle = getComputedStyle$1(currentNode);
    const currentNodeIsContaining = isContainingBlock(currentNode);
    if (!currentNodeIsContaining && computedStyle.position === "fixed") {
      currentContainingBlockComputedStyle = null;
    }
    const shouldDropCurrentNode = elementIsFixed ? !currentNodeIsContaining && !currentContainingBlockComputedStyle : !currentNodeIsContaining && computedStyle.position === "static" && !!currentContainingBlockComputedStyle && absoluteOrFixed.has(currentContainingBlockComputedStyle.position) || isOverflowElement(currentNode) && !currentNodeIsContaining && hasFixedPositionAncestor(element, currentNode);
    if (shouldDropCurrentNode) {
      result = result.filter((ancestor) => ancestor !== currentNode);
    } else {
      currentContainingBlockComputedStyle = computedStyle;
    }
    currentNode = getParentNode(currentNode);
  }
  cache.set(element, result);
  return result;
}
function getClippingRect(_ref) {
  let {
    element,
    boundary,
    rootBoundary,
    strategy
  } = _ref;
  const elementClippingAncestors = boundary === "clippingAncestors" ? isTopLayer(element) ? [] : getClippingElementAncestors(element, this._c) : [].concat(boundary);
  const clippingAncestors = [...elementClippingAncestors, rootBoundary];
  const firstClippingAncestor = clippingAncestors[0];
  const clippingRect = clippingAncestors.reduce((accRect, clippingAncestor) => {
    const rect = getClientRectFromClippingAncestor(element, clippingAncestor, strategy);
    accRect.top = max(rect.top, accRect.top);
    accRect.right = min(rect.right, accRect.right);
    accRect.bottom = min(rect.bottom, accRect.bottom);
    accRect.left = max(rect.left, accRect.left);
    return accRect;
  }, getClientRectFromClippingAncestor(element, firstClippingAncestor, strategy));
  return {
    width: clippingRect.right - clippingRect.left,
    height: clippingRect.bottom - clippingRect.top,
    x: clippingRect.left,
    y: clippingRect.top
  };
}
function getDimensions(element) {
  const {
    width,
    height
  } = getCssDimensions(element);
  return {
    width,
    height
  };
}
function getRectRelativeToOffsetParent(element, offsetParent, strategy) {
  const isOffsetParentAnElement = isHTMLElement(offsetParent);
  const documentElement = getDocumentElement(offsetParent);
  const isFixed = strategy === "fixed";
  const rect = getBoundingClientRect(element, true, isFixed, offsetParent);
  let scroll = {
    scrollLeft: 0,
    scrollTop: 0
  };
  const offsets = createCoords(0);
  function setLeftRTLScrollbarOffset() {
    offsets.x = getWindowScrollBarX(documentElement);
  }
  if (isOffsetParentAnElement || !isOffsetParentAnElement && !isFixed) {
    if (getNodeName(offsetParent) !== "body" || isOverflowElement(documentElement)) {
      scroll = getNodeScroll(offsetParent);
    }
    if (isOffsetParentAnElement) {
      const offsetRect = getBoundingClientRect(offsetParent, true, isFixed, offsetParent);
      offsets.x = offsetRect.x + offsetParent.clientLeft;
      offsets.y = offsetRect.y + offsetParent.clientTop;
    } else if (documentElement) {
      setLeftRTLScrollbarOffset();
    }
  }
  if (isFixed && !isOffsetParentAnElement && documentElement) {
    setLeftRTLScrollbarOffset();
  }
  const htmlOffset = documentElement && !isOffsetParentAnElement && !isFixed ? getHTMLOffset(documentElement, scroll) : createCoords(0);
  const x3 = rect.left + scroll.scrollLeft - offsets.x - htmlOffset.x;
  const y3 = rect.top + scroll.scrollTop - offsets.y - htmlOffset.y;
  return {
    x: x3,
    y: y3,
    width: rect.width,
    height: rect.height
  };
}
function isStaticPositioned(element) {
  return getComputedStyle$1(element).position === "static";
}
function getTrueOffsetParent(element, polyfill) {
  if (!isHTMLElement(element) || getComputedStyle$1(element).position === "fixed") {
    return null;
  }
  if (polyfill) {
    return polyfill(element);
  }
  let rawOffsetParent = element.offsetParent;
  if (getDocumentElement(element) === rawOffsetParent) {
    rawOffsetParent = rawOffsetParent.ownerDocument.body;
  }
  return rawOffsetParent;
}
function getOffsetParent(element, polyfill) {
  const win = getWindow(element);
  if (isTopLayer(element)) {
    return win;
  }
  if (!isHTMLElement(element)) {
    let svgOffsetParent = getParentNode(element);
    while (svgOffsetParent && !isLastTraversableNode(svgOffsetParent)) {
      if (isElement(svgOffsetParent) && !isStaticPositioned(svgOffsetParent)) {
        return svgOffsetParent;
      }
      svgOffsetParent = getParentNode(svgOffsetParent);
    }
    return win;
  }
  let offsetParent = getTrueOffsetParent(element, polyfill);
  while (offsetParent && isTableElement(offsetParent) && isStaticPositioned(offsetParent)) {
    offsetParent = getTrueOffsetParent(offsetParent, polyfill);
  }
  if (offsetParent && isLastTraversableNode(offsetParent) && isStaticPositioned(offsetParent) && !isContainingBlock(offsetParent)) {
    return win;
  }
  return offsetParent || getContainingBlock(element) || win;
}
const getElementRects = async function(data) {
  const getOffsetParentFn = this.getOffsetParent || getOffsetParent;
  const getDimensionsFn = this.getDimensions;
  const floatingDimensions = await getDimensionsFn(data.floating);
  return {
    reference: getRectRelativeToOffsetParent(data.reference, await getOffsetParentFn(data.floating), data.strategy),
    floating: {
      x: 0,
      y: 0,
      width: floatingDimensions.width,
      height: floatingDimensions.height
    }
  };
};
function isRTL(element) {
  return getComputedStyle$1(element).direction === "rtl";
}
const platform = {
  convertOffsetParentRelativeRectToViewportRelativeRect,
  getDocumentElement,
  getClippingRect,
  getOffsetParent,
  getElementRects,
  getClientRects,
  getDimensions,
  getScale,
  isElement,
  isRTL
};
function rectsAreEqual(a3, b3) {
  return a3.x === b3.x && a3.y === b3.y && a3.width === b3.width && a3.height === b3.height;
}
function observeMove(element, onMove) {
  let io2 = null;
  let timeoutId;
  const root = getDocumentElement(element);
  function cleanup() {
    var _io;
    clearTimeout(timeoutId);
    (_io = io2) == null || _io.disconnect();
    io2 = null;
  }
  function refresh(skip, threshold) {
    if (skip === void 0) {
      skip = false;
    }
    if (threshold === void 0) {
      threshold = 1;
    }
    cleanup();
    const elementRectForRootMargin = element.getBoundingClientRect();
    const {
      left,
      top: top2,
      width,
      height
    } = elementRectForRootMargin;
    if (!skip) {
      onMove();
    }
    if (!width || !height) {
      return;
    }
    const insetTop = floor(top2);
    const insetRight = floor(root.clientWidth - (left + width));
    const insetBottom = floor(root.clientHeight - (top2 + height));
    const insetLeft = floor(left);
    const rootMargin = -insetTop + "px " + -insetRight + "px " + -insetBottom + "px " + -insetLeft + "px";
    const options = {
      rootMargin,
      threshold: max(0, min(1, threshold)) || 1
    };
    let isFirstUpdate = true;
    function handleObserve(entries) {
      const ratio = entries[0].intersectionRatio;
      if (ratio !== threshold) {
        if (!isFirstUpdate) {
          return refresh();
        }
        if (!ratio) {
          timeoutId = setTimeout(() => {
            refresh(false, 1e-7);
          }, 1e3);
        } else {
          refresh(false, ratio);
        }
      }
      if (ratio === 1 && !rectsAreEqual(elementRectForRootMargin, element.getBoundingClientRect())) {
        refresh();
      }
      isFirstUpdate = false;
    }
    try {
      io2 = new IntersectionObserver(handleObserve, {
        ...options,
        // Handle <iframe>s
        root: root.ownerDocument
      });
    } catch (_e2) {
      io2 = new IntersectionObserver(handleObserve, options);
    }
    io2.observe(element);
  }
  refresh(true);
  return cleanup;
}
function autoUpdate(reference, floating, update, options) {
  if (options === void 0) {
    options = {};
  }
  const {
    ancestorScroll = true,
    ancestorResize = true,
    elementResize = typeof ResizeObserver === "function",
    layoutShift = typeof IntersectionObserver === "function",
    animationFrame = false
  } = options;
  const referenceEl = unwrapElement(reference);
  const ancestors = ancestorScroll || ancestorResize ? [...referenceEl ? getOverflowAncestors(referenceEl) : [], ...getOverflowAncestors(floating)] : [];
  ancestors.forEach((ancestor) => {
    ancestorScroll && ancestor.addEventListener("scroll", update, {
      passive: true
    });
    ancestorResize && ancestor.addEventListener("resize", update);
  });
  const cleanupIo = referenceEl && layoutShift ? observeMove(referenceEl, update) : null;
  let reobserveFrame = -1;
  let resizeObserver = null;
  if (elementResize) {
    resizeObserver = new ResizeObserver((_ref) => {
      let [firstEntry] = _ref;
      if (firstEntry && firstEntry.target === referenceEl && resizeObserver) {
        resizeObserver.unobserve(floating);
        cancelAnimationFrame(reobserveFrame);
        reobserveFrame = requestAnimationFrame(() => {
          var _resizeObserver;
          (_resizeObserver = resizeObserver) == null || _resizeObserver.observe(floating);
        });
      }
      update();
    });
    if (referenceEl && !animationFrame) {
      resizeObserver.observe(referenceEl);
    }
    resizeObserver.observe(floating);
  }
  let frameId;
  let prevRefRect = animationFrame ? getBoundingClientRect(reference) : null;
  if (animationFrame) {
    frameLoop();
  }
  function frameLoop() {
    const nextRefRect = getBoundingClientRect(reference);
    if (prevRefRect && !rectsAreEqual(prevRefRect, nextRefRect)) {
      update();
    }
    prevRefRect = nextRefRect;
    frameId = requestAnimationFrame(frameLoop);
  }
  update();
  return () => {
    var _resizeObserver2;
    ancestors.forEach((ancestor) => {
      ancestorScroll && ancestor.removeEventListener("scroll", update);
      ancestorResize && ancestor.removeEventListener("resize", update);
    });
    cleanupIo == null || cleanupIo();
    (_resizeObserver2 = resizeObserver) == null || _resizeObserver2.disconnect();
    resizeObserver = null;
    if (animationFrame) {
      cancelAnimationFrame(frameId);
    }
  };
}
const offset$1 = offset$2;
const shift$1 = shift$2;
const flip$1 = flip$2;
const size$1 = size$2;
const hide$1 = hide$2;
const arrow$2 = arrow$3;
const limitShift$1 = limitShift$2;
const computePosition = (reference, floating, options) => {
  const cache = /* @__PURE__ */ new Map();
  const mergedOptions = {
    platform,
    ...options
  };
  const platformWithCache = {
    ...mergedOptions.platform,
    _c: cache
  };
  return computePosition$1(reference, floating, {
    ...mergedOptions,
    platform: platformWithCache
  });
};
var isClient = typeof document !== "undefined";
var noop = function noop2() {
};
var index = isClient ? reactExports.useLayoutEffect : noop;
function deepEqual(a3, b3) {
  if (a3 === b3) {
    return true;
  }
  if (typeof a3 !== typeof b3) {
    return false;
  }
  if (typeof a3 === "function" && a3.toString() === b3.toString()) {
    return true;
  }
  let length;
  let i3;
  let keys;
  if (a3 && b3 && typeof a3 === "object") {
    if (Array.isArray(a3)) {
      length = a3.length;
      if (length !== b3.length) return false;
      for (i3 = length; i3-- !== 0; ) {
        if (!deepEqual(a3[i3], b3[i3])) {
          return false;
        }
      }
      return true;
    }
    keys = Object.keys(a3);
    length = keys.length;
    if (length !== Object.keys(b3).length) {
      return false;
    }
    for (i3 = length; i3-- !== 0; ) {
      if (!{}.hasOwnProperty.call(b3, keys[i3])) {
        return false;
      }
    }
    for (i3 = length; i3-- !== 0; ) {
      const key = keys[i3];
      if (key === "_owner" && a3.$$typeof) {
        continue;
      }
      if (!deepEqual(a3[key], b3[key])) {
        return false;
      }
    }
    return true;
  }
  return a3 !== a3 && b3 !== b3;
}
function getDPR(element) {
  if (typeof window === "undefined") {
    return 1;
  }
  const win = element.ownerDocument.defaultView || window;
  return win.devicePixelRatio || 1;
}
function roundByDPR(element, value) {
  const dpr = getDPR(element);
  return Math.round(value * dpr) / dpr;
}
function useLatestRef(value) {
  const ref = reactExports.useRef(value);
  index(() => {
    ref.current = value;
  });
  return ref;
}
function useFloating(options) {
  if (options === void 0) {
    options = {};
  }
  const {
    placement = "bottom",
    strategy = "absolute",
    middleware = [],
    platform: platform2,
    elements: {
      reference: externalReference,
      floating: externalFloating
    } = {},
    transform = true,
    whileElementsMounted,
    open
  } = options;
  const [data, setData] = reactExports.useState({
    x: 0,
    y: 0,
    strategy,
    placement,
    middlewareData: {},
    isPositioned: false
  });
  const [latestMiddleware, setLatestMiddleware] = reactExports.useState(middleware);
  if (!deepEqual(latestMiddleware, middleware)) {
    setLatestMiddleware(middleware);
  }
  const [_reference, _setReference] = reactExports.useState(null);
  const [_floating, _setFloating] = reactExports.useState(null);
  const setReference = reactExports.useCallback((node) => {
    if (node !== referenceRef.current) {
      referenceRef.current = node;
      _setReference(node);
    }
  }, []);
  const setFloating = reactExports.useCallback((node) => {
    if (node !== floatingRef.current) {
      floatingRef.current = node;
      _setFloating(node);
    }
  }, []);
  const referenceEl = externalReference || _reference;
  const floatingEl = externalFloating || _floating;
  const referenceRef = reactExports.useRef(null);
  const floatingRef = reactExports.useRef(null);
  const dataRef = reactExports.useRef(data);
  const hasWhileElementsMounted = whileElementsMounted != null;
  const whileElementsMountedRef = useLatestRef(whileElementsMounted);
  const platformRef = useLatestRef(platform2);
  const openRef = useLatestRef(open);
  const update = reactExports.useCallback(() => {
    if (!referenceRef.current || !floatingRef.current) {
      return;
    }
    const config = {
      placement,
      strategy,
      middleware: latestMiddleware
    };
    if (platformRef.current) {
      config.platform = platformRef.current;
    }
    computePosition(referenceRef.current, floatingRef.current, config).then((data2) => {
      const fullData = {
        ...data2,
        // The floating element's position may be recomputed while it's closed
        // but still mounted (such as when transitioning out). To ensure
        // `isPositioned` will be `false` initially on the next open, avoid
        // setting it to `true` when `open === false` (must be specified).
        isPositioned: openRef.current !== false
      };
      if (isMountedRef.current && !deepEqual(dataRef.current, fullData)) {
        dataRef.current = fullData;
        reactDomExports.flushSync(() => {
          setData(fullData);
        });
      }
    });
  }, [latestMiddleware, placement, strategy, platformRef, openRef]);
  index(() => {
    if (open === false && dataRef.current.isPositioned) {
      dataRef.current.isPositioned = false;
      setData((data2) => ({
        ...data2,
        isPositioned: false
      }));
    }
  }, [open]);
  const isMountedRef = reactExports.useRef(false);
  index(() => {
    isMountedRef.current = true;
    return () => {
      isMountedRef.current = false;
    };
  }, []);
  index(() => {
    if (referenceEl) referenceRef.current = referenceEl;
    if (floatingEl) floatingRef.current = floatingEl;
    if (referenceEl && floatingEl) {
      if (whileElementsMountedRef.current) {
        return whileElementsMountedRef.current(referenceEl, floatingEl, update);
      }
      update();
    }
  }, [referenceEl, floatingEl, update, whileElementsMountedRef, hasWhileElementsMounted]);
  const refs = reactExports.useMemo(() => ({
    reference: referenceRef,
    floating: floatingRef,
    setReference,
    setFloating
  }), [setReference, setFloating]);
  const elements = reactExports.useMemo(() => ({
    reference: referenceEl,
    floating: floatingEl
  }), [referenceEl, floatingEl]);
  const floatingStyles = reactExports.useMemo(() => {
    const initialStyles = {
      position: strategy,
      left: 0,
      top: 0
    };
    if (!elements.floating) {
      return initialStyles;
    }
    const x3 = roundByDPR(elements.floating, data.x);
    const y3 = roundByDPR(elements.floating, data.y);
    if (transform) {
      return {
        ...initialStyles,
        transform: "translate(" + x3 + "px, " + y3 + "px)",
        ...getDPR(elements.floating) >= 1.5 && {
          willChange: "transform"
        }
      };
    }
    return {
      position: strategy,
      left: x3,
      top: y3
    };
  }, [strategy, transform, elements.floating, data.x, data.y]);
  return reactExports.useMemo(() => ({
    ...data,
    update,
    refs,
    elements,
    floatingStyles
  }), [data, update, refs, elements, floatingStyles]);
}
const arrow$1 = (options) => {
  function isRef(value) {
    return {}.hasOwnProperty.call(value, "current");
  }
  return {
    name: "arrow",
    options,
    fn(state) {
      const {
        element,
        padding
      } = typeof options === "function" ? options(state) : options;
      if (element && isRef(element)) {
        if (element.current != null) {
          return arrow$2({
            element: element.current,
            padding
          }).fn(state);
        }
        return {};
      }
      if (element) {
        return arrow$2({
          element,
          padding
        }).fn(state);
      }
      return {};
    }
  };
};
const offset = (options, deps) => ({
  ...offset$1(options),
  options: [options, deps]
});
const shift = (options, deps) => ({
  ...shift$1(options),
  options: [options, deps]
});
const limitShift = (options, deps) => ({
  ...limitShift$1(options),
  options: [options, deps]
});
const flip = (options, deps) => ({
  ...flip$1(options),
  options: [options, deps]
});
const size = (options, deps) => ({
  ...size$1(options),
  options: [options, deps]
});
const hide = (options, deps) => ({
  ...hide$1(options),
  options: [options, deps]
});
const arrow = (options, deps) => ({
  ...arrow$1(options),
  options: [options, deps]
});
var NAME = "Arrow";
var Arrow$1 = reactExports.forwardRef((props, forwardedRef) => {
  const { children, width = 10, height = 5, ...arrowProps } = props;
  return /* @__PURE__ */ jsxRuntimeExports.jsx(
    Primitive.svg,
    {
      ...arrowProps,
      ref: forwardedRef,
      width,
      height,
      viewBox: "0 0 30 10",
      preserveAspectRatio: "none",
      children: props.asChild ? children : /* @__PURE__ */ jsxRuntimeExports.jsx("polygon", { points: "0,0 30,0 15,10" })
    }
  );
});
Arrow$1.displayName = NAME;
var Root = Arrow$1;
function useSize(element) {
  const [size2, setSize] = reactExports.useState(void 0);
  useLayoutEffect2(() => {
    if (element) {
      setSize({ width: element.offsetWidth, height: element.offsetHeight });
      const resizeObserver = new ResizeObserver((entries) => {
        if (!Array.isArray(entries)) {
          return;
        }
        if (!entries.length) {
          return;
        }
        const entry = entries[0];
        let width;
        let height;
        if ("borderBoxSize" in entry) {
          const borderSizeEntry = entry["borderBoxSize"];
          const borderSize = Array.isArray(borderSizeEntry) ? borderSizeEntry[0] : borderSizeEntry;
          width = borderSize["inlineSize"];
          height = borderSize["blockSize"];
        } else {
          width = element.offsetWidth;
          height = element.offsetHeight;
        }
        setSize({ width, height });
      });
      resizeObserver.observe(element, { box: "border-box" });
      return () => resizeObserver.unobserve(element);
    } else {
      setSize(void 0);
    }
  }, [element]);
  return size2;
}
var POPPER_NAME = "Popper";
var [createPopperContext, createPopperScope] = createContextScope(POPPER_NAME);
var [PopperProvider, usePopperContext] = createPopperContext(POPPER_NAME);
var Popper = (props) => {
  const { __scopePopper, children } = props;
  const [anchor, setAnchor] = reactExports.useState(null);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(PopperProvider, { scope: __scopePopper, anchor, onAnchorChange: setAnchor, children });
};
Popper.displayName = POPPER_NAME;
var ANCHOR_NAME$1 = "PopperAnchor";
var PopperAnchor = reactExports.forwardRef(
  (props, forwardedRef) => {
    const { __scopePopper, virtualRef, ...anchorProps } = props;
    const context = usePopperContext(ANCHOR_NAME$1, __scopePopper);
    const ref = reactExports.useRef(null);
    const composedRefs = useComposedRefs(forwardedRef, ref);
    reactExports.useEffect(() => {
      context.onAnchorChange(virtualRef?.current || ref.current);
    });
    return virtualRef ? null : /* @__PURE__ */ jsxRuntimeExports.jsx(Primitive.div, { ...anchorProps, ref: composedRefs });
  }
);
PopperAnchor.displayName = ANCHOR_NAME$1;
var CONTENT_NAME$1 = "PopperContent";
var [PopperContentProvider, useContentContext] = createPopperContext(CONTENT_NAME$1);
var PopperContent = reactExports.forwardRef(
  (props, forwardedRef) => {
    const {
      __scopePopper,
      side = "bottom",
      sideOffset = 0,
      align = "center",
      alignOffset = 0,
      arrowPadding = 0,
      avoidCollisions = true,
      collisionBoundary = [],
      collisionPadding: collisionPaddingProp = 0,
      sticky = "partial",
      hideWhenDetached = false,
      updatePositionStrategy = "optimized",
      onPlaced,
      ...contentProps
    } = props;
    const context = usePopperContext(CONTENT_NAME$1, __scopePopper);
    const [content, setContent] = reactExports.useState(null);
    const composedRefs = useComposedRefs(forwardedRef, (node) => setContent(node));
    const [arrow$12, setArrow] = reactExports.useState(null);
    const arrowSize = useSize(arrow$12);
    const arrowWidth = arrowSize?.width ?? 0;
    const arrowHeight = arrowSize?.height ?? 0;
    const desiredPlacement = side + (align !== "center" ? "-" + align : "");
    const collisionPadding = typeof collisionPaddingProp === "number" ? collisionPaddingProp : { top: 0, right: 0, bottom: 0, left: 0, ...collisionPaddingProp };
    const boundary = Array.isArray(collisionBoundary) ? collisionBoundary : [collisionBoundary];
    const hasExplicitBoundaries = boundary.length > 0;
    const detectOverflowOptions = {
      padding: collisionPadding,
      boundary: boundary.filter(isNotNull),
      // with `strategy: 'fixed'`, this is the only way to get it to respect boundaries
      altBoundary: hasExplicitBoundaries
    };
    const { refs, floatingStyles, placement, isPositioned, middlewareData } = useFloating({
      // default to `fixed` strategy so users don't have to pick and we also avoid focus scroll issues
      strategy: "fixed",
      placement: desiredPlacement,
      whileElementsMounted: (...args) => {
        const cleanup = autoUpdate(...args, {
          animationFrame: updatePositionStrategy === "always"
        });
        return cleanup;
      },
      elements: {
        reference: context.anchor
      },
      middleware: [
        offset({ mainAxis: sideOffset + arrowHeight, alignmentAxis: alignOffset }),
        avoidCollisions && shift({
          mainAxis: true,
          crossAxis: false,
          limiter: sticky === "partial" ? limitShift() : void 0,
          ...detectOverflowOptions
        }),
        avoidCollisions && flip({ ...detectOverflowOptions }),
        size({
          ...detectOverflowOptions,
          apply: ({ elements, rects, availableWidth, availableHeight }) => {
            const { width: anchorWidth, height: anchorHeight } = rects.reference;
            const contentStyle = elements.floating.style;
            contentStyle.setProperty("--radix-popper-available-width", `${availableWidth}px`);
            contentStyle.setProperty("--radix-popper-available-height", `${availableHeight}px`);
            contentStyle.setProperty("--radix-popper-anchor-width", `${anchorWidth}px`);
            contentStyle.setProperty("--radix-popper-anchor-height", `${anchorHeight}px`);
          }
        }),
        arrow$12 && arrow({ element: arrow$12, padding: arrowPadding }),
        transformOrigin({ arrowWidth, arrowHeight }),
        hideWhenDetached && hide({ strategy: "referenceHidden", ...detectOverflowOptions })
      ]
    });
    const [placedSide, placedAlign] = getSideAndAlignFromPlacement(placement);
    const handlePlaced = useCallbackRef$1(onPlaced);
    useLayoutEffect2(() => {
      if (isPositioned) {
        handlePlaced?.();
      }
    }, [isPositioned, handlePlaced]);
    const arrowX = middlewareData.arrow?.x;
    const arrowY = middlewareData.arrow?.y;
    const cannotCenterArrow = middlewareData.arrow?.centerOffset !== 0;
    const [contentZIndex, setContentZIndex] = reactExports.useState();
    useLayoutEffect2(() => {
      if (content) setContentZIndex(window.getComputedStyle(content).zIndex);
    }, [content]);
    return /* @__PURE__ */ jsxRuntimeExports.jsx(
      "div",
      {
        ref: refs.setFloating,
        "data-radix-popper-content-wrapper": "",
        style: {
          ...floatingStyles,
          transform: isPositioned ? floatingStyles.transform : "translate(0, -200%)",
          // keep off the page when measuring
          minWidth: "max-content",
          zIndex: contentZIndex,
          ["--radix-popper-transform-origin"]: [
            middlewareData.transformOrigin?.x,
            middlewareData.transformOrigin?.y
          ].join(" "),
          // hide the content if using the hide middleware and should be hidden
          // set visibility to hidden and disable pointer events so the UI behaves
          // as if the PopperContent isn't there at all
          ...middlewareData.hide?.referenceHidden && {
            visibility: "hidden",
            pointerEvents: "none"
          }
        },
        dir: props.dir,
        children: /* @__PURE__ */ jsxRuntimeExports.jsx(
          PopperContentProvider,
          {
            scope: __scopePopper,
            placedSide,
            onArrowChange: setArrow,
            arrowX,
            arrowY,
            shouldHideArrow: cannotCenterArrow,
            children: /* @__PURE__ */ jsxRuntimeExports.jsx(
              Primitive.div,
              {
                "data-side": placedSide,
                "data-align": placedAlign,
                ...contentProps,
                ref: composedRefs,
                style: {
                  ...contentProps.style,
                  // if the PopperContent hasn't been placed yet (not all measurements done)
                  // we prevent animations so that users's animation don't kick in too early referring wrong sides
                  animation: !isPositioned ? "none" : void 0
                }
              }
            )
          }
        )
      }
    );
  }
);
PopperContent.displayName = CONTENT_NAME$1;
var ARROW_NAME$1 = "PopperArrow";
var OPPOSITE_SIDE = {
  top: "bottom",
  right: "left",
  bottom: "top",
  left: "right"
};
var PopperArrow = reactExports.forwardRef(function PopperArrow2(props, forwardedRef) {
  const { __scopePopper, ...arrowProps } = props;
  const contentContext = useContentContext(ARROW_NAME$1, __scopePopper);
  const baseSide = OPPOSITE_SIDE[contentContext.placedSide];
  return (
    // we have to use an extra wrapper because `ResizeObserver` (used by `useSize`)
    // doesn't report size as we'd expect on SVG elements.
    // it reports their bounding box which is effectively the largest path inside the SVG.
    /* @__PURE__ */ jsxRuntimeExports.jsx(
      "span",
      {
        ref: contentContext.onArrowChange,
        style: {
          position: "absolute",
          left: contentContext.arrowX,
          top: contentContext.arrowY,
          [baseSide]: 0,
          transformOrigin: {
            top: "",
            right: "0 0",
            bottom: "center 0",
            left: "100% 0"
          }[contentContext.placedSide],
          transform: {
            top: "translateY(100%)",
            right: "translateY(50%) rotate(90deg) translateX(-50%)",
            bottom: `rotate(180deg)`,
            left: "translateY(50%) rotate(-90deg) translateX(50%)"
          }[contentContext.placedSide],
          visibility: contentContext.shouldHideArrow ? "hidden" : void 0
        },
        children: /* @__PURE__ */ jsxRuntimeExports.jsx(
          Root,
          {
            ...arrowProps,
            ref: forwardedRef,
            style: {
              ...arrowProps.style,
              // ensures the element can be measured correctly (mostly for if SVG)
              display: "block"
            }
          }
        )
      }
    )
  );
});
PopperArrow.displayName = ARROW_NAME$1;
function isNotNull(value) {
  return value !== null;
}
var transformOrigin = (options) => ({
  name: "transformOrigin",
  options,
  fn(data) {
    const { placement, rects, middlewareData } = data;
    const cannotCenterArrow = middlewareData.arrow?.centerOffset !== 0;
    const isArrowHidden = cannotCenterArrow;
    const arrowWidth = isArrowHidden ? 0 : options.arrowWidth;
    const arrowHeight = isArrowHidden ? 0 : options.arrowHeight;
    const [placedSide, placedAlign] = getSideAndAlignFromPlacement(placement);
    const noArrowAlign = { start: "0%", center: "50%", end: "100%" }[placedAlign];
    const arrowXCenter = (middlewareData.arrow?.x ?? 0) + arrowWidth / 2;
    const arrowYCenter = (middlewareData.arrow?.y ?? 0) + arrowHeight / 2;
    let x3 = "";
    let y3 = "";
    if (placedSide === "bottom") {
      x3 = isArrowHidden ? noArrowAlign : `${arrowXCenter}px`;
      y3 = `${-arrowHeight}px`;
    } else if (placedSide === "top") {
      x3 = isArrowHidden ? noArrowAlign : `${arrowXCenter}px`;
      y3 = `${rects.floating.height + arrowHeight}px`;
    } else if (placedSide === "right") {
      x3 = `${-arrowHeight}px`;
      y3 = isArrowHidden ? noArrowAlign : `${arrowYCenter}px`;
    } else if (placedSide === "left") {
      x3 = `${rects.floating.width + arrowHeight}px`;
      y3 = isArrowHidden ? noArrowAlign : `${arrowYCenter}px`;
    }
    return { data: { x: x3, y: y3 } };
  }
});
function getSideAndAlignFromPlacement(placement) {
  const [side, align = "center"] = placement.split("-");
  return [side, align];
}
var Root2$1 = Popper;
var Anchor = PopperAnchor;
var Content = PopperContent;
var Arrow = PopperArrow;
var PORTAL_NAME$1 = "Portal";
var Portal$1 = reactExports.forwardRef((props, forwardedRef) => {
  const { container: containerProp, ...portalProps } = props;
  const [mounted, setMounted] = reactExports.useState(false);
  useLayoutEffect2(() => setMounted(true), []);
  const container = containerProp || mounted && globalThis?.document?.body;
  return container ? ReactDOM.createPortal(/* @__PURE__ */ jsxRuntimeExports.jsx(Primitive.div, { ...portalProps, ref: forwardedRef }), container) : null;
});
Portal$1.displayName = PORTAL_NAME$1;
function useStateMachine(initialState, machine) {
  return reactExports.useReducer((state, event) => {
    const nextState = machine[state][event];
    return nextState ?? state;
  }, initialState);
}
var Presence = (props) => {
  const { present, children } = props;
  const presence = usePresence(present);
  const child = typeof children === "function" ? children({ present: presence.isPresent }) : reactExports.Children.only(children);
  const ref = useComposedRefs(presence.ref, getElementRef(child));
  const forceMount = typeof children === "function";
  return forceMount || presence.isPresent ? reactExports.cloneElement(child, { ref }) : null;
};
Presence.displayName = "Presence";
function usePresence(present) {
  const [node, setNode] = reactExports.useState();
  const stylesRef = reactExports.useRef({});
  const prevPresentRef = reactExports.useRef(present);
  const prevAnimationNameRef = reactExports.useRef("none");
  const initialState = present ? "mounted" : "unmounted";
  const [state, send] = useStateMachine(initialState, {
    mounted: {
      UNMOUNT: "unmounted",
      ANIMATION_OUT: "unmountSuspended"
    },
    unmountSuspended: {
      MOUNT: "mounted",
      ANIMATION_END: "unmounted"
    },
    unmounted: {
      MOUNT: "mounted"
    }
  });
  reactExports.useEffect(() => {
    const currentAnimationName = getAnimationName(stylesRef.current);
    prevAnimationNameRef.current = state === "mounted" ? currentAnimationName : "none";
  }, [state]);
  useLayoutEffect2(() => {
    const styles = stylesRef.current;
    const wasPresent = prevPresentRef.current;
    const hasPresentChanged = wasPresent !== present;
    if (hasPresentChanged) {
      const prevAnimationName = prevAnimationNameRef.current;
      const currentAnimationName = getAnimationName(styles);
      if (present) {
        send("MOUNT");
      } else if (currentAnimationName === "none" || styles?.display === "none") {
        send("UNMOUNT");
      } else {
        const isAnimating = prevAnimationName !== currentAnimationName;
        if (wasPresent && isAnimating) {
          send("ANIMATION_OUT");
        } else {
          send("UNMOUNT");
        }
      }
      prevPresentRef.current = present;
    }
  }, [present, send]);
  useLayoutEffect2(() => {
    if (node) {
      let timeoutId;
      const ownerWindow = node.ownerDocument.defaultView ?? window;
      const handleAnimationEnd = (event) => {
        const currentAnimationName = getAnimationName(stylesRef.current);
        const isCurrentAnimation = currentAnimationName.includes(event.animationName);
        if (event.target === node && isCurrentAnimation) {
          send("ANIMATION_END");
          if (!prevPresentRef.current) {
            const currentFillMode = node.style.animationFillMode;
            node.style.animationFillMode = "forwards";
            timeoutId = ownerWindow.setTimeout(() => {
              if (node.style.animationFillMode === "forwards") {
                node.style.animationFillMode = currentFillMode;
              }
            });
          }
        }
      };
      const handleAnimationStart = (event) => {
        if (event.target === node) {
          prevAnimationNameRef.current = getAnimationName(stylesRef.current);
        }
      };
      node.addEventListener("animationstart", handleAnimationStart);
      node.addEventListener("animationcancel", handleAnimationEnd);
      node.addEventListener("animationend", handleAnimationEnd);
      return () => {
        ownerWindow.clearTimeout(timeoutId);
        node.removeEventListener("animationstart", handleAnimationStart);
        node.removeEventListener("animationcancel", handleAnimationEnd);
        node.removeEventListener("animationend", handleAnimationEnd);
      };
    } else {
      send("ANIMATION_END");
    }
  }, [node, send]);
  return {
    isPresent: ["mounted", "unmountSuspended"].includes(state),
    ref: reactExports.useCallback((node2) => {
      if (node2) stylesRef.current = getComputedStyle(node2);
      setNode(node2);
    }, [])
  };
}
function getAnimationName(styles) {
  return styles?.animationName || "none";
}
function getElementRef(element) {
  let getter = Object.getOwnPropertyDescriptor(element.props, "ref")?.get;
  let mayWarn = getter && "isReactWarning" in getter && getter.isReactWarning;
  if (mayWarn) {
    return element.ref;
  }
  getter = Object.getOwnPropertyDescriptor(element, "ref")?.get;
  mayWarn = getter && "isReactWarning" in getter && getter.isReactWarning;
  if (mayWarn) {
    return element.props.ref;
  }
  return element.props.ref || element.ref;
}
function useControllableState({
  prop,
  defaultProp,
  onChange = () => {
  }
}) {
  const [uncontrolledProp, setUncontrolledProp] = useUncontrolledState({ defaultProp, onChange });
  const isControlled = prop !== void 0;
  const value = isControlled ? prop : uncontrolledProp;
  const handleChange = useCallbackRef$1(onChange);
  const setValue = reactExports.useCallback(
    (nextValue) => {
      if (isControlled) {
        const setter = nextValue;
        const value2 = typeof nextValue === "function" ? setter(prop) : nextValue;
        if (value2 !== prop) handleChange(value2);
      } else {
        setUncontrolledProp(nextValue);
      }
    },
    [isControlled, prop, setUncontrolledProp, handleChange]
  );
  return [value, setValue];
}
function useUncontrolledState({
  defaultProp,
  onChange
}) {
  const uncontrolledState = reactExports.useState(defaultProp);
  const [value] = uncontrolledState;
  const prevValueRef = reactExports.useRef(value);
  const handleChange = useCallbackRef$1(onChange);
  reactExports.useEffect(() => {
    if (prevValueRef.current !== value) {
      handleChange(value);
      prevValueRef.current = value;
    }
  }, [value, prevValueRef, handleChange]);
  return uncontrolledState;
}
var getDefaultParent = function(originalTarget) {
  if (typeof document === "undefined") {
    return null;
  }
  var sampleTarget = Array.isArray(originalTarget) ? originalTarget[0] : originalTarget;
  return sampleTarget.ownerDocument.body;
};
var counterMap = /* @__PURE__ */ new WeakMap();
var uncontrolledNodes = /* @__PURE__ */ new WeakMap();
var markerMap = {};
var lockCount = 0;
var unwrapHost = function(node) {
  return node && (node.host || unwrapHost(node.parentNode));
};
var correctTargets = function(parent, targets) {
  return targets.map(function(target) {
    if (parent.contains(target)) {
      return target;
    }
    var correctedTarget = unwrapHost(target);
    if (correctedTarget && parent.contains(correctedTarget)) {
      return correctedTarget;
    }
    console.error("aria-hidden", target, "in not contained inside", parent, ". Doing nothing");
    return null;
  }).filter(function(x3) {
    return Boolean(x3);
  });
};
var applyAttributeToOthers = function(originalTarget, parentNode, markerName, controlAttribute) {
  var targets = correctTargets(parentNode, Array.isArray(originalTarget) ? originalTarget : [originalTarget]);
  if (!markerMap[markerName]) {
    markerMap[markerName] = /* @__PURE__ */ new WeakMap();
  }
  var markerCounter = markerMap[markerName];
  var hiddenNodes = [];
  var elementsToKeep = /* @__PURE__ */ new Set();
  var elementsToStop = new Set(targets);
  var keep = function(el2) {
    if (!el2 || elementsToKeep.has(el2)) {
      return;
    }
    elementsToKeep.add(el2);
    keep(el2.parentNode);
  };
  targets.forEach(keep);
  var deep = function(parent) {
    if (!parent || elementsToStop.has(parent)) {
      return;
    }
    Array.prototype.forEach.call(parent.children, function(node) {
      if (elementsToKeep.has(node)) {
        deep(node);
      } else {
        try {
          var attr = node.getAttribute(controlAttribute);
          var alreadyHidden = attr !== null && attr !== "false";
          var counterValue = (counterMap.get(node) || 0) + 1;
          var markerValue = (markerCounter.get(node) || 0) + 1;
          counterMap.set(node, counterValue);
          markerCounter.set(node, markerValue);
          hiddenNodes.push(node);
          if (counterValue === 1 && alreadyHidden) {
            uncontrolledNodes.set(node, true);
          }
          if (markerValue === 1) {
            node.setAttribute(markerName, "true");
          }
          if (!alreadyHidden) {
            node.setAttribute(controlAttribute, "true");
          }
        } catch (e12) {
          console.error("aria-hidden: cannot operate on ", node, e12);
        }
      }
    });
  };
  deep(parentNode);
  elementsToKeep.clear();
  lockCount++;
  return function() {
    hiddenNodes.forEach(function(node) {
      var counterValue = counterMap.get(node) - 1;
      var markerValue = markerCounter.get(node) - 1;
      counterMap.set(node, counterValue);
      markerCounter.set(node, markerValue);
      if (!counterValue) {
        if (!uncontrolledNodes.has(node)) {
          node.removeAttribute(controlAttribute);
        }
        uncontrolledNodes.delete(node);
      }
      if (!markerValue) {
        node.removeAttribute(markerName);
      }
    });
    lockCount--;
    if (!lockCount) {
      counterMap = /* @__PURE__ */ new WeakMap();
      counterMap = /* @__PURE__ */ new WeakMap();
      uncontrolledNodes = /* @__PURE__ */ new WeakMap();
      markerMap = {};
    }
  };
};
var hideOthers = function(originalTarget, parentNode, markerName) {
  if (markerName === void 0) {
    markerName = "data-aria-hidden";
  }
  var targets = Array.from(Array.isArray(originalTarget) ? originalTarget : [originalTarget]);
  var activeParentNode = getDefaultParent(originalTarget);
  if (!activeParentNode) {
    return function() {
      return null;
    };
  }
  targets.push.apply(targets, Array.from(activeParentNode.querySelectorAll("[aria-live], script")));
  return applyAttributeToOthers(targets, activeParentNode, markerName, "aria-hidden");
};
var __assign = function() {
  __assign = Object.assign || function __assign2(t3) {
    for (var s3, i3 = 1, n3 = arguments.length; i3 < n3; i3++) {
      s3 = arguments[i3];
      for (var p3 in s3) if (Object.prototype.hasOwnProperty.call(s3, p3)) t3[p3] = s3[p3];
    }
    return t3;
  };
  return __assign.apply(this, arguments);
};
function __rest(s3, e12) {
  var t3 = {};
  for (var p3 in s3) if (Object.prototype.hasOwnProperty.call(s3, p3) && e12.indexOf(p3) < 0)
    t3[p3] = s3[p3];
  if (s3 != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i3 = 0, p3 = Object.getOwnPropertySymbols(s3); i3 < p3.length; i3++) {
      if (e12.indexOf(p3[i3]) < 0 && Object.prototype.propertyIsEnumerable.call(s3, p3[i3]))
        t3[p3[i3]] = s3[p3[i3]];
    }
  return t3;
}
function __spreadArray(to2, from, pack) {
  if (pack || arguments.length === 2) for (var i3 = 0, l3 = from.length, ar2; i3 < l3; i3++) {
    if (ar2 || !(i3 in from)) {
      if (!ar2) ar2 = Array.prototype.slice.call(from, 0, i3);
      ar2[i3] = from[i3];
    }
  }
  return to2.concat(ar2 || Array.prototype.slice.call(from));
}
typeof SuppressedError === "function" ? SuppressedError : function(error, suppressed, message) {
  var e12 = new Error(message);
  return e12.name = "SuppressedError", e12.error = error, e12.suppressed = suppressed, e12;
};
var zeroRightClassName = "right-scroll-bar-position";
var fullWidthClassName = "width-before-scroll-bar";
var noScrollbarsClassName = "with-scroll-bars-hidden";
var removedBarSizeVariable = "--removed-body-scroll-bar-size";
function assignRef(ref, value) {
  if (typeof ref === "function") {
    ref(value);
  } else if (ref) {
    ref.current = value;
  }
  return ref;
}
function useCallbackRef(initialValue, callback) {
  var ref = reactExports.useState(function() {
    return {
      // value
      value: initialValue,
      // last callback
      callback,
      // "memoized" public interface
      facade: {
        get current() {
          return ref.value;
        },
        set current(value) {
          var last = ref.value;
          if (last !== value) {
            ref.value = value;
            ref.callback(value, last);
          }
        }
      }
    };
  })[0];
  ref.callback = callback;
  return ref.facade;
}
var useIsomorphicLayoutEffect$1 = typeof window !== "undefined" ? reactExports.useLayoutEffect : reactExports.useEffect;
var currentValues = /* @__PURE__ */ new WeakMap();
function useMergeRefs(refs, defaultValue) {
  var callbackRef = useCallbackRef(null, function(newValue) {
    return refs.forEach(function(ref) {
      return assignRef(ref, newValue);
    });
  });
  useIsomorphicLayoutEffect$1(function() {
    var oldValue = currentValues.get(callbackRef);
    if (oldValue) {
      var prevRefs_1 = new Set(oldValue);
      var nextRefs_1 = new Set(refs);
      var current_1 = callbackRef.current;
      prevRefs_1.forEach(function(ref) {
        if (!nextRefs_1.has(ref)) {
          assignRef(ref, null);
        }
      });
      nextRefs_1.forEach(function(ref) {
        if (!prevRefs_1.has(ref)) {
          assignRef(ref, current_1);
        }
      });
    }
    currentValues.set(callbackRef, refs);
  }, [refs]);
  return callbackRef;
}
function ItoI(a3) {
  return a3;
}
function innerCreateMedium(defaults, middleware) {
  if (middleware === void 0) {
    middleware = ItoI;
  }
  var buffer = [];
  var assigned = false;
  var medium = {
    read: function() {
      if (assigned) {
        throw new Error("Sidecar: could not `read` from an `assigned` medium. `read` could be used only with `useMedium`.");
      }
      if (buffer.length) {
        return buffer[buffer.length - 1];
      }
      return defaults;
    },
    useMedium: function(data) {
      var item = middleware(data, assigned);
      buffer.push(item);
      return function() {
        buffer = buffer.filter(function(x3) {
          return x3 !== item;
        });
      };
    },
    assignSyncMedium: function(cb2) {
      assigned = true;
      while (buffer.length) {
        var cbs = buffer;
        buffer = [];
        cbs.forEach(cb2);
      }
      buffer = {
        push: function(x3) {
          return cb2(x3);
        },
        filter: function() {
          return buffer;
        }
      };
    },
    assignMedium: function(cb2) {
      assigned = true;
      var pendingQueue = [];
      if (buffer.length) {
        var cbs = buffer;
        buffer = [];
        cbs.forEach(cb2);
        pendingQueue = buffer;
      }
      var executeQueue = function() {
        var cbs2 = pendingQueue;
        pendingQueue = [];
        cbs2.forEach(cb2);
      };
      var cycle = function() {
        return Promise.resolve().then(executeQueue);
      };
      cycle();
      buffer = {
        push: function(x3) {
          pendingQueue.push(x3);
          cycle();
        },
        filter: function(filter) {
          pendingQueue = pendingQueue.filter(filter);
          return buffer;
        }
      };
    }
  };
  return medium;
}
function createSidecarMedium(options) {
  if (options === void 0) {
    options = {};
  }
  var medium = innerCreateMedium(null);
  medium.options = __assign({ async: true, ssr: false }, options);
  return medium;
}
var SideCar$1 = function(_a2) {
  var sideCar = _a2.sideCar, rest = __rest(_a2, ["sideCar"]);
  if (!sideCar) {
    throw new Error("Sidecar: please provide `sideCar` property to import the right car");
  }
  var Target = sideCar.read();
  if (!Target) {
    throw new Error("Sidecar medium not found");
  }
  return reactExports.createElement(Target, __assign({}, rest));
};
SideCar$1.isSideCarExport = true;
function exportSidecar(medium, exported) {
  medium.useMedium(exported);
  return SideCar$1;
}
var effectCar = createSidecarMedium();
var nothing = function() {
  return;
};
var RemoveScroll = reactExports.forwardRef(function(props, parentRef) {
  var ref = reactExports.useRef(null);
  var _a2 = reactExports.useState({
    onScrollCapture: nothing,
    onWheelCapture: nothing,
    onTouchMoveCapture: nothing
  }), callbacks = _a2[0], setCallbacks = _a2[1];
  var forwardProps = props.forwardProps, children = props.children, className = props.className, removeScrollBar = props.removeScrollBar, enabled = props.enabled, shards = props.shards, sideCar = props.sideCar, noRelative = props.noRelative, noIsolation = props.noIsolation, inert = props.inert, allowPinchZoom = props.allowPinchZoom, _b = props.as, Container = _b === void 0 ? "div" : _b, gapMode = props.gapMode, rest = __rest(props, ["forwardProps", "children", "className", "removeScrollBar", "enabled", "shards", "sideCar", "noRelative", "noIsolation", "inert", "allowPinchZoom", "as", "gapMode"]);
  var SideCar2 = sideCar;
  var containerRef = useMergeRefs([ref, parentRef]);
  var containerProps = __assign(__assign({}, rest), callbacks);
  return reactExports.createElement(
    reactExports.Fragment,
    null,
    enabled && reactExports.createElement(SideCar2, { sideCar: effectCar, removeScrollBar, shards, noRelative, noIsolation, inert, setCallbacks, allowPinchZoom: !!allowPinchZoom, lockRef: ref, gapMode }),
    forwardProps ? reactExports.cloneElement(reactExports.Children.only(children), __assign(__assign({}, containerProps), { ref: containerRef })) : reactExports.createElement(Container, __assign({}, containerProps, { className, ref: containerRef }), children)
  );
});
RemoveScroll.defaultProps = {
  enabled: true,
  removeScrollBar: true,
  inert: false
};
RemoveScroll.classNames = {
  fullWidth: fullWidthClassName,
  zeroRight: zeroRightClassName
};
var getNonce = function() {
  if (typeof __webpack_nonce__ !== "undefined") {
    return __webpack_nonce__;
  }
  return void 0;
};
function makeStyleTag() {
  if (!document)
    return null;
  var tag = document.createElement("style");
  tag.type = "text/css";
  var nonce = getNonce();
  if (nonce) {
    tag.setAttribute("nonce", nonce);
  }
  return tag;
}
function injectStyles(tag, css) {
  if (tag.styleSheet) {
    tag.styleSheet.cssText = css;
  } else {
    tag.appendChild(document.createTextNode(css));
  }
}
function insertStyleTag(tag) {
  var head = document.head || document.getElementsByTagName("head")[0];
  head.appendChild(tag);
}
var stylesheetSingleton = function() {
  var counter = 0;
  var stylesheet = null;
  return {
    add: function(style) {
      if (counter == 0) {
        if (stylesheet = makeStyleTag()) {
          injectStyles(stylesheet, style);
          insertStyleTag(stylesheet);
        }
      }
      counter++;
    },
    remove: function() {
      counter--;
      if (!counter && stylesheet) {
        stylesheet.parentNode && stylesheet.parentNode.removeChild(stylesheet);
        stylesheet = null;
      }
    }
  };
};
var styleHookSingleton = function() {
  var sheet = stylesheetSingleton();
  return function(styles, isDynamic) {
    reactExports.useEffect(function() {
      sheet.add(styles);
      return function() {
        sheet.remove();
      };
    }, [styles && isDynamic]);
  };
};
var styleSingleton = function() {
  var useStyle = styleHookSingleton();
  var Sheet = function(_a2) {
    var styles = _a2.styles, dynamic = _a2.dynamic;
    useStyle(styles, dynamic);
    return null;
  };
  return Sheet;
};
var zeroGap = {
  left: 0,
  top: 0,
  right: 0,
  gap: 0
};
var parse = function(x3) {
  return parseInt(x3 || "", 10) || 0;
};
var getOffset = function(gapMode) {
  var cs2 = window.getComputedStyle(document.body);
  var left = cs2[gapMode === "padding" ? "paddingLeft" : "marginLeft"];
  var top2 = cs2[gapMode === "padding" ? "paddingTop" : "marginTop"];
  var right = cs2[gapMode === "padding" ? "paddingRight" : "marginRight"];
  return [parse(left), parse(top2), parse(right)];
};
var getGapWidth = function(gapMode) {
  if (gapMode === void 0) {
    gapMode = "margin";
  }
  if (typeof window === "undefined") {
    return zeroGap;
  }
  var offsets = getOffset(gapMode);
  var documentWidth = document.documentElement.clientWidth;
  var windowWidth = window.innerWidth;
  return {
    left: offsets[0],
    top: offsets[1],
    right: offsets[2],
    gap: Math.max(0, windowWidth - documentWidth + offsets[2] - offsets[0])
  };
};
var Style = styleSingleton();
var lockAttribute = "data-scroll-locked";
var getStyles = function(_a2, allowRelative, gapMode, important) {
  var left = _a2.left, top2 = _a2.top, right = _a2.right, gap = _a2.gap;
  if (gapMode === void 0) {
    gapMode = "margin";
  }
  return "\n  .".concat(noScrollbarsClassName, " {\n   overflow: hidden ").concat(important, ";\n   padding-right: ").concat(gap, "px ").concat(important, ";\n  }\n  body[").concat(lockAttribute, "] {\n    overflow: hidden ").concat(important, ";\n    overscroll-behavior: contain;\n    ").concat([
    allowRelative && "position: relative ".concat(important, ";"),
    gapMode === "margin" && "\n    padding-left: ".concat(left, "px;\n    padding-top: ").concat(top2, "px;\n    padding-right: ").concat(right, "px;\n    margin-left:0;\n    margin-top:0;\n    margin-right: ").concat(gap, "px ").concat(important, ";\n    "),
    gapMode === "padding" && "padding-right: ".concat(gap, "px ").concat(important, ";")
  ].filter(Boolean).join(""), "\n  }\n  \n  .").concat(zeroRightClassName, " {\n    right: ").concat(gap, "px ").concat(important, ";\n  }\n  \n  .").concat(fullWidthClassName, " {\n    margin-right: ").concat(gap, "px ").concat(important, ";\n  }\n  \n  .").concat(zeroRightClassName, " .").concat(zeroRightClassName, " {\n    right: 0 ").concat(important, ";\n  }\n  \n  .").concat(fullWidthClassName, " .").concat(fullWidthClassName, " {\n    margin-right: 0 ").concat(important, ";\n  }\n  \n  body[").concat(lockAttribute, "] {\n    ").concat(removedBarSizeVariable, ": ").concat(gap, "px;\n  }\n");
};
var getCurrentUseCounter = function() {
  var counter = parseInt(document.body.getAttribute(lockAttribute) || "0", 10);
  return isFinite(counter) ? counter : 0;
};
var useLockAttribute = function() {
  reactExports.useEffect(function() {
    document.body.setAttribute(lockAttribute, (getCurrentUseCounter() + 1).toString());
    return function() {
      var newCounter = getCurrentUseCounter() - 1;
      if (newCounter <= 0) {
        document.body.removeAttribute(lockAttribute);
      } else {
        document.body.setAttribute(lockAttribute, newCounter.toString());
      }
    };
  }, []);
};
var RemoveScrollBar = function(_a2) {
  var noRelative = _a2.noRelative, noImportant = _a2.noImportant, _b = _a2.gapMode, gapMode = _b === void 0 ? "margin" : _b;
  useLockAttribute();
  var gap = reactExports.useMemo(function() {
    return getGapWidth(gapMode);
  }, [gapMode]);
  return reactExports.createElement(Style, { styles: getStyles(gap, !noRelative, gapMode, !noImportant ? "!important" : "") });
};
var passiveSupported = false;
if (typeof window !== "undefined") {
  try {
    var options = Object.defineProperty({}, "passive", {
      get: function() {
        passiveSupported = true;
        return true;
      }
    });
    window.addEventListener("test", options, options);
    window.removeEventListener("test", options, options);
  } catch (err2) {
    passiveSupported = false;
  }
}
var nonPassive = passiveSupported ? { passive: false } : false;
var alwaysContainsScroll = function(node) {
  return node.tagName === "TEXTAREA";
};
var elementCanBeScrolled = function(node, overflow) {
  if (!(node instanceof Element)) {
    return false;
  }
  var styles = window.getComputedStyle(node);
  return (
    // not-not-scrollable
    styles[overflow] !== "hidden" && // contains scroll inside self
    !(styles.overflowY === styles.overflowX && !alwaysContainsScroll(node) && styles[overflow] === "visible")
  );
};
var elementCouldBeVScrolled = function(node) {
  return elementCanBeScrolled(node, "overflowY");
};
var elementCouldBeHScrolled = function(node) {
  return elementCanBeScrolled(node, "overflowX");
};
var locationCouldBeScrolled = function(axis, node) {
  var ownerDocument = node.ownerDocument;
  var current = node;
  do {
    if (typeof ShadowRoot !== "undefined" && current instanceof ShadowRoot) {
      current = current.host;
    }
    var isScrollable = elementCouldBeScrolled(axis, current);
    if (isScrollable) {
      var _a2 = getScrollVariables(axis, current), scrollHeight = _a2[1], clientHeight = _a2[2];
      if (scrollHeight > clientHeight) {
        return true;
      }
    }
    current = current.parentNode;
  } while (current && current !== ownerDocument.body);
  return false;
};
var getVScrollVariables = function(_a2) {
  var scrollTop = _a2.scrollTop, scrollHeight = _a2.scrollHeight, clientHeight = _a2.clientHeight;
  return [
    scrollTop,
    scrollHeight,
    clientHeight
  ];
};
var getHScrollVariables = function(_a2) {
  var scrollLeft = _a2.scrollLeft, scrollWidth = _a2.scrollWidth, clientWidth = _a2.clientWidth;
  return [
    scrollLeft,
    scrollWidth,
    clientWidth
  ];
};
var elementCouldBeScrolled = function(axis, node) {
  return axis === "v" ? elementCouldBeVScrolled(node) : elementCouldBeHScrolled(node);
};
var getScrollVariables = function(axis, node) {
  return axis === "v" ? getVScrollVariables(node) : getHScrollVariables(node);
};
var getDirectionFactor = function(axis, direction) {
  return axis === "h" && direction === "rtl" ? -1 : 1;
};
var handleScroll = function(axis, endTarget, event, sourceDelta, noOverscroll) {
  var directionFactor = getDirectionFactor(axis, window.getComputedStyle(endTarget).direction);
  var delta = directionFactor * sourceDelta;
  var target = event.target;
  var targetInLock = endTarget.contains(target);
  var shouldCancelScroll = false;
  var isDeltaPositive = delta > 0;
  var availableScroll = 0;
  var availableScrollTop = 0;
  do {
    if (!target) {
      break;
    }
    var _a2 = getScrollVariables(axis, target), position = _a2[0], scroll_1 = _a2[1], capacity = _a2[2];
    var elementScroll = scroll_1 - capacity - directionFactor * position;
    if (position || elementScroll) {
      if (elementCouldBeScrolled(axis, target)) {
        availableScroll += elementScroll;
        availableScrollTop += position;
      }
    }
    var parent_1 = target.parentNode;
    target = parent_1 && parent_1.nodeType === Node.DOCUMENT_FRAGMENT_NODE ? parent_1.host : parent_1;
  } while (
    // portaled content
    !targetInLock && target !== document.body || // self content
    targetInLock && (endTarget.contains(target) || endTarget === target)
  );
  if (isDeltaPositive && (Math.abs(availableScroll) < 1 || false)) {
    shouldCancelScroll = true;
  } else if (!isDeltaPositive && (Math.abs(availableScrollTop) < 1 || false)) {
    shouldCancelScroll = true;
  }
  return shouldCancelScroll;
};
var getTouchXY = function(event) {
  return "changedTouches" in event ? [event.changedTouches[0].clientX, event.changedTouches[0].clientY] : [0, 0];
};
var getDeltaXY = function(event) {
  return [event.deltaX, event.deltaY];
};
var extractRef = function(ref) {
  return ref && "current" in ref ? ref.current : ref;
};
var deltaCompare = function(x3, y3) {
  return x3[0] === y3[0] && x3[1] === y3[1];
};
var generateStyle = function(id2) {
  return "\n  .block-interactivity-".concat(id2, " {pointer-events: none;}\n  .allow-interactivity-").concat(id2, " {pointer-events: all;}\n");
};
var idCounter = 0;
var lockStack = [];
function RemoveScrollSideCar(props) {
  var shouldPreventQueue = reactExports.useRef([]);
  var touchStartRef = reactExports.useRef([0, 0]);
  var activeAxis = reactExports.useRef();
  var id2 = reactExports.useState(idCounter++)[0];
  var Style2 = reactExports.useState(styleSingleton)[0];
  var lastProps = reactExports.useRef(props);
  reactExports.useEffect(function() {
    lastProps.current = props;
  }, [props]);
  reactExports.useEffect(function() {
    if (props.inert) {
      document.body.classList.add("block-interactivity-".concat(id2));
      var allow_1 = __spreadArray([props.lockRef.current], (props.shards || []).map(extractRef), true).filter(Boolean);
      allow_1.forEach(function(el2) {
        return el2.classList.add("allow-interactivity-".concat(id2));
      });
      return function() {
        document.body.classList.remove("block-interactivity-".concat(id2));
        allow_1.forEach(function(el2) {
          return el2.classList.remove("allow-interactivity-".concat(id2));
        });
      };
    }
    return;
  }, [props.inert, props.lockRef.current, props.shards]);
  var shouldCancelEvent = reactExports.useCallback(function(event, parent) {
    if ("touches" in event && event.touches.length === 2 || event.type === "wheel" && event.ctrlKey) {
      return !lastProps.current.allowPinchZoom;
    }
    var touch = getTouchXY(event);
    var touchStart = touchStartRef.current;
    var deltaX = "deltaX" in event ? event.deltaX : touchStart[0] - touch[0];
    var deltaY = "deltaY" in event ? event.deltaY : touchStart[1] - touch[1];
    var currentAxis;
    var target = event.target;
    var moveDirection = Math.abs(deltaX) > Math.abs(deltaY) ? "h" : "v";
    if ("touches" in event && moveDirection === "h" && target.type === "range") {
      return false;
    }
    var canBeScrolledInMainDirection = locationCouldBeScrolled(moveDirection, target);
    if (!canBeScrolledInMainDirection) {
      return true;
    }
    if (canBeScrolledInMainDirection) {
      currentAxis = moveDirection;
    } else {
      currentAxis = moveDirection === "v" ? "h" : "v";
      canBeScrolledInMainDirection = locationCouldBeScrolled(moveDirection, target);
    }
    if (!canBeScrolledInMainDirection) {
      return false;
    }
    if (!activeAxis.current && "changedTouches" in event && (deltaX || deltaY)) {
      activeAxis.current = currentAxis;
    }
    if (!currentAxis) {
      return true;
    }
    var cancelingAxis = activeAxis.current || currentAxis;
    return handleScroll(cancelingAxis, parent, event, cancelingAxis === "h" ? deltaX : deltaY);
  }, []);
  var shouldPrevent = reactExports.useCallback(function(_event) {
    var event = _event;
    if (!lockStack.length || lockStack[lockStack.length - 1] !== Style2) {
      return;
    }
    var delta = "deltaY" in event ? getDeltaXY(event) : getTouchXY(event);
    var sourceEvent = shouldPreventQueue.current.filter(function(e12) {
      return e12.name === event.type && (e12.target === event.target || event.target === e12.shadowParent) && deltaCompare(e12.delta, delta);
    })[0];
    if (sourceEvent && sourceEvent.should) {
      if (event.cancelable) {
        event.preventDefault();
      }
      return;
    }
    if (!sourceEvent) {
      var shardNodes = (lastProps.current.shards || []).map(extractRef).filter(Boolean).filter(function(node) {
        return node.contains(event.target);
      });
      var shouldStop = shardNodes.length > 0 ? shouldCancelEvent(event, shardNodes[0]) : !lastProps.current.noIsolation;
      if (shouldStop) {
        if (event.cancelable) {
          event.preventDefault();
        }
      }
    }
  }, []);
  var shouldCancel = reactExports.useCallback(function(name, delta, target, should) {
    var event = { name, delta, target, should, shadowParent: getOutermostShadowParent(target) };
    shouldPreventQueue.current.push(event);
    setTimeout(function() {
      shouldPreventQueue.current = shouldPreventQueue.current.filter(function(e12) {
        return e12 !== event;
      });
    }, 1);
  }, []);
  var scrollTouchStart = reactExports.useCallback(function(event) {
    touchStartRef.current = getTouchXY(event);
    activeAxis.current = void 0;
  }, []);
  var scrollWheel = reactExports.useCallback(function(event) {
    shouldCancel(event.type, getDeltaXY(event), event.target, shouldCancelEvent(event, props.lockRef.current));
  }, []);
  var scrollTouchMove = reactExports.useCallback(function(event) {
    shouldCancel(event.type, getTouchXY(event), event.target, shouldCancelEvent(event, props.lockRef.current));
  }, []);
  reactExports.useEffect(function() {
    lockStack.push(Style2);
    props.setCallbacks({
      onScrollCapture: scrollWheel,
      onWheelCapture: scrollWheel,
      onTouchMoveCapture: scrollTouchMove
    });
    document.addEventListener("wheel", shouldPrevent, nonPassive);
    document.addEventListener("touchmove", shouldPrevent, nonPassive);
    document.addEventListener("touchstart", scrollTouchStart, nonPassive);
    return function() {
      lockStack = lockStack.filter(function(inst) {
        return inst !== Style2;
      });
      document.removeEventListener("wheel", shouldPrevent, nonPassive);
      document.removeEventListener("touchmove", shouldPrevent, nonPassive);
      document.removeEventListener("touchstart", scrollTouchStart, nonPassive);
    };
  }, []);
  var removeScrollBar = props.removeScrollBar, inert = props.inert;
  return reactExports.createElement(
    reactExports.Fragment,
    null,
    inert ? reactExports.createElement(Style2, { styles: generateStyle(id2) }) : null,
    removeScrollBar ? reactExports.createElement(RemoveScrollBar, { noRelative: props.noRelative, gapMode: props.gapMode }) : null
  );
}
function getOutermostShadowParent(node) {
  var shadowParent = null;
  while (node !== null) {
    if (node instanceof ShadowRoot) {
      shadowParent = node.host;
      node = node.host;
    }
    node = node.parentNode;
  }
  return shadowParent;
}
const SideCar = exportSidecar(effectCar, RemoveScrollSideCar);
var ReactRemoveScroll = reactExports.forwardRef(function(props, ref) {
  return reactExports.createElement(RemoveScroll, __assign({}, props, { ref, sideCar: SideCar }));
});
ReactRemoveScroll.classNames = RemoveScroll.classNames;
var POPOVER_NAME = "Popover";
var [createPopoverContext] = createContextScope(POPOVER_NAME, [
  createPopperScope
]);
var usePopperScope = createPopperScope();
var [PopoverProvider, usePopoverContext] = createPopoverContext(POPOVER_NAME);
var Popover = (props) => {
  const {
    __scopePopover,
    children,
    open: openProp,
    defaultOpen,
    onOpenChange,
    modal = false
  } = props;
  const popperScope = usePopperScope(__scopePopover);
  const triggerRef = reactExports.useRef(null);
  const [hasCustomAnchor, setHasCustomAnchor] = reactExports.useState(false);
  const [open = false, setOpen] = useControllableState({
    prop: openProp,
    defaultProp: defaultOpen,
    onChange: onOpenChange
  });
  return /* @__PURE__ */ jsxRuntimeExports.jsx(Root2$1, { ...popperScope, children: /* @__PURE__ */ jsxRuntimeExports.jsx(
    PopoverProvider,
    {
      scope: __scopePopover,
      contentId: useId(),
      triggerRef,
      open,
      onOpenChange: setOpen,
      onOpenToggle: reactExports.useCallback(() => setOpen((prevOpen) => !prevOpen), [setOpen]),
      hasCustomAnchor,
      onCustomAnchorAdd: reactExports.useCallback(() => setHasCustomAnchor(true), []),
      onCustomAnchorRemove: reactExports.useCallback(() => setHasCustomAnchor(false), []),
      modal,
      children
    }
  ) });
};
Popover.displayName = POPOVER_NAME;
var ANCHOR_NAME = "PopoverAnchor";
var PopoverAnchor = reactExports.forwardRef(
  (props, forwardedRef) => {
    const { __scopePopover, ...anchorProps } = props;
    const context = usePopoverContext(ANCHOR_NAME, __scopePopover);
    const popperScope = usePopperScope(__scopePopover);
    const { onCustomAnchorAdd, onCustomAnchorRemove } = context;
    reactExports.useEffect(() => {
      onCustomAnchorAdd();
      return () => onCustomAnchorRemove();
    }, [onCustomAnchorAdd, onCustomAnchorRemove]);
    return /* @__PURE__ */ jsxRuntimeExports.jsx(Anchor, { ...popperScope, ...anchorProps, ref: forwardedRef });
  }
);
PopoverAnchor.displayName = ANCHOR_NAME;
var TRIGGER_NAME = "PopoverTrigger";
var PopoverTrigger = reactExports.forwardRef(
  (props, forwardedRef) => {
    const { __scopePopover, ...triggerProps } = props;
    const context = usePopoverContext(TRIGGER_NAME, __scopePopover);
    const popperScope = usePopperScope(__scopePopover);
    const composedTriggerRef = useComposedRefs(forwardedRef, context.triggerRef);
    const trigger = /* @__PURE__ */ jsxRuntimeExports.jsx(
      Primitive.button,
      {
        type: "button",
        "aria-haspopup": "dialog",
        "aria-expanded": context.open,
        "aria-controls": context.contentId,
        "data-state": getState(context.open),
        ...triggerProps,
        ref: composedTriggerRef,
        onClick: composeEventHandlers(props.onClick, context.onOpenToggle)
      }
    );
    return context.hasCustomAnchor ? trigger : /* @__PURE__ */ jsxRuntimeExports.jsx(Anchor, { asChild: true, ...popperScope, children: trigger });
  }
);
PopoverTrigger.displayName = TRIGGER_NAME;
var PORTAL_NAME = "PopoverPortal";
var [PortalProvider, usePortalContext] = createPopoverContext(PORTAL_NAME, {
  forceMount: void 0
});
var PopoverPortal = (props) => {
  const { __scopePopover, forceMount, children, container } = props;
  const context = usePopoverContext(PORTAL_NAME, __scopePopover);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(PortalProvider, { scope: __scopePopover, forceMount, children: /* @__PURE__ */ jsxRuntimeExports.jsx(Presence, { present: forceMount || context.open, children: /* @__PURE__ */ jsxRuntimeExports.jsx(Portal$1, { asChild: true, container, children }) }) });
};
PopoverPortal.displayName = PORTAL_NAME;
var CONTENT_NAME = "PopoverContent";
var PopoverContent = reactExports.forwardRef(
  (props, forwardedRef) => {
    const portalContext = usePortalContext(CONTENT_NAME, props.__scopePopover);
    const { forceMount = portalContext.forceMount, ...contentProps } = props;
    const context = usePopoverContext(CONTENT_NAME, props.__scopePopover);
    return /* @__PURE__ */ jsxRuntimeExports.jsx(Presence, { present: forceMount || context.open, children: context.modal ? /* @__PURE__ */ jsxRuntimeExports.jsx(PopoverContentModal, { ...contentProps, ref: forwardedRef }) : /* @__PURE__ */ jsxRuntimeExports.jsx(PopoverContentNonModal, { ...contentProps, ref: forwardedRef }) });
  }
);
PopoverContent.displayName = CONTENT_NAME;
var PopoverContentModal = reactExports.forwardRef(
  (props, forwardedRef) => {
    const context = usePopoverContext(CONTENT_NAME, props.__scopePopover);
    const contentRef = reactExports.useRef(null);
    const composedRefs = useComposedRefs(forwardedRef, contentRef);
    const isRightClickOutsideRef = reactExports.useRef(false);
    reactExports.useEffect(() => {
      const content = contentRef.current;
      if (content) return hideOthers(content);
    }, []);
    return /* @__PURE__ */ jsxRuntimeExports.jsx(ReactRemoveScroll, { as: Slot, allowPinchZoom: true, children: /* @__PURE__ */ jsxRuntimeExports.jsx(
      PopoverContentImpl,
      {
        ...props,
        ref: composedRefs,
        trapFocus: context.open,
        disableOutsidePointerEvents: true,
        onCloseAutoFocus: composeEventHandlers(props.onCloseAutoFocus, (event) => {
          event.preventDefault();
          if (!isRightClickOutsideRef.current) context.triggerRef.current?.focus();
        }),
        onPointerDownOutside: composeEventHandlers(
          props.onPointerDownOutside,
          (event) => {
            const originalEvent = event.detail.originalEvent;
            const ctrlLeftClick = originalEvent.button === 0 && originalEvent.ctrlKey === true;
            const isRightClick = originalEvent.button === 2 || ctrlLeftClick;
            isRightClickOutsideRef.current = isRightClick;
          },
          { checkForDefaultPrevented: false }
        ),
        onFocusOutside: composeEventHandlers(
          props.onFocusOutside,
          (event) => event.preventDefault(),
          { checkForDefaultPrevented: false }
        )
      }
    ) });
  }
);
var PopoverContentNonModal = reactExports.forwardRef(
  (props, forwardedRef) => {
    const context = usePopoverContext(CONTENT_NAME, props.__scopePopover);
    const hasInteractedOutsideRef = reactExports.useRef(false);
    const hasPointerDownOutsideRef = reactExports.useRef(false);
    return /* @__PURE__ */ jsxRuntimeExports.jsx(
      PopoverContentImpl,
      {
        ...props,
        ref: forwardedRef,
        trapFocus: false,
        disableOutsidePointerEvents: false,
        onCloseAutoFocus: (event) => {
          props.onCloseAutoFocus?.(event);
          if (!event.defaultPrevented) {
            if (!hasInteractedOutsideRef.current) context.triggerRef.current?.focus();
            event.preventDefault();
          }
          hasInteractedOutsideRef.current = false;
          hasPointerDownOutsideRef.current = false;
        },
        onInteractOutside: (event) => {
          props.onInteractOutside?.(event);
          if (!event.defaultPrevented) {
            hasInteractedOutsideRef.current = true;
            if (event.detail.originalEvent.type === "pointerdown") {
              hasPointerDownOutsideRef.current = true;
            }
          }
          const target = event.target;
          const targetIsTrigger = context.triggerRef.current?.contains(target);
          if (targetIsTrigger) event.preventDefault();
          if (event.detail.originalEvent.type === "focusin" && hasPointerDownOutsideRef.current) {
            event.preventDefault();
          }
        }
      }
    );
  }
);
var PopoverContentImpl = reactExports.forwardRef(
  (props, forwardedRef) => {
    const {
      __scopePopover,
      trapFocus,
      onOpenAutoFocus,
      onCloseAutoFocus,
      disableOutsidePointerEvents,
      onEscapeKeyDown,
      onPointerDownOutside,
      onFocusOutside,
      onInteractOutside,
      ...contentProps
    } = props;
    const context = usePopoverContext(CONTENT_NAME, __scopePopover);
    const popperScope = usePopperScope(__scopePopover);
    useFocusGuards();
    return /* @__PURE__ */ jsxRuntimeExports.jsx(
      FocusScope,
      {
        asChild: true,
        loop: true,
        trapped: trapFocus,
        onMountAutoFocus: onOpenAutoFocus,
        onUnmountAutoFocus: onCloseAutoFocus,
        children: /* @__PURE__ */ jsxRuntimeExports.jsx(
          DismissableLayer,
          {
            asChild: true,
            disableOutsidePointerEvents,
            onInteractOutside,
            onEscapeKeyDown,
            onPointerDownOutside,
            onFocusOutside,
            onDismiss: () => context.onOpenChange(false),
            children: /* @__PURE__ */ jsxRuntimeExports.jsx(
              Content,
              {
                "data-state": getState(context.open),
                role: "dialog",
                id: context.contentId,
                ...popperScope,
                ...contentProps,
                ref: forwardedRef,
                style: {
                  ...contentProps.style,
                  // re-namespace exposed content custom properties
                  ...{
                    "--radix-popover-content-transform-origin": "var(--radix-popper-transform-origin)",
                    "--radix-popover-content-available-width": "var(--radix-popper-available-width)",
                    "--radix-popover-content-available-height": "var(--radix-popper-available-height)",
                    "--radix-popover-trigger-width": "var(--radix-popper-anchor-width)",
                    "--radix-popover-trigger-height": "var(--radix-popper-anchor-height)"
                  }
                }
              }
            )
          }
        )
      }
    );
  }
);
var CLOSE_NAME = "PopoverClose";
var PopoverClose = reactExports.forwardRef(
  (props, forwardedRef) => {
    const { __scopePopover, ...closeProps } = props;
    const context = usePopoverContext(CLOSE_NAME, __scopePopover);
    return /* @__PURE__ */ jsxRuntimeExports.jsx(
      Primitive.button,
      {
        type: "button",
        ...closeProps,
        ref: forwardedRef,
        onClick: composeEventHandlers(props.onClick, () => context.onOpenChange(false))
      }
    );
  }
);
PopoverClose.displayName = CLOSE_NAME;
var ARROW_NAME = "PopoverArrow";
var PopoverArrow = reactExports.forwardRef(
  (props, forwardedRef) => {
    const { __scopePopover, ...arrowProps } = props;
    const popperScope = usePopperScope(__scopePopover);
    return /* @__PURE__ */ jsxRuntimeExports.jsx(Arrow, { ...popperScope, ...arrowProps, ref: forwardedRef });
  }
);
PopoverArrow.displayName = ARROW_NAME;
function getState(open) {
  return open ? "open" : "closed";
}
var Root2 = Popover;
var Trigger = PopoverTrigger;
var Portal = PopoverPortal;
var Content2 = PopoverContent;
var Arrow2 = PopoverArrow;
var fuzzy = { exports: {} };
var hasRequiredFuzzy;
function requireFuzzy() {
  if (hasRequiredFuzzy) return fuzzy.exports;
  hasRequiredFuzzy = 1;
  (function(module, exports$1) {
    (function() {
      var fuzzy2 = {};
      {
        module.exports = fuzzy2;
      }
      fuzzy2.simpleFilter = function(pattern, array) {
        return array.filter(function(str) {
          return fuzzy2.test(pattern, str);
        });
      };
      fuzzy2.test = function(pattern, str) {
        return fuzzy2.match(pattern, str) !== null;
      };
      fuzzy2.match = function(pattern, str, opts) {
        opts = opts || {};
        var patternIdx = 0, result = [], len = str.length, totalScore = 0, currScore = 0, pre = opts.pre || "", post = opts.post || "", compareString = opts.caseSensitive && str || str.toLowerCase(), ch2;
        pattern = opts.caseSensitive && pattern || pattern.toLowerCase();
        for (var idx = 0; idx < len; idx++) {
          ch2 = str[idx];
          if (compareString[idx] === pattern[patternIdx]) {
            ch2 = pre + ch2 + post;
            patternIdx += 1;
            currScore += 1 + currScore;
          } else {
            currScore = 0;
          }
          totalScore += currScore;
          result[result.length] = ch2;
        }
        if (patternIdx === pattern.length) {
          totalScore = compareString === pattern ? Infinity : totalScore;
          return { rendered: result.join(""), score: totalScore };
        }
        return null;
      };
      fuzzy2.filter = function(pattern, arr, opts) {
        if (!arr || arr.length === 0) {
          return [];
        }
        if (typeof pattern !== "string") {
          return arr;
        }
        opts = opts || {};
        return arr.reduce(function(prev, element, idx, arr2) {
          var str = element;
          if (opts.extract) {
            str = opts.extract(element);
          }
          var rendered = fuzzy2.match(pattern, str, opts);
          if (rendered != null) {
            prev[prev.length] = {
              string: rendered.rendered,
              score: rendered.score,
              index: idx,
              original: element
            };
          }
          return prev;
        }, []).sort(function(a3, b3) {
          var compare = b3.score - a3.score;
          if (compare) return compare;
          return a3.index - b3.index;
        });
      };
    })();
  })(fuzzy);
  return fuzzy.exports;
}
var fuzzyExports = requireFuzzy();
const _k = /* @__PURE__ */ getDefaultExportFromCjs(fuzzyExports);
const __vite_import_meta_env__$1 = {};
const createStoreImpl$1 = (createState) => {
  let state;
  const listeners = /* @__PURE__ */ new Set();
  const setState = (partial, replace) => {
    const nextState = typeof partial === "function" ? partial(state) : partial;
    if (!Object.is(nextState, state)) {
      const previousState = state;
      state = (replace != null ? replace : typeof nextState !== "object" || nextState === null) ? nextState : Object.assign({}, state, nextState);
      listeners.forEach((listener) => listener(state, previousState));
    }
  };
  const getState2 = () => state;
  const getInitialState = () => initialState;
  const subscribe = (listener) => {
    listeners.add(listener);
    return () => listeners.delete(listener);
  };
  const destroy = () => {
    if ((__vite_import_meta_env__$1 ? "production" : void 0) !== "production") {
      console.warn(
        "[DEPRECATED] The `destroy` method will be unsupported in a future version. Instead use unsubscribe function returned by subscribe. Everything will be garbage-collected if store is garbage-collected."
      );
    }
    listeners.clear();
  };
  const api = { setState, getState: getState2, getInitialState, subscribe, destroy };
  const initialState = state = createState(setState, getState2, api);
  return api;
};
const createStore$1 = (createState) => createState ? createStoreImpl$1(createState) : createStoreImpl$1;
var withSelector = { exports: {} };
var withSelector_production = {};
var shim = { exports: {} };
var useSyncExternalStoreShim_production = {};
var hasRequiredUseSyncExternalStoreShim_production;
function requireUseSyncExternalStoreShim_production() {
  if (hasRequiredUseSyncExternalStoreShim_production) return useSyncExternalStoreShim_production;
  hasRequiredUseSyncExternalStoreShim_production = 1;
  var React2 = requireReact();
  function is2(x3, y3) {
    return x3 === y3 && (0 !== x3 || 1 / x3 === 1 / y3) || x3 !== x3 && y3 !== y3;
  }
  var objectIs = "function" === typeof Object.is ? Object.is : is2, useState = React2.useState, useEffect = React2.useEffect, useLayoutEffect = React2.useLayoutEffect, useDebugValue2 = React2.useDebugValue;
  function useSyncExternalStore$2(subscribe, getSnapshot) {
    var value = getSnapshot(), _useState = useState({ inst: { value, getSnapshot } }), inst = _useState[0].inst, forceUpdate = _useState[1];
    useLayoutEffect(
      function() {
        inst.value = value;
        inst.getSnapshot = getSnapshot;
        checkIfSnapshotChanged(inst) && forceUpdate({ inst });
      },
      [subscribe, value, getSnapshot]
    );
    useEffect(
      function() {
        checkIfSnapshotChanged(inst) && forceUpdate({ inst });
        return subscribe(function() {
          checkIfSnapshotChanged(inst) && forceUpdate({ inst });
        });
      },
      [subscribe]
    );
    useDebugValue2(value);
    return value;
  }
  function checkIfSnapshotChanged(inst) {
    var latestGetSnapshot = inst.getSnapshot;
    inst = inst.value;
    try {
      var nextValue = latestGetSnapshot();
      return !objectIs(inst, nextValue);
    } catch (error) {
      return true;
    }
  }
  function useSyncExternalStore$1(subscribe, getSnapshot) {
    return getSnapshot();
  }
  var shim2 = "undefined" === typeof window || "undefined" === typeof window.document || "undefined" === typeof window.document.createElement ? useSyncExternalStore$1 : useSyncExternalStore$2;
  useSyncExternalStoreShim_production.useSyncExternalStore = void 0 !== React2.useSyncExternalStore ? React2.useSyncExternalStore : shim2;
  return useSyncExternalStoreShim_production;
}
var hasRequiredShim;
function requireShim() {
  if (hasRequiredShim) return shim.exports;
  hasRequiredShim = 1;
  {
    shim.exports = requireUseSyncExternalStoreShim_production();
  }
  return shim.exports;
}
var hasRequiredWithSelector_production;
function requireWithSelector_production() {
  if (hasRequiredWithSelector_production) return withSelector_production;
  hasRequiredWithSelector_production = 1;
  var React2 = requireReact(), shim2 = requireShim();
  function is2(x3, y3) {
    return x3 === y3 && (0 !== x3 || 1 / x3 === 1 / y3) || x3 !== x3 && y3 !== y3;
  }
  var objectIs = "function" === typeof Object.is ? Object.is : is2, useSyncExternalStore = shim2.useSyncExternalStore, useRef = React2.useRef, useEffect = React2.useEffect, useMemo = React2.useMemo, useDebugValue2 = React2.useDebugValue;
  withSelector_production.useSyncExternalStoreWithSelector = function(subscribe, getSnapshot, getServerSnapshot, selector, isEqual) {
    var instRef = useRef(null);
    if (null === instRef.current) {
      var inst = { hasValue: false, value: null };
      instRef.current = inst;
    } else inst = instRef.current;
    instRef = useMemo(
      function() {
        function memoizedSelector(nextSnapshot) {
          if (!hasMemo) {
            hasMemo = true;
            memoizedSnapshot = nextSnapshot;
            nextSnapshot = selector(nextSnapshot);
            if (void 0 !== isEqual && inst.hasValue) {
              var currentSelection = inst.value;
              if (isEqual(currentSelection, nextSnapshot))
                return memoizedSelection = currentSelection;
            }
            return memoizedSelection = nextSnapshot;
          }
          currentSelection = memoizedSelection;
          if (objectIs(memoizedSnapshot, nextSnapshot)) return currentSelection;
          var nextSelection = selector(nextSnapshot);
          if (void 0 !== isEqual && isEqual(currentSelection, nextSelection))
            return memoizedSnapshot = nextSnapshot, currentSelection;
          memoizedSnapshot = nextSnapshot;
          return memoizedSelection = nextSelection;
        }
        var hasMemo = false, memoizedSnapshot, memoizedSelection, maybeGetServerSnapshot = void 0 === getServerSnapshot ? null : getServerSnapshot;
        return [
          function() {
            return memoizedSelector(getSnapshot());
          },
          null === maybeGetServerSnapshot ? void 0 : function() {
            return memoizedSelector(maybeGetServerSnapshot());
          }
        ];
      },
      [getSnapshot, getServerSnapshot, selector, isEqual]
    );
    var value = useSyncExternalStore(subscribe, instRef[0], instRef[1]);
    useEffect(
      function() {
        inst.hasValue = true;
        inst.value = value;
      },
      [value]
    );
    useDebugValue2(value);
    return value;
  };
  return withSelector_production;
}
var hasRequiredWithSelector;
function requireWithSelector() {
  if (hasRequiredWithSelector) return withSelector.exports;
  hasRequiredWithSelector = 1;
  {
    withSelector.exports = requireWithSelector_production();
  }
  return withSelector.exports;
}
var withSelectorExports = requireWithSelector();
const useSyncExternalStoreExports = /* @__PURE__ */ getDefaultExportFromCjs(withSelectorExports);
const __vite_import_meta_env__ = {};
const { useDebugValue } = React;
const { useSyncExternalStoreWithSelector } = useSyncExternalStoreExports;
let didWarnAboutEqualityFn = false;
const identity$1 = (arg) => arg;
function useStore$1(api, selector = identity$1, equalityFn) {
  if ((__vite_import_meta_env__ ? "production" : void 0) !== "production" && equalityFn && !didWarnAboutEqualityFn) {
    console.warn(
      "[DEPRECATED] Use `createWithEqualityFn` instead of `create` or use `useStoreWithEqualityFn` instead of `useStore`. They can be imported from 'zustand/traditional'. https://github.com/pmndrs/zustand/discussions/1937"
    );
    didWarnAboutEqualityFn = true;
  }
  const slice = useSyncExternalStoreWithSelector(
    api.subscribe,
    api.getState,
    api.getServerState || api.getInitialState,
    selector,
    equalityFn
  );
  useDebugValue(slice);
  return slice;
}
const createImpl$1 = (createState) => {
  if ((__vite_import_meta_env__ ? "production" : void 0) !== "production" && typeof createState !== "function") {
    console.warn(
      "[DEPRECATED] Passing a vanilla store will be unsupported in a future version. Instead use `import { useStore } from 'zustand'`."
    );
  }
  const api = typeof createState === "function" ? createStore$1(createState) : createState;
  const useBoundStore = (selector, equalityFn) => useStore$1(api, selector, equalityFn);
  Object.assign(useBoundStore, api);
  return useBoundStore;
};
const create$1 = (createState) => createState ? createImpl$1(createState) : createImpl$1;
var _window$document, _window$navigator;
const useIsomorphicLayoutEffect = typeof window !== "undefined" && ((_window$document = window.document) != null && _window$document.createElement || ((_window$navigator = window.navigator) == null ? void 0 : _window$navigator.product) === "ReactNative") ? React.useLayoutEffect : React.useEffect;
function tunnel() {
  const useStore2 = create$1((set) => ({
    current: new Array(),
    version: 0,
    set
  }));
  return {
    In: ({
      children
    }) => {
      const set = useStore2((state) => state.set);
      const version = useStore2((state) => state.version);
      useIsomorphicLayoutEffect(() => {
        set((state) => ({
          version: state.version + 1
        }));
      }, []);
      useIsomorphicLayoutEffect(() => {
        set(({
          current
        }) => ({
          current: [...current, children]
        }));
        return () => set(({
          current
        }) => ({
          current: current.filter((c3) => c3 !== children)
        }));
      }, [children, version]);
      return null;
    },
    Out: () => {
      const current = useStore2((state) => state.current);
      return /* @__PURE__ */ React.createElement(React.Fragment, null, current);
    }
  };
}
function _extends() {
  return _extends = Object.assign ? Object.assign.bind() : function(n3) {
    for (var e12 = 1; e12 < arguments.length; e12++) {
      var t3 = arguments[e12];
      for (var r3 in t3) ({}).hasOwnProperty.call(t3, r3) && (n3[r3] = t3[r3]);
    }
    return n3;
  }, _extends.apply(null, arguments);
}
function $e42e1063c40fb3ef$export$b9ecd428b558ff10$1(originalEventHandler, ourEventHandler, { checkForDefaultPrevented = true } = {}) {
  return function handleEvent(event) {
    originalEventHandler === null || originalEventHandler === void 0 || originalEventHandler(event);
    if (checkForDefaultPrevented === false || !event.defaultPrevented) return ourEventHandler === null || ourEventHandler === void 0 ? void 0 : ourEventHandler(event);
  };
}
function $c512c27ab02ef895$export$50c7b4e9d9f19c1$2(scopeName, createContextScopeDeps = []) {
  let defaultContexts = [];
  function $c512c27ab02ef895$export$fd42f52fd3ae1109(rootComponentName, defaultContext) {
    const BaseContext = /* @__PURE__ */ reactExports.createContext(defaultContext);
    const index2 = defaultContexts.length;
    defaultContexts = [
      ...defaultContexts,
      defaultContext
    ];
    function Provider(props) {
      const { scope, children, ...context } = props;
      const Context = (scope === null || scope === void 0 ? void 0 : scope[scopeName][index2]) || BaseContext;
      const value = reactExports.useMemo(
        () => context,
        Object.values(context)
      );
      return /* @__PURE__ */ reactExports.createElement(Context.Provider, {
        value
      }, children);
    }
    function useContext(consumerName, scope) {
      const Context = (scope === null || scope === void 0 ? void 0 : scope[scopeName][index2]) || BaseContext;
      const context = reactExports.useContext(Context);
      if (context) return context;
      if (defaultContext !== void 0) return defaultContext;
      throw new Error(`\`${consumerName}\` must be used within \`${rootComponentName}\``);
    }
    Provider.displayName = rootComponentName + "Provider";
    return [
      Provider,
      useContext
    ];
  }
  const createScope = () => {
    const scopeContexts = defaultContexts.map((defaultContext) => {
      return /* @__PURE__ */ reactExports.createContext(defaultContext);
    });
    return function useScope(scope) {
      const contexts = (scope === null || scope === void 0 ? void 0 : scope[scopeName]) || scopeContexts;
      return reactExports.useMemo(
        () => ({
          [`__scope${scopeName}`]: {
            ...scope,
            [scopeName]: contexts
          }
        }),
        [
          scope,
          contexts
        ]
      );
    };
  };
  createScope.scopeName = scopeName;
  return [
    $c512c27ab02ef895$export$fd42f52fd3ae1109,
    $c512c27ab02ef895$var$composeContextScopes$2(createScope, ...createContextScopeDeps)
  ];
}
function $c512c27ab02ef895$var$composeContextScopes$2(...scopes) {
  const baseScope = scopes[0];
  if (scopes.length === 1) return baseScope;
  const createScope1 = () => {
    const scopeHooks = scopes.map(
      (createScope) => ({
        useScope: createScope(),
        scopeName: createScope.scopeName
      })
    );
    return function useComposedScopes(overrideScopes) {
      const nextScopes1 = scopeHooks.reduce((nextScopes, { useScope, scopeName }) => {
        const scopeProps = useScope(overrideScopes);
        const currentScope = scopeProps[`__scope${scopeName}`];
        return {
          ...nextScopes,
          ...currentScope
        };
      }, {});
      return reactExports.useMemo(
        () => ({
          [`__scope${baseScope.scopeName}`]: nextScopes1
        }),
        [
          nextScopes1
        ]
      );
    };
  };
  createScope1.scopeName = baseScope.scopeName;
  return createScope1;
}
function $e42e1063c40fb3ef$export$b9ecd428b558ff10(originalEventHandler, ourEventHandler, { checkForDefaultPrevented = true } = {}) {
  return function handleEvent(event) {
    originalEventHandler === null || originalEventHandler === void 0 || originalEventHandler(event);
    if (checkForDefaultPrevented === false || !event.defaultPrevented) return ourEventHandler === null || ourEventHandler === void 0 ? void 0 : ourEventHandler(event);
  };
}
function $c512c27ab02ef895$export$50c7b4e9d9f19c1$1(scopeName, createContextScopeDeps = []) {
  let defaultContexts = [];
  function $c512c27ab02ef895$export$fd42f52fd3ae1109(rootComponentName, defaultContext) {
    const BaseContext = /* @__PURE__ */ reactExports.createContext(defaultContext);
    const index2 = defaultContexts.length;
    defaultContexts = [
      ...defaultContexts,
      defaultContext
    ];
    function Provider(props) {
      const { scope, children, ...context } = props;
      const Context = (scope === null || scope === void 0 ? void 0 : scope[scopeName][index2]) || BaseContext;
      const value = reactExports.useMemo(
        () => context,
        Object.values(context)
      );
      return /* @__PURE__ */ reactExports.createElement(Context.Provider, {
        value
      }, children);
    }
    function useContext(consumerName, scope) {
      const Context = (scope === null || scope === void 0 ? void 0 : scope[scopeName][index2]) || BaseContext;
      const context = reactExports.useContext(Context);
      if (context) return context;
      if (defaultContext !== void 0) return defaultContext;
      throw new Error(`\`${consumerName}\` must be used within \`${rootComponentName}\``);
    }
    Provider.displayName = rootComponentName + "Provider";
    return [
      Provider,
      useContext
    ];
  }
  const createScope = () => {
    const scopeContexts = defaultContexts.map((defaultContext) => {
      return /* @__PURE__ */ reactExports.createContext(defaultContext);
    });
    return function useScope(scope) {
      const contexts = (scope === null || scope === void 0 ? void 0 : scope[scopeName]) || scopeContexts;
      return reactExports.useMemo(
        () => ({
          [`__scope${scopeName}`]: {
            ...scope,
            [scopeName]: contexts
          }
        }),
        [
          scope,
          contexts
        ]
      );
    };
  };
  createScope.scopeName = scopeName;
  return [
    $c512c27ab02ef895$export$fd42f52fd3ae1109,
    $c512c27ab02ef895$var$composeContextScopes$1(createScope, ...createContextScopeDeps)
  ];
}
function $c512c27ab02ef895$var$composeContextScopes$1(...scopes) {
  const baseScope = scopes[0];
  if (scopes.length === 1) return baseScope;
  const createScope1 = () => {
    const scopeHooks = scopes.map(
      (createScope) => ({
        useScope: createScope(),
        scopeName: createScope.scopeName
      })
    );
    return function useComposedScopes(overrideScopes) {
      const nextScopes1 = scopeHooks.reduce((nextScopes, { useScope, scopeName }) => {
        const scopeProps = useScope(overrideScopes);
        const currentScope = scopeProps[`__scope${scopeName}`];
        return {
          ...nextScopes,
          ...currentScope
        };
      }, {});
      return reactExports.useMemo(
        () => ({
          [`__scope${baseScope.scopeName}`]: nextScopes1
        }),
        [
          nextScopes1
        ]
      );
    };
  };
  createScope1.scopeName = baseScope.scopeName;
  return createScope1;
}
function $6ed0406888f73fc4$var$setRef$2(ref, value) {
  if (typeof ref === "function") ref(value);
  else if (ref !== null && ref !== void 0) ref.current = value;
}
function $6ed0406888f73fc4$export$43e446d32b3d21af$2(...refs) {
  return (node) => refs.forEach(
    (ref) => $6ed0406888f73fc4$var$setRef$2(ref, node)
  );
}
function $6ed0406888f73fc4$export$c7b2cbe3552a0d05$2(...refs) {
  return reactExports.useCallback($6ed0406888f73fc4$export$43e446d32b3d21af$2(...refs), refs);
}
const $5e63c961fc1ce211$export$8c6ed5c666ac1360$2 = /* @__PURE__ */ reactExports.forwardRef((props, forwardedRef) => {
  const { children, ...slotProps } = props;
  const childrenArray = reactExports.Children.toArray(children);
  const slottable = childrenArray.find($5e63c961fc1ce211$var$isSlottable$2);
  if (slottable) {
    const newElement = slottable.props.children;
    const newChildren = childrenArray.map((child) => {
      if (child === slottable) {
        if (reactExports.Children.count(newElement) > 1) return reactExports.Children.only(null);
        return /* @__PURE__ */ reactExports.isValidElement(newElement) ? newElement.props.children : null;
      } else return child;
    });
    return /* @__PURE__ */ reactExports.createElement($5e63c961fc1ce211$var$SlotClone$2, _extends({}, slotProps, {
      ref: forwardedRef
    }), /* @__PURE__ */ reactExports.isValidElement(newElement) ? /* @__PURE__ */ reactExports.cloneElement(newElement, void 0, newChildren) : null);
  }
  return /* @__PURE__ */ reactExports.createElement($5e63c961fc1ce211$var$SlotClone$2, _extends({}, slotProps, {
    ref: forwardedRef
  }), children);
});
$5e63c961fc1ce211$export$8c6ed5c666ac1360$2.displayName = "Slot";
const $5e63c961fc1ce211$var$SlotClone$2 = /* @__PURE__ */ reactExports.forwardRef((props, forwardedRef) => {
  const { children, ...slotProps } = props;
  if (/* @__PURE__ */ reactExports.isValidElement(children)) return /* @__PURE__ */ reactExports.cloneElement(children, {
    ...$5e63c961fc1ce211$var$mergeProps$2(slotProps, children.props),
    ref: $6ed0406888f73fc4$export$43e446d32b3d21af$2(forwardedRef, children.ref)
  });
  return reactExports.Children.count(children) > 1 ? reactExports.Children.only(null) : null;
});
$5e63c961fc1ce211$var$SlotClone$2.displayName = "SlotClone";
const $5e63c961fc1ce211$export$d9f1ccf0bdb05d45$2 = ({ children }) => {
  return /* @__PURE__ */ reactExports.createElement(reactExports.Fragment, null, children);
};
function $5e63c961fc1ce211$var$isSlottable$2(child) {
  return /* @__PURE__ */ reactExports.isValidElement(child) && child.type === $5e63c961fc1ce211$export$d9f1ccf0bdb05d45$2;
}
function $5e63c961fc1ce211$var$mergeProps$2(slotProps, childProps) {
  const overrideProps = {
    ...childProps
  };
  for (const propName in childProps) {
    const slotPropValue = slotProps[propName];
    const childPropValue = childProps[propName];
    const isHandler = /^on[A-Z]/.test(propName);
    if (isHandler) {
      if (slotPropValue && childPropValue) overrideProps[propName] = (...args) => {
        childPropValue(...args);
        slotPropValue(...args);
      };
      else if (slotPropValue) overrideProps[propName] = slotPropValue;
    } else if (propName === "style") overrideProps[propName] = {
      ...slotPropValue,
      ...childPropValue
    };
    else if (propName === "className") overrideProps[propName] = [
      slotPropValue,
      childPropValue
    ].filter(Boolean).join(" ");
  }
  return {
    ...slotProps,
    ...overrideProps
  };
}
function $e02a7d9cb1dc128c$export$c74125a8e3af6bb2(name) {
  const PROVIDER_NAME = name + "CollectionProvider";
  const [createCollectionContext, createCollectionScope] = $c512c27ab02ef895$export$50c7b4e9d9f19c1$1(PROVIDER_NAME);
  const [CollectionProviderImpl, useCollectionContext] = createCollectionContext(PROVIDER_NAME, {
    collectionRef: {
      current: null
    },
    itemMap: /* @__PURE__ */ new Map()
  });
  const CollectionProvider = (props) => {
    const { scope, children } = props;
    const ref = React.useRef(null);
    const itemMap = React.useRef(/* @__PURE__ */ new Map()).current;
    return /* @__PURE__ */ React.createElement(CollectionProviderImpl, {
      scope,
      itemMap,
      collectionRef: ref
    }, children);
  };
  const COLLECTION_SLOT_NAME = name + "CollectionSlot";
  const CollectionSlot = /* @__PURE__ */ React.forwardRef((props, forwardedRef) => {
    const { scope, children } = props;
    const context = useCollectionContext(COLLECTION_SLOT_NAME, scope);
    const composedRefs = $6ed0406888f73fc4$export$c7b2cbe3552a0d05$2(forwardedRef, context.collectionRef);
    return /* @__PURE__ */ React.createElement($5e63c961fc1ce211$export$8c6ed5c666ac1360$2, {
      ref: composedRefs
    }, children);
  });
  const ITEM_SLOT_NAME = name + "CollectionItemSlot";
  const ITEM_DATA_ATTR = "data-radix-collection-item";
  const CollectionItemSlot = /* @__PURE__ */ React.forwardRef((props, forwardedRef) => {
    const { scope, children, ...itemData } = props;
    const ref = React.useRef(null);
    const composedRefs = $6ed0406888f73fc4$export$c7b2cbe3552a0d05$2(forwardedRef, ref);
    const context = useCollectionContext(ITEM_SLOT_NAME, scope);
    React.useEffect(() => {
      context.itemMap.set(ref, {
        ref,
        ...itemData
      });
      return () => void context.itemMap.delete(ref);
    });
    return /* @__PURE__ */ React.createElement($5e63c961fc1ce211$export$8c6ed5c666ac1360$2, {
      [ITEM_DATA_ATTR]: "",
      ref: composedRefs
    }, children);
  });
  function useCollection(scope) {
    const context = useCollectionContext(name + "CollectionConsumer", scope);
    const getItems = React.useCallback(() => {
      const collectionNode = context.collectionRef.current;
      if (!collectionNode) return [];
      const orderedNodes = Array.from(collectionNode.querySelectorAll(`[${ITEM_DATA_ATTR}]`));
      const items = Array.from(context.itemMap.values());
      const orderedItems = items.sort(
        (a3, b3) => orderedNodes.indexOf(a3.ref.current) - orderedNodes.indexOf(b3.ref.current)
      );
      return orderedItems;
    }, [
      context.collectionRef,
      context.itemMap
    ]);
    return getItems;
  }
  return [
    {
      Provider: CollectionProvider,
      Slot: CollectionSlot,
      ItemSlot: CollectionItemSlot
    },
    useCollection,
    createCollectionScope
  ];
}
function $6ed0406888f73fc4$var$setRef$1(ref, value) {
  if (typeof ref === "function") ref(value);
  else if (ref !== null && ref !== void 0) ref.current = value;
}
function $6ed0406888f73fc4$export$43e446d32b3d21af$1(...refs) {
  return (node) => refs.forEach(
    (ref) => $6ed0406888f73fc4$var$setRef$1(ref, node)
  );
}
function $6ed0406888f73fc4$export$c7b2cbe3552a0d05$1(...refs) {
  return reactExports.useCallback($6ed0406888f73fc4$export$43e446d32b3d21af$1(...refs), refs);
}
function $c512c27ab02ef895$export$50c7b4e9d9f19c1(scopeName, createContextScopeDeps = []) {
  let defaultContexts = [];
  function $c512c27ab02ef895$export$fd42f52fd3ae1109(rootComponentName, defaultContext) {
    const BaseContext = /* @__PURE__ */ reactExports.createContext(defaultContext);
    const index2 = defaultContexts.length;
    defaultContexts = [
      ...defaultContexts,
      defaultContext
    ];
    function Provider(props) {
      const { scope, children, ...context } = props;
      const Context = (scope === null || scope === void 0 ? void 0 : scope[scopeName][index2]) || BaseContext;
      const value = reactExports.useMemo(
        () => context,
        Object.values(context)
      );
      return /* @__PURE__ */ reactExports.createElement(Context.Provider, {
        value
      }, children);
    }
    function useContext(consumerName, scope) {
      const Context = (scope === null || scope === void 0 ? void 0 : scope[scopeName][index2]) || BaseContext;
      const context = reactExports.useContext(Context);
      if (context) return context;
      if (defaultContext !== void 0) return defaultContext;
      throw new Error(`\`${consumerName}\` must be used within \`${rootComponentName}\``);
    }
    Provider.displayName = rootComponentName + "Provider";
    return [
      Provider,
      useContext
    ];
  }
  const createScope = () => {
    const scopeContexts = defaultContexts.map((defaultContext) => {
      return /* @__PURE__ */ reactExports.createContext(defaultContext);
    });
    return function useScope(scope) {
      const contexts = (scope === null || scope === void 0 ? void 0 : scope[scopeName]) || scopeContexts;
      return reactExports.useMemo(
        () => ({
          [`__scope${scopeName}`]: {
            ...scope,
            [scopeName]: contexts
          }
        }),
        [
          scope,
          contexts
        ]
      );
    };
  };
  createScope.scopeName = scopeName;
  return [
    $c512c27ab02ef895$export$fd42f52fd3ae1109,
    $c512c27ab02ef895$var$composeContextScopes(createScope, ...createContextScopeDeps)
  ];
}
function $c512c27ab02ef895$var$composeContextScopes(...scopes) {
  const baseScope = scopes[0];
  if (scopes.length === 1) return baseScope;
  const createScope1 = () => {
    const scopeHooks = scopes.map(
      (createScope) => ({
        useScope: createScope(),
        scopeName: createScope.scopeName
      })
    );
    return function useComposedScopes(overrideScopes) {
      const nextScopes1 = scopeHooks.reduce((nextScopes, { useScope, scopeName }) => {
        const scopeProps = useScope(overrideScopes);
        const currentScope = scopeProps[`__scope${scopeName}`];
        return {
          ...nextScopes,
          ...currentScope
        };
      }, {});
      return reactExports.useMemo(
        () => ({
          [`__scope${baseScope.scopeName}`]: nextScopes1
        }),
        [
          nextScopes1
        ]
      );
    };
  };
  createScope1.scopeName = baseScope.scopeName;
  return createScope1;
}
const $9f79659886946c16$export$e5c5a5f917a5871c$1 = Boolean(globalThis === null || globalThis === void 0 ? void 0 : globalThis.document) ? reactExports.useLayoutEffect : () => {
};
const $1746a345f3d73bb7$var$useReactId$1 = $2AODx$react["useId".toString()] || (() => void 0);
let $1746a345f3d73bb7$var$count$1 = 0;
function $1746a345f3d73bb7$export$f680877a34711e37$1(deterministicId) {
  const [id2, setId] = reactExports.useState($1746a345f3d73bb7$var$useReactId$1());
  $9f79659886946c16$export$e5c5a5f917a5871c$1(() => {
    setId(
      (reactId) => reactId !== null && reactId !== void 0 ? reactId : String($1746a345f3d73bb7$var$count$1++)
    );
  }, [
    deterministicId
  ]);
  return id2 ? `radix-${id2}` : "";
}
const $5e63c961fc1ce211$export$8c6ed5c666ac1360$1 = /* @__PURE__ */ reactExports.forwardRef((props, forwardedRef) => {
  const { children, ...slotProps } = props;
  const childrenArray = reactExports.Children.toArray(children);
  const slottable = childrenArray.find($5e63c961fc1ce211$var$isSlottable$1);
  if (slottable) {
    const newElement = slottable.props.children;
    const newChildren = childrenArray.map((child) => {
      if (child === slottable) {
        if (reactExports.Children.count(newElement) > 1) return reactExports.Children.only(null);
        return /* @__PURE__ */ reactExports.isValidElement(newElement) ? newElement.props.children : null;
      } else return child;
    });
    return /* @__PURE__ */ reactExports.createElement($5e63c961fc1ce211$var$SlotClone$1, _extends({}, slotProps, {
      ref: forwardedRef
    }), /* @__PURE__ */ reactExports.isValidElement(newElement) ? /* @__PURE__ */ reactExports.cloneElement(newElement, void 0, newChildren) : null);
  }
  return /* @__PURE__ */ reactExports.createElement($5e63c961fc1ce211$var$SlotClone$1, _extends({}, slotProps, {
    ref: forwardedRef
  }), children);
});
$5e63c961fc1ce211$export$8c6ed5c666ac1360$1.displayName = "Slot";
const $5e63c961fc1ce211$var$SlotClone$1 = /* @__PURE__ */ reactExports.forwardRef((props, forwardedRef) => {
  const { children, ...slotProps } = props;
  if (/* @__PURE__ */ reactExports.isValidElement(children)) return /* @__PURE__ */ reactExports.cloneElement(children, {
    ...$5e63c961fc1ce211$var$mergeProps$1(slotProps, children.props),
    ref: $6ed0406888f73fc4$export$43e446d32b3d21af$1(forwardedRef, children.ref)
  });
  return reactExports.Children.count(children) > 1 ? reactExports.Children.only(null) : null;
});
$5e63c961fc1ce211$var$SlotClone$1.displayName = "SlotClone";
const $5e63c961fc1ce211$export$d9f1ccf0bdb05d45$1 = ({ children }) => {
  return /* @__PURE__ */ reactExports.createElement(reactExports.Fragment, null, children);
};
function $5e63c961fc1ce211$var$isSlottable$1(child) {
  return /* @__PURE__ */ reactExports.isValidElement(child) && child.type === $5e63c961fc1ce211$export$d9f1ccf0bdb05d45$1;
}
function $5e63c961fc1ce211$var$mergeProps$1(slotProps, childProps) {
  const overrideProps = {
    ...childProps
  };
  for (const propName in childProps) {
    const slotPropValue = slotProps[propName];
    const childPropValue = childProps[propName];
    const isHandler = /^on[A-Z]/.test(propName);
    if (isHandler) {
      if (slotPropValue && childPropValue) overrideProps[propName] = (...args) => {
        childPropValue(...args);
        slotPropValue(...args);
      };
      else if (slotPropValue) overrideProps[propName] = slotPropValue;
    } else if (propName === "style") overrideProps[propName] = {
      ...slotPropValue,
      ...childPropValue
    };
    else if (propName === "className") overrideProps[propName] = [
      slotPropValue,
      childPropValue
    ].filter(Boolean).join(" ");
  }
  return {
    ...slotProps,
    ...overrideProps
  };
}
const $8927f6f2acc4f386$var$NODES$1 = [
  "a",
  "button",
  "div",
  "h2",
  "h3",
  "img",
  "label",
  "li",
  "nav",
  "ol",
  "p",
  "span",
  "svg",
  "ul"
];
const $8927f6f2acc4f386$export$250ffa63cdc0d034$1 = $8927f6f2acc4f386$var$NODES$1.reduce((primitive, node) => {
  const Node2 = /* @__PURE__ */ reactExports.forwardRef((props, forwardedRef) => {
    const { asChild, ...primitiveProps } = props;
    const Comp = asChild ? $5e63c961fc1ce211$export$8c6ed5c666ac1360$1 : node;
    reactExports.useEffect(() => {
      window[Symbol.for("radix-ui")] = true;
    }, []);
    return /* @__PURE__ */ reactExports.createElement(Comp, _extends({}, primitiveProps, {
      ref: forwardedRef
    }));
  });
  Node2.displayName = `Primitive.${node}`;
  return {
    ...primitive,
    [node]: Node2
  };
}, {});
function $b1b2314f5f9a1d84$export$25bec8c6f54ee79a$1(callback) {
  const callbackRef = reactExports.useRef(callback);
  reactExports.useEffect(() => {
    callbackRef.current = callback;
  });
  return reactExports.useMemo(
    () => (...args) => {
      var _callbackRef$current;
      return (_callbackRef$current = callbackRef.current) === null || _callbackRef$current === void 0 ? void 0 : _callbackRef$current.call(callbackRef, ...args);
    },
    []
  );
}
function $71cd76cc60e0454e$export$6f32135080cb4c3$1({ prop, defaultProp, onChange = () => {
} }) {
  const [uncontrolledProp, setUncontrolledProp] = $71cd76cc60e0454e$var$useUncontrolledState$1({
    defaultProp,
    onChange
  });
  const isControlled = prop !== void 0;
  const value1 = isControlled ? prop : uncontrolledProp;
  const handleChange = $b1b2314f5f9a1d84$export$25bec8c6f54ee79a$1(onChange);
  const setValue = reactExports.useCallback((nextValue) => {
    if (isControlled) {
      const setter = nextValue;
      const value = typeof nextValue === "function" ? setter(prop) : nextValue;
      if (value !== prop) handleChange(value);
    } else setUncontrolledProp(nextValue);
  }, [
    isControlled,
    prop,
    setUncontrolledProp,
    handleChange
  ]);
  return [
    value1,
    setValue
  ];
}
function $71cd76cc60e0454e$var$useUncontrolledState$1({ defaultProp, onChange }) {
  const uncontrolledState = reactExports.useState(defaultProp);
  const [value] = uncontrolledState;
  const prevValueRef = reactExports.useRef(value);
  const handleChange = $b1b2314f5f9a1d84$export$25bec8c6f54ee79a$1(onChange);
  reactExports.useEffect(() => {
    if (prevValueRef.current !== value) {
      handleChange(value);
      prevValueRef.current = value;
    }
  }, [
    value,
    prevValueRef,
    handleChange
  ]);
  return uncontrolledState;
}
const $f631663db3294ace$var$DirectionContext = /* @__PURE__ */ reactExports.createContext(void 0);
function $f631663db3294ace$export$b39126d51d94e6f3(localDir) {
  const globalDir = reactExports.useContext($f631663db3294ace$var$DirectionContext);
  return localDir || globalDir || "ltr";
}
const $d7bdfb9eb0fdf311$var$ENTRY_FOCUS = "rovingFocusGroup.onEntryFocus";
const $d7bdfb9eb0fdf311$var$EVENT_OPTIONS = {
  bubbles: false,
  cancelable: true
};
const $d7bdfb9eb0fdf311$var$GROUP_NAME = "RovingFocusGroup";
const [$d7bdfb9eb0fdf311$var$Collection, $d7bdfb9eb0fdf311$var$useCollection, $d7bdfb9eb0fdf311$var$createCollectionScope] = $e02a7d9cb1dc128c$export$c74125a8e3af6bb2($d7bdfb9eb0fdf311$var$GROUP_NAME);
const [$d7bdfb9eb0fdf311$var$createRovingFocusGroupContext, $d7bdfb9eb0fdf311$export$c7109489551a4f4] = $c512c27ab02ef895$export$50c7b4e9d9f19c1($d7bdfb9eb0fdf311$var$GROUP_NAME, [
  $d7bdfb9eb0fdf311$var$createCollectionScope
]);
const [$d7bdfb9eb0fdf311$var$RovingFocusProvider, $d7bdfb9eb0fdf311$var$useRovingFocusContext] = $d7bdfb9eb0fdf311$var$createRovingFocusGroupContext($d7bdfb9eb0fdf311$var$GROUP_NAME);
const $d7bdfb9eb0fdf311$export$8699f7c8af148338 = /* @__PURE__ */ reactExports.forwardRef((props, forwardedRef) => {
  return /* @__PURE__ */ reactExports.createElement($d7bdfb9eb0fdf311$var$Collection.Provider, {
    scope: props.__scopeRovingFocusGroup
  }, /* @__PURE__ */ reactExports.createElement($d7bdfb9eb0fdf311$var$Collection.Slot, {
    scope: props.__scopeRovingFocusGroup
  }, /* @__PURE__ */ reactExports.createElement($d7bdfb9eb0fdf311$var$RovingFocusGroupImpl, _extends({}, props, {
    ref: forwardedRef
  }))));
});
const $d7bdfb9eb0fdf311$var$RovingFocusGroupImpl = /* @__PURE__ */ reactExports.forwardRef((props, forwardedRef) => {
  const { __scopeRovingFocusGroup, orientation, loop = false, dir, currentTabStopId: currentTabStopIdProp, defaultCurrentTabStopId, onCurrentTabStopIdChange, onEntryFocus, ...groupProps } = props;
  const ref = reactExports.useRef(null);
  const composedRefs = $6ed0406888f73fc4$export$c7b2cbe3552a0d05$1(forwardedRef, ref);
  const direction = $f631663db3294ace$export$b39126d51d94e6f3(dir);
  const [currentTabStopId = null, setCurrentTabStopId] = $71cd76cc60e0454e$export$6f32135080cb4c3$1({
    prop: currentTabStopIdProp,
    defaultProp: defaultCurrentTabStopId,
    onChange: onCurrentTabStopIdChange
  });
  const [isTabbingBackOut, setIsTabbingBackOut] = reactExports.useState(false);
  const handleEntryFocus = $b1b2314f5f9a1d84$export$25bec8c6f54ee79a$1(onEntryFocus);
  const getItems = $d7bdfb9eb0fdf311$var$useCollection(__scopeRovingFocusGroup);
  const isClickFocusRef = reactExports.useRef(false);
  const [focusableItemsCount, setFocusableItemsCount] = reactExports.useState(0);
  reactExports.useEffect(() => {
    const node = ref.current;
    if (node) {
      node.addEventListener($d7bdfb9eb0fdf311$var$ENTRY_FOCUS, handleEntryFocus);
      return () => node.removeEventListener($d7bdfb9eb0fdf311$var$ENTRY_FOCUS, handleEntryFocus);
    }
  }, [
    handleEntryFocus
  ]);
  return /* @__PURE__ */ reactExports.createElement($d7bdfb9eb0fdf311$var$RovingFocusProvider, {
    scope: __scopeRovingFocusGroup,
    orientation,
    dir: direction,
    loop,
    currentTabStopId,
    onItemFocus: reactExports.useCallback(
      (tabStopId) => setCurrentTabStopId(tabStopId),
      [
        setCurrentTabStopId
      ]
    ),
    onItemShiftTab: reactExports.useCallback(
      () => setIsTabbingBackOut(true),
      []
    ),
    onFocusableItemAdd: reactExports.useCallback(
      () => setFocusableItemsCount(
        (prevCount) => prevCount + 1
      ),
      []
    ),
    onFocusableItemRemove: reactExports.useCallback(
      () => setFocusableItemsCount(
        (prevCount) => prevCount - 1
      ),
      []
    )
  }, /* @__PURE__ */ reactExports.createElement($8927f6f2acc4f386$export$250ffa63cdc0d034$1.div, _extends({
    tabIndex: isTabbingBackOut || focusableItemsCount === 0 ? -1 : 0,
    "data-orientation": orientation
  }, groupProps, {
    ref: composedRefs,
    style: {
      outline: "none",
      ...props.style
    },
    onMouseDown: $e42e1063c40fb3ef$export$b9ecd428b558ff10(props.onMouseDown, () => {
      isClickFocusRef.current = true;
    }),
    onFocus: $e42e1063c40fb3ef$export$b9ecd428b558ff10(props.onFocus, (event) => {
      const isKeyboardFocus = !isClickFocusRef.current;
      if (event.target === event.currentTarget && isKeyboardFocus && !isTabbingBackOut) {
        const entryFocusEvent = new CustomEvent($d7bdfb9eb0fdf311$var$ENTRY_FOCUS, $d7bdfb9eb0fdf311$var$EVENT_OPTIONS);
        event.currentTarget.dispatchEvent(entryFocusEvent);
        if (!entryFocusEvent.defaultPrevented) {
          const items = getItems().filter(
            (item) => item.focusable
          );
          const activeItem = items.find(
            (item) => item.active
          );
          const currentItem = items.find(
            (item) => item.id === currentTabStopId
          );
          const candidateItems = [
            activeItem,
            currentItem,
            ...items
          ].filter(Boolean);
          const candidateNodes = candidateItems.map(
            (item) => item.ref.current
          );
          $d7bdfb9eb0fdf311$var$focusFirst(candidateNodes);
        }
      }
      isClickFocusRef.current = false;
    }),
    onBlur: $e42e1063c40fb3ef$export$b9ecd428b558ff10(
      props.onBlur,
      () => setIsTabbingBackOut(false)
    )
  })));
});
const $d7bdfb9eb0fdf311$var$ITEM_NAME = "RovingFocusGroupItem";
const $d7bdfb9eb0fdf311$export$ab9df7c53fe8454 = /* @__PURE__ */ reactExports.forwardRef((props, forwardedRef) => {
  const { __scopeRovingFocusGroup, focusable = true, active = false, tabStopId, ...itemProps } = props;
  const autoId = $1746a345f3d73bb7$export$f680877a34711e37$1();
  const id2 = tabStopId || autoId;
  const context = $d7bdfb9eb0fdf311$var$useRovingFocusContext($d7bdfb9eb0fdf311$var$ITEM_NAME, __scopeRovingFocusGroup);
  const isCurrentTabStop = context.currentTabStopId === id2;
  const getItems = $d7bdfb9eb0fdf311$var$useCollection(__scopeRovingFocusGroup);
  const { onFocusableItemAdd, onFocusableItemRemove } = context;
  reactExports.useEffect(() => {
    if (focusable) {
      onFocusableItemAdd();
      return () => onFocusableItemRemove();
    }
  }, [
    focusable,
    onFocusableItemAdd,
    onFocusableItemRemove
  ]);
  return /* @__PURE__ */ reactExports.createElement($d7bdfb9eb0fdf311$var$Collection.ItemSlot, {
    scope: __scopeRovingFocusGroup,
    id: id2,
    focusable,
    active
  }, /* @__PURE__ */ reactExports.createElement($8927f6f2acc4f386$export$250ffa63cdc0d034$1.span, _extends({
    tabIndex: isCurrentTabStop ? 0 : -1,
    "data-orientation": context.orientation
  }, itemProps, {
    ref: forwardedRef,
    onMouseDown: $e42e1063c40fb3ef$export$b9ecd428b558ff10(props.onMouseDown, (event) => {
      if (!focusable) event.preventDefault();
      else context.onItemFocus(id2);
    }),
    onFocus: $e42e1063c40fb3ef$export$b9ecd428b558ff10(
      props.onFocus,
      () => context.onItemFocus(id2)
    ),
    onKeyDown: $e42e1063c40fb3ef$export$b9ecd428b558ff10(props.onKeyDown, (event) => {
      if (event.key === "Tab" && event.shiftKey) {
        context.onItemShiftTab();
        return;
      }
      if (event.target !== event.currentTarget) return;
      const focusIntent = $d7bdfb9eb0fdf311$var$getFocusIntent(event, context.orientation, context.dir);
      if (focusIntent !== void 0) {
        event.preventDefault();
        const items = getItems().filter(
          (item) => item.focusable
        );
        let candidateNodes = items.map(
          (item) => item.ref.current
        );
        if (focusIntent === "last") candidateNodes.reverse();
        else if (focusIntent === "prev" || focusIntent === "next") {
          if (focusIntent === "prev") candidateNodes.reverse();
          const currentIndex = candidateNodes.indexOf(event.currentTarget);
          candidateNodes = context.loop ? $d7bdfb9eb0fdf311$var$wrapArray(candidateNodes, currentIndex + 1) : candidateNodes.slice(currentIndex + 1);
        }
        setTimeout(
          () => $d7bdfb9eb0fdf311$var$focusFirst(candidateNodes)
        );
      }
    })
  })));
});
const $d7bdfb9eb0fdf311$var$MAP_KEY_TO_FOCUS_INTENT = {
  ArrowLeft: "prev",
  ArrowUp: "prev",
  ArrowRight: "next",
  ArrowDown: "next",
  PageUp: "first",
  Home: "first",
  PageDown: "last",
  End: "last"
};
function $d7bdfb9eb0fdf311$var$getDirectionAwareKey(key, dir) {
  if (dir !== "rtl") return key;
  return key === "ArrowLeft" ? "ArrowRight" : key === "ArrowRight" ? "ArrowLeft" : key;
}
function $d7bdfb9eb0fdf311$var$getFocusIntent(event, orientation, dir) {
  const key = $d7bdfb9eb0fdf311$var$getDirectionAwareKey(event.key, dir);
  if (orientation === "vertical" && [
    "ArrowLeft",
    "ArrowRight"
  ].includes(key)) return void 0;
  if (orientation === "horizontal" && [
    "ArrowUp",
    "ArrowDown"
  ].includes(key)) return void 0;
  return $d7bdfb9eb0fdf311$var$MAP_KEY_TO_FOCUS_INTENT[key];
}
function $d7bdfb9eb0fdf311$var$focusFirst(candidates) {
  const PREVIOUSLY_FOCUSED_ELEMENT = document.activeElement;
  for (const candidate of candidates) {
    if (candidate === PREVIOUSLY_FOCUSED_ELEMENT) return;
    candidate.focus();
    if (document.activeElement !== PREVIOUSLY_FOCUSED_ELEMENT) return;
  }
}
function $d7bdfb9eb0fdf311$var$wrapArray(array, startIndex) {
  return array.map(
    (_3, index2) => array[(startIndex + index2) % array.length]
  );
}
const $d7bdfb9eb0fdf311$export$be92b6f5f03c0fe9 = $d7bdfb9eb0fdf311$export$8699f7c8af148338;
const $d7bdfb9eb0fdf311$export$6d08773d2e66f8f2 = $d7bdfb9eb0fdf311$export$ab9df7c53fe8454;
function $6ed0406888f73fc4$var$setRef(ref, value) {
  if (typeof ref === "function") ref(value);
  else if (ref !== null && ref !== void 0) ref.current = value;
}
function $6ed0406888f73fc4$export$43e446d32b3d21af(...refs) {
  return (node) => refs.forEach(
    (ref) => $6ed0406888f73fc4$var$setRef(ref, node)
  );
}
function $6ed0406888f73fc4$export$c7b2cbe3552a0d05(...refs) {
  return reactExports.useCallback($6ed0406888f73fc4$export$43e446d32b3d21af(...refs), refs);
}
const $9f79659886946c16$export$e5c5a5f917a5871c = Boolean(globalThis === null || globalThis === void 0 ? void 0 : globalThis.document) ? reactExports.useLayoutEffect : () => {
};
function $fe963b355347cc68$export$3e6543de14f8614f(initialState, machine) {
  return reactExports.useReducer((state, event) => {
    const nextState = machine[state][event];
    return nextState !== null && nextState !== void 0 ? nextState : state;
  }, initialState);
}
const $921a889cee6df7e8$export$99c2b779aa4e8b8b = (props) => {
  const { present, children } = props;
  const presence = $921a889cee6df7e8$var$usePresence(present);
  const child = typeof children === "function" ? children({
    present: presence.isPresent
  }) : reactExports.Children.only(children);
  const ref = $6ed0406888f73fc4$export$c7b2cbe3552a0d05(presence.ref, child.ref);
  const forceMount = typeof children === "function";
  return forceMount || presence.isPresent ? /* @__PURE__ */ reactExports.cloneElement(child, {
    ref
  }) : null;
};
$921a889cee6df7e8$export$99c2b779aa4e8b8b.displayName = "Presence";
function $921a889cee6df7e8$var$usePresence(present) {
  const [node1, setNode] = reactExports.useState();
  const stylesRef = reactExports.useRef({});
  const prevPresentRef = reactExports.useRef(present);
  const prevAnimationNameRef = reactExports.useRef("none");
  const initialState = present ? "mounted" : "unmounted";
  const [state, send] = $fe963b355347cc68$export$3e6543de14f8614f(initialState, {
    mounted: {
      UNMOUNT: "unmounted",
      ANIMATION_OUT: "unmountSuspended"
    },
    unmountSuspended: {
      MOUNT: "mounted",
      ANIMATION_END: "unmounted"
    },
    unmounted: {
      MOUNT: "mounted"
    }
  });
  reactExports.useEffect(() => {
    const currentAnimationName = $921a889cee6df7e8$var$getAnimationName(stylesRef.current);
    prevAnimationNameRef.current = state === "mounted" ? currentAnimationName : "none";
  }, [
    state
  ]);
  $9f79659886946c16$export$e5c5a5f917a5871c(() => {
    const styles = stylesRef.current;
    const wasPresent = prevPresentRef.current;
    const hasPresentChanged = wasPresent !== present;
    if (hasPresentChanged) {
      const prevAnimationName = prevAnimationNameRef.current;
      const currentAnimationName = $921a889cee6df7e8$var$getAnimationName(styles);
      if (present) send("MOUNT");
      else if (currentAnimationName === "none" || (styles === null || styles === void 0 ? void 0 : styles.display) === "none")
        send("UNMOUNT");
      else {
        const isAnimating = prevAnimationName !== currentAnimationName;
        if (wasPresent && isAnimating) send("ANIMATION_OUT");
        else send("UNMOUNT");
      }
      prevPresentRef.current = present;
    }
  }, [
    present,
    send
  ]);
  $9f79659886946c16$export$e5c5a5f917a5871c(() => {
    if (node1) {
      const handleAnimationEnd = (event) => {
        const currentAnimationName = $921a889cee6df7e8$var$getAnimationName(stylesRef.current);
        const isCurrentAnimation = currentAnimationName.includes(event.animationName);
        if (event.target === node1 && isCurrentAnimation)
          reactDomExports.flushSync(
            () => send("ANIMATION_END")
          );
      };
      const handleAnimationStart = (event) => {
        if (event.target === node1)
          prevAnimationNameRef.current = $921a889cee6df7e8$var$getAnimationName(stylesRef.current);
      };
      node1.addEventListener("animationstart", handleAnimationStart);
      node1.addEventListener("animationcancel", handleAnimationEnd);
      node1.addEventListener("animationend", handleAnimationEnd);
      return () => {
        node1.removeEventListener("animationstart", handleAnimationStart);
        node1.removeEventListener("animationcancel", handleAnimationEnd);
        node1.removeEventListener("animationend", handleAnimationEnd);
      };
    } else
      send("ANIMATION_END");
  }, [
    node1,
    send
  ]);
  return {
    isPresent: [
      "mounted",
      "unmountSuspended"
    ].includes(state),
    ref: reactExports.useCallback((node) => {
      if (node) stylesRef.current = getComputedStyle(node);
      setNode(node);
    }, [])
  };
}
function $921a889cee6df7e8$var$getAnimationName(styles) {
  return (styles === null || styles === void 0 ? void 0 : styles.animationName) || "none";
}
const $5e63c961fc1ce211$export$8c6ed5c666ac1360 = /* @__PURE__ */ reactExports.forwardRef((props, forwardedRef) => {
  const { children, ...slotProps } = props;
  const childrenArray = reactExports.Children.toArray(children);
  const slottable = childrenArray.find($5e63c961fc1ce211$var$isSlottable);
  if (slottable) {
    const newElement = slottable.props.children;
    const newChildren = childrenArray.map((child) => {
      if (child === slottable) {
        if (reactExports.Children.count(newElement) > 1) return reactExports.Children.only(null);
        return /* @__PURE__ */ reactExports.isValidElement(newElement) ? newElement.props.children : null;
      } else return child;
    });
    return /* @__PURE__ */ reactExports.createElement($5e63c961fc1ce211$var$SlotClone, _extends({}, slotProps, {
      ref: forwardedRef
    }), /* @__PURE__ */ reactExports.isValidElement(newElement) ? /* @__PURE__ */ reactExports.cloneElement(newElement, void 0, newChildren) : null);
  }
  return /* @__PURE__ */ reactExports.createElement($5e63c961fc1ce211$var$SlotClone, _extends({}, slotProps, {
    ref: forwardedRef
  }), children);
});
$5e63c961fc1ce211$export$8c6ed5c666ac1360.displayName = "Slot";
const $5e63c961fc1ce211$var$SlotClone = /* @__PURE__ */ reactExports.forwardRef((props, forwardedRef) => {
  const { children, ...slotProps } = props;
  if (/* @__PURE__ */ reactExports.isValidElement(children)) return /* @__PURE__ */ reactExports.cloneElement(children, {
    ...$5e63c961fc1ce211$var$mergeProps(slotProps, children.props),
    ref: $6ed0406888f73fc4$export$43e446d32b3d21af(forwardedRef, children.ref)
  });
  return reactExports.Children.count(children) > 1 ? reactExports.Children.only(null) : null;
});
$5e63c961fc1ce211$var$SlotClone.displayName = "SlotClone";
const $5e63c961fc1ce211$export$d9f1ccf0bdb05d45 = ({ children }) => {
  return /* @__PURE__ */ reactExports.createElement(reactExports.Fragment, null, children);
};
function $5e63c961fc1ce211$var$isSlottable(child) {
  return /* @__PURE__ */ reactExports.isValidElement(child) && child.type === $5e63c961fc1ce211$export$d9f1ccf0bdb05d45;
}
function $5e63c961fc1ce211$var$mergeProps(slotProps, childProps) {
  const overrideProps = {
    ...childProps
  };
  for (const propName in childProps) {
    const slotPropValue = slotProps[propName];
    const childPropValue = childProps[propName];
    const isHandler = /^on[A-Z]/.test(propName);
    if (isHandler) {
      if (slotPropValue && childPropValue) overrideProps[propName] = (...args) => {
        childPropValue(...args);
        slotPropValue(...args);
      };
      else if (slotPropValue) overrideProps[propName] = slotPropValue;
    } else if (propName === "style") overrideProps[propName] = {
      ...slotPropValue,
      ...childPropValue
    };
    else if (propName === "className") overrideProps[propName] = [
      slotPropValue,
      childPropValue
    ].filter(Boolean).join(" ");
  }
  return {
    ...slotProps,
    ...overrideProps
  };
}
const $8927f6f2acc4f386$var$NODES = [
  "a",
  "button",
  "div",
  "h2",
  "h3",
  "img",
  "label",
  "li",
  "nav",
  "ol",
  "p",
  "span",
  "svg",
  "ul"
];
const $8927f6f2acc4f386$export$250ffa63cdc0d034 = $8927f6f2acc4f386$var$NODES.reduce((primitive, node) => {
  const Node2 = /* @__PURE__ */ reactExports.forwardRef((props, forwardedRef) => {
    const { asChild, ...primitiveProps } = props;
    const Comp = asChild ? $5e63c961fc1ce211$export$8c6ed5c666ac1360 : node;
    reactExports.useEffect(() => {
      window[Symbol.for("radix-ui")] = true;
    }, []);
    return /* @__PURE__ */ reactExports.createElement(Comp, _extends({}, primitiveProps, {
      ref: forwardedRef
    }));
  });
  Node2.displayName = `Primitive.${node}`;
  return {
    ...primitive,
    [node]: Node2
  };
}, {});
function $b1b2314f5f9a1d84$export$25bec8c6f54ee79a(callback) {
  const callbackRef = reactExports.useRef(callback);
  reactExports.useEffect(() => {
    callbackRef.current = callback;
  });
  return reactExports.useMemo(
    () => (...args) => {
      var _callbackRef$current;
      return (_callbackRef$current = callbackRef.current) === null || _callbackRef$current === void 0 ? void 0 : _callbackRef$current.call(callbackRef, ...args);
    },
    []
  );
}
function $71cd76cc60e0454e$export$6f32135080cb4c3({ prop, defaultProp, onChange = () => {
} }) {
  const [uncontrolledProp, setUncontrolledProp] = $71cd76cc60e0454e$var$useUncontrolledState({
    defaultProp,
    onChange
  });
  const isControlled = prop !== void 0;
  const value1 = isControlled ? prop : uncontrolledProp;
  const handleChange = $b1b2314f5f9a1d84$export$25bec8c6f54ee79a(onChange);
  const setValue = reactExports.useCallback((nextValue) => {
    if (isControlled) {
      const setter = nextValue;
      const value = typeof nextValue === "function" ? setter(prop) : nextValue;
      if (value !== prop) handleChange(value);
    } else setUncontrolledProp(nextValue);
  }, [
    isControlled,
    prop,
    setUncontrolledProp,
    handleChange
  ]);
  return [
    value1,
    setValue
  ];
}
function $71cd76cc60e0454e$var$useUncontrolledState({ defaultProp, onChange }) {
  const uncontrolledState = reactExports.useState(defaultProp);
  const [value] = uncontrolledState;
  const prevValueRef = reactExports.useRef(value);
  const handleChange = $b1b2314f5f9a1d84$export$25bec8c6f54ee79a(onChange);
  reactExports.useEffect(() => {
    if (prevValueRef.current !== value) {
      handleChange(value);
      prevValueRef.current = value;
    }
  }, [
    value,
    prevValueRef,
    handleChange
  ]);
  return uncontrolledState;
}
const $1746a345f3d73bb7$var$useReactId = $2AODx$react["useId".toString()] || (() => void 0);
let $1746a345f3d73bb7$var$count = 0;
function $1746a345f3d73bb7$export$f680877a34711e37(deterministicId) {
  const [id2, setId] = reactExports.useState($1746a345f3d73bb7$var$useReactId());
  $9f79659886946c16$export$e5c5a5f917a5871c(() => {
    setId(
      (reactId) => reactId !== null && reactId !== void 0 ? reactId : String($1746a345f3d73bb7$var$count++)
    );
  }, [
    deterministicId
  ]);
  return deterministicId || (id2 ? `radix-${id2}` : "");
}
const $69cb30bb0017df05$var$TABS_NAME = "Tabs";
const [$69cb30bb0017df05$var$createTabsContext] = $c512c27ab02ef895$export$50c7b4e9d9f19c1$2($69cb30bb0017df05$var$TABS_NAME, [
  $d7bdfb9eb0fdf311$export$c7109489551a4f4
]);
const $69cb30bb0017df05$var$useRovingFocusGroupScope = $d7bdfb9eb0fdf311$export$c7109489551a4f4();
const [$69cb30bb0017df05$var$TabsProvider, $69cb30bb0017df05$var$useTabsContext] = $69cb30bb0017df05$var$createTabsContext($69cb30bb0017df05$var$TABS_NAME);
const $69cb30bb0017df05$export$b2539bed5023c21c = /* @__PURE__ */ reactExports.forwardRef((props, forwardedRef) => {
  const { __scopeTabs, value: valueProp, onValueChange, defaultValue, orientation = "horizontal", dir, activationMode = "automatic", ...tabsProps } = props;
  const direction = $f631663db3294ace$export$b39126d51d94e6f3(dir);
  const [value, setValue] = $71cd76cc60e0454e$export$6f32135080cb4c3({
    prop: valueProp,
    onChange: onValueChange,
    defaultProp: defaultValue
  });
  return /* @__PURE__ */ reactExports.createElement($69cb30bb0017df05$var$TabsProvider, {
    scope: __scopeTabs,
    baseId: $1746a345f3d73bb7$export$f680877a34711e37(),
    value,
    onValueChange: setValue,
    orientation,
    dir: direction,
    activationMode
  }, /* @__PURE__ */ reactExports.createElement($8927f6f2acc4f386$export$250ffa63cdc0d034.div, _extends({
    dir: direction,
    "data-orientation": orientation
  }, tabsProps, {
    ref: forwardedRef
  })));
});
const $69cb30bb0017df05$var$TAB_LIST_NAME = "TabsList";
const $69cb30bb0017df05$export$9712d22edc0d78c1 = /* @__PURE__ */ reactExports.forwardRef((props, forwardedRef) => {
  const { __scopeTabs, loop = true, ...listProps } = props;
  const context = $69cb30bb0017df05$var$useTabsContext($69cb30bb0017df05$var$TAB_LIST_NAME, __scopeTabs);
  const rovingFocusGroupScope = $69cb30bb0017df05$var$useRovingFocusGroupScope(__scopeTabs);
  return /* @__PURE__ */ reactExports.createElement($d7bdfb9eb0fdf311$export$be92b6f5f03c0fe9, _extends({
    asChild: true
  }, rovingFocusGroupScope, {
    orientation: context.orientation,
    dir: context.dir,
    loop
  }), /* @__PURE__ */ reactExports.createElement($8927f6f2acc4f386$export$250ffa63cdc0d034.div, _extends({
    role: "tablist",
    "aria-orientation": context.orientation
  }, listProps, {
    ref: forwardedRef
  })));
});
const $69cb30bb0017df05$var$TRIGGER_NAME = "TabsTrigger";
const $69cb30bb0017df05$export$8114b9fdfdf9f3ba = /* @__PURE__ */ reactExports.forwardRef((props, forwardedRef) => {
  const { __scopeTabs, value, disabled = false, ...triggerProps } = props;
  const context = $69cb30bb0017df05$var$useTabsContext($69cb30bb0017df05$var$TRIGGER_NAME, __scopeTabs);
  const rovingFocusGroupScope = $69cb30bb0017df05$var$useRovingFocusGroupScope(__scopeTabs);
  const triggerId = $69cb30bb0017df05$var$makeTriggerId(context.baseId, value);
  const contentId = $69cb30bb0017df05$var$makeContentId(context.baseId, value);
  const isSelected = value === context.value;
  return /* @__PURE__ */ reactExports.createElement($d7bdfb9eb0fdf311$export$6d08773d2e66f8f2, _extends({
    asChild: true
  }, rovingFocusGroupScope, {
    focusable: !disabled,
    active: isSelected
  }), /* @__PURE__ */ reactExports.createElement($8927f6f2acc4f386$export$250ffa63cdc0d034.button, _extends({
    type: "button",
    role: "tab",
    "aria-selected": isSelected,
    "aria-controls": contentId,
    "data-state": isSelected ? "active" : "inactive",
    "data-disabled": disabled ? "" : void 0,
    disabled,
    id: triggerId
  }, triggerProps, {
    ref: forwardedRef,
    onMouseDown: $e42e1063c40fb3ef$export$b9ecd428b558ff10$1(props.onMouseDown, (event) => {
      if (!disabled && event.button === 0 && event.ctrlKey === false) context.onValueChange(value);
      else
        event.preventDefault();
    }),
    onKeyDown: $e42e1063c40fb3ef$export$b9ecd428b558ff10$1(props.onKeyDown, (event) => {
      if ([
        " ",
        "Enter"
      ].includes(event.key)) context.onValueChange(value);
    }),
    onFocus: $e42e1063c40fb3ef$export$b9ecd428b558ff10$1(props.onFocus, () => {
      const isAutomaticActivation = context.activationMode !== "manual";
      if (!isSelected && !disabled && isAutomaticActivation) context.onValueChange(value);
    })
  })));
});
const $69cb30bb0017df05$var$CONTENT_NAME = "TabsContent";
const $69cb30bb0017df05$export$bd905d70e8fd2ebb = /* @__PURE__ */ reactExports.forwardRef((props, forwardedRef) => {
  const { __scopeTabs, value, forceMount, children, ...contentProps } = props;
  const context = $69cb30bb0017df05$var$useTabsContext($69cb30bb0017df05$var$CONTENT_NAME, __scopeTabs);
  const triggerId = $69cb30bb0017df05$var$makeTriggerId(context.baseId, value);
  const contentId = $69cb30bb0017df05$var$makeContentId(context.baseId, value);
  const isSelected = value === context.value;
  const isMountAnimationPreventedRef = reactExports.useRef(isSelected);
  reactExports.useEffect(() => {
    const rAF = requestAnimationFrame(
      () => isMountAnimationPreventedRef.current = false
    );
    return () => cancelAnimationFrame(rAF);
  }, []);
  return /* @__PURE__ */ reactExports.createElement(
    $921a889cee6df7e8$export$99c2b779aa4e8b8b,
    {
      present: forceMount || isSelected
    },
    ({ present }) => /* @__PURE__ */ reactExports.createElement($8927f6f2acc4f386$export$250ffa63cdc0d034.div, _extends({
      "data-state": isSelected ? "active" : "inactive",
      "data-orientation": context.orientation,
      role: "tabpanel",
      "aria-labelledby": triggerId,
      hidden: !present,
      id: contentId,
      tabIndex: 0
    }, contentProps, {
      ref: forwardedRef,
      style: {
        ...props.style,
        animationDuration: isMountAnimationPreventedRef.current ? "0s" : void 0
      }
    }), present && children)
  );
});
function $69cb30bb0017df05$var$makeTriggerId(baseId, value) {
  return `${baseId}-trigger-${value}`;
}
function $69cb30bb0017df05$var$makeContentId(baseId, value) {
  return `${baseId}-content-${value}`;
}
const $69cb30bb0017df05$export$be92b6f5f03c0fe9 = $69cb30bb0017df05$export$b2539bed5023c21c;
const $69cb30bb0017df05$export$54c2e3dc7acea9f5 = $69cb30bb0017df05$export$9712d22edc0d78c1;
const $69cb30bb0017df05$export$41fb9f06171c75f4 = $69cb30bb0017df05$export$8114b9fdfdf9f3ba;
const $69cb30bb0017df05$export$7c6e2c02157bb7d2 = $69cb30bb0017df05$export$bd905d70e8fd2ebb;
var lodash_debounce;
var hasRequiredLodash_debounce;
function requireLodash_debounce() {
  if (hasRequiredLodash_debounce) return lodash_debounce;
  hasRequiredLodash_debounce = 1;
  var FUNC_ERROR_TEXT = "Expected a function";
  var NAN = 0 / 0;
  var symbolTag = "[object Symbol]";
  var reTrim = /^\s+|\s+$/g;
  var reIsBadHex = /^[-+]0x[0-9a-f]+$/i;
  var reIsBinary = /^0b[01]+$/i;
  var reIsOctal = /^0o[0-7]+$/i;
  var freeParseInt = parseInt;
  var freeGlobal = typeof commonjsGlobal == "object" && commonjsGlobal && commonjsGlobal.Object === Object && commonjsGlobal;
  var freeSelf = typeof self == "object" && self && self.Object === Object && self;
  var root = freeGlobal || freeSelf || Function("return this")();
  var objectProto = Object.prototype;
  var objectToString = objectProto.toString;
  var nativeMax = Math.max, nativeMin = Math.min;
  var now = function() {
    return root.Date.now();
  };
  function debounce(func, wait, options) {
    var lastArgs, lastThis, maxWait, result, timerId, lastCallTime, lastInvokeTime = 0, leading = false, maxing = false, trailing = true;
    if (typeof func != "function") {
      throw new TypeError(FUNC_ERROR_TEXT);
    }
    wait = toNumber(wait) || 0;
    if (isObject(options)) {
      leading = !!options.leading;
      maxing = "maxWait" in options;
      maxWait = maxing ? nativeMax(toNumber(options.maxWait) || 0, wait) : maxWait;
      trailing = "trailing" in options ? !!options.trailing : trailing;
    }
    function invokeFunc(time) {
      var args = lastArgs, thisArg = lastThis;
      lastArgs = lastThis = void 0;
      lastInvokeTime = time;
      result = func.apply(thisArg, args);
      return result;
    }
    function leadingEdge(time) {
      lastInvokeTime = time;
      timerId = setTimeout(timerExpired, wait);
      return leading ? invokeFunc(time) : result;
    }
    function remainingWait(time) {
      var timeSinceLastCall = time - lastCallTime, timeSinceLastInvoke = time - lastInvokeTime, result2 = wait - timeSinceLastCall;
      return maxing ? nativeMin(result2, maxWait - timeSinceLastInvoke) : result2;
    }
    function shouldInvoke(time) {
      var timeSinceLastCall = time - lastCallTime, timeSinceLastInvoke = time - lastInvokeTime;
      return lastCallTime === void 0 || timeSinceLastCall >= wait || timeSinceLastCall < 0 || maxing && timeSinceLastInvoke >= maxWait;
    }
    function timerExpired() {
      var time = now();
      if (shouldInvoke(time)) {
        return trailingEdge(time);
      }
      timerId = setTimeout(timerExpired, remainingWait(time));
    }
    function trailingEdge(time) {
      timerId = void 0;
      if (trailing && lastArgs) {
        return invokeFunc(time);
      }
      lastArgs = lastThis = void 0;
      return result;
    }
    function cancel() {
      if (timerId !== void 0) {
        clearTimeout(timerId);
      }
      lastInvokeTime = 0;
      lastArgs = lastCallTime = lastThis = timerId = void 0;
    }
    function flush() {
      return timerId === void 0 ? result : trailingEdge(now());
    }
    function debounced() {
      var time = now(), isInvoking = shouldInvoke(time);
      lastArgs = arguments;
      lastThis = this;
      lastCallTime = time;
      if (isInvoking) {
        if (timerId === void 0) {
          return leadingEdge(lastCallTime);
        }
        if (maxing) {
          timerId = setTimeout(timerExpired, wait);
          return invokeFunc(lastCallTime);
        }
      }
      if (timerId === void 0) {
        timerId = setTimeout(timerExpired, wait);
      }
      return result;
    }
    debounced.cancel = cancel;
    debounced.flush = flush;
    return debounced;
  }
  function isObject(value) {
    var type = typeof value;
    return !!value && (type == "object" || type == "function");
  }
  function isObjectLike(value) {
    return !!value && typeof value == "object";
  }
  function isSymbol(value) {
    return typeof value == "symbol" || isObjectLike(value) && objectToString.call(value) == symbolTag;
  }
  function toNumber(value) {
    if (typeof value == "number") {
      return value;
    }
    if (isSymbol(value)) {
      return NAN;
    }
    if (isObject(value)) {
      var other = typeof value.valueOf == "function" ? value.valueOf() : value;
      value = isObject(other) ? other + "" : other;
    }
    if (typeof value != "string") {
      return value === 0 ? value : +value;
    }
    value = value.replace(reTrim, "");
    var isBinary = reIsBinary.test(value);
    return isBinary || reIsOctal.test(value) ? freeParseInt(value.slice(2), isBinary ? 2 : 8) : reIsBadHex.test(value) ? NAN : +value;
  }
  lodash_debounce = debounce;
  return lodash_debounce;
}
var lodash_debounceExports = requireLodash_debounce();
const xA = /* @__PURE__ */ getDefaultExportFromCjs(lodash_debounceExports);
function $parcel$export(e12, n3, v3, s3) {
  Object.defineProperty(e12, n3, { get: v3, set: s3, enumerable: true, configurable: true });
}
var $94cfa2cfccc8cc22$exports = {};
$parcel$export($94cfa2cfccc8cc22$exports, "LaserPointer", () => $94cfa2cfccc8cc22$export$6531021b3bf36eae);
function $8cd7efb5af385306$export$e16d8520af44a096([ax, ay2, ar2], [bx2, by, br2]) {
  return [
    ax + bx2,
    ay2 + by,
    ar2 + br2
  ];
}
function $8cd7efb5af385306$export$f93b5905241a7cca([ax, ay2, ar2], [bx2, by, br2]) {
  return [
    ax - bx2,
    ay2 - by,
    ar2 - br2
  ];
}
function $8cd7efb5af385306$export$1c8884ee32bdf443([x3, y3, r3], s3) {
  return [
    x3 * s3,
    y3 * s3,
    r3 * s3
  ];
}
function $8cd7efb5af385306$export$1991ecd29cc92c6b([x3, y3, r3]) {
  return [
    x3 / Math.sqrt(x3 ** 2 + y3 ** 2),
    y3 / Math.sqrt(x3 ** 2 + y3 ** 2),
    r3
  ];
}
function $8cd7efb5af385306$export$855df823ceb9b81b([x3, y3, r3], rad) {
  return [
    Math.cos(rad) * x3 - Math.sin(rad) * y3,
    Math.sin(rad) * x3 + Math.cos(rad) * y3,
    r3
  ];
}
function $8cd7efb5af385306$export$92d8e23769117a5e(a3, b3, t3) {
  return $8cd7efb5af385306$export$e16d8520af44a096(a3, $8cd7efb5af385306$export$1c8884ee32bdf443($8cd7efb5af385306$export$f93b5905241a7cca(b3, a3), t3));
}
function $8cd7efb5af385306$export$944b09d2ad10b378(p3, p12, p22) {
  return Math.atan2(p22[1] - p3[1], p22[0] - p3[0]) - Math.atan2(p12[1] - p3[1], p12[0] - p3[0]);
}
function $8cd7efb5af385306$export$3c05aaf71f141f73(a3) {
  return Math.atan2(Math.sin(a3), Math.cos(a3));
}
function $8cd7efb5af385306$export$1b9bab504faa9305([x3, y3]) {
  return Math.sqrt(x3 ** 2 + y3 ** 2);
}
function $8cd7efb5af385306$export$6c4a311cc157c764([ax, ay2], [bx2, by]) {
  return Math.sqrt((bx2 - ax) ** 2 + (by - ay2) ** 2);
}
function $8cd7efb5af385306$export$ccb1b4dfbd3f36a7(ps2) {
  if (ps2.length < 2) return 0;
  let len = 0;
  for (let i3 = 1; i3 <= ps2.length - 1; i3++) len += $8cd7efb5af385306$export$6c4a311cc157c764(ps2[i3 - 1], ps2[i3]);
  len += $8cd7efb5af385306$export$6c4a311cc157c764(ps2[ps2.length - 2], ps2[ps2.length - 1]);
  return len;
}
const $8cd7efb5af385306$export$7d15b64cf5a3a4c4 = (v3, min2, max2) => Math.max(min2, Math.min(max2, v3));
function $8cd7efb5af385306$export$548cc43590159af6(p3, p12, p22) {
  const sMag = $8cd7efb5af385306$export$6c4a311cc157c764(p12, p22);
  if (sMag === 0) return $8cd7efb5af385306$export$6c4a311cc157c764(p3, p12);
  const u3 = $8cd7efb5af385306$export$7d15b64cf5a3a4c4(((p3[0] - p12[0]) * (p22[0] - p12[0]) + (p3[1] - p12[1]) * (p22[1] - p12[1])) / sMag ** 2, 0, 1);
  const pi2 = [
    p12[0] + u3 * (p22[0] - p12[0]),
    p12[1] + u3 * (p22[1] - p12[1]),
    p3[2]
  ];
  return $8cd7efb5af385306$export$6c4a311cc157c764(pi2, p3);
}
function $34bab0059f842ce6$export$ef693d1572e64fb8(points, epsilon) {
  if (epsilon === 0) return points;
  if (points.length <= 2) return points;
  const first = points[0];
  const last = points[points.length - 1];
  const [maxDistance, maxIndex] = points.reduce(([maxDistance2, maxIndex2], point, index2) => {
    const distance2 = $8cd7efb5af385306$export$548cc43590159af6(point, first, last);
    return distance2 > maxDistance2 ? [
      distance2,
      index2
    ] : [
      maxDistance2,
      maxIndex2
    ];
  }, [
    0,
    -1
  ]);
  if (maxDistance >= epsilon) {
    const maxIndexPoint = points[maxIndex];
    return [
      ...$34bab0059f842ce6$export$ef693d1572e64fb8([
        first,
        ...points.slice(1, maxIndex),
        maxIndexPoint
      ], epsilon).slice(0, -1),
      maxIndexPoint,
      ...$34bab0059f842ce6$export$ef693d1572e64fb8([
        maxIndexPoint,
        ...points.slice(maxIndex, -1),
        last
      ], epsilon).slice(1)
    ];
  } else return [
    first,
    last
  ];
}
class $94cfa2cfccc8cc22$export$6531021b3bf36eae {
  static {
    this.defaults = {
      size: 2,
      streamline: 0.45,
      simplify: 0.1,
      simplifyPhase: "output",
      keepHead: false,
      sizeMapping: () => 1
    };
  }
  static {
    this.constants = {
      cornerDetectionMaxAngle: 75,
      cornerDetectionVariance: (s3) => s3 > 35 ? 0.5 : 1,
      maxTailLength: 50
    };
  }
  constructor(options) {
    this.originalPoints = [];
    this.stablePoints = [];
    this.tailPoints = [];
    this.isFresh = true;
    this.options = Object.assign({}, $94cfa2cfccc8cc22$export$6531021b3bf36eae.defaults, options);
  }
  get lastPoint() {
    return this.tailPoints[this.tailPoints.length - 1] ?? this.stablePoints[this.stablePoints.length - 1];
  }
  addPoint(point) {
    const lastPoint = this.originalPoints[this.originalPoints.length - 1];
    if (lastPoint && lastPoint[0] === point[0] && lastPoint[1] === point[1]) return;
    this.originalPoints.push(point);
    if (this.isFresh) {
      this.isFresh = false;
      this.stablePoints.push(point);
      return;
    }
    if (this.options.streamline > 0) point = $8cd7efb5af385306$export$92d8e23769117a5e(this.lastPoint, point, 1 - this.options.streamline);
    this.tailPoints.push(point);
    if ($8cd7efb5af385306$export$ccb1b4dfbd3f36a7(this.tailPoints) > $94cfa2cfccc8cc22$export$6531021b3bf36eae.constants.maxTailLength) this.stabilizeTail();
  }
  close() {
    this.stabilizeTail();
  }
  stabilizeTail() {
    if (this.options.simplify > 0 && this.options.simplifyPhase == "tail") throw new Error("Not implemented yet");
    else {
      this.stablePoints.push(...this.tailPoints);
      this.tailPoints = [];
    }
  }
  getSize(sizeOverride, pressure, index2, totalLength, runningLength) {
    return (sizeOverride ?? this.options.size) * this.options.sizeMapping({
      pressure,
      runningLength,
      currentIndex: index2,
      totalLength
    });
  }
  getStrokeOutline(sizeOverride) {
    if (this.isFresh) return [];
    let points = [
      ...this.stablePoints,
      ...this.tailPoints
    ];
    if (this.options.simplify > 0 && this.options.simplifyPhase === "input") points = $34bab0059f842ce6$export$ef693d1572e64fb8(points, this.options.simplify);
    const len = points.length;
    if (len === 0) return [];
    if (len === 1) {
      const c3 = points[0];
      const size2 = this.getSize(sizeOverride, c3[2], 0, len, 0);
      if (size2 < 0.5) return [];
      const ps2 = [];
      for (let theta = 0; theta <= Math.PI * 2; theta += Math.PI / 16) ps2.push($8cd7efb5af385306$export$e16d8520af44a096(c3, $8cd7efb5af385306$export$1c8884ee32bdf443($8cd7efb5af385306$export$855df823ceb9b81b([
        1,
        0,
        0
      ], theta), size2)));
      ps2.push($8cd7efb5af385306$export$e16d8520af44a096(c3, $8cd7efb5af385306$export$1c8884ee32bdf443([
        1,
        0,
        0
      ], this.getSize(sizeOverride, c3[2], 0, len, 0))));
      return ps2;
    }
    if (len === 2) {
      const c3 = points[0];
      const n3 = points[1];
      const cSize = this.getSize(sizeOverride, c3[2], 0, len, 0);
      const nSize = this.getSize(sizeOverride, n3[2], 0, len, 0);
      if (cSize < 0.5 || nSize < 0.5) return [];
      const ps2 = [];
      const pAngle = $8cd7efb5af385306$export$944b09d2ad10b378(c3, [
        c3[0],
        c3[1] - 100,
        c3[2]
      ], n3);
      for (let theta = pAngle; theta <= Math.PI + pAngle; theta += Math.PI / 16) ps2.push($8cd7efb5af385306$export$e16d8520af44a096(c3, $8cd7efb5af385306$export$1c8884ee32bdf443($8cd7efb5af385306$export$855df823ceb9b81b([
        1,
        0,
        0
      ], theta), cSize)));
      for (let theta = Math.PI + pAngle; theta <= Math.PI * 2 + pAngle; theta += Math.PI / 16) ps2.push($8cd7efb5af385306$export$e16d8520af44a096(n3, $8cd7efb5af385306$export$1c8884ee32bdf443($8cd7efb5af385306$export$855df823ceb9b81b([
        1,
        0,
        0
      ], theta), nSize)));
      ps2.push(ps2[0]);
      return ps2;
    }
    const forwardPoints = [];
    const backwardPoints = [];
    let speed = 0;
    let prevSpeed = 0;
    let visibleStartIndex = 0;
    let runningLength = 0;
    for (let i3 = 1; i3 < len - 1; i3++) {
      const p3 = points[i3 - 1], c3 = points[i3], n3 = points[i3 + 1];
      let pressure = c3[2];
      const d3 = $8cd7efb5af385306$export$6c4a311cc157c764(p3, c3);
      runningLength += d3;
      speed = prevSpeed + (d3 - prevSpeed) * 0.2;
      const cSize = this.getSize(sizeOverride, pressure, i3, len, runningLength);
      if (cSize === 0) {
        visibleStartIndex = i3 + 1;
        continue;
      }
      const dirPC = $8cd7efb5af385306$export$1991ecd29cc92c6b($8cd7efb5af385306$export$f93b5905241a7cca(p3, c3));
      const dirNC = $8cd7efb5af385306$export$1991ecd29cc92c6b($8cd7efb5af385306$export$f93b5905241a7cca(n3, c3));
      const p1dirPC = $8cd7efb5af385306$export$855df823ceb9b81b(dirPC, Math.PI / 2);
      const p2dirPC = $8cd7efb5af385306$export$855df823ceb9b81b(dirPC, -Math.PI / 2);
      const p1dirNC = $8cd7efb5af385306$export$855df823ceb9b81b(dirNC, Math.PI / 2);
      const p2dirNC = $8cd7efb5af385306$export$855df823ceb9b81b(dirNC, -Math.PI / 2);
      const p1PC = $8cd7efb5af385306$export$e16d8520af44a096(c3, $8cd7efb5af385306$export$1c8884ee32bdf443(p1dirPC, cSize));
      const p2PC = $8cd7efb5af385306$export$e16d8520af44a096(c3, $8cd7efb5af385306$export$1c8884ee32bdf443(p2dirPC, cSize));
      const p1NC = $8cd7efb5af385306$export$e16d8520af44a096(c3, $8cd7efb5af385306$export$1c8884ee32bdf443(p1dirNC, cSize));
      const p2NC = $8cd7efb5af385306$export$e16d8520af44a096(c3, $8cd7efb5af385306$export$1c8884ee32bdf443(p2dirNC, cSize));
      const ftdir = $8cd7efb5af385306$export$e16d8520af44a096(p1dirPC, p2dirNC);
      const btdir = $8cd7efb5af385306$export$e16d8520af44a096(p2dirPC, p1dirNC);
      const paPC = $8cd7efb5af385306$export$e16d8520af44a096(c3, $8cd7efb5af385306$export$1c8884ee32bdf443($8cd7efb5af385306$export$1b9bab504faa9305(ftdir) === 0 ? dirPC : $8cd7efb5af385306$export$1991ecd29cc92c6b(ftdir), cSize));
      const paNC = $8cd7efb5af385306$export$e16d8520af44a096(c3, $8cd7efb5af385306$export$1c8884ee32bdf443($8cd7efb5af385306$export$1b9bab504faa9305(btdir) === 0 ? dirNC : $8cd7efb5af385306$export$1991ecd29cc92c6b(btdir), cSize));
      const cAngle = $8cd7efb5af385306$export$3c05aaf71f141f73($8cd7efb5af385306$export$944b09d2ad10b378(c3, p3, n3));
      const D_ANGLE = $94cfa2cfccc8cc22$export$6531021b3bf36eae.constants.cornerDetectionMaxAngle / 180 * Math.PI * $94cfa2cfccc8cc22$export$6531021b3bf36eae.constants.cornerDetectionVariance(speed);
      if (Math.abs(cAngle) < D_ANGLE) {
        const tAngle = Math.abs($8cd7efb5af385306$export$3c05aaf71f141f73(Math.PI - cAngle));
        if (tAngle === 0) continue;
        if (cAngle < 0) {
          backwardPoints.push(p2PC, paNC);
          for (let theta = 0; theta <= tAngle; theta += tAngle / 4) forwardPoints.push($8cd7efb5af385306$export$e16d8520af44a096(c3, $8cd7efb5af385306$export$855df823ceb9b81b($8cd7efb5af385306$export$1c8884ee32bdf443(p1dirPC, cSize), theta)));
          for (let theta = tAngle; theta >= 0; theta -= tAngle / 4) backwardPoints.push($8cd7efb5af385306$export$e16d8520af44a096(c3, $8cd7efb5af385306$export$855df823ceb9b81b($8cd7efb5af385306$export$1c8884ee32bdf443(p1dirPC, cSize), theta)));
          backwardPoints.push(paNC, p1NC);
        } else {
          forwardPoints.push(p1PC, paPC);
          for (let theta = 0; theta <= tAngle; theta += tAngle / 4) backwardPoints.push($8cd7efb5af385306$export$e16d8520af44a096(c3, $8cd7efb5af385306$export$855df823ceb9b81b($8cd7efb5af385306$export$1c8884ee32bdf443(p1dirPC, -cSize), -theta)));
          for (let theta = tAngle; theta >= 0; theta -= tAngle / 4) forwardPoints.push($8cd7efb5af385306$export$e16d8520af44a096(c3, $8cd7efb5af385306$export$855df823ceb9b81b($8cd7efb5af385306$export$1c8884ee32bdf443(p1dirPC, -cSize), -theta)));
          forwardPoints.push(paPC, p2NC);
        }
      } else {
        forwardPoints.push(paPC);
        backwardPoints.push(paNC);
      }
      prevSpeed = speed;
    }
    if (visibleStartIndex >= len - 2) {
      if (this.options.keepHead) {
        const c3 = points[len - 1];
        const ps2 = [];
        for (let theta = 0; theta <= Math.PI * 2; theta += Math.PI / 16) ps2.push($8cd7efb5af385306$export$e16d8520af44a096(c3, $8cd7efb5af385306$export$1c8884ee32bdf443($8cd7efb5af385306$export$855df823ceb9b81b([
          1,
          0,
          0
        ], theta), this.options.size)));
        ps2.push($8cd7efb5af385306$export$e16d8520af44a096(c3, $8cd7efb5af385306$export$1c8884ee32bdf443([
          1,
          0,
          0
        ], this.options.size)));
        return ps2;
      } else return [];
    }
    const first = points[visibleStartIndex];
    const second = points[visibleStartIndex + 1];
    const penultimate = points[len - 2];
    const ultimate = points[len - 1];
    const dirFS = $8cd7efb5af385306$export$1991ecd29cc92c6b($8cd7efb5af385306$export$f93b5905241a7cca(second, first));
    const dirPU = $8cd7efb5af385306$export$1991ecd29cc92c6b($8cd7efb5af385306$export$f93b5905241a7cca(penultimate, ultimate));
    const ppdirFS = $8cd7efb5af385306$export$855df823ceb9b81b(dirFS, -Math.PI / 2);
    const ppdirPU = $8cd7efb5af385306$export$855df823ceb9b81b(dirPU, Math.PI / 2);
    const startCapSize = this.getSize(sizeOverride, first[2], 0, len, 0);
    const startCap = [];
    const endCapSize = this.options.keepHead ? this.options.size : this.getSize(sizeOverride, penultimate[2], len - 2, len, runningLength);
    const endCap = [];
    if (startCapSize > 1) {
      for (let theta = 0; theta <= Math.PI; theta += Math.PI / 16) startCap.unshift($8cd7efb5af385306$export$e16d8520af44a096(first, $8cd7efb5af385306$export$855df823ceb9b81b($8cd7efb5af385306$export$1c8884ee32bdf443(ppdirFS, startCapSize), -theta)));
      startCap.unshift($8cd7efb5af385306$export$e16d8520af44a096(first, $8cd7efb5af385306$export$1c8884ee32bdf443(ppdirFS, -startCapSize)));
    } else startCap.push(first);
    for (let theta = 0; theta <= Math.PI * 3; theta += Math.PI / 16) endCap.push($8cd7efb5af385306$export$e16d8520af44a096(ultimate, $8cd7efb5af385306$export$855df823ceb9b81b($8cd7efb5af385306$export$1c8884ee32bdf443(ppdirPU, -endCapSize), -theta)));
    const strokeOutline = [
      ...startCap,
      ...forwardPoints,
      ...endCap.reverse(),
      ...backwardPoints.reverse()
    ];
    if (startCap.length > 0) strokeOutline.push(startCap[0]);
    if (this.options.simplify > 0 && this.options.simplifyPhase === "output") return $34bab0059f842ce6$export$ef693d1572e64fb8(strokeOutline, this.options.simplify);
    return strokeOutline;
  }
}
var YE = createIsolation();
var { useAtom: ce, useSetAtom: Tr, useAtomValue: Ws, useStore: LM } = YE, VE = YE.Provider, st = createStore$2();
var YT = g$2({ "./locales/ar-SA.json": () => __vitePreload(() => import("./ar-SA-G6X2FPQ2-C9eOm9Jh.js"), true ? [] : void 0, import.meta.url), "./locales/az-AZ.json": () => __vitePreload(() => import("./az-AZ-76LH7QW2-BWyy07lV.js"), true ? [] : void 0, import.meta.url), "./locales/bg-BG.json": () => __vitePreload(() => import("./bg-BG-XCXSNQG7-D7zzkj2N.js"), true ? [] : void 0, import.meta.url), "./locales/bn-BD.json": () => __vitePreload(() => import("./bn-BD-2XOGV67Q-CyaZ46ml.js"), true ? [] : void 0, import.meta.url), "./locales/ca-ES.json": () => __vitePreload(() => import("./ca-ES-6MX7JW3Y-nGoXqErY.js"), true ? [] : void 0, import.meta.url), "./locales/cs-CZ.json": () => __vitePreload(() => import("./cs-CZ-2BRQDIVT-De12l5-b.js"), true ? [] : void 0, import.meta.url), "./locales/da-DK.json": () => __vitePreload(() => import("./da-DK-5WZEPLOC-BE70N0QU.js"), true ? [] : void 0, import.meta.url), "./locales/de-DE.json": () => __vitePreload(() => import("./de-DE-XR44H4JA-Cpx1HYk1.js"), true ? [] : void 0, import.meta.url), "./locales/el-GR.json": () => __vitePreload(() => import("./el-GR-BZB4AONW-B3nWoWkb.js"), true ? [] : void 0, import.meta.url), "./locales/en.json": () => __vitePreload(() => Promise.resolve().then(() => enB4ZKOASM), true ? void 0 : void 0, import.meta.url), "./locales/es-ES.json": () => __vitePreload(() => import("./es-ES-U4NZUMDT-BuU_ylfC.js"), true ? [] : void 0, import.meta.url), "./locales/eu-ES.json": () => __vitePreload(() => import("./eu-ES-A7QVB2H4-tjYKRpr9.js"), true ? [] : void 0, import.meta.url), "./locales/fa-IR.json": () => __vitePreload(() => import("./fa-IR-HGAKTJCU-Bg3iLlYd.js"), true ? [] : void 0, import.meta.url), "./locales/fi-FI.json": () => __vitePreload(() => import("./fi-FI-Z5N7JZ37-Cweo0HLq.js"), true ? [] : void 0, import.meta.url), "./locales/fr-FR.json": () => __vitePreload(() => import("./fr-FR-RHASNOE6-C-vaX90F.js"), true ? [] : void 0, import.meta.url), "./locales/gl-ES.json": () => __vitePreload(() => import("./gl-ES-HMX3MZ6V-CZlFNcjn.js"), true ? [] : void 0, import.meta.url), "./locales/he-IL.json": () => __vitePreload(() => import("./he-IL-6SHJWFNN-JtiF8Zrj.js"), true ? [] : void 0, import.meta.url), "./locales/hi-IN.json": () => __vitePreload(() => import("./hi-IN-IWLTKZ5I-DxVWpNYF.js"), true ? [] : void 0, import.meta.url), "./locales/hu-HU.json": () => __vitePreload(() => import("./hu-HU-A5ZG7DT2-iPj2KwLK.js"), true ? [] : void 0, import.meta.url), "./locales/id-ID.json": () => __vitePreload(() => import("./id-ID-SAP4L64H-CiLonOOH.js"), true ? [] : void 0, import.meta.url), "./locales/it-IT.json": () => __vitePreload(() => import("./it-IT-JPQ66NNP-Bm4YCMvu.js"), true ? [] : void 0, import.meta.url), "./locales/ja-JP.json": () => __vitePreload(() => import("./ja-JP-DBVTYXUO-DGRslFXl.js"), true ? [] : void 0, import.meta.url), "./locales/kaa.json": () => __vitePreload(() => import("./kaa-6HZHGXH3-Bl5hDwMv.js"), true ? [] : void 0, import.meta.url), "./locales/kab-KAB.json": () => __vitePreload(() => import("./kab-KAB-ZGHBKWFO-BhG6ZKr8.js"), true ? [] : void 0, import.meta.url), "./locales/kk-KZ.json": () => __vitePreload(() => import("./kk-KZ-P5N5QNE5-fs4GXUkB.js"), true ? [] : void 0, import.meta.url), "./locales/km-KH.json": () => __vitePreload(() => import("./km-KH-HSX4SM5Z-Dj5TqNY-.js"), true ? [] : void 0, import.meta.url), "./locales/ko-KR.json": () => __vitePreload(() => import("./ko-KR-MTYHY66A-_jISIG0J.js"), true ? [] : void 0, import.meta.url), "./locales/ku-TR.json": () => __vitePreload(() => import("./ku-TR-6OUDTVRD-D2biWF92.js"), true ? [] : void 0, import.meta.url), "./locales/lt-LT.json": () => __vitePreload(() => import("./lt-LT-XHIRWOB4-zy_tyops.js"), true ? [] : void 0, import.meta.url), "./locales/lv-LV.json": () => __vitePreload(() => import("./lv-LV-5QDEKY6T-CGZNcyST.js"), true ? [] : void 0, import.meta.url), "./locales/mr-IN.json": () => __vitePreload(() => import("./mr-IN-CRQNXWMA-Fs4SkiYv.js"), true ? [] : void 0, import.meta.url), "./locales/my-MM.json": () => __vitePreload(() => import("./my-MM-5M5IBNSE-CdqXJ93d.js"), true ? [] : void 0, import.meta.url), "./locales/nb-NO.json": () => __vitePreload(() => import("./nb-NO-T6EIAALU-DOIjkub3.js"), true ? [] : void 0, import.meta.url), "./locales/nl-NL.json": () => __vitePreload(() => import("./nl-NL-IS3SIHDZ-BzvNuIeS.js"), true ? [] : void 0, import.meta.url), "./locales/nn-NO.json": () => __vitePreload(() => import("./nn-NO-6E72VCQL-DTftx7Vd.js"), true ? [] : void 0, import.meta.url), "./locales/oc-FR.json": () => __vitePreload(() => import("./oc-FR-POXYY2M6-BDfdoluz.js"), true ? [] : void 0, import.meta.url), "./locales/pa-IN.json": () => __vitePreload(() => import("./pa-IN-N4M65BXN-sXItDliR.js"), true ? [] : void 0, import.meta.url), "./locales/percentages.json": () => __vitePreload(() => Promise.resolve().then(() => percentagesBXMCSKIN), true ? void 0 : void 0, import.meta.url), "./locales/pl-PL.json": () => __vitePreload(() => import("./pl-PL-T2D74RX3-L3A-ix_w.js"), true ? [] : void 0, import.meta.url), "./locales/pt-BR.json": () => __vitePreload(() => import("./pt-BR-5N22H2LF-C24eu7r5.js"), true ? [] : void 0, import.meta.url), "./locales/pt-PT.json": () => __vitePreload(() => import("./pt-PT-UZXXM6DQ-g70Fmnvm.js"), true ? [] : void 0, import.meta.url), "./locales/ro-RO.json": () => __vitePreload(() => import("./ro-RO-JPDTUUEW-CENsJd_x.js"), true ? [] : void 0, import.meta.url), "./locales/ru-RU.json": () => __vitePreload(() => import("./ru-RU-B4JR7IUQ-BaFPJE47.js"), true ? [] : void 0, import.meta.url), "./locales/si-LK.json": () => __vitePreload(() => import("./si-LK-N5RQ5JYF-B-t8VdFu.js"), true ? [] : void 0, import.meta.url), "./locales/sk-SK.json": () => __vitePreload(() => import("./sk-SK-C5VTKIMK-CYV7L1vv.js"), true ? [] : void 0, import.meta.url), "./locales/sl-SI.json": () => __vitePreload(() => import("./sl-SI-NN7IZMDC-DhhLy5YD.js"), true ? [] : void 0, import.meta.url), "./locales/sv-SE.json": () => __vitePreload(() => import("./sv-SE-XGPEYMSR-DBNBe0lB.js"), true ? [] : void 0, import.meta.url), "./locales/ta-IN.json": () => __vitePreload(() => import("./ta-IN-2NMHFXQM-CM49o0Hp.js"), true ? [] : void 0, import.meta.url), "./locales/th-TH.json": () => __vitePreload(() => import("./th-TH-HPSO5L25-BhhvjtEM.js"), true ? [] : void 0, import.meta.url), "./locales/tr-TR.json": () => __vitePreload(() => import("./tr-TR-DEFEU3FU-Df7iyMKq.js"), true ? [] : void 0, import.meta.url), "./locales/uk-UA.json": () => __vitePreload(() => import("./uk-UA-QMV73CPH-DkS5oHwj.js"), true ? [] : void 0, import.meta.url), "./locales/vi-VN.json": () => __vitePreload(() => import("./vi-VN-M7AON7JQ-DOxELqRT.js"), true ? [] : void 0, import.meta.url), "./locales/zh-CN.json": () => __vitePreload(() => import("./zh-CN-LNUGB5OW-DVTz5vya.js"), true ? [] : void 0, import.meta.url), "./locales/zh-HK.json": () => __vitePreload(() => import("./zh-HK-E62DVLB3-BR6ph5Fu.js"), true ? [] : void 0, import.meta.url), "./locales/zh-TW.json": () => __vitePreload(() => import("./zh-TW-RAJ6MFWO-DwxVQLBG.js"), true ? [] : void 0, import.meta.url) });
var VT = 85, _o = { code: "en", label: "English" }, xi = [_o, ...[{ code: "ar-SA", label: "", rtl: true }, { code: "bg-BG", label: "" }, { code: "ca-ES", label: "Catal" }, { code: "cs-CZ", label: "esky" }, { code: "de-DE", label: "Deutsch" }, { code: "el-GR", label: "" }, { code: "es-ES", label: "Espaol" }, { code: "eu-ES", label: "Euskara" }, { code: "fa-IR", label: "", rtl: true }, { code: "fi-FI", label: "Suomi" }, { code: "fr-FR", label: "Franais" }, { code: "gl-ES", label: "Galego" }, { code: "he-IL", label: "", rtl: true }, { code: "hi-IN", label: "" }, { code: "hu-HU", label: "Magyar" }, { code: "id-ID", label: "Bahasa Indonesia" }, { code: "it-IT", label: "Italiano" }, { code: "ja-JP", label: "" }, { code: "kab-KAB", label: "Taqbaylit" }, { code: "kk-KZ", label: " " }, { code: "ko-KR", label: "" }, { code: "ku-TR", label: "Kurd" }, { code: "lt-LT", label: "Lietuvi" }, { code: "lv-LV", label: "Latvieu" }, { code: "my-MM", label: "Burmese" }, { code: "nb-NO", label: "Norsk bokml" }, { code: "nl-NL", label: "Nederlands" }, { code: "nn-NO", label: "Norsk nynorsk" }, { code: "oc-FR", label: "Occitan" }, { code: "pa-IN", label: "" }, { code: "pl-PL", label: "Polski" }, { code: "pt-BR", label: "Portugus Brasileiro" }, { code: "pt-PT", label: "Portugus" }, { code: "ro-RO", label: "Romn" }, { code: "ru-RU", label: "" }, { code: "sk-SK", label: "Slovenina" }, { code: "sv-SE", label: "Svenska" }, { code: "sl-SI", label: "Slovenina" }, { code: "tr-TR", label: "Trke" }, { code: "uk-UA", label: "" }, { code: "zh-CN", label: "" }, { code: "zh-TW", label: "" }, { code: "vi-VN", label: "Ting Vit" }, { code: "mr-IN", label: "" }].filter((e12) => N[e12.code] >= VT).sort((e12, o3) => e12.label > o3.label ? 1 : -1)], Xs = "__test__";
c$1.DEV && xi.unshift({ code: Xs, label: "test language" }, { code: `${Xs}.rtl`, label: "test language (rtl)", rtl: true });
var bi = _o, Ks = {}, $s = async (e12) => {
  if (bi = e12, document.documentElement.dir = bi.rtl ? "rtl" : "ltr", document.documentElement.lang = bi.code, e12.code.startsWith(Xs)) Ks = {};
  else try {
    Ks = await YT(`./locales/${bi.code}.json`);
  } catch (o3) {
    console.error(`Failed to load language ${e12.code}:`, o3.message), Ks = B;
  }
  st.set(KE, e12.code);
}, qo = () => bi, WE = (e12, o3) => {
  for (let t3 = 0; t3 < o3.length; ++t3) {
    let r3 = o3[t3];
    if (e12[r3] === void 0) return;
    e12 = e12[r3];
  }
  if (typeof e12 == "string") return e12;
}, g = (e12, o3, t3) => {
  if (bi.code.startsWith(Xs)) return `[[${o3 ? `${e12}(${JSON.stringify(o3).slice(1, -1)})` : e12}]]`;
  let r3 = e12.split("."), n3 = WE(Ks, r3) || WE(B, r3) || t3;
  if (n3 === void 0) {
    let i3 = `Can't find translation for ${e12}`;
    return console.warn(i3), "";
  }
  if (o3) for (let i3 in o3) n3 = n3.replace(`{{${i3}}}`, String(o3[i3]));
  return n3;
}, KE = atom(_o.code), Ve = () => {
  let e12 = Ws(KE);
  return { t: g, langCode: e12 };
};
var KT = ({ size: e12 = "1em", circleWidth: o3 = 8, synchronized: t3 = false, className: r3 = "" }) => {
  let i3 = -(React.useRef(Date.now()).current % 1600);
  return jsxRuntimeExports.jsx("div", { className: `Spinner ${r3}`, children: jsxRuntimeExports.jsx("svg", { viewBox: "0 0 100 100", style: { width: e12, height: e12, "--spinner-delay": t3 ? `${i3}ms` : 0 }, children: jsxRuntimeExports.jsx("circle", { cx: "50", cy: "50", r: 50 - o3 / 2, strokeWidth: o3, fill: "none", strokeMiterlimit: "10" }) }) });
}, ct = KT;
var Zs = ({ delay: e12, theme: o3 }) => {
  let [t3, r3] = reactExports.useState(!!e12);
  return reactExports.useEffect(() => {
    if (!e12) return;
    let n3 = setTimeout(() => {
      r3(false);
    }, e12);
    return () => clearTimeout(n3);
  }, [e12]), t3 ? null : jsxRuntimeExports.jsxs("div", { className: dM("LoadingMessage", { "LoadingMessage--dark": o3 === ke.DARK }), children: [jsxRuntimeExports.jsx("div", { children: jsxRuntimeExports.jsx(ct, {}) }), jsxRuntimeExports.jsx("div", { className: "LoadingMessage-text", children: g("labels.loadingScene") })] });
};
var XE = (e12) => {
  let [o3, t3] = reactExports.useState(true);
  return reactExports.useEffect(() => {
    let r3 = async () => {
      await $s(n3), t3(false);
    }, n3 = xi.find((i3) => i3.code === e12.langCode) || _o;
    r3();
  }, [e12.langCode]), o3 ? jsxRuntimeExports.jsx(Zs, { theme: e12.theme }) : e12.children;
};
var X = React.forwardRef(({ size: e12 = "medium", visible: o3 = true, className: t3 = "", ...r3 }, n3) => {
  let { id: i3 } = Ke(), a3 = React.useRef(null);
  React.useImperativeHandle(n3, () => a3.current);
  let l3 = `ToolIcon_size_${e12}`, [s3, c3] = reactExports.useState(false), m3 = reactExports.useRef(true), d3 = async (u3) => {
    let h3 = "onClick" in r3 && r3.onClick?.(u3);
    if (Fo(h3)) try {
      c3(true), await h3;
    } catch (f3) {
      if (f3 instanceof Co) console.warn(f3);
      else throw f3;
    } finally {
      m3.current && c3(false);
    }
  };
  reactExports.useEffect(() => (m3.current = true, () => {
    m3.current = false;
  }), []);
  let p3 = reactExports.useRef(null);
  if (r3.type === "button" || r3.type === "icon" || r3.type === "submit") {
    let u3 = r3.type === "icon" ? "button" : r3.type;
    return jsxRuntimeExports.jsxs("button", { className: dM("ToolIcon_type_button", l3, t3, o3 && !r3.hidden ? "ToolIcon_type_button--show" : "ToolIcon_type_button--hide", { ToolIcon: !r3.hidden, "ToolIcon--selected": r3.selected, "ToolIcon--plain": r3.type === "icon" }), style: r3.style, "data-testid": r3["data-testid"], hidden: r3.hidden, title: r3.title, "aria-label": r3["aria-label"], type: u3, onClick: d3, ref: a3, disabled: s3 || r3.isLoading || !!r3.disabled, children: [(r3.icon || r3.label) && jsxRuntimeExports.jsxs("div", { className: "ToolIcon__icon", "aria-hidden": "true", "aria-disabled": !!r3.disabled, children: [r3.icon || r3.label, r3.keyBindingLabel && jsxRuntimeExports.jsx("span", { className: "ToolIcon__keybinding", children: r3.keyBindingLabel }), r3.isLoading && jsxRuntimeExports.jsx(ct, {})] }), r3.showAriaLabel && jsxRuntimeExports.jsxs("div", { className: "ToolIcon__label", children: [r3["aria-label"], " ", s3 && jsxRuntimeExports.jsx(ct, {})] }), r3.children] });
  }
  return jsxRuntimeExports.jsxs("label", { className: dM("ToolIcon", t3), title: r3.title, onPointerDown: (u3) => {
    p3.current = u3.pointerType || null, r3.onPointerDown?.({ pointerType: u3.pointerType || null });
  }, onPointerUp: () => {
    requestAnimationFrame(() => {
      p3.current = null;
    });
  }, children: [jsxRuntimeExports.jsx("input", { className: `ToolIcon_type_radio ${l3}`, type: "radio", name: r3.name, "aria-label": r3["aria-label"], "aria-keyshortcuts": r3["aria-keyshortcuts"], "data-testid": r3["data-testid"], id: `${i3}-${r3.id}`, onChange: () => {
    r3.onChange?.({ pointerType: p3.current });
  }, checked: r3.checked, ref: a3 }), jsxRuntimeExports.jsxs("div", { className: "ToolIcon__icon", children: [r3.icon, r3.keyBindingLabel && jsxRuntimeExports.jsx("span", { className: "ToolIcon__keybinding", children: r3.keyBindingLabel })] })] });
});
X.displayName = "ToolButton";
var oC = (e12, o3, t3) => {
  let r3 = new Set(at$1(e12.filter((m3) => de(m3)), o3).map((m3) => m3.id)), n3 = {}, i3 = t3.scene.getNonDeletedElementsMap(), a3 = /* @__PURE__ */ new Set();
  for (let m3 of r3) {
    let d3 = co(e12, m3);
    for (let p3 of d3) if (!a3.has(p3.id)) {
      if (Ne(p3)) {
        let u3 = qe(p3, i3);
        u3 && (n3[u3.id] = true);
      } else n3[p3.id] = true;
      a3.add(p3.id);
    }
  }
  let l3 = true, s3 = e12.map((m3) => {
    if (o3.selectedElementIds[m3.id]) {
      let d3 = Ne(m3) ? qe(m3, i3) : null;
      return m3.frameId && r3.has(m3.frameId) ? (l3 = false, n3[m3.id] = true, m3) : d3?.frameId && r3.has(d3?.frameId) ? m3 : (m3.boundElements && m3.boundElements.forEach((p3) => {
        let u3 = t3.scene.getNonDeletedElementsMap().get(p3.id);
        u3 && X$1(u3) && (Y(u3, { startBinding: m3.id === u3.startBinding?.elementId ? null : u3.startBinding, endBinding: m3.id === u3.endBinding?.elementId ? null : u3.endBinding }), Y(u3, { points: u3.points }));
      }), vt$1(m3, { isDeleted: true }));
    }
    return m3.frameId && r3.has(m3.frameId) ? (l3 = false, Ne(m3) || (n3[m3.id] = true), vt$1(m3, { frameId: null })) : Ne(m3) && o3.selectedElementIds[m3.containerId] ? vt$1(m3, { isDeleted: true }) : m3;
  }), c3 = o3.editingGroupId;
  if (l3 && o3.editingGroupId) {
    let m3 = an(s3, o3.editingGroupId).filter((d3) => !d3.isDeleted);
    if (m3.length > 1) m3[0] && (n3[m3[0].id] = true);
    else {
      c3 = null, m3[0] && (n3[m3[0].id] = true);
      let d3 = m3[0];
      if (d3) {
        let p3 = d3.groupIds.findIndex((h3) => h3 === o3.editingGroupId), u3 = d3.groupIds[p3 + 1];
        if (u3) {
          let h3 = an(s3, u3).filter((f3) => !f3.isDeleted);
          h3.length > 1 && (c3 = u3, h3.forEach((f3) => {
            n3[f3.id] = true;
          }));
        }
      }
    }
  }
  return { elements: s3, appState: { ...o3, ...aF({ selectedElementIds: n3, editingGroupId: c3 }, s3, o3, null) } };
}, jE = (e12, o3) => {
  if (e12.editingGroupId) {
    let t3 = an(Es(o3), e12.editingGroupId);
    if (t3.length) return { ...e12, selectedElementIds: { [t3[0].id]: true } };
  }
  return e12;
}, _a = L2({ name: "deleteSelectedElements", label: "labels.delete", icon: Tx, trackEvent: { category: "element", action: "delete" }, perform: (e12, o3, t3, r3) => {
  if (o3.editingLinearElement) {
    let { elementId: a3, selectedPointsIndices: l3, startBindingElement: s3, endBindingElement: c3 } = o3.editingLinearElement, m3 = r3.scene.getNonDeletedElementsMap(), d3 = z$1.getElement(a3, m3);
    if (!d3 || l3 == null) return false;
    if (d3.points.length < 2) {
      let u3 = e12.map((f3) => f3.id === d3.id ? vt$1(f3, { isDeleted: true }) : f3), h3 = jE(o3, u3);
      return { elements: u3, appState: { ...h3, editingLinearElement: null }, captureUpdate: dr.IMMEDIATELY };
    }
    let p3 = { startBindingElement: l3?.includes(0) ? null : s3, endBindingElement: l3?.includes(d3.points.length - 1) ? null : c3 };
    return z$1.deletePoints(d3, l3), { elements: e12, appState: { ...o3, editingLinearElement: { ...o3.editingLinearElement, ...p3, selectedPointsIndices: l3?.[0] > 0 ? [l3[0] - 1] : [0] } }, captureUpdate: dr.IMMEDIATELY };
  }
  let { elements: n3, appState: i3 } = oC(e12, o3, r3);
  return KN(n3, n3.filter((a3) => a3.isDeleted)), i3 = jE(i3, n3), { elements: n3, appState: { ...i3, activeTool: $r(o3, { type: "selection" }), multiElement: null, activeEmbeddable: null }, captureUpdate: Ib(Es(e12), o3) ? dr.IMMEDIATELY : dr.EVENTUALLY };
}, keyTest: (e12, o3, t3) => (e12.key === Q.BACKSPACE || e12.key === Q.DELETE) && !e12[Q.CTRL_OR_CMD], PanelComponent: ({ elements: e12, appState: o3, updateData: t3 }) => jsxRuntimeExports.jsx(X, { type: "button", icon: Tx, title: g("labels.delete"), "aria-label": g("labels.delete"), onClick: () => t3(null), visible: Ib(Es(e12), o3) }) });
var pp = (e12, o3) => e12.frameId === o3 || e12.id === o3, qE = (e12, o3, t3) => {
  let r3 = [], n3 = [], i3 = null, a3 = -1, l3 = te(t3 || at$1(e12, o3, { includeBoundTextElement: true, includeElementsInFrames: true }));
  for (; ++a3 < e12.length; ) {
    let s3 = e12[a3];
    l3.get(s3.id) ? (n3.length && (r3 = r3.concat(n3), n3 = []), r3.push(a3), i3 = a3 + 1) : s3.isDeleted && i3 === a3 ? (i3 = a3 + 1, n3.push(a3)) : n3 = [];
  }
  return r3;
}, nC = (e12) => {
  let o3 = 0;
  return e12.reduce((t3, r3, n3) => (n3 > 0 && e12[n3 - 1] !== r3 - 1 && (o3 = ++o3), (t3[o3] || (t3[o3] = [])).push(r3), t3), []);
}, JE = (e12, o3, t3) => {
  if ("containerId" in e12 && e12.containerId) {
    let r3 = Ts.getScene(e12).getElement(e12.containerId);
    if (r3) return t3 === "left" ? Math.min(o3.indexOf(r3), o3.indexOf(e12)) : Math.max(o3.indexOf(r3), o3.indexOf(e12));
  } else {
    let r3 = e12.boundElements?.find((n3) => n3.type !== "arrow")?.id;
    if (r3) {
      let n3 = Ts.getScene(e12).getElement(r3);
      if (n3) return t3 === "left" ? Math.min(o3.indexOf(n3), o3.indexOf(e12)) : Math.max(o3.indexOf(n3), o3.indexOf(e12));
    }
  }
}, iC = (e12, o3) => {
  let t3 = -1, r3 = -1;
  return e12.forEach((n3, i3) => {
    pp(n3, o3) && (t3 === -1 && (t3 = i3), r3 = i3);
  }), t3 === -1 ? [] : e12.slice(t3, r3 + 1);
}, aC = (e12, o3, t3, r3, n3) => {
  let i3 = o3[t3], a3 = (d3) => d3.isDeleted ? false : n3 ? d3.frameId === n3 : e12.editingGroupId ? d3.groupIds.includes(e12.editingGroupId) : true, l3 = r3 === "left" ? pg(o3, (d3) => a3(d3), Math.max(0, t3 - 1)) : fg$1(o3, (d3) => a3(d3), t3 + 1), s3 = o3[l3];
  if (!s3) return -1;
  if (e12.editingGroupId) {
    if (i3?.groupIds.join("") === s3?.groupIds.join("")) return JE(s3, o3, r3) ?? l3;
    if (!s3?.groupIds.includes(e12.editingGroupId)) return -1;
  }
  if (!n3 && (s3.frameId || de(s3))) {
    let d3 = iC(o3, s3.frameId || s3.id);
    return r3 === "left" ? o3.indexOf(d3[0]) : o3.indexOf(d3[d3.length - 1]);
  }
  if (!s3.groupIds.length) return JE(s3, o3, r3) ?? l3;
  let c3 = e12.editingGroupId ? s3.groupIds[s3.groupIds.indexOf(e12.editingGroupId) - 1] : s3.groupIds[s3.groupIds.length - 1], m3 = an(o3, c3);
  return m3.length ? r3 === "left" ? o3.indexOf(m3[0]) : o3.indexOf(m3[m3.length - 1]) : l3;
}, QE = (e12, o3) => o3.reduce((t3, r3) => {
  let n3 = e12[r3];
  return t3.set(n3.id, n3), t3;
}, /* @__PURE__ */ new Map()), ey = (e12, o3, t3) => {
  let r3 = qE(e12, o3), n3 = QE(e12, r3), i3 = nC(r3);
  t3 === "right" && (i3 = i3.reverse());
  let a3 = new Set(r3.filter((l3) => de(e12[l3])).map((l3) => e12[l3].id));
  return i3.forEach((l3, s3) => {
    let c3 = l3[0], m3 = l3[l3.length - 1], d3 = t3 === "left" ? c3 : m3, p3 = l3.some((T3) => {
      let E3 = e12[T3];
      return E3.frameId && a3.has(E3.frameId);
    }) ? null : e12[d3]?.frameId, u3 = aC(o3, e12, d3, t3, p3);
    if (u3 === -1 || d3 === u3) return;
    let h3 = t3 === "left" ? e12.slice(0, u3) : e12.slice(0, c3), f3 = e12.slice(c3, m3 + 1), b3 = t3 === "left" ? e12.slice(u3, c3) : e12.slice(m3 + 1, u3 + 1), x3 = t3 === "left" ? e12.slice(m3 + 1) : e12.slice(u3 + 1);
    e12 = t3 === "left" ? [...h3, ...f3, ...b3, ...x3] : [...h3, ...b3, ...f3, ...x3];
  }), Zr(e12, n3), e12;
}, ty = (e12, o3, t3, r3, n3) => {
  let i3 = qE(e12, o3, n3), a3 = QE(e12, i3), l3 = [], s3, c3;
  if (t3 === "left") {
    if (r3) s3 = fg$1(e12, (h3) => pp(h3, r3));
    else if (o3.editingGroupId) {
      let h3 = an(e12, o3.editingGroupId);
      if (!h3.length) return e12;
      s3 = e12.indexOf(h3[0]);
    } else s3 = 0;
    c3 = i3[i3.length - 1];
  } else {
    if (r3) c3 = pg(e12, (h3) => pp(h3, r3));
    else if (o3.editingGroupId) {
      let h3 = an(e12, o3.editingGroupId);
      if (!h3.length) return e12;
      c3 = e12.indexOf(h3[h3.length - 1]);
    } else c3 = e12.length - 1;
    s3 = i3[0];
  }
  s3 === -1 && (s3 = 0);
  for (let h3 = s3; h3 < c3 + 1; h3++) i3.includes(h3) || l3.push(e12[h3]);
  let m3 = Array.from(a3.values()), d3 = e12.slice(0, s3), p3 = e12.slice(c3 + 1), u3 = t3 === "left" ? [...d3, ...m3, ...l3, ...p3] : [...d3, ...l3, ...m3, ...p3];
  return Zr(u3, a3), u3;
};
function oy(e12, o3, t3, r3) {
  let n3 = te(at$1(e12, o3, { includeBoundTextElement: true, includeElementsInFrames: true })), i3 = { regularElements: [], frameChildren: /* @__PURE__ */ new Map() }, a3 = /* @__PURE__ */ new Set();
  for (let c3 of e12) n3.has(c3.id) && de(c3) && a3.add(c3.id);
  for (let c3 of e12) if (n3.has(c3.id)) if (de(c3) || c3.frameId && a3.has(c3.frameId)) i3.regularElements.push(c3);
  else if (!c3.frameId) i3.regularElements.push(c3);
  else {
    let m3 = i3.frameChildren.get(c3.frameId) || [];
    m3.push(c3), i3.frameChildren.set(c3.frameId, m3);
  }
  let l3 = e12, s3 = Array.from(i3.frameChildren.entries());
  for (let [c3, m3] of s3) l3 = r3(e12, o3, t3, c3, m3);
  return r3(l3, o3, t3, null, i3.regularElements);
}
var ry = (e12, o3) => ey(e12, o3, "left"), ny = (e12, o3) => ey(e12, o3, "right"), iy = (e12, o3) => oy(e12, o3, "left", ty), ay = (e12, o3) => oy(e12, o3, "right", ty);
var up = L2({ name: "sendBackward", label: "labels.sendBackward", keywords: ["move down", "zindex", "layer"], icon: dh, trackEvent: { category: "element" }, perform: (e12, o3) => ({ elements: ry(e12, o3), appState: o3, captureUpdate: dr.IMMEDIATELY }), keyPriority: 40, keyTest: (e12) => e12[Q.CTRL_OR_CMD] && !e12.shiftKey && e12.code === D1.BRACKET_LEFT, PanelComponent: ({ updateData: e12, appState: o3 }) => jsxRuntimeExports.jsx("button", { type: "button", className: "zIndexButton", onClick: () => e12(null), title: `${g("labels.sendBackward")}  ${cg$1("CtrlOrCmd+[")}`, children: dh }) }), gp = L2({ name: "bringForward", label: "labels.bringForward", keywords: ["move up", "zindex", "layer"], icon: sh, trackEvent: { category: "element" }, perform: (e12, o3) => ({ elements: ny(e12, o3), appState: o3, captureUpdate: dr.IMMEDIATELY }), keyPriority: 40, keyTest: (e12) => e12[Q.CTRL_OR_CMD] && !e12.shiftKey && e12.code === D1.BRACKET_RIGHT, PanelComponent: ({ updateData: e12, appState: o3 }) => jsxRuntimeExports.jsx("button", { type: "button", className: "zIndexButton", onClick: () => e12(null), title: `${g("labels.bringForward")}  ${cg$1("CtrlOrCmd+]")}`, children: sh }) }), hp = L2({ name: "sendToBack", label: "labels.sendToBack", keywords: ["move down", "zindex", "layer"], icon: lh, trackEvent: { category: "element" }, perform: (e12, o3) => ({ elements: iy(e12, o3), appState: o3, captureUpdate: dr.IMMEDIATELY }), keyTest: (e12) => uo ? e12[Q.CTRL_OR_CMD] && e12.altKey && e12.code === D1.BRACKET_LEFT : e12[Q.CTRL_OR_CMD] && e12.shiftKey && e12.code === D1.BRACKET_LEFT, PanelComponent: ({ updateData: e12, appState: o3 }) => jsxRuntimeExports.jsx("button", { type: "button", className: "zIndexButton", onClick: () => e12(null), title: `${g("labels.sendToBack")}  ${uo ? cg$1("CtrlOrCmd+Alt+[") : cg$1("CtrlOrCmd+Shift+[")}`, children: lh }) }), fp = L2({ name: "bringToFront", label: "labels.bringToFront", keywords: ["move up", "zindex", "layer"], icon: ch, trackEvent: { category: "element" }, perform: (e12, o3) => ({ elements: ay(e12, o3), appState: o3, captureUpdate: dr.IMMEDIATELY }), keyTest: (e12) => uo ? e12[Q.CTRL_OR_CMD] && e12.altKey && e12.code === D1.BRACKET_RIGHT : e12[Q.CTRL_OR_CMD] && e12.shiftKey && e12.code === D1.BRACKET_RIGHT, PanelComponent: ({ updateData: e12, appState: o3 }) => jsxRuntimeExports.jsx("button", { type: "button", className: "zIndexButton", onClick: (t3) => e12(null), title: `${g("labels.bringToFront")}  ${uo ? cg$1("CtrlOrCmd+Alt+]") : cg$1("CtrlOrCmd+Shift+]")}`, children: ch }) });
var bp = L2({ name: "selectAll", label: "labels.selectAll", icon: C4, trackEvent: { category: "canvas" }, viewMode: false, perform: (e12, o3, t3, r3) => {
  if (o3.editingLinearElement) return false;
  let n3 = e12.filter((i3) => !i3.isDeleted && !(k$2(i3) && i3.containerId) && !i3.locked).reduce((i3, a3) => (i3[a3.id] = true, i3), {});
  return { appState: { ...o3, ...aF({ editingGroupId: null, selectedElementIds: n3 }, Es(e12), o3, r3), selectedLinearElement: Object.keys(n3).length === 1 && ae(e12[0]) ? new z$1(e12[0]) : null }, captureUpdate: dr.IMMEDIATELY };
}, keyTest: (e12) => e12[Q.CTRL_OR_CMD] && e12.key === Q.A });
var lC = (e12) => {
  let o3 = e12.slice(), t3 = /* @__PURE__ */ new Set(), r3 = (i3) => {
    let a3 = i3[0]?.groupIds?.join(""), l3 = [i3[0]], s3 = [];
    for (let c3 of i3.slice(1)) c3.groupIds?.join("") === a3 ? l3.push(c3) : s3.push(c3);
    return s3.length ? [...l3, ...r3(s3)] : l3;
  }, n3 = /* @__PURE__ */ new Map();
  return o3.forEach((i3, a3) => {
    if (!n3.has(i3.id)) if (i3.groupIds?.length) {
      let l3 = i3.groupIds[i3.groupIds.length - 1], s3 = o3.slice(a3).filter((c3) => {
        let m3 = c3?.groupIds?.some((d3) => d3 === l3);
        return m3 && n3.set(c3.id, true), m3;
      });
      for (let c3 of r3(s3)) t3.add(c3);
    } else t3.add(i3);
  }), t3.size !== e12.length ? (console.error("normalizeGroupElementOrder: lost some elements... bailing!"), e12) : [...t3];
}, sC = (e12) => {
  let o3 = gg$1(e12), t3 = e12.slice(), r3 = /* @__PURE__ */ new Set();
  return t3.forEach((n3, i3) => {
    n3 && (n3.boundElements?.length ? (r3.add(n3), t3[i3] = null, n3.boundElements.forEach((a3) => {
      let l3 = o3.get(a3.id);
      l3 && a3.type === "text" && (r3.add(l3[0]), t3[l3[1]] = null);
    })) : n3.type === "text" && n3.containerId && o3.get(n3.containerId)?.[0].boundElements?.find((l3) => l3.id === n3.id) || (r3.add(n3), t3[i3] = null));
  }), r3.size !== e12.length ? (console.error("normalizeBoundElementsOrder: lost some elements... bailing!"), e12) : [...r3];
}, ly = (e12) => sC(lC(e12));
var xp = L2({ name: "duplicateSelection", label: "labels.duplicateSelection", icon: Lx, trackEvent: { category: "element" }, perform: (e12, o3, t3, r3) => {
  if (o3.editingLinearElement) try {
    let i3 = z$1.duplicateSelectedPoints(o3, r3.scene.getNonDeletedElementsMap());
    return { elements: e12, appState: i3, captureUpdate: dr.IMMEDIATELY };
  } catch {
    return false;
  }
  let n3 = cC(e12, o3);
  if (r3.props.onDuplicate && n3.elements) {
    let i3 = r3.props.onDuplicate(n3.elements, e12);
    i3 && (n3.elements = i3);
  }
  return { ...n3, captureUpdate: dr.IMMEDIATELY };
}, keyTest: (e12) => e12[Q.CTRL_OR_CMD] && e12.key === Q.D, PanelComponent: ({ elements: e12, appState: o3, updateData: t3 }) => jsxRuntimeExports.jsx(X, { type: "button", icon: Lx, title: `${g("labels.duplicateSelection")}  ${cg$1("CtrlOrCmd+D")}`, "aria-label": g("labels.duplicateSelection"), onClick: () => t3(null), visible: Ib(Es(e12), o3) }) }), cC = (e12, o3) => {
  let t3 = /* @__PURE__ */ new Map(), r3 = [], n3 = [], i3 = /* @__PURE__ */ new Map(), a3 = /* @__PURE__ */ new Map(), l3 = te(e12), s3 = (f3) => {
    let x3 = $g$1(f3).reduce((T3, E3) => {
      if (m3.has(E3.id)) return T3;
      m3.set(E3.id, true);
      let w3 = zb(o3.editingGroupId, t3, E3, { x: E3.x + xo / 2, y: E3.y + xo / 2 });
      return m3.set(w3.id, true), a3.set(w3.id, w3), i3.set(E3.id, w3.id), n3.push(E3), r3.push(w3), T3.push(w3), T3;
    }, []);
    return Array.isArray(f3) ? x3 : x3[0] || null;
  };
  e12 = ly(e12);
  let c3 = te(at$1(e12, o3, { includeBoundTextElement: true, includeElementsInFrames: true })), m3 = /* @__PURE__ */ new Map(), d3 = e12.slice(), p3 = (f3, b3) => {
    Ae(f3 !== -1, "targetIndex === -1 "), !(!Array.isArray(b3) && !b3) && d3.splice(f3 + 1, 0, ...$g$1(b3));
  }, u3 = new Set(e12.filter((f3) => c3.has(f3.id) && de(f3)).map((f3) => f3.id));
  for (let f3 of e12) {
    if (m3.has(f3.id) || !c3.has(f3.id)) continue;
    let b3 = Mb(o3, f3);
    if (b3) {
      let x3 = an(e12, b3).flatMap((E3) => de(E3) ? [...co(e12, E3.id), E3] : [E3]), T3 = pg(d3, (E3) => E3.groupIds?.includes(b3));
      p3(T3, s3(x3));
      continue;
    }
    if (!(f3.frameId && u3.has(f3.frameId))) {
      if (de(f3)) {
        let x3 = f3.id, T3 = co(e12, x3), E3 = pg(d3, (w3) => w3.frameId === x3 || w3.id === x3);
        p3(E3, s3([...T3, f3]));
        continue;
      }
      if (bn(f3)) {
        let x3 = oe(f3, l3), T3 = pg(d3, (E3) => E3.id === f3.id || "containerId" in E3 && E3.containerId === f3.id);
        x3 ? p3(T3, s3([f3, x3])) : p3(T3, s3(f3));
        continue;
      }
      if (Ne(f3)) {
        let x3 = qe(f3, l3), T3 = pg(d3, (E3) => E3.id === f3.id || E3.id === x3?.id);
        x3 ? p3(T3, s3([x3, f3])) : p3(T3, s3(f3));
        continue;
      }
      p3(pg(d3, (x3) => x3.id === f3.id), s3(f3));
    }
  }
  dB(d3, n3, i3), AN(d3, n3, i3), uH(d3, n3, i3);
  let h3 = f9(r3);
  return { elements: d3, appState: { ...o3, ...aF({ editingGroupId: o3.editingGroupId, selectedElementIds: h3.reduce((f3, b3) => (Ne(b3) || (f3[b3.id] = true), f3), {}) }, Es(d3), o3, null) } };
};
var mC = /* @__PURE__ */ new Set(["command_palette", "export"]), le = (e12, o3, t3, r3) => {
  try {
    if (typeof window > "u" || c$1.VITE_WORKER_ID || c$1.VITE_APP_ENABLE_TRACKING !== "true" || !mC.has(e12) || c$1.DEV) return;
    c$1.PROD || console.info("trackEvent", { category: e12, action: o3, label: t3, value: r3 }), window.sa_event && window.sa_event(o3, { category: e12, label: t3, value: r3 });
  } catch (n3) {
    console.error("error during analytics", n3);
  }
};
var Js = reactExports.forwardRef((e12, o3) => {
  let { title: t3, className: r3, testId: n3, active: i3, standalone: a3, icon: l3, onClick: s3 } = e12;
  return jsxRuntimeExports.jsx("button", { type: "button", ref: o3, title: t3, "data-testid": n3, className: dM(r3, { standalone: a3, active: i3 }), onClick: s3, children: l3 }, t3);
});
var eo = (e12) => jsxRuntimeExports.jsx("div", { className: "buttonList", children: e12.options.map((o3) => e12.type === "button" ? jsxRuntimeExports.jsx(Js, { icon: o3.icon, title: o3.text, testId: o3.testId, active: o3.active ?? e12.value === o3.value, onClick: (t3) => e12.onClick(o3.value, t3) }, o3.text) : jsxRuntimeExports.jsxs("label", { className: dM({ active: e12.value === o3.value }), title: o3.text, children: [jsxRuntimeExports.jsx("input", { type: "radio", name: e12.group, onChange: () => e12.onChange(o3.value), checked: e12.value === o3.value, "data-testid": o3.testId }), o3.icon] }, o3.text)) });
var sy = ({ onChange: e12, type: o3, activeColor: t3, topPicks: r3 }) => {
  let n3;
  return o3 === "elementStroke" && (n3 = W9), o3 === "elementBackground" && (n3 = z9), o3 === "canvasBackground" && (n3 = Q9), r3 && (n3 = r3), n3 ? jsxRuntimeExports.jsx("div", { className: "color-picker__top-picks", children: n3.map((i3) => jsxRuntimeExports.jsx("button", { className: dM("color-picker__button", { active: i3 === t3, "is-transparent": i3 === "transparent" || !i3 }), style: { "--swatch-color": i3 }, type: "button", title: i3, onClick: () => e12(i3), "data-testid": `color-top-pick-${i3}`, children: jsxRuntimeExports.jsx("div", { className: "color-picker__button-outline" }) }, i3)) }) : (console.error("Invalid type for TopPicks"), null);
};
var qs = () => jsxRuntimeExports.jsx("div", { style: { width: 1, height: "1rem", backgroundColor: "var(--default-border-color)", margin: "0 auto" } });
var Cr = ({ palette: e12, color: o3 }) => {
  for (let [t3, r3] of Object.entries(e12)) if (Array.isArray(r3)) {
    let n3 = r3.indexOf(o3);
    if (n3 > -1) return { colorName: t3, shade: n3 };
  } else if (r3 === o3) return { colorName: t3, shade: null };
  return null;
}, Ma = [["q", "w", "e", "r", "t"], ["a", "s", "d", "f", "g"], ["z", "x", "c", "v", "b"]].flat(), vp = ({ color: e12, palette: o3 }) => !Object.values(o3).flat().includes(e12), dy = (e12, o3, t3) => {
  let r3 = { elementBackground: "backgroundColor", elementStroke: "strokeColor" }, n3 = e12.filter((a3) => {
    if (a3.isDeleted) return false;
    let l3 = a3[r3[o3]];
    return vp({ color: l3, palette: t3 });
  }), i3 = /* @__PURE__ */ new Map();
  return n3.forEach((a3) => {
    let l3 = a3[r3[o3]];
    i3.has(l3) ? i3.set(l3, i3.get(l3) + 1) : i3.set(l3, 1);
  }), [...i3.entries()].sort((a3, l3) => l3[1] - a3[1]).map((a3) => a3[0]).slice(0, k9);
}, to = atom(null), cy = (e12, o3, t3) => (e12 * 299 + o3 * 587 + t3 * 114) / 1e3 >= 160 ? "black" : "white", my = (e12, o3) => {
  if (o3) {
    let i3 = new Option().style;
    if (i3.color = e12, i3.color) {
      let a3 = i3.color.replace(/^(rgb|rgba)\(/, "").replace(/\)$/, "").replace(/\s/g, "").split(","), l3 = parseInt(a3[0]), s3 = parseInt(a3[1]), c3 = parseInt(a3[2]);
      return cy(l3, s3, c3);
    }
  }
  if (e12 === "transparent") return "black";
  let t3 = parseInt(e12.substring(1, 3), 16), r3 = parseInt(e12.substring(3, 5), 16), n3 = parseInt(e12.substring(5, 7), 16);
  return cy(t3, r3, n3);
};
var EC = ({ color: e12, keyLabel: o3, isCustomColor: t3 = false, isShade: r3 = false }) => jsxRuntimeExports.jsxs("div", { className: "color-picker__button__hotkey-label", style: { color: my(e12, t3) }, children: [r3 && "", o3] }), Ei = EC;
var uy = ({ hex: e12, onChange: o3, palette: t3 }) => {
  let r3 = Cr({ color: e12 || "transparent", palette: t3 }), [n3, i3] = ce(to), a3 = reactExports.useRef(null);
  if (reactExports.useEffect(() => {
    a3.current && n3 === "shades" && a3.current.focus();
  }, [r3, n3]), r3) {
    let { colorName: l3, shade: s3 } = r3, c3 = t3[l3];
    if (Array.isArray(c3)) return jsxRuntimeExports.jsx("div", { className: "color-picker-content--default shades", children: c3.map((m3, d3) => jsxRuntimeExports.jsxs("button", { ref: d3 === s3 && n3 === "shades" ? a3 : void 0, tabIndex: -1, type: "button", className: dM("color-picker__button color-picker__button--large", { active: d3 === s3 }), "aria-label": "Shade", title: `${l3} - ${d3 + 1}`, style: m3 ? { "--swatch-color": m3 } : void 0, onClick: () => {
      o3(m3), i3("shades");
    }, children: [jsxRuntimeExports.jsx("div", { className: "color-picker__button-outline" }), jsxRuntimeExports.jsx(Ei, { color: m3, keyLabel: d3 + 1, isShade: true })] }, d3)) });
  }
  return jsxRuntimeExports.jsxs("div", { className: "color-picker-content--default", style: { position: "relative" }, tabIndex: -1, children: [jsxRuntimeExports.jsx("button", { type: "button", tabIndex: -1, className: "color-picker__button color-picker__button--large color-picker__button--no-focus-visible" }), jsxRuntimeExports.jsx("div", { tabIndex: -1, style: { position: "absolute", top: 0, left: 0, right: 0, bottom: 0, display: "flex", alignItems: "center", justifyContent: "center", textAlign: "center", fontSize: "0.75rem" }, children: g("colorPicker.noShades") })] });
};
var kC = ({ palette: e12, color: o3, onChange: t3, label: r3, activeShade: n3 }) => {
  let i3 = Cr({ color: o3 || "transparent", palette: e12 }), [a3, l3] = ce(to), s3 = reactExports.useRef(null);
  return reactExports.useEffect(() => {
    s3.current && a3 === "baseColors" && s3.current.focus();
  }, [i3?.colorName, a3]), jsxRuntimeExports.jsx("div", { className: "color-picker-content--default", children: Object.entries(e12).map(([c3, m3], d3) => {
    let p3 = (Array.isArray(m3) ? m3[n3] : m3) || "transparent", u3 = Ma[d3], h3 = g(`colors.${c3.replace(/\d+/, "")}`, null, "");
    return jsxRuntimeExports.jsxs("button", { ref: i3?.colorName === c3 ? s3 : void 0, tabIndex: -1, type: "button", className: dM("color-picker__button color-picker__button--large", { active: i3?.colorName === c3, "is-transparent": p3 === "transparent" || !p3 }), onClick: () => {
      t3(p3), l3("baseColors");
    }, title: `${h3}${p3.startsWith("#") ? ` ${p3}` : ""}  ${u3}`, "aria-label": `${h3}  ${u3}`, style: { "--swatch-color": p3 }, "data-testid": `color-${c3}`, children: [jsxRuntimeExports.jsx("div", { className: "color-picker__button-outline" }), jsxRuntimeExports.jsx(Ei, { color: p3, keyLabel: u3 })] }, c3);
  }) });
}, gy = kC;
var hy = ({ colors: e12, color: o3, onChange: t3, label: r3 }) => {
  let [n3, i3] = ce(to), a3 = reactExports.useRef(null);
  return reactExports.useEffect(() => {
    a3.current && a3.current.focus();
  }, [o3, n3]), jsxRuntimeExports.jsx("div", { className: "color-picker-content--default", children: e12.map((l3, s3) => jsxRuntimeExports.jsxs("button", { ref: o3 === l3 ? a3 : void 0, tabIndex: -1, type: "button", className: dM("color-picker__button color-picker__button--large", { active: o3 === l3, "is-transparent": l3 === "transparent" || !l3 }), onClick: () => {
    t3(l3), i3("custom");
  }, title: l3, "aria-label": r3, style: { "--swatch-color": l3 }, children: [jsxRuntimeExports.jsx("div", { className: "color-picker__button-outline" }), jsxRuntimeExports.jsx(Ei, { color: l3, keyLabel: s3 + 1, isCustomColor: true })] }, s3)) });
};
var Cp = (e12, o3, t3) => {
  let r3 = Math.ceil(t3 / Z9);
  switch (o3 = o3 ?? -1, e12) {
    case "ArrowLeft": {
      let n3 = o3 - 1;
      return n3 < 0 ? t3 - 1 : n3;
    }
    case "ArrowRight":
      return (o3 + 1) % t3;
    case "ArrowDown": {
      let n3 = o3 + Z9;
      return n3 >= t3 ? o3 % Z9 : n3;
    }
    case "ArrowUp": {
      let n3 = o3 - Z9, i3 = n3 < 0 ? Z9 * r3 + n3 : n3;
      return i3 >= t3 ? void 0 : i3;
    }
  }
}, PC = ({ e: e12, colorObj: o3, onChange: t3, palette: r3, customColors: n3, setActiveColorPickerSection: i3, activeShade: a3 }) => {
  if (o3?.shade != null && ["Digit1", "Digit2", "Digit3", "Digit4", "Digit5"].includes(e12.code) && e12.shiftKey) {
    let l3 = Number(e12.code.slice(-1)) - 1;
    return t3(r3[o3.colorName][l3]), i3("shades"), true;
  }
  if (["1", "2", "3", "4", "5"].includes(e12.key) && n3[Number(e12.key) - 1]) return t3(n3[Number(e12.key) - 1]), i3("custom"), true;
  if (Ma.includes(e12.key)) {
    let l3 = Ma.indexOf(e12.key), s3 = Object.keys(r3)[l3], c3 = r3[s3], m3 = Array.isArray(c3) ? c3[a3] : c3;
    return t3(m3), i3("baseColors"), true;
  }
  return false;
}, fy = ({ event: e12, activeColorPickerSection: o3, palette: t3, color: r3, onChange: n3, customColors: i3, setActiveColorPickerSection: a3, updateData: l3, activeShade: s3, onEyeDropperToggle: c3, onEscape: m3 }) => {
  if (e12[Q.CTRL_OR_CMD]) return false;
  if (e12.key === Q.ESCAPE) return m3(e12), true;
  if (e12.key === Q.ALT) return c3(true), true;
  if (e12.key === Q.I) return c3(), true;
  let d3 = Cr({ color: r3, palette: t3 });
  if (e12.key === Q.TAB) {
    let p3 = { custom: !!i3.length, baseColors: true, shades: d3?.shade != null, hex: true }, u3 = Object.entries(p3).reduce((T3, [E3, w3]) => (w3 && T3.push(E3), T3), []), h3 = u3.indexOf(o3), f3 = e12.shiftKey ? -1 : 1, b3 = h3 + f3 > u3.length - 1 ? 0 : h3 + f3 < 0 ? u3.length - 1 : h3 + f3, x3 = u3[b3];
    return x3 && a3(x3), x3 === "custom" ? n3(i3[0]) : x3 === "baseColors" && (Object.entries(t3).find(([E3, w3]) => Array.isArray(w3) ? w3.includes(r3) : w3 === r3 ? E3 : null) || n3(Z.black)), e12.preventDefault(), e12.stopPropagation(), true;
  }
  if (PC({ e: e12, colorObj: d3, onChange: n3, palette: t3, customColors: i3, setActiveColorPickerSection: a3, activeShade: s3 })) return true;
  if (o3 === "shades" && d3) {
    let { shade: p3 } = d3, u3 = Cp(e12.key, p3, Z9);
    if (u3 !== void 0) return n3(t3[d3.colorName][u3]), true;
  }
  if (o3 === "baseColors" && d3) {
    let { colorName: p3 } = d3, u3 = Object.keys(t3), h3 = u3.indexOf(p3), f3 = Cp(e12.key, h3, u3.length);
    if (f3 !== void 0) {
      let b3 = u3[f3], x3 = t3[b3];
      return n3(Array.isArray(x3) ? x3[s3] : x3), true;
    }
  }
  if (o3 === "custom") {
    let p3 = i3.indexOf(r3), u3 = Cp(e12.key, p3, i3.length);
    if (u3 !== void 0) {
      let h3 = i3[u3];
      return n3(h3), true;
    }
  }
  return false;
};
var RC = ({ children: e12 }) => jsxRuntimeExports.jsx("div", { className: "color-picker__heading", children: e12 }), yi = RC;
var Ey = ({ color: e12, onChange: o3, label: t3, type: r3, elements: n3, palette: i3, updateData: a3, children: l3, onEyeDropperToggle: s3, onEscape: c3 }) => {
  let [m3] = React.useState(() => r3 === "canvasBackground" ? [] : dy(n3, r3, i3)), [d3, p3] = ce(to), u3 = Cr({ color: e12, palette: i3 });
  reactExports.useEffect(() => {
    if (!d3) {
      let x3 = vp({ color: e12, palette: i3 }), T3 = x3 && !m3.includes(e12);
      p3(T3 ? "hex" : x3 ? "custom" : u3?.shade != null ? "shades" : "baseColors");
    }
  }, [d3, e12, i3, p3, u3, m3]);
  let [h3, f3] = reactExports.useState(u3?.shade ?? (r3 === "elementBackground" ? po : fo));
  reactExports.useEffect(() => {
    u3?.shade != null && f3(u3.shade);
    let x3 = (T3) => {
      T3.key === Q.ALT && s3(false);
    };
    return document.addEventListener("keyup", x3, { capture: true }), () => {
      document.removeEventListener("keyup", x3, { capture: true });
    };
  }, [u3, s3]);
  let b3 = React.useRef(null);
  return jsxRuntimeExports.jsx("div", { role: "dialog", "aria-modal": "true", "aria-label": g("labels.colorPicker"), children: jsxRuntimeExports.jsxs("div", { ref: b3, onKeyDown: (x3) => {
    fy({ event: x3, activeColorPickerSection: d3, palette: i3, color: e12, onChange: o3, onEyeDropperToggle: s3, customColors: m3, setActiveColorPickerSection: p3, updateData: a3, activeShade: h3, onEscape: c3 }) && (x3.preventDefault(), x3.stopPropagation());
  }, className: "color-picker-content properties-content", tabIndex: -1, children: [!!m3.length && jsxRuntimeExports.jsxs("div", { children: [jsxRuntimeExports.jsx(yi, { children: g("colorPicker.mostUsedCustomColors") }), jsxRuntimeExports.jsx(hy, { colors: m3, color: e12, label: g("colorPicker.mostUsedCustomColors"), onChange: o3 })] }), jsxRuntimeExports.jsxs("div", { children: [jsxRuntimeExports.jsx(yi, { children: g("colorPicker.colors") }), jsxRuntimeExports.jsx(gy, { color: e12, label: t3, palette: i3, onChange: o3, activeShade: h3 })] }), jsxRuntimeExports.jsxs("div", { children: [jsxRuntimeExports.jsx(yi, { children: g("colorPicker.shades") }), jsxRuntimeExports.jsx(uy, { hex: e12, onChange: o3, palette: i3 })] }), l3] }) });
};
var Ip = React.createContext(null), ve = () => React.useContext(Ip);
var ec = (e12) => {
  let [o3, t3] = reactExports.useState(null), r3 = me(), { theme: n3 } = ve(), { container: i3 } = Ke();
  return reactExports.useLayoutEffect(() => {
    o3 && (o3.className = "", o3.classList.add("excalidraw", ...e12?.className?.split(/\s+/) || []), o3.classList.toggle("excalidraw--mobile", r3.editor.isMobile), o3.classList.toggle("theme--dark", n3 === ke.DARK));
  }, [o3, n3, r3.editor.isMobile, e12?.className]), reactExports.useLayoutEffect(() => {
    let a3 = e12?.parentSelector ? i3?.querySelector(e12.parentSelector) : document.body;
    if (!a3) return;
    let l3 = document.createElement("div");
    return a3.appendChild(l3), t3(l3), () => {
      a3.removeChild(l3);
    };
  }, [i3, e12?.parentSelector]), o3;
};
function vi(e12, o3, t3) {
  reactExports.useEffect(() => {
    function r3(n3) {
      let i3 = n3;
      if (!e12.current) return;
      let a3 = t3?.(i3, e12.current);
      if (a3 === true) return;
      if (a3 === false) return o3(i3);
      e12.current.contains(i3.target) || !document.documentElement.contains(i3.target) || i3.target.closest("[data-radix-portal]") || i3.target === document.documentElement && document.body.style.pointerEvents === "none" || i3.target.closest("[data-prevent-outside-click]") || o3(i3);
    }
    return document.addEventListener("pointerdown", r3), document.addEventListener("touchstart", r3), () => {
      document.removeEventListener("pointerdown", r3), document.removeEventListener("touchstart", r3);
    };
  }, [e12, o3, t3]);
}
var Ir = (e12) => {
  let o3 = reactExports.useRef(e12);
  return Object.assign(o3.current, e12), o3.current;
};
var Sr = atom(null), wy = ({ onCancel: e12, onChange: o3, onSelect: t3, colorPickerType: r3 }) => {
  let n3 = ec({ className: "excalidraw-eye-dropper-backdrop", parentSelector: ".excalidraw-eye-dropper-container" }), i3 = ve(), a3 = kr(), l3 = He(), s3 = at$1(a3, i3), c3 = Ir({ app: l3, onCancel: e12, onChange: o3, onSelect: t3, selectedElements: s3 }), { container: m3 } = Ke();
  reactExports.useEffect(() => {
    let p3 = d3.current;
    if (!p3 || !l3.canvas || !n3) return;
    let u3 = false, h3 = l3.canvas.getContext("2d"), f3 = ({ clientX: I3, clientY: _3 }) => {
      let k2 = h3.getImageData((I3 - i3.offsetLeft) * window.devicePixelRatio, (_3 - i3.offsetTop) * window.devicePixelRatio, 1, 1).data;
      return tE(k2[0], k2[1], k2[2]);
    }, b3 = ({ clientX: I3, clientY: _3, altKey: k2 }) => {
      p3.style.top = `${_3 + 20}px`, p3.style.left = `${I3 + 20}px`;
      let R3 = f3({ clientX: I3, clientY: _3 });
      u3 && c3.onChange(r3, R3, c3.selectedElements, { altKey: k2 }), p3.style.background = R3;
    }, x3 = () => {
      c3.onCancel();
    }, T3 = (I3, _3) => {
      c3.onSelect(I3, _3);
    }, E3 = (I3) => {
      u3 = true, I3.stopImmediatePropagation();
    }, w3 = (I3) => {
      u3 = false, m3?.focus(), I3.stopImmediatePropagation(), I3.preventDefault(), T3(f3(I3), I3);
    }, S3 = (I3) => {
      I3.key === Q.ESCAPE && (I3.preventDefault(), I3.stopImmediatePropagation(), x3());
    };
    return n3.tabIndex = -1, n3.focus(), b3({ clientX: c3.app.lastViewportPosition.x, clientY: c3.app.lastViewportPosition.y, altKey: false }), n3.addEventListener("keydown", S3), n3.addEventListener("pointerdown", E3), n3.addEventListener("pointerup", w3), window.addEventListener("pointermove", b3, { passive: true }), window.addEventListener("blur", x3), () => {
      u3 = false, n3.removeEventListener("keydown", S3), n3.removeEventListener("pointerdown", E3), n3.removeEventListener("pointerup", w3), window.removeEventListener("pointermove", b3), window.removeEventListener("blur", x3);
    };
  }, [c3, l3.canvas, n3, r3, m3, i3.offsetLeft, i3.offsetTop]);
  let d3 = reactExports.useRef(null);
  return vi(d3, () => {
    e12();
  }, (p3) => !!p3.target.closest(".excalidraw-eye-dropper-trigger, .excalidraw-eye-dropper-backdrop")), n3 ? reactDomExports.createPortal(jsxRuntimeExports.jsx("div", { ref: d3, className: "excalidraw-eye-dropper-preview" }), n3) : null;
};
var Iy = ({ color: e12, onChange: o3, label: t3, colorPickerType: r3 }) => {
  let n3 = me(), [i3, a3] = reactExports.useState(e12), [l3, s3] = ce(to);
  reactExports.useEffect(() => {
    a3(e12);
  }, [e12]);
  let c3 = reactExports.useCallback((h3) => {
    let f3 = h3.toLowerCase(), b3 = Sy(f3);
    b3 && o3(b3), a3(f3);
  }, [o3]), m3 = reactExports.useRef(null), d3 = reactExports.useRef(null);
  reactExports.useEffect(() => {
    m3.current && m3.current.focus();
  }, [l3]);
  let [p3, u3] = ce(Sr);
  return reactExports.useEffect(() => () => {
    u3(null);
  }, [u3]), jsxRuntimeExports.jsxs("div", { className: "color-picker__input-label", children: [jsxRuntimeExports.jsx("div", { className: "color-picker__input-hash", children: "#" }), jsxRuntimeExports.jsx("input", { ref: l3 === "hex" ? m3 : void 0, style: { border: 0, padding: 0 }, spellCheck: false, className: "color-picker-input", "aria-label": t3, onChange: (h3) => {
    c3(h3.target.value);
  }, value: (i3 || "").replace(/^#/, ""), onBlur: () => {
    a3(e12);
  }, tabIndex: -1, onFocus: () => s3("hex"), onKeyDown: (h3) => {
    h3.key !== Q.TAB && (h3.key === Q.ESCAPE && d3.current?.focus(), h3.stopPropagation());
  } }), !n3.editor.isMobile && jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [jsxRuntimeExports.jsx("div", { style: { width: "1px", height: "1.25rem", backgroundColor: "var(--default-border-color)" } }), jsxRuntimeExports.jsx("div", { ref: d3, className: dM("excalidraw-eye-dropper-trigger", { selected: p3 }), onClick: () => u3((h3) => h3 ? null : { keepOpenOnAlt: false, onSelect: (f3) => o3(f3), colorPickerType: r3 }), title: `${g("labels.eyeDropper")}  ${Q.I.toLocaleUpperCase()} or ${cg$1("Alt")} `, children: R4 })] })] });
};
var Qe2 = React.forwardRef(({ children: e12, padding: o3, className: t3, style: r3 }, n3) => jsxRuntimeExports.jsx("div", { className: dM("Island", t3), style: { "--padding": o3, ...r3 }, ref: n3, children: e12 }));
var oc = React.forwardRef(({ className: e12, container: o3, children: t3, style: r3, onClose: n3, onKeyDown: i3, onFocusOutside: a3, onPointerLeave: l3, onPointerDownOutside: s3 }, c3) => {
  let m3 = me();
  return jsxRuntimeExports.jsx(Portal, { container: o3, children: jsxRuntimeExports.jsxs(Content2, { ref: c3, className: dM("focus-visible-none", e12), "data-prevent-outside-click": true, side: m3.editor.isMobile && !m3.viewport.isLandscape ? "bottom" : "right", align: m3.editor.isMobile && !m3.viewport.isLandscape ? "center" : "start", alignOffset: -16, sideOffset: 20, style: { zIndex: "var(--zIndex-popup)" }, onPointerLeave: l3, onKeyDown: i3, onFocusOutside: a3, onPointerDownOutside: s3, onCloseAutoFocus: (d3) => {
    d3.stopPropagation(), d3.preventDefault(), o3 && !ig$1(document.activeElement) && o3.focus(), n3();
  }, children: [jsxRuntimeExports.jsx(Qe2, { padding: 3, style: r3, children: t3 }), jsxRuntimeExports.jsx(Arrow2, { width: 20, height: 10, style: { fill: "var(--popup-bg-color)", filter: "drop-shadow(rgba(0, 0, 0, 0.05) 0px 3px 2px)" } })] }) });
});
var ky = (e12) => {
  let o3 = new Option().style;
  return o3.color = e12, !!o3.color;
}, Sy = (e12) => Wt(e12) ? e12 : ky(`#${e12}`) ? `#${e12}` : ky(e12) ? e12 : null, o2 = ({ type: e12, color: o3, onChange: t3, label: r3, elements: n3, palette: i3 = Z, updateData: a3 }) => {
  let { container: l3 } = Ke(), [, s3] = ce(to), [c3, m3] = ce(Sr), d3 = jsxRuntimeExports.jsxs("div", { children: [jsxRuntimeExports.jsx(yi, { children: g("colorPicker.hexCode") }), jsxRuntimeExports.jsx(Iy, { color: o3, label: r3, onChange: (h3) => {
    t3(h3);
  }, colorPickerType: e12 })] }), p3 = reactExports.useRef(null), u3 = () => {
    p3.current?.querySelector(".color-picker-content")?.focus();
  };
  return jsxRuntimeExports.jsx(oc, { container: l3, style: { maxWidth: "13rem" }, onFocusOutside: (h3) => {
    u3(), h3.preventDefault();
  }, onPointerDownOutside: (h3) => {
    c3 && h3.preventDefault();
  }, onClose: () => {
    a3({ openPopup: null }), s3(null);
  }, children: i3 ? jsxRuntimeExports.jsx(Ey, { palette: i3, color: o3, onChange: (h3) => {
    t3(h3);
  }, onEyeDropperToggle: (h3) => {
    m3((f3) => h3 ? (f3 = f3 || { keepOpenOnAlt: true, onSelect: t3, colorPickerType: e12 }, f3.keepOpenOnAlt = true, f3) : h3 === false || f3 ? null : { keepOpenOnAlt: false, onSelect: t3, colorPickerType: e12 });
  }, onEscape: (h3) => {
    c3 ? m3(null) : a3({ openPopup: null });
  }, label: r3, type: e12, elements: n3, updateData: a3, children: d3 }) : d3 });
}, r2 = ({ label: e12, color: o3, type: t3 }) => jsxRuntimeExports.jsx(Trigger, { type: "button", className: dM("color-picker__button active-color properties-trigger", { "is-transparent": o3 === "transparent" || !o3 }), "aria-label": e12, style: o3 ? { "--swatch-color": o3 } : void 0, title: t3 === "elementStroke" ? g("labels.showStroke") : g("labels.showBackground"), children: jsxRuntimeExports.jsx("div", { className: "color-picker__button-outline" }) }), Pa = ({ type: e12, color: o3, onChange: t3, label: r3, elements: n3, palette: i3 = Z, topPicks: a3, updateData: l3, appState: s3 }) => jsxRuntimeExports.jsx("div", { children: jsxRuntimeExports.jsxs("div", { role: "dialog", "aria-modal": "true", className: "color-picker-container", children: [jsxRuntimeExports.jsx(sy, { activeColor: o3, onChange: t3, type: e12, topPicks: a3 }), jsxRuntimeExports.jsx(qs, {}), jsxRuntimeExports.jsxs(Root2, { open: s3.openPopup === e12, onOpenChange: (c3) => {
  l3({ openPopup: c3 ? e12 : null });
}, children: [jsxRuntimeExports.jsx(r2, { color: o3, label: r3, type: e12 }), s3.openPopup === e12 && jsxRuntimeExports.jsx(o2, { type: e12, color: o3, onChange: t3, label: r3, elements: n3, palette: i3, updateData: l3 })] })] }) });
var Lr = ({ icon: e12 }) => jsxRuntimeExports.jsx("span", { style: { width: "1em", margin: "0 0.5ex 0 0.5ex", display: "inline-block", lineHeight: 0, verticalAlign: "middle" }, children: e12 });
var i2 = ({ label: e12, open: o3, openTrigger: t3, children: r3, className: n3 }) => jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [jsxRuntimeExports.jsxs("div", { style: { cursor: "pointer", display: "flex", justifyContent: "space-between", alignItems: "center" }, className: n3, onClick: t3, children: [e12, jsxRuntimeExports.jsx(Lr, { icon: o3 ? dy$1 : sy$1 })] }), o3 && jsxRuntimeExports.jsx("div", { style: { display: "flex", flexDirection: "column" }, children: r3 })] }), Ra = i2;
var c2 = atom(false);
function d2({ options: e12, value: o3, label: t3, onChange: r3, onClose: n3, numberOfOptionsToAlwaysShow: i3 = e12.length }) {
  let a3 = me(), l3 = (u3) => {
    let h3 = e12.find((f3) => f3.keyBinding === u3.key.toLowerCase());
    if (!(u3.metaKey || u3.altKey || u3.ctrlKey) && h3) r3(h3.value), u3.preventDefault();
    else if (u3.key === Q.TAB) {
      let f3 = e12.findIndex((x3) => x3.value === o3), b3 = u3.shiftKey ? (e12.length + f3 - 1) % e12.length : (f3 + 1) % e12.length;
      r3(e12[b3].value);
    } else if (C$(u3.key)) {
      let f3 = qo().rtl, b3 = e12.findIndex((x3) => x3.value === o3);
      if (b3 !== -1) {
        let x3 = e12.length, T3 = b3;
        switch (u3.key) {
          case (f3 ? Q.ARROW_LEFT : Q.ARROW_RIGHT):
            T3 = (b3 + 1) % x3;
            break;
          case (f3 ? Q.ARROW_RIGHT : Q.ARROW_LEFT):
            T3 = (x3 + b3 - 1) % x3;
            break;
          case Q.ARROW_DOWN: {
            T3 = (b3 + (i3 ?? 1)) % x3;
            break;
          }
          case Q.ARROW_UP: {
            T3 = (x3 + b3 - (i3 ?? 1)) % x3;
            break;
          }
        }
        r3(e12[T3].value);
      }
      u3.preventDefault();
    } else (u3.key === Q.ESCAPE || u3.key === Q.ENTER) && (u3.preventDefault(), n3());
    u3.nativeEvent.stopImmediatePropagation(), u3.stopPropagation();
  }, [s3, c3] = ce(c2), m3 = React.useMemo(() => e12.slice(0, i3), [e12, i3]), d3 = React.useMemo(() => e12.slice(i3), [e12, i3]);
  reactExports.useEffect(() => {
    m3.some((u3) => u3.value === o3) || c3(true);
  }, [o3, m3, c3]);
  let p3 = (u3) => jsxRuntimeExports.jsx("div", { className: "picker-content", children: u3.map((h3, f3) => jsxRuntimeExports.jsxs("button", { type: "button", className: dM("picker-option", { active: o3 === h3.value }), onClick: (b3) => {
    r3(h3.value);
  }, title: `${h3.text} ${h3.keyBinding && ` ${h3.keyBinding.toUpperCase()}`}`, "aria-label": h3.text || "none", "aria-keyshortcuts": h3.keyBinding || void 0, ref: (b3) => {
    o3 === h3.value && setTimeout(() => {
      b3?.focus();
    }, 0);
  }, children: [h3.icon, h3.keyBinding && jsxRuntimeExports.jsx("span", { className: "picker-keybinding", children: h3.keyBinding })] }, h3.text)) });
  return jsxRuntimeExports.jsx(Content2, { side: a3.editor.isMobile && !a3.viewport.isLandscape ? "top" : "bottom", align: "start", sideOffset: 12, style: { zIndex: "var(--zIndex-popup)" }, onKeyDown: l3, children: jsxRuntimeExports.jsxs("div", { className: "picker", role: "dialog", "aria-modal": "true", "aria-label": t3, children: [p3(m3), d3.length > 0 && jsxRuntimeExports.jsx(Ra, { label: g("labels.more_options"), open: s3, openTrigger: () => {
    c3((u3) => !u3);
  }, className: "picker-collapsible", children: p3(d3) })] }) });
}
function _p({ value: e12, label: o3, options: t3, onChange: r3, group: n3 = "", numberOfOptionsToAlwaysShow: i3 }) {
  let [a3, l3] = React.useState(false), s3 = React.useRef(null);
  return jsxRuntimeExports.jsx("div", { children: jsxRuntimeExports.jsxs(Root2, { open: a3, onOpenChange: (c3) => l3(c3), children: [jsxRuntimeExports.jsx(Trigger, { name: n3, type: "button", "aria-label": o3, onClick: () => l3(!a3), ref: s3, className: a3 ? "active" : "", children: t3.find((c3) => c3.value === e12)?.icon }), a3 && jsxRuntimeExports.jsx(d2, { options: t3, value: e12, label: o3, onChange: r3, onClose: () => {
    l3(false);
  }, numberOfOptionsToAlwaysShow: i3 })] }) });
}
var ic = React.forwardRef(({ className: e12, placeholder: o3, onChange: t3 }, r3) => jsxRuntimeExports.jsxs("div", { className: dM("QuickSearch__wrapper", e12), children: [A4, jsxRuntimeExports.jsx("input", { ref: r3, className: "QuickSearch__input", type: "text", placeholder: o3, onChange: (n3) => t3(n3.target.value.trim().toLowerCase()) })] }));
var ac = ({ className: e12, placeholder: o3, children: t3 }) => {
  let r3 = !reactExports.Children.count(t3);
  return jsxRuntimeExports.jsx("div", { className: dM("ScrollableList__wrapper", e12), role: "menu", children: r3 ? jsxRuntimeExports.jsx("div", { className: "empty", children: o3 }) : t3 });
};
var My = ({ children: e12, className: o3 = "", style: t3, title: r3 }) => jsxRuntimeExports.jsxs("div", { className: `dropdown-menu-group ${o3}`, style: t3, children: [r3 && jsxRuntimeExports.jsx("p", { className: "dropdown-menu-group-title", children: r3 }), e12] }), Na = My;
My.displayName = "DropdownMenuGroup";
var Mp = React.createContext({}), lc = (e12 = "", o3 = false, t3 = false) => `dropdown-menu-item dropdown-menu-item-base ${e12}
  ${o3 ? "dropdown-menu-item--selected" : ""} ${t3 ? "dropdown-menu-item--hovered" : ""}`.trim(), sc = (e12, o3) => {
  let t3 = reactExports.useContext(Mp);
  return Tg$1(e12, (r3) => {
    let n3 = new CustomEvent("menu.itemSelect", { bubbles: true, cancelable: true });
    o3?.(n3), n3.defaultPrevented || t3.onSelect?.(n3);
  });
};
var v2 = ({ textStyle: e12, icon: o3, shortcut: t3, children: r3 }) => {
  let n3 = me();
  return jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [o3 && jsxRuntimeExports.jsx("div", { className: "dropdown-menu-item__icon", children: o3 }), jsxRuntimeExports.jsx("div", { style: e12, className: "dropdown-menu-item__text", children: r3 }), t3 && !n3.editor.isMobile && jsxRuntimeExports.jsx("div", { className: "dropdown-menu-item__shortcut", children: t3 })] });
}, cc = v2;
var Rp = ({ icon: e12, value: o3, order: t3, children: r3, shortcut: n3, className: i3, hovered: a3, selected: l3, textStyle: s3, onSelect: c3, onClick: m3, ...d3 }) => {
  let p3 = sc(m3, c3), u3 = reactExports.useRef(null);
  return reactExports.useEffect(() => {
    a3 && (t3 === 0 ? u3.current?.scrollIntoView({ block: "end" }) : u3.current?.scrollIntoView({ block: "nearest" }));
  }, [a3, t3]), jsxRuntimeExports.jsx("button", { ...d3, ref: u3, value: o3, onClick: p3, className: lc(i3, l3, a3), title: d3.title ?? d3["aria-label"], children: jsxRuntimeExports.jsx(cc, { textStyle: s3, icon: e12, shortcut: n3, children: r3 }) });
};
Rp.displayName = "DropdownMenuItem";
var Ci = { GREEN: "green", RED: "red", BLUE: "blue" }, dc = ({ type: e12 = Ci.BLUE, children: o3 }) => {
  let { theme: t3 } = Mo(), r3 = { display: "inline-flex", marginLeft: "auto", padding: "2px 4px", borderRadius: 6, fontSize: 9, fontFamily: "Cascadia, monospace", border: t3 === ke.LIGHT ? "1.5px solid white" : "none" };
  switch (e12) {
    case Ci.GREEN:
      Object.assign(r3, { backgroundColor: "var(--background-color-badge)", color: "var(--color-badge)" });
      break;
    case Ci.RED:
      Object.assign(r3, { backgroundColor: "pink", color: "darkred" });
      break;
    case Ci.BLUE:
    default:
      Object.assign(r3, { background: "var(--color-promo)", color: "var(--color-surface-lowest)" });
  }
  return jsxRuntimeExports.jsx("div", { className: "DropDownMenuItemBadge", style: r3, children: o3 });
};
dc.displayName = "DropdownMenuItemBadge";
Rp.Badge = dc;
var vt = Rp;
var Dy = ({ event: e12, inputRef: o3, hoveredFont: t3, filteredFonts: r3, onClose: n3, onSelect: i3, onHover: a3 }) => {
  if (!e12[Q.CTRL_OR_CMD] && e12.shiftKey && e12.key.toLowerCase() === Q.F) return o3.current?.focus(), true;
  if (e12.key === Q.ESCAPE) return n3(), true;
  if (e12.key === Q.ENTER) return t3?.value && i3(t3.value), true;
  if (e12.key === Q.ARROW_DOWN) return t3?.next ? a3(t3.next.value) : r3[0]?.value && a3(r3[0].value), true;
  if (e12.key === Q.ARROW_UP) return t3?.prev ? a3(t3.prev.value) : r3[r3.length - 1]?.value && a3(r3[r3.length - 1].value), true;
};
var Ry = React.memo(({ selectedFontFamily: e12, hoveredFontFamily: o3, onSelect: t3, onHover: r3, onLeave: n3, onOpen: i3, onClose: a3 }) => {
  let { container: l3 } = Ke(), { fonts: s3 } = He(), { showDeprecatedFonts: c3 } = Do(), [m3, d3] = reactExports.useState(""), p3 = reactExports.useRef(null), u3 = reactExports.useMemo(() => Array.from(Nn.registered.entries()).filter(([k2, { metadata: R3 }]) => !R3.serverSide && !R3.fallback).map(([k2, { metadata: R3, fontFaces: M }]) => {
    let N3 = { value: k2, icon: R3.icon ?? la, text: M[0]?.fontFace?.family ?? "Unknown" };
    return R3.deprecated && Object.assign(N3, { deprecated: R3.deprecated, badge: { type: Ci.RED, placeholder: g("fontList.badge.old") } }), N3;
  }).sort((k2, R3) => k2.text.toLowerCase() > R3.text.toLowerCase() ? 1 : -1), []), h3 = reactExports.useMemo(() => new Set(s3.getSceneFamilies()), [e12]), f3 = reactExports.useMemo(() => u3.filter((k2) => h3.has(k2.value)), [u3, h3]), b3 = reactExports.useMemo(() => u3.filter((k2) => !h3.has(k2.value) && (c3 || !k2.deprecated)), [u3, h3, c3]), x3 = reactExports.useMemo(() => xg$1([...f3, ...b3].filter((k2) => k2.text?.toLowerCase().includes(m3))), [f3, b3, m3]), T3 = reactExports.useMemo(() => {
    let k2;
    return o3 ? k2 = x3.find((R3) => R3.value === o3) : e12 && (k2 = x3.find((R3) => R3.value === e12)), !k2 && m3 && (x3[0]?.value ? r3(x3[0].value) : n3()), k2;
  }, [o3, e12, m3, x3, r3, n3]), E3 = reactExports.useCallback((k2) => {
    Dy({ event: k2, inputRef: p3, hoveredFont: T3, filteredFonts: x3, onSelect: t3, onHover: r3, onClose: a3 }) && (k2.preventDefault(), k2.stopPropagation());
  }, [T3, x3, t3, r3, a3]);
  reactExports.useEffect(() => (i3(), () => {
    a3();
  }), []);
  let w3 = reactExports.useMemo(() => x3.filter((k2) => h3.has(k2.value)), [x3, h3]), S3 = reactExports.useMemo(() => x3.filter((k2) => !h3.has(k2.value)), [x3, h3]), I3 = (k2, R3) => jsxRuntimeExports.jsxs(vt, { icon: k2.icon, value: k2.value, order: R3, textStyle: { fontFamily: ea({ fontFamily: k2.value }) }, hovered: k2.value === T3?.value, selected: k2.value === e12, tabIndex: k2.value === e12 ? 0 : -1, onClick: (M) => {
    t3(Number(M.currentTarget.value));
  }, onMouseMove: () => {
    T3?.value !== k2.value && r3(k2.value);
  }, children: [k2.text, k2.badge && jsxRuntimeExports.jsx(dc, { type: k2.badge.type, children: k2.badge.placeholder })] }, k2.value), _3 = [];
  return w3.length && _3.push(jsxRuntimeExports.jsx(Na, { title: g("fontList.sceneFonts"), children: w3.map(I3) }, "group_1")), S3.length && _3.push(jsxRuntimeExports.jsx(Na, { title: g("fontList.availableFonts"), children: S3.map((k2, R3) => I3(k2, R3 + w3.length)) }, "group_2")), jsxRuntimeExports.jsxs(oc, { className: "properties-content", container: l3, style: { width: "15rem" }, onClose: a3, onPointerLeave: n3, onKeyDown: E3, children: [jsxRuntimeExports.jsx(ic, { ref: p3, placeholder: g("quickSearch.placeholder"), onChange: $o(d3, 20) }), jsxRuntimeExports.jsx(ac, { className: "dropdown-menu fonts manual-hover", placeholder: g("fontList.empty"), children: _3.length ? _3 : null })] });
}, (e12, o3) => e12.selectedFontFamily === o3.selectedFontFamily && e12.hoveredFontFamily === o3.hoveredFontFamily);
var Oy = ({ selectedFontFamily: e12 }) => {
  let o3 = reactExports.useMemo(() => !!(e12 && !Fy(e12)), [e12]);
  return jsxRuntimeExports.jsx(Trigger, { asChild: true, children: jsxRuntimeExports.jsx("div", { children: jsxRuntimeExports.jsx(Js, { standalone: true, icon: Ad$1, title: g("labels.showFonts"), className: "properties-trigger", testId: "font-family-show-fonts", active: o3, onClick: () => {
  } }) }) });
};
var Uy = [{ value: Ie.Excalifont, icon: Nr$1, text: g("labels.handDrawn"), testId: "font-family-hand-drawn" }, { value: Ie.Nunito, icon: la, text: g("labels.normal"), testId: "font-family-normal" }, { value: Ie["Comic Shanns"], icon: Ua$1, text: g("labels.code"), testId: "font-family-code" }], N2 = new Set(Uy.map((e12) => e12.value)), Fy = (e12) => e12 ? N2.has(e12) : false, Hy = React.memo(({ isOpened: e12, selectedFontFamily: o3, hoveredFontFamily: t3, onSelect: r3, onHover: n3, onLeave: i3, onPopupChange: a3 }) => {
  let l3 = reactExports.useMemo(() => Uy, []), s3 = reactExports.useCallback((c3) => {
    c3 && r3(c3);
  }, [r3]);
  return jsxRuntimeExports.jsxs("div", { role: "dialog", "aria-modal": "true", className: "FontPicker__container", children: [jsxRuntimeExports.jsx(eo, { type: "button", options: l3, value: o3, onClick: s3 }), jsxRuntimeExports.jsx(qs, {}), jsxRuntimeExports.jsxs(Root2, { open: e12, onOpenChange: a3, children: [jsxRuntimeExports.jsx(Oy, { selectedFontFamily: o3 }), e12 && jsxRuntimeExports.jsx(Ry, { selectedFontFamily: o3, hoveredFontFamily: t3, onSelect: s3, onHover: n3, onLeave: i3, onOpen: () => a3(true), onClose: () => a3(false) })] })] });
}, (e12, o3) => e12.isOpened === o3.isOpened && e12.selectedFontFamily === o3.selectedFontFamily && e12.hoveredFontFamily === o3.hoveredFontFamily);
var Vy = ({ updateData: e12, appState: o3, elements: t3, testId: r3 }) => {
  let n3 = React.useRef(null), i3 = React.useRef(null), a3 = gt(t3, o3, (l3) => l3.opacity, true, o3.currentItemOpacity);
  return reactExports.useEffect(() => {
    if (n3.current && i3.current) {
      let l3 = n3.current, s3 = i3.current, c3 = l3.offsetWidth, m3 = 15, d3 = a3 / 100 * (c3 - m3) + m3 / 2;
      s3.style.left = `${d3}px`, l3.style.background = `linear-gradient(to right, var(--color-slider-track) 0%, var(--color-slider-track) ${a3}%, var(--button-bg) ${a3}%, var(--button-bg) 100%)`;
    }
  }, [a3]), jsxRuntimeExports.jsxs("label", { className: "control-label", children: [g("labels.opacity"), jsxRuntimeExports.jsxs("div", { className: "range-wrapper", children: [jsxRuntimeExports.jsx("input", { ref: n3, type: "range", min: "0", max: "100", step: "10", onChange: (l3) => {
    e12(+l3.target.value);
  }, value: a3, className: "range-input", "data-testid": r3 }), jsxRuntimeExports.jsx("div", { className: "value-bubble", ref: i3, children: a3 !== 0 ? a3 : null }), jsxRuntimeExports.jsx("div", { className: "zero-label", children: "0" })] })] });
};
var Ky = 0.1, wt = (e12, o3, t3, r3 = false) => {
  let n3 = te(at$1(e12, o3, { includeBoundTextElement: r3 }));
  return e12.map((i3) => n3.get(i3.id) || i3.id === o3.editingTextElement?.id ? t3(i3) : i3);
}, gt = function(e12, o3, t3, r3, n3) {
  let i3 = o3.editingTextElement, a3 = Es(e12), l3 = null;
  return i3 && (l3 = t3(i3)), l3 || (Ib(a3, o3) ? l3 = wb(r3 === true ? a3 : a3.filter((c3) => r3(c3)), o3, t3) ?? (typeof n3 == "function" ? n3(true) : n3) : l3 = typeof n3 == "function" ? n3(false) : n3), l3;
}, z2 = (e12, o3) => Ne(o3) || !o3.autoResize ? o3 : Y(o3, { x: e12.textAlign === "left" ? e12.x : e12.x + (e12.width - o3.width) / (e12.textAlign === "center" ? 2 : 1), y: e12.y + (e12.height - o3.height) / 2 }, false), zp = (e12, o3, t3, r3, n3) => {
  let i3 = /* @__PURE__ */ new Set(), a3 = wt(e12, o3, (s3) => {
    if (k$2(s3)) {
      let c3 = r3(s3);
      i3.add(c3);
      let m3 = vt$1(s3, { fontSize: c3 });
      return Xa$1(m3, t3.scene.getContainerElement(s3), t3.scene.getNonDeletedElementsMap()), m3 = z2(s3, m3), m3;
    }
    return s3;
  }, true), l3 = te(a3);
  return at$1(e12, o3, { includeBoundTextElement: true }).forEach((s3) => {
    k$2(s3) && Jt(s3, l3);
  }), { elements: a3, appState: { ...o3, currentItemFontSize: i3.size === 1 ? [...i3][0] : n3 ?? o3.currentItemFontSize }, captureUpdate: dr.IMMEDIATELY };
};
L2({ name: "changeStrokeColor", label: "labels.stroke", trackEvent: false, perform: (e12, o3, t3) => ({ ...t3.currentItemStrokeColor && { elements: wt(e12, o3, (r3) => NP(r3.type) ? vt$1(r3, { strokeColor: t3.currentItemStrokeColor }) : r3, true) }, appState: { ...o3, ...t3 }, captureUpdate: t3.currentItemStrokeColor ? dr.IMMEDIATELY : dr.EVENTUALLY }), PanelComponent: ({ elements: e12, appState: o3, updateData: t3, appProps: r3 }) => jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [jsxRuntimeExports.jsx("h3", { "aria-hidden": "true", children: g("labels.stroke") }), jsxRuntimeExports.jsx(Pa, { topPicks: W9, palette: j9, type: "elementStroke", label: g("labels.stroke"), color: gt(e12, o3, (n3) => n3.strokeColor, true, o3.currentItemStrokeColor), onChange: (n3) => t3({ currentItemStrokeColor: n3 }), elements: e12, appState: o3, updateData: t3 })] }) });
L2({ name: "changeBackgroundColor", label: "labels.changeBackground", trackEvent: false, perform: (e12, o3, t3) => ({ ...t3.currentItemBackgroundColor && { elements: wt(e12, o3, (r3) => vt$1(r3, { backgroundColor: t3.currentItemBackgroundColor })) }, appState: { ...o3, ...t3 }, captureUpdate: t3.currentItemBackgroundColor ? dr.IMMEDIATELY : dr.EVENTUALLY }), PanelComponent: ({ elements: e12, appState: o3, updateData: t3, appProps: r3 }) => jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [jsxRuntimeExports.jsx("h3", { "aria-hidden": "true", children: g("labels.background") }), jsxRuntimeExports.jsx(Pa, { topPicks: z9, palette: eE, type: "elementBackground", label: g("labels.background"), color: gt(e12, o3, (n3) => n3.backgroundColor, true, o3.currentItemBackgroundColor), onChange: (n3) => t3({ currentItemBackgroundColor: n3 }), elements: e12, appState: o3, updateData: t3 })] }) });
L2({ name: "changeFillStyle", label: "labels.fill", trackEvent: false, perform: (e12, o3, t3, r3) => (le("element", "changeFillStyle", `${t3} (${r3.device.editor.isMobile ? "mobile" : "desktop"})`), { elements: wt(e12, o3, (n3) => vt$1(n3, { fillStyle: t3 })), appState: { ...o3, currentItemFillStyle: t3 }, captureUpdate: dr.IMMEDIATELY }), PanelComponent: ({ elements: e12, appState: o3, updateData: t3 }) => {
  let r3 = at$1(e12, o3), n3 = r3.length > 0 && r3.every((i3) => i3.fillStyle === "zigzag");
  return jsxRuntimeExports.jsxs("fieldset", { children: [jsxRuntimeExports.jsx("legend", { children: g("labels.fill") }), jsxRuntimeExports.jsx(eo, { type: "button", options: [{ value: "hachure", text: `${n3 ? g("labels.zigzag") : g("labels.hachure")} (${cg$1("Alt-Click")})`, icon: n3 ? Dh : Sh, active: n3 ? true : void 0, testId: "fill-hachure" }, { value: "cross-hatch", text: g("labels.crossHatch"), icon: vh, testId: "fill-cross-hatch" }, { value: "solid", text: g("labels.solid"), icon: $h, testId: "fill-solid" }], value: gt(e12, o3, (i3) => i3.fillStyle, (i3) => i3.hasOwnProperty("fillStyle"), (i3) => i3 ? null : o3.currentItemFillStyle), onClick: (i3, a3) => {
    let l3 = a3.altKey && i3 === "hachure" && r3.every((s3) => s3.fillStyle === "hachure") ? "zigzag" : i3;
    t3(l3);
  } })] });
} });
L2({ name: "changeStrokeWidth", label: "labels.strokeWidth", trackEvent: false, perform: (e12, o3, t3) => ({ elements: wt(e12, o3, (r3) => vt$1(r3, { strokeWidth: t3 })), appState: { ...o3, currentItemStrokeWidth: t3 }, captureUpdate: dr.IMMEDIATELY }), PanelComponent: ({ elements: e12, appState: o3, updateData: t3 }) => jsxRuntimeExports.jsxs("fieldset", { children: [jsxRuntimeExports.jsx("legend", { children: g("labels.strokeWidth") }), jsxRuntimeExports.jsx(eo, { group: "stroke-width", options: [{ value: KE$1.thin, text: g("labels.thin"), icon: Ph, testId: "strokeWidth-thin" }, { value: KE$1.bold, text: g("labels.bold"), icon: Nh, testId: "strokeWidth-bold" }, { value: KE$1.extraBold, text: g("labels.extraBold"), icon: Fh, testId: "strokeWidth-extraBold" }], value: gt(e12, o3, (r3) => r3.strokeWidth, (r3) => r3.hasOwnProperty("strokeWidth"), (r3) => r3 ? null : o3.currentItemStrokeWidth), onChange: (r3) => t3(r3) })] }) });
L2({ name: "changeSloppiness", label: "labels.sloppiness", trackEvent: false, perform: (e12, o3, t3) => ({ elements: wt(e12, o3, (r3) => vt$1(r3, { seed: Vt(), roughness: t3 })), appState: { ...o3, currentItemRoughness: t3 }, captureUpdate: dr.IMMEDIATELY }), PanelComponent: ({ elements: e12, appState: o3, updateData: t3 }) => jsxRuntimeExports.jsxs("fieldset", { children: [jsxRuntimeExports.jsx("legend", { children: g("labels.sloppiness") }), jsxRuntimeExports.jsx(eo, { group: "sloppiness", options: [{ value: 0, text: g("labels.architect"), icon: Ah }, { value: 1, text: g("labels.artist"), icon: Kh }, { value: 2, text: g("labels.cartoonist"), icon: Hh }], value: gt(e12, o3, (r3) => r3.roughness, (r3) => r3.hasOwnProperty("roughness"), (r3) => r3 ? null : o3.currentItemRoughness), onChange: (r3) => t3(r3) })] }) });
L2({ name: "changeStrokeStyle", label: "labels.strokeStyle", trackEvent: false, perform: (e12, o3, t3) => ({ elements: wt(e12, o3, (r3) => vt$1(r3, { strokeStyle: t3 })), appState: { ...o3, currentItemStrokeStyle: t3 }, captureUpdate: dr.IMMEDIATELY }), PanelComponent: ({ elements: e12, appState: o3, updateData: t3 }) => jsxRuntimeExports.jsxs("fieldset", { children: [jsxRuntimeExports.jsx("legend", { children: g("labels.strokeStyle") }), jsxRuntimeExports.jsx(eo, { group: "strokeStyle", options: [{ value: "solid", text: g("labels.strokeStyle_solid"), icon: Ph }, { value: "dashed", text: g("labels.strokeStyle_dashed"), icon: _h }, { value: "dotted", text: g("labels.strokeStyle_dotted"), icon: Oh }], value: gt(e12, o3, (r3) => r3.strokeStyle, (r3) => r3.hasOwnProperty("strokeStyle"), (r3) => r3 ? null : o3.currentItemStrokeStyle), onChange: (r3) => t3(r3) })] }) });
L2({ name: "changeOpacity", label: "labels.opacity", trackEvent: false, perform: (e12, o3, t3) => ({ elements: wt(e12, o3, (r3) => vt$1(r3, { opacity: t3 }), true), appState: { ...o3, currentItemOpacity: t3 }, captureUpdate: dr.IMMEDIATELY }), PanelComponent: ({ elements: e12, appState: o3, updateData: t3 }) => jsxRuntimeExports.jsx(Vy, { updateData: t3, elements: e12, appState: o3, testId: "opacity" }) });
L2({ name: "changeFontSize", label: "labels.fontSize", trackEvent: false, perform: (e12, o3, t3, r3) => zp(e12, o3, r3, () => t3, t3), PanelComponent: ({ elements: e12, appState: o3, updateData: t3, app: r3 }) => jsxRuntimeExports.jsxs("fieldset", { children: [jsxRuntimeExports.jsx("legend", { children: g("labels.fontSize") }), jsxRuntimeExports.jsx(eo, { group: "font-size", options: [{ value: 16, text: g("labels.small"), icon: t4, testId: "fontSize-small" }, { value: 20, text: g("labels.medium"), icon: n4, testId: "fontSize-medium" }, { value: 28, text: g("labels.large"), icon: r4, testId: "fontSize-large" }, { value: 36, text: g("labels.veryLarge"), icon: o4, testId: "fontSize-veryLarge" }], value: gt(e12, o3, (n3) => {
  if (k$2(n3)) return n3.fontSize;
  let i3 = oe(n3, r3.scene.getNonDeletedElementsMap());
  return i3 ? i3.fontSize : null;
}, (n3) => k$2(n3) || oe(n3, r3.scene.getNonDeletedElementsMap()) !== null, (n3) => n3 ? null : o3.currentItemFontSize || ut), onChange: (n3) => t3(n3) })] }) });
var Up = L2({ name: "decreaseFontSize", label: "labels.decreaseFontSize", icon: i4, trackEvent: false, perform: (e12, o3, t3, r3) => zp(e12, o3, r3, (n3) => Math.round(1 / (1 + Ky) * n3.fontSize)), keyTest: (e12) => e12[Q.CTRL_OR_CMD] && e12.shiftKey && (e12.key === Q.CHEVRON_LEFT || e12.key === Q.COMMA) }), Hp = L2({ name: "increaseFontSize", label: "labels.increaseFontSize", icon: i4, trackEvent: false, perform: (e12, o3, t3, r3) => zp(e12, o3, r3, (n3) => Math.round(n3.fontSize * (1 + Ky))), keyTest: (e12) => e12[Q.CTRL_OR_CMD] && e12.shiftKey && (e12.key === Q.CHEVRON_RIGHT || e12.key === Q.PERIOD) });
L2({ name: "changeFontFamily", label: "labels.fontFamily", trackEvent: false, perform: (e12, o3, t3, r3) => {
  let { cachedElements: n3, resetAll: i3, resetContainers: a3, ...l3 } = t3;
  if (i3) return { elements: wt(e12, o3, (f3) => {
    let b3 = n3?.get(f3.id);
    return b3 ? vt$1(f3, { ...b3 }) : f3;
  }, true), appState: { ...o3, ...l3 }, captureUpdate: dr.NEVER };
  let { currentItemFontFamily: s3, currentHoveredFontFamily: c3 } = t3, m3 = dr.EVENTUALLY, d3, p3 = false;
  if (s3) d3 = s3, m3 = dr.IMMEDIATELY;
  else if (c3) {
    d3 = c3, m3 = dr.EVENTUALLY;
    let h3 = at$1(e12, o3, { includeBoundTextElement: true }).filter((f3) => k$2(f3));
    if (h3.length > 200) p3 = true;
    else {
      let f3 = 0, b3 = 0;
      for (; f3 < h3.length && b3 < 5e3; ) {
        let x3 = h3[f3];
        b3 += x3?.originalText.length || 0, f3++;
      }
      b3 > 5e3 && (p3 = true);
    }
  }
  let u3 = { appState: { ...o3, ...l3 }, captureUpdate: m3 };
  if (d3 && !p3) {
    let h3 = /* @__PURE__ */ new Map(), f3 = /* @__PURE__ */ new Set(), b3 = false, x3 = Array.from(Nn.loadedFontsCache.values()), T3 = Object.entries(Ie).find(([S3, I3]) => I3 === d3)?.[0];
    c3 && T3 && x3.some((S3) => S3.startsWith(T3)) && (b3 = true), Object.assign(u3, { elements: wt(e12, o3, (S3) => {
      if (k$2(S3) && (S3.fontFamily !== d3 || s3)) {
        let I3 = vt$1(S3, { fontFamily: d3, lineHeight: ko(d3) }), _3 = n3?.get(S3.containerId || "") || {}, k2 = r3.scene.getContainerElement(S3);
        return a3 && k2 && _3 && Y(k2, { ..._3 }, false), b3 || (f3 = /* @__PURE__ */ new Set([...f3, ...Array.from(I3.originalText)])), h3.set(I3, k2), I3;
      }
      return S3;
    }, true) });
    let E3 = `10px ${ea({ fontFamily: d3 })}`, w3 = Array.from(f3.values()).join();
    if (b3 || window.document.fonts.check(E3, w3)) for (let [S3, I3] of h3) Xa$1(S3, I3, r3.scene.getNonDeletedElementsMap(), false);
    else window.document.fonts.load(E3, w3).then((S3) => {
      for (let [I3, _3] of h3) {
        let k2 = r3.scene.getElement(I3.id), R3 = _3 ? r3.scene.getElement(_3.id) : null;
        k2 && Xa$1(k2, R3, r3.scene.getNonDeletedElementsMap(), false);
      }
      r3.fonts.onLoaded(S3);
    });
  }
  return u3;
}, PanelComponent: ({ elements: e12, appState: o3, app: t3, updateData: r3 }) => {
  let n3 = reactExports.useRef(/* @__PURE__ */ new Map()), i3 = reactExports.useRef(null), [a3, l3] = reactExports.useState({}), s3 = reactExports.useRef(true), c3 = reactExports.useMemo(() => {
    let m3 = (d3, p3) => gt(d3, o3, (u3) => {
      if (k$2(u3)) return u3.fontFamily;
      let h3 = oe(u3, p3);
      return h3 ? h3.fontFamily : null;
    }, (u3) => k$2(u3) || oe(u3, p3) !== null, (u3) => u3 ? null : o3.currentItemFontFamily || Ft);
    return a3.openPopup === "fontFamily" && o3.openPopup === "fontFamily" ? m3(Array.from(n3.current?.values() ?? []), n3.current) : !a3.openPopup && o3.openPopup !== "fontFamily" ? m3(e12, t3.scene.getNonDeletedElementsMap()) : i3.current;
  }, [a3.openPopup, o3, e12, t3.scene]);
  return reactExports.useEffect(() => {
    i3.current = c3;
  }, [c3]), reactExports.useEffect(() => {
    Object.keys(a3).length && (r3(a3), l3({}));
  }, [a3]), reactExports.useEffect(() => (s3.current = false, () => {
    s3.current = true;
  }), []), jsxRuntimeExports.jsxs("fieldset", { children: [jsxRuntimeExports.jsx("legend", { children: g("labels.fontFamily") }), jsxRuntimeExports.jsx(Hy, { isOpened: o3.openPopup === "fontFamily", selectedFontFamily: c3, hoveredFontFamily: o3.currentHoveredFontFamily, onSelect: (m3) => {
    l3({ openPopup: null, currentHoveredFontFamily: null, currentItemFontFamily: m3 }), n3.current.clear();
  }, onHover: (m3) => {
    l3({ currentHoveredFontFamily: m3, cachedElements: new Map(n3.current), resetContainers: true });
  }, onLeave: () => {
    l3({ currentHoveredFontFamily: null, cachedElements: new Map(n3.current), resetAll: true });
  }, onPopupChange: (m3) => {
    if (m3) {
      n3.current.clear();
      let { editingTextElement: d3 } = o3;
      if (d3?.type === "text") {
        let p3 = t3.scene.getElement(d3.id);
        n3.current.set(d3.id, vt$1(p3 || d3, {}, true));
      } else {
        let p3 = at$1(e12, o3, { includeBoundTextElement: true });
        for (let u3 of p3) n3.current.set(u3.id, vt$1(u3, {}, true));
      }
      l3({ openPopup: "fontFamily" });
    } else {
      let d3 = { openPopup: null, currentHoveredFontFamily: null, cachedElements: new Map(n3.current), resetAll: true };
      s3.current ? r3({ ...a3, ...d3 }) : l3(d3), n3.current.clear();
    }
  } })] });
} });
L2({ name: "changeTextAlign", label: "Change text alignment", trackEvent: false, perform: (e12, o3, t3, r3) => ({ elements: wt(e12, o3, (n3) => {
  if (k$2(n3)) {
    let i3 = vt$1(n3, { textAlign: t3 });
    return Xa$1(i3, r3.scene.getContainerElement(n3), r3.scene.getNonDeletedElementsMap()), i3;
  }
  return n3;
}, true), appState: { ...o3, currentItemTextAlign: t3 }, captureUpdate: dr.IMMEDIATELY }), PanelComponent: ({ elements: e12, appState: o3, updateData: t3, app: r3 }) => {
  let n3 = r3.scene.getNonDeletedElementsMap();
  return jsxRuntimeExports.jsxs("fieldset", { children: [jsxRuntimeExports.jsx("legend", { children: g("labels.textAlign") }), jsxRuntimeExports.jsx(eo, { group: "text-align", options: [{ value: "left", text: g("labels.left"), icon: a4, testId: "align-left" }, { value: "center", text: g("labels.center"), icon: s4, testId: "align-horizontal-center" }, { value: "right", text: g("labels.right"), icon: d4, testId: "align-right" }], value: gt(e12, o3, (i3) => {
    if (k$2(i3)) return i3.textAlign;
    let a3 = oe(i3, n3);
    return a3 ? a3.textAlign : null;
  }, (i3) => k$2(i3) || oe(i3, n3) !== null, (i3) => i3 ? null : o3.currentItemTextAlign), onChange: (i3) => t3(i3) })] });
} });
L2({ name: "changeVerticalAlign", label: "Change vertical alignment", trackEvent: { category: "element" }, perform: (e12, o3, t3, r3) => ({ elements: wt(e12, o3, (n3) => {
  if (k$2(n3)) {
    let i3 = vt$1(n3, { verticalAlign: t3 });
    return Xa$1(i3, r3.scene.getContainerElement(n3), r3.scene.getNonDeletedElementsMap()), i3;
  }
  return n3;
}, true), appState: { ...o3 }, captureUpdate: dr.IMMEDIATELY }), PanelComponent: ({ elements: e12, appState: o3, updateData: t3, app: r3 }) => jsxRuntimeExports.jsx("fieldset", { children: jsxRuntimeExports.jsx(eo, { group: "text-align", options: [{ value: kt.TOP, text: g("labels.alignTop"), icon: jsxRuntimeExports.jsx(c4, { theme: o3.theme }), testId: "align-top" }, { value: kt.MIDDLE, text: g("labels.centerVertically"), icon: jsxRuntimeExports.jsx(U4, { theme: o3.theme }), testId: "align-middle" }, { value: kt.BOTTOM, text: g("labels.alignBottom"), icon: jsxRuntimeExports.jsx(l4, { theme: o3.theme }), testId: "align-bottom" }], value: gt(e12, o3, (n3) => {
  if (k$2(n3) && n3.containerId) return n3.verticalAlign;
  let i3 = oe(n3, r3.scene.getNonDeletedElementsMap());
  return i3 ? i3.verticalAlign : null;
}, (n3) => k$2(n3) || oe(n3, r3.scene.getNonDeletedElementsMap()) !== null, (n3) => n3 ? null : kt.MIDDLE), onChange: (n3) => t3(n3) }) }) });
L2({ name: "changeRoundness", label: "Change edge roundness", trackEvent: false, perform: (e12, o3, t3) => ({ elements: wt(e12, o3, (r3) => X$1(r3) ? r3 : vt$1(r3, { roundness: t3 === "round" ? { type: Oo$1(r3.type) ? ot.ADAPTIVE_RADIUS : ot.PROPORTIONAL_RADIUS } : null })), appState: { ...o3, currentItemRoundness: t3 }, captureUpdate: dr.IMMEDIATELY }), PanelComponent: ({ elements: e12, appState: o3, updateData: t3 }) => {
  let n3 = Rb(Es(e12), o3).some((i3) => i3.roundness?.type === ot.LEGACY);
  return jsxRuntimeExports.jsxs("fieldset", { children: [jsxRuntimeExports.jsx("legend", { children: g("labels.edges") }), jsxRuntimeExports.jsx(eo, { group: "edges", options: [{ value: "sharp", text: g("labels.sharp"), icon: Jh }, { value: "round", text: g("labels.round"), icon: Yh }], value: gt(e12, o3, (i3) => n3 ? null : i3.roundness ? "round" : "sharp", (i3) => !ee(i3) && i3.hasOwnProperty("roundness"), (i3) => i3 ? null : o3.currentItemRoundness), onChange: (i3) => t3(i3) })] });
} });
var Wy = (e12) => [{ value: null, text: g("labels.arrowhead_none"), keyBinding: "q", icon: Ch }, { value: "arrow", text: g("labels.arrowhead_arrow"), keyBinding: "w", icon: jsxRuntimeExports.jsx(Vh, { flip: e12 }) }, { value: "triangle", text: g("labels.arrowhead_triangle"), icon: jsxRuntimeExports.jsx(kh, { flip: e12 }), keyBinding: "e" }, { value: "triangle_outline", text: g("labels.arrowhead_triangle_outline"), icon: jsxRuntimeExports.jsx(Zh, { flip: e12 }), keyBinding: "r" }, { value: "circle", text: g("labels.arrowhead_circle"), keyBinding: "a", icon: jsxRuntimeExports.jsx(qh, { flip: e12 }) }, { value: "circle_outline", text: g("labels.arrowhead_circle_outline"), keyBinding: "s", icon: jsxRuntimeExports.jsx(Xh, { flip: e12 }) }, { value: "diamond", text: g("labels.arrowhead_diamond"), icon: jsxRuntimeExports.jsx(Wh, { flip: e12 }), keyBinding: "d" }, { value: "diamond_outline", text: g("labels.arrowhead_diamond_outline"), icon: jsxRuntimeExports.jsx(zh, { flip: e12 }), keyBinding: "f" }, { value: "bar", text: g("labels.arrowhead_bar"), keyBinding: "z", icon: jsxRuntimeExports.jsx(Gh, { flip: e12 }) }, { value: "crowfoot_one", text: g("labels.arrowhead_crowfoot_one"), icon: jsxRuntimeExports.jsx(jh, { flip: e12 }), keyBinding: "c" }, { value: "crowfoot_many", text: g("labels.arrowhead_crowfoot_many"), icon: jsxRuntimeExports.jsx(Qh, { flip: e12 }), keyBinding: "x" }, { value: "crowfoot_one_or_many", text: g("labels.arrowhead_crowfoot_one_or_many"), icon: jsxRuntimeExports.jsx(e4, { flip: e12 }), keyBinding: "v" }];
L2({ name: "changeArrowhead", label: "Change arrowheads", trackEvent: false, perform: (e12, o3, t3) => ({ elements: wt(e12, o3, (r3) => {
  if (ae(r3)) {
    let { position: n3, type: i3 } = t3;
    if (n3 === "start") return vt$1(r3, { startArrowhead: i3 });
    if (n3 === "end") return vt$1(r3, { endArrowhead: i3 });
  }
  return r3;
}), appState: { ...o3, [t3.position === "start" ? "currentItemStartArrowhead" : "currentItemEndArrowhead"]: t3.type }, captureUpdate: dr.IMMEDIATELY }), PanelComponent: ({ elements: e12, appState: o3, updateData: t3 }) => {
  let r3 = qo().rtl;
  return jsxRuntimeExports.jsxs("fieldset", { children: [jsxRuntimeExports.jsx("legend", { children: g("labels.arrowheads") }), jsxRuntimeExports.jsxs("div", { className: "iconSelectList buttonList", children: [jsxRuntimeExports.jsx(_p, { label: "arrowhead_start", options: Wy(!r3), value: gt(e12, o3, (n3) => ae(n3) && Jm(n3.type) ? n3.startArrowhead : o3.currentItemStartArrowhead, true, o3.currentItemStartArrowhead), onChange: (n3) => t3({ position: "start", type: n3 }), numberOfOptionsToAlwaysShow: 4 }), jsxRuntimeExports.jsx(_p, { label: "arrowhead_end", group: "arrowheads", options: Wy(!!r3), value: gt(e12, o3, (n3) => ae(n3) && Jm(n3.type) ? n3.endArrowhead : o3.currentItemEndArrowhead, true, o3.currentItemEndArrowhead), onChange: (n3) => t3({ position: "end", type: n3 }), numberOfOptionsToAlwaysShow: 4 })] })] });
} });
L2({ name: "changeArrowType", label: "Change arrow types", trackEvent: false, perform: (e12, o3, t3, r3) => {
  let n3 = wt(e12, o3, (l3) => {
    if (!ee(l3)) return l3;
    let s3 = vt$1(l3, { roundness: t3 === Ws$1.round ? { type: ot.PROPORTIONAL_RADIUS } : null, elbowed: t3 === Ws$1.elbow, points: t3 === Ws$1.elbow || l3.elbowed ? [l3.points[0], l3.points[l3.points.length - 1]] : l3.points });
    if (X$1(s3)) {
      let c3 = r3.scene.getNonDeletedElementsMap();
      r3.dismissLinearEditor();
      let m3 = z$1.getPointAtIndexGlobalCoordinates(s3, 0, c3), d3 = z$1.getPointAtIndexGlobalCoordinates(s3, -1, c3), p3 = !s3.startBinding && Bn(un(m3), e12, c3, o3.zoom, false, true), u3 = !s3.endBinding && Bn(un(d3), e12, c3, o3.zoom, false, true), h3 = p3 || s3.startBinding && c3.get(s3.startBinding.elementId), f3 = u3 || s3.endBinding && c3.get(s3.endBinding.elementId), b3 = p3 ? fi(s3, p3, "start") : m3, x3 = u3 ? fi(s3, u3, "end") : d3;
      p3 && di(s3, p3, "start", c3), u3 && di(s3, u3, "end", c3), Y(s3, { points: [b3, x3].map((T3) => u$1(T3[0] - s3.x, T3[1] - s3.y)), ...h3 && s3.startBinding ? { startBinding: { ...s3.startBinding, ...d2$1(s3, h3, "start") } } : {}, ...f3 && s3.endBinding ? { endBinding: { ...s3.endBinding, ...d2$1(s3, f3, "end") } } : {} }), z$1.updateEditorMidPointsCache(s3, c3, r3.state);
    }
    return s3;
  }), i3 = { ...o3, currentItemArrowType: t3 }, a3 = o3.selectedLinearElement?.elementId;
  if (a3) {
    let l3 = n3.find((s3) => s3.id === a3);
    l3 && (i3.selectedLinearElement = new z$1(l3));
  }
  return { elements: n3, appState: i3, captureUpdate: dr.IMMEDIATELY };
}, PanelComponent: ({ elements: e12, appState: o3, updateData: t3 }) => jsxRuntimeExports.jsxs("fieldset", { children: [jsxRuntimeExports.jsx("legend", { children: g("labels.arrowtypes") }), jsxRuntimeExports.jsx(eo, { group: "arrowtypes", options: [{ value: Ws$1.sharp, text: g("labels.arrowtype_sharp"), icon: oy$1, testId: "sharp-arrow" }, { value: Ws$1.round, text: g("labels.arrowtype_round"), icon: ay$1, testId: "round-arrow" }, { value: Ws$1.elbow, text: g("labels.arrowtype_elbowed"), icon: iy$1, testId: "elbow-arrow" }], value: gt(e12, o3, (r3) => ee(r3) ? r3.elbowed ? Ws$1.elbow : r3.roundness ? Ws$1.round : Ws$1.sharp : null, (r3) => ee(r3), (r3) => r3 ? null : o3.currentItemArrowType), onChange: (r3) => t3(r3) })] }) });
var Qo = ({ viewportX: e12, viewportY: o3, nextZoom: t3 }, r3) => {
  let n3 = e12 - r3.offsetLeft, i3 = o3 - r3.offsetTop, a3 = r3.zoom.value, l3 = r3.scrollX + (n3 - n3 / a3), s3 = r3.scrollY + (i3 - i3 / a3), c3 = -(n3 - n3 / t3), m3 = -(i3 - i3 / t3);
  return { scrollX: l3 + c3, scrollY: s3 + m3, zoom: { value: t3 } };
};
var Ii = () => {
  let e12 = document.querySelector(".excalidraw-tooltip");
  if (e12) return e12;
  let o3 = document.createElement("div");
  return document.body.appendChild(o3), o3.classList.add("excalidraw-tooltip"), o3;
}, Gp = (e12, o3, t3 = "bottom") => {
  let r3 = e12.getBoundingClientRect(), n3 = window.innerWidth, i3 = window.innerHeight, a3 = 5, l3 = o3.left + o3.width / 2 - r3.width / 2;
  l3 < 0 ? l3 = a3 : l3 + r3.width >= n3 && (l3 = n3 - r3.width - a3);
  let s3;
  t3 === "bottom" ? (s3 = o3.top + o3.height + a3, s3 + r3.height >= i3 && (s3 = o3.top - r3.height - a3)) : (s3 = o3.top - r3.height - a3, s3 < 0 && (s3 = o3.top + o3.height + a3)), Object.assign(e12.style, { top: `${s3}px`, left: `${l3}px` });
}, J2 = (e12, o3, t3, r3) => {
  o3.classList.add("excalidraw-tooltip--visible"), o3.style.minWidth = r3 ? "50ch" : "10ch", o3.style.maxWidth = r3 ? "50ch" : "15ch", o3.textContent = t3;
  let n3 = e12.getBoundingClientRect();
  Gp(o3, n3);
}, Ut = ({ children: e12, label: o3, long: t3 = false, style: r3, disabled: n3 }) => (reactExports.useEffect(() => () => Ii().classList.remove("excalidraw-tooltip--visible"), []), n3 ? null : jsxRuntimeExports.jsx("div", { className: "excalidraw-tooltip-wrapper", onPointerEnter: (i3) => J2(i3.currentTarget, Ii(), o3, t3), onPointerLeave: () => Ii().classList.remove("excalidraw-tooltip--visible"), style: r3, children: e12 }));
L2({ name: "changeViewBackgroundColor", label: "labels.canvasBackground", paletteName: "Change canvas background color", trackEvent: false, predicate: (e12, o3, t3, r3) => !!r3.props.UIOptions.canvasActions.changeViewBackgroundColor && !o3.viewModeEnabled, perform: (e12, o3, t3) => ({ appState: { ...o3, ...t3 }, captureUpdate: t3.viewBackgroundColor ? dr.IMMEDIATELY : dr.EVENTUALLY }), PanelComponent: ({ elements: e12, appState: o3, updateData: t3, appProps: r3 }) => jsxRuntimeExports.jsx(Pa, { palette: null, topPicks: Q9, label: g("labels.canvasBackground"), type: "canvasBackground", color: o3.viewBackgroundColor, onChange: (n3) => t3({ viewBackgroundColor: n3 }), "data-testid": "canvas-background-picker", elements: e12, appState: o3, updateData: t3 }) });
var er = L2({ name: "clearCanvas", label: "labels.clearCanvas", paletteName: "Clear canvas", icon: Tx, trackEvent: { category: "canvas" }, predicate: (e12, o3, t3, r3) => !!r3.props.UIOptions.canvasActions.clearCanvas && !o3.viewModeEnabled && o3.openDialog?.name !== "elementLinkSelector", perform: (e12, o3, t3, r3) => (r3.imageCache.clear(), { elements: e12.map((n3) => vt$1(n3, { isDeleted: true })), appState: { ...mt(), files: {}, theme: o3.theme, penMode: o3.penMode, penDetected: o3.penDetected, exportBackground: o3.exportBackground, exportEmbedScene: o3.exportEmbedScene, gridSize: o3.gridSize, gridStep: o3.gridStep, gridModeEnabled: o3.gridModeEnabled, stats: o3.stats, pasteDialog: o3.pasteDialog, activeTool: o3.activeTool.type === "image" ? { ...o3.activeTool, type: "selection" } : o3.activeTool }, captureUpdate: dr.IMMEDIATELY }) }), pc = L2({ name: "zoomIn", label: "buttons.zoomIn", viewMode: true, icon: Ix, trackEvent: { category: "canvas" }, perform: (e12, o3, t3, r3) => ({ appState: { ...o3, ...Qo({ viewportX: o3.width / 2 + o3.offsetLeft, viewportY: o3.height / 2 + o3.offsetTop, nextZoom: Oa(o3.zoom.value + DE) }, o3), userToFollow: null }, captureUpdate: dr.EVENTUALLY }), PanelComponent: ({ updateData: e12, appState: o3 }) => jsxRuntimeExports.jsx(X, { type: "button", className: "zoom-in-button zoom-button", icon: Ix, title: `${g("buttons.zoomIn")}  ${cg$1("CtrlOrCmd++")}`, "aria-label": g("buttons.zoomIn"), disabled: o3.zoom.value >= Ys, onClick: () => {
  e12(null);
} }), keyTest: (e12) => (e12.code === D1.EQUAL || e12.code === D1.NUM_ADD) && (e12[Q.CTRL_OR_CMD] || e12.shiftKey) }), uc = L2({ name: "zoomOut", label: "buttons.zoomOut", icon: wx, viewMode: true, trackEvent: { category: "canvas" }, perform: (e12, o3, t3, r3) => ({ appState: { ...o3, ...Qo({ viewportX: o3.width / 2 + o3.offsetLeft, viewportY: o3.height / 2 + o3.offsetTop, nextZoom: Oa(o3.zoom.value - DE) }, o3), userToFollow: null }, captureUpdate: dr.EVENTUALLY }), PanelComponent: ({ updateData: e12, appState: o3 }) => jsxRuntimeExports.jsx(X, { type: "button", className: "zoom-out-button zoom-button", icon: wx, title: `${g("buttons.zoomOut")}  ${cg$1("CtrlOrCmd+-")}`, "aria-label": g("buttons.zoomOut"), disabled: o3.zoom.value <= Js$1, onClick: () => {
  e12(null);
} }), keyTest: (e12) => (e12.code === D1.MINUS || e12.code === D1.NUM_SUBTRACT) && (e12[Q.CTRL_OR_CMD] || e12.shiftKey) }), gc = L2({ name: "resetZoom", label: "buttons.resetZoom", icon: Rx, viewMode: true, trackEvent: { category: "canvas" }, perform: (e12, o3, t3, r3) => ({ appState: { ...o3, ...Qo({ viewportX: o3.width / 2 + o3.offsetLeft, viewportY: o3.height / 2 + o3.offsetTop, nextZoom: Oa(1) }, o3), userToFollow: null }, captureUpdate: dr.EVENTUALLY }), PanelComponent: ({ updateData: e12, appState: o3 }) => jsxRuntimeExports.jsx(Ut, { label: g("buttons.resetZoom"), style: { height: "100%" }, children: jsxRuntimeExports.jsxs(X, { type: "button", className: "reset-zoom-button zoom-button", title: g("buttons.resetZoom"), "aria-label": g("buttons.resetZoom"), onClick: () => {
  e12(null);
}, children: [(o3.zoom.value * 100).toFixed(0), "%"] }) }), keyTest: (e12) => (e12.code === D1.ZERO || e12.code === D1.NUM_ZERO) && (e12[Q.CTRL_OR_CMD] || e12.shiftKey) }), eI = (e12, o3, t3 = 1) => {
  let [r3, n3, i3, a3] = e12, l3 = i3 - r3, s3 = o3.width / l3, c3 = a3 - n3, m3 = o3.height / c3, p3 = Math.min(s3, m3) * se(t3, 0.1, 1);
  return Math.min(p3, 1);
}, $y = ({ bounds: e12, appState: o3, canvasOffsets: t3, fitToViewport: r3 = false, viewportZoomFactor: n3 = 1, minZoom: i3 = -1 / 0, maxZoom: a3 = 1 / 0 }) => {
  n3 = se(n3, Js$1, Ys);
  let [l3, s3, c3, m3] = e12, d3 = (l3 + c3) / 2, p3 = (s3 + m3) / 2, u3 = t3?.left ?? 0, h3 = t3?.top ?? 0, f3 = t3?.right ?? 0, b3 = t3?.bottom ?? 0, x3 = o3.width - u3 - f3, T3 = o3.height - h3 - b3, E3;
  if (r3) {
    let I3 = c3 - l3, _3 = m3 - s3;
    E3 = Math.min(x3 / I3, T3 / _3) * n3;
  } else E3 = eI(e12, { width: x3, height: T3 }, n3);
  let w3 = Oa(se(WE$1(E3, DE, "floor"), i3, a3)), S3 = yb({ scenePoint: { x: d3, y: p3 }, viewportDimensions: { width: o3.width, height: o3.height }, offsets: t3, zoom: { value: w3 } });
  return { appState: { ...o3, scrollX: S3.scrollX, scrollY: S3.scrollY, zoom: { value: w3 } }, captureUpdate: dr.EVENTUALLY };
}, Fa = ({ canvasOffsets: e12, targetElements: o3, appState: t3, fitToViewport: r3, viewportZoomFactor: n3, minZoom: i3, maxZoom: a3 }) => {
  let l3 = $e$1(Es(o3));
  return $y({ canvasOffsets: e12, bounds: l3, appState: t3, fitToViewport: r3, viewportZoomFactor: n3, minZoom: i3, maxZoom: a3 });
};
L2({ name: "zoomToFitSelectionInViewport", label: "labels.zoomToFitViewport", icon: k4, trackEvent: { category: "canvas" }, perform: (e12, o3, t3, r3) => {
  let n3 = r3.scene.getSelectedElements(o3);
  return Fa({ targetElements: n3.length ? n3 : e12, appState: { ...o3, userToFollow: null }, fitToViewport: false, canvasOffsets: r3.getEditorUIOffsets() });
}, keyTest: (e12) => e12.code === D1.TWO && e12.shiftKey && !e12.altKey && !e12[Q.CTRL_OR_CMD] });
L2({ name: "zoomToFitSelection", label: "helpDialog.zoomToSelection", icon: k4, trackEvent: { category: "canvas" }, perform: (e12, o3, t3, r3) => {
  let n3 = r3.scene.getSelectedElements(o3);
  return Fa({ targetElements: n3.length ? n3 : e12, appState: { ...o3, userToFollow: null }, fitToViewport: true, canvasOffsets: r3.getEditorUIOffsets() });
}, keyTest: (e12) => e12.code === D1.THREE && e12.shiftKey && !e12.altKey && !e12[Q.CTRL_OR_CMD] });
L2({ name: "zoomToFit", label: "helpDialog.zoomToFit", icon: k4, viewMode: true, trackEvent: { category: "canvas" }, perform: (e12, o3, t3, r3) => Fa({ targetElements: e12, appState: { ...o3, userToFollow: null }, fitToViewport: false, canvasOffsets: r3.getEditorUIOffsets() }), keyTest: (e12) => e12.code === D1.ONE && e12.shiftKey && !e12.altKey && !e12[Q.CTRL_OR_CMD] });
var En = L2({ name: "toggleTheme", label: (e12, o3) => o3.theme === ke.DARK ? "buttons.lightMode" : "buttons.darkMode", keywords: ["toggle", "dark", "light", "mode", "theme"], icon: (e12) => e12.theme === ke.LIGHT ? Dx : Sx, viewMode: true, trackEvent: { category: "canvas" }, perform: (e12, o3, t3) => ({ appState: { ...o3, theme: t3 || (o3.theme === ke.LIGHT ? ke.DARK : ke.LIGHT) }, captureUpdate: dr.EVENTUALLY }), keyTest: (e12) => e12.altKey && e12.shiftKey && e12.code === D1.D, predicate: (e12, o3, t3, r3) => !!r3.props.UIOptions.canvasActions.toggleTheme });
L2({ name: "toggleEraserTool", label: "toolBar.eraser", trackEvent: { category: "toolbar" }, perform: (e12, o3) => {
  let t3;
  return td$1(o3) ? t3 = $r(o3, { ...o3.activeTool.lastActiveTool || { type: "selection" }, lastActiveToolBeforeEraser: null }) : t3 = $r(o3, { type: "eraser", lastActiveToolBeforeEraser: o3.activeTool }), { appState: { ...o3, selectedElementIds: {}, selectedGroupIds: {}, activeEmbeddable: null, activeTool: t3 }, captureUpdate: dr.IMMEDIATELY };
}, keyTest: (e12) => e12.key === Q.E });
var Zy = L2({ name: "toggleHandTool", label: "toolBar.hand", paletteName: "Toggle hand tool", trackEvent: { category: "toolbar" }, icon: m4, viewMode: false, perform: (e12, o3, t3, r3) => {
  let n3;
  return nd(o3) ? n3 = $r(o3, { ...o3.activeTool.lastActiveTool || { type: "selection" }, lastActiveToolBeforeEraser: null }) : (n3 = $r(o3, { type: "hand", lastActiveToolBeforeEraser: o3.activeTool }), Jb(r3.interactiveCanvas, mo.GRAB)), { appState: { ...o3, selectedElementIds: {}, selectedGroupIds: {}, activeEmbeddable: null, activeTool: n3 }, captureUpdate: dr.IMMEDIATELY };
}, keyTest: (e12) => !e12.altKey && !e12[Q.CTRL_OR_CMD] && e12.key === Q.H });
var Ht = L2({ name: "finalize", label: "", trackEvent: false, perform: (e12, o3, t3, r3) => {
  let { interactiveCanvas: n3, focusContainer: i3, scene: a3 } = r3, l3 = a3.getNonDeletedElementsMap();
  if (o3.editingLinearElement) {
    let { elementId: p3, startBindingElement: u3, endBindingElement: h3 } = o3.editingLinearElement, f3 = z$1.getElement(p3, l3);
    if (f3) return Pr(f3) && Ba(f3, u3, h3, l3, a3), { elements: f3.points.length < 2 || ao$1(f3) ? e12.filter((b3) => b3.id !== f3.id) : void 0, appState: { ...o3, cursorButton: "up", editingLinearElement: null }, captureUpdate: dr.IMMEDIATELY };
  }
  let s3 = e12, c3 = o3.pendingImageElementId && a3.getElement(o3.pendingImageElementId);
  c3 && Y(c3, { isDeleted: true }, false), window.document.activeElement instanceof HTMLElement && i3();
  let m3 = o3.multiElement ? o3.multiElement : o3.newElement?.type === "freedraw" ? o3.newElement : null;
  if (m3) {
    if (m3.type !== "freedraw" && o3.lastPointerDownWith !== "touch") {
      let { points: u3, lastCommittedPoint: h3 } = m3;
      (!h3 || u3[u3.length - 1] !== h3) && Y(m3, { points: m3.points.slice(0, -1) });
    }
    ao$1(m3) && (s3 = s3.filter((u3) => u3.id !== m3.id));
    let p3 = Kt(m3.points, o3.zoom.value);
    if ((m3.type === "line" || m3.type === "freedraw") && p3) {
      let u3 = m3.points, h3 = u3[0];
      Y(m3, { points: u3.map((f3, b3) => b3 === u3.length - 1 ? u$1(h3[0], h3[1]) : f3) });
    }
    if (Pr(m3) && !p3 && m3.points.length > 1) {
      let [u3, h3] = z$1.getPointAtIndexGlobalCoordinates(m3, -1, te(e12));
      ON(m3, o3, { x: u3, y: h3 }, l3, e12);
    }
  }
  (!o3.activeTool.locked && o3.activeTool.type !== "freedraw" || !m3) && Hb(n3);
  let d3;
  return o3.activeTool.type === "eraser" ? d3 = $r(o3, { ...o3.activeTool.lastActiveTool || { type: "selection" }, lastActiveToolBeforeEraser: null }) : d3 = $r(o3, { type: "selection" }), { elements: s3, appState: { ...o3, cursorButton: "up", activeTool: (o3.activeTool.locked || o3.activeTool.type === "freedraw") && m3 ? o3.activeTool : d3, activeEmbeddable: null, newElement: null, selectionElement: null, multiElement: null, editingTextElement: null, startBoundElement: null, suggestedBindings: [], selectedElementIds: m3 && !o3.activeTool.locked && o3.activeTool.type !== "freedraw" ? { ...o3.selectedElementIds, [m3.id]: true } : o3.selectedElementIds, selectedLinearElement: m3 && ae(m3) ? new z$1(m3) : o3.selectedLinearElement, pendingImageElementId: null }, captureUpdate: dr.IMMEDIATELY };
}, keyTest: (e12, o3) => e12.key === Q.ESCAPE && (o3.editingLinearElement !== null || !o3.newElement && o3.multiElement === null) || (e12.key === Q.ESCAPE || e12.key === Q.ENTER) && o3.multiElement !== null, PanelComponent: ({ appState: e12, updateData: o3, data: t3 }) => jsxRuntimeExports.jsx(X, { type: "button", icon: Wx, title: g("buttons.done"), "aria-label": g("buttons.done"), onClick: o3, visible: e12.multiElement != null, size: t3?.size || "medium", style: { pointerEvents: "all" } }) });
var Jy = (e12) => {
  let { id: o3 } = Ke(), [t3, r3] = reactExports.useState(e12.value), n3 = (a3) => {
    e12.ignoreFocus || bg$1(a3.target);
    let l3 = a3.target.value;
    l3 !== e12.value && e12.onChange(l3);
  }, i3 = (a3) => {
    if (a3.key === Q.ENTER) {
      if (a3.preventDefault(), a3.nativeEvent.isComposing || a3.keyCode === 229) return;
      a3.currentTarget.blur();
    }
  };
  return jsxRuntimeExports.jsxs("div", { className: "ProjectName", children: [jsxRuntimeExports.jsx("label", { className: "ProjectName-label", htmlFor: "filename", children: `${e12.label}:` }), jsxRuntimeExports.jsx("input", { type: "text", className: "TextInput", onBlur: n3, onKeyDown: i3, id: `${o3}-filename`, value: t3, onChange: (a3) => r3(a3.target.value) })] });
};
var Qy = (e12) => {
  let o3 = e12.title || (e12.value === ke.DARK ? g("buttons.lightMode") : g("buttons.darkMode"));
  return jsxRuntimeExports.jsx(X, { type: "icon", icon: e12.value === ke.LIGHT ? qy.MOON : qy.SUN, title: o3, "aria-label": o3, onClick: () => e12.onChange(e12.value === ke.DARK ? ke.LIGHT : ke.DARK), "data-testid": "toggle-dark-mode" });
}, qy = { SUN: jsxRuntimeExports.jsx("svg", { width: "512", height: "512", className: "rtl-mirror", viewBox: "0 0 512 512", children: jsxRuntimeExports.jsx("path", { fill: "currentColor", d: "M256 160c-52.9 0-96 43.1-96 96s43.1 96 96 96 96-43.1 96-96-43.1-96-96-96zm246.4 80.5l-94.7-47.3 33.5-100.4c4.5-13.6-8.4-26.5-21.9-21.9l-100.4 33.5-47.4-94.8c-6.4-12.8-24.6-12.8-31 0l-47.3 94.7L92.7 70.8c-13.6-4.5-26.5 8.4-21.9 21.9l33.5 100.4-94.7 47.4c-12.8 6.4-12.8 24.6 0 31l94.7 47.3-33.5 100.5c-4.5 13.6 8.4 26.5 21.9 21.9l100.4-33.5 47.3 94.7c6.4 12.8 24.6 12.8 31 0l47.3-94.7 100.4 33.5c13.6 4.5 26.5-8.4 21.9-21.9l-33.5-100.4 94.7-47.3c13-6.5 13-24.7.2-31.1zm-155.9 106c-49.9 49.9-131.1 49.9-181 0-49.9-49.9-49.9-131.1 0-181 49.9-49.9 131.1-49.9 181 0 49.9 49.9 49.9 131.1 0 181z" }) }), MOON: jsxRuntimeExports.jsx("svg", { width: "512", height: "512", className: "rtl-mirror", viewBox: "0 0 512 512", children: jsxRuntimeExports.jsx("path", { fill: "currentColor", d: "M283.211 512c78.962 0 151.079-35.925 198.857-94.792 7.068-8.708-.639-21.43-11.562-19.35-124.203 23.654-238.262-71.576-238.262-196.954 0-72.222 38.662-138.635 101.498-174.394 9.686-5.512 7.25-20.197-3.756-22.23A258.156 258.156 0 0 0 283.211 0c-141.309 0-256 114.511-256 256 0 141.309 114.511 256 256 256z" }) }) };
var yn = (e12, { selectedElementIds: o3 }, t3) => {
  e12 = Es(e12);
  let r3 = t3 && Ib(e12, { selectedElementIds: o3 }), n3 = null, i3 = r3 ? at$1(e12, { selectedElementIds: o3 }, { includeBoundTextElement: true }) : e12;
  return r3 && (i3.length === 1 && de(i3[0]) ? (n3 = i3[0], i3 = Ep(e12, n3)) : i3.length > 1 && (i3 = at$1(e12, { selectedElementIds: o3 }, { includeBoundTextElement: true, includeElementsInFrames: true }))), { exportingFrame: n3, exportedElements: Lg$1(i3) };
}, vn = async (e12, o3, t3, r3, { exportBackground: n3, exportPadding: i3 = Vi$1, viewBackgroundColor: a3, name: l3 = t3.name || Zs$1, fileHandle: s3 = null, exportingFrame: c3 = null }) => {
  if (o3.length === 0) throw new Error(g("alerts.cannotExportEmptyCanvas"));
  if (e12 === "svg" || e12 === "clipboard-svg") {
    let d3 = up$1(o3, { exportBackground: n3, exportWithDarkMode: t3.exportWithDarkMode, viewBackgroundColor: a3, exportPadding: i3, exportScale: t3.exportScale, exportEmbedScene: t3.exportEmbedScene && e12 === "svg" }, r3, { exportingFrame: c3 });
    if (e12 === "svg") return es(d3.then((p3) => new Blob([p3.outerHTML], { type: H.svg })), { description: "Export to SVG", name: l3, extension: t3.exportEmbedScene ? "excalidraw.svg" : "svg", mimeTypes: [yo.svg], fileHandle: s3 });
    if (e12 === "clipboard-svg") {
      let p3 = await d3.then((u3) => u3.outerHTML);
      try {
        await hs(p3);
      } catch {
        throw new Error(g("errors.copyToSystemClipboardFailed"));
      }
      return;
    }
  }
  let m3 = pp$1(o3, t3, r3, { exportBackground: n3, viewBackgroundColor: a3, exportPadding: i3, exportingFrame: c3 });
  if (e12 === "png") {
    let d3 = vY(m3);
    return t3.exportEmbedScene && (d3 = d3.then((p3) => __vitePreload(async () => {
      const { encodePngMetadata: u3 } = await Promise.resolve().then(() => image7KUKJ7J4);
      return { encodePngMetadata: u3 };
    }, true ? void 0 : void 0, import.meta.url).then(({ encodePngMetadata: u3 }) => u3({ blob: p3, metadata: to$1(o3, t3, r3) })))), es(d3, { description: "Export to PNG", name: l3, extension: t3.exportEmbedScene ? "excalidraw.png" : "png", mimeTypes: [yo.png], fileHandle: s3 });
  } else if (e12 === "clipboard") try {
    let d3 = vY(m3);
    await Bp(d3);
  } catch (d3) {
    throw console.warn(d3), d3.name === "CANVAS_POSSIBLY_TOO_BIG" ? new Error(g("canvasError.canvasTooBig")) : aE && d3.name === "TypeError" ? new Error(`${g("alerts.couldNotCopyToClipboard")}

${g("hints.firefox_clipboard_write")}`) : new Error(g("alerts.couldNotCopyToClipboard"));
  }
  else throw new Error("Unsupported export type");
};
var ev = async (e12, o3, t3, r3) => {
  let { exportBackground: n3, viewBackgroundColor: i3, fileHandle: a3 } = o3, l3 = K9(a3);
  if (!a3 || !DY(l3)) throw new Error("fileHandle should exist and should be of type svg or png when resaving");
  o3 = { ...o3, exportEmbedScene: true };
  let { exportedElements: s3, exportingFrame: c3 } = yn(e12, o3, false);
  return await vn(l3, s3, o3, t3, { exportBackground: n3, viewBackgroundColor: i3, name: r3, fileHandle: a3, exportingFrame: c3 }), { fileHandle: a3 };
};
var za = ({ children: e12, checked: o3, onChange: t3, className: r3 }) => jsxRuntimeExports.jsxs("div", { className: dM("Checkbox", r3, { "is-checked": o3 }), onClick: (n3) => {
  t3(!o3, n3), n3.currentTarget.querySelector(".Checkbox-box").focus();
}, children: [jsxRuntimeExports.jsx("button", { type: "button", className: "Checkbox-box", role: "checkbox", "aria-checked": o3, children: Ax }), jsxRuntimeExports.jsx("div", { className: "Checkbox-label", children: e12 })] });
var Yp = L2({ name: "changeProjectName", label: "labels.fileTitle", trackEvent: false, perform: (e12, o3, t3) => ({ appState: { ...o3, name: t3 }, captureUpdate: dr.EVENTUALLY }), PanelComponent: ({ appState: e12, updateData: o3, appProps: t3, data: r3, app: n3 }) => jsxRuntimeExports.jsx(Jy, { label: g("labels.fileTitle"), value: n3.getName(), onChange: (i3) => o3(i3), ignoreFocus: r3?.ignoreFocus ?? false }) }), ov = L2({ name: "changeExportScale", label: "imageExportDialog.scale", trackEvent: { category: "export", action: "scale" }, perform: (e12, o3, t3) => ({ appState: { ...o3, exportScale: t3 }, captureUpdate: dr.EVENTUALLY }), PanelComponent: ({ elements: e12, appState: o3, updateData: t3 }) => {
  let r3 = Es(e12), i3 = Ib(r3, o3) ? at$1(r3, o3) : r3;
  return jsxRuntimeExports.jsx(jsxRuntimeExports.Fragment, { children: Cs.map((a3) => {
    let [l3, s3] = TA$1(i3, Vi$1, a3), c3 = `${g("imageExportDialog.label.scale")} ${a3}x (${l3}x${s3})`;
    return jsxRuntimeExports.jsx(X, { size: "small", type: "radio", icon: `${a3}x`, name: "export-canvas-scale", title: c3, "aria-label": c3, id: "export-canvas-scale", checked: a3 === o3.exportScale, onChange: () => t3(a3) }, a3);
  }) });
} }), Vp = L2({ name: "changeExportBackground", label: "imageExportDialog.label.withBackground", trackEvent: { category: "export", action: "toggleBackground" }, perform: (e12, o3, t3) => ({ appState: { ...o3, exportBackground: t3 }, captureUpdate: dr.EVENTUALLY }), PanelComponent: ({ appState: e12, updateData: o3 }) => jsxRuntimeExports.jsx(za, { checked: e12.exportBackground, onChange: (t3) => o3(t3), children: g("imageExportDialog.label.withBackground") }) }), fc = L2({ name: "changeExportEmbedScene", label: "imageExportDialog.tooltip.embedScene", trackEvent: { category: "export", action: "embedScene" }, perform: (e12, o3, t3) => ({ appState: { ...o3, exportEmbedScene: t3 }, captureUpdate: dr.EVENTUALLY }), PanelComponent: ({ appState: e12, updateData: o3 }) => jsxRuntimeExports.jsxs(za, { checked: e12.exportEmbedScene, onChange: (t3) => o3(t3), children: [g("imageExportDialog.label.embedScene"), jsxRuntimeExports.jsx(Ut, { label: g("imageExportDialog.tooltip.embedScene"), long: true, children: jsxRuntimeExports.jsx("div", { className: "excalidraw-tooltip-icon", children: eh }) })] }) }), bc = L2({ name: "saveToActiveFile", label: "buttons.save", icon: $x, trackEvent: { category: "export" }, predicate: (e12, o3, t3, r3) => !!r3.props.UIOptions.canvasActions.saveToActiveFile && !!o3.fileHandle && !o3.viewModeEnabled, perform: async (e12, o3, t3, r3) => {
  let n3 = !!o3.fileHandle;
  try {
    let { fileHandle: i3 } = W2(o3.fileHandle) ? await ev(e12, o3, r3.files, r3.getName()) : await hO(e12, o3, r3.files, r3.getName());
    return { captureUpdate: dr.EVENTUALLY, appState: { ...o3, fileHandle: i3, toast: n3 ? { message: i3?.name ? g("toast.fileSavedToFilename").replace("{filename}", `"${i3.name}"`) : g("toast.fileSaved") } : null } };
  } catch (i3) {
    return i3?.name !== "AbortError" ? console.error(i3) : console.warn(i3), { captureUpdate: dr.EVENTUALLY };
  }
}, keyTest: (e12) => e12.key === Q.S && e12[Q.CTRL_OR_CMD] && !e12.shiftKey }), Ua = L2({ name: "saveFileToDisk", label: "exportDialog.disk_title", icon: $x, viewMode: true, trackEvent: { category: "export" }, perform: async (e12, o3, t3, r3) => {
  try {
    let { fileHandle: n3 } = await hO(e12, { ...o3, fileHandle: null }, r3.files, r3.getName());
    return { captureUpdate: dr.EVENTUALLY, appState: { ...o3, openDialog: null, fileHandle: n3, toast: { message: g("toast.fileSaved") } } };
  } catch (n3) {
    return n3?.name !== "AbortError" ? console.error(n3) : console.warn(n3), { captureUpdate: dr.EVENTUALLY };
  }
}, keyTest: (e12) => e12.key === Q.S && e12.shiftKey && e12[Q.CTRL_OR_CMD], PanelComponent: ({ updateData: e$12 }) => jsxRuntimeExports.jsx(X, { type: "button", icon: Jx, title: g("buttons.saveAs"), "aria-label": g("buttons.saveAs"), showAriaLabel: me().editor.isMobile, hidden: !e, onClick: () => e$12(null), "data-testid": "save-as-button" }) }), Si = L2({ name: "loadScene", label: "buttons.load", trackEvent: { category: "export" }, predicate: (e12, o3, t3, r3) => !!r3.props.UIOptions.canvasActions.loadScene && !o3.viewModeEnabled, perform: async (e12, o3, t3, r3) => {
  try {
    let { elements: n3, appState: i3, files: a3 } = await yO(o3, e12);
    return { elements: n3, appState: i3, files: a3, captureUpdate: dr.IMMEDIATELY };
  } catch (n3) {
    return n3?.name === "AbortError" ? (console.warn(n3), false) : { elements: e12, appState: { ...o3, errorMessage: n3.message }, files: r3.files, captureUpdate: dr.EVENTUALLY };
  }
}, keyTest: (e12) => e12[Q.CTRL_OR_CMD] && e12.key === Q.O }), rv = L2({ name: "exportWithDarkMode", label: "imageExportDialog.label.darkMode", trackEvent: { category: "export", action: "toggleTheme" }, perform: (e12, o3, t3) => ({ appState: { ...o3, exportWithDarkMode: t3 }, captureUpdate: dr.EVENTUALLY }), PanelComponent: ({ appState: e12, updateData: o3 }) => jsxRuntimeExports.jsx("div", { style: { display: "flex", justifyContent: "flex-end", marginTop: "-45px", marginBottom: "10px" }, children: jsxRuntimeExports.jsx(Qy, { value: e12.exportWithDarkMode ? ke.DARK : ke.LIGHT, onChange: (t3) => {
  o3(t3 === ke.DARK);
}, title: g("imageExportDialog.label.darkMode") }) }) });
var nv = "{}", Wp = L2({ name: "copyStyles", label: "labels.copyStyles", icon: G4, trackEvent: { category: "element" }, perform: (e12, o3, t3, r3) => {
  let n3 = [], i3 = e12.find((a3) => o3.selectedElementIds[a3.id]);
  if (n3.push(i3), i3 && bn(i3)) {
    let a3 = oe(i3, r3.scene.getNonDeletedElementsMap());
    n3.push(a3);
  }
  return i3 && (nv = JSON.stringify(n3)), { appState: { ...o3, toast: { message: g("toast.copyStyles") } }, captureUpdate: dr.EVENTUALLY };
}, keyTest: (e12) => e12[Q.CTRL_OR_CMD] && e12.altKey && e12.code === D1.C }), Kp = L2({ name: "pasteStyles", label: "labels.pasteStyles", icon: G4, trackEvent: { category: "element" }, perform: (e12, o3, t3, r3) => {
  let n3 = JSON.parse(nv), i3 = n3[0], a3 = n3[1];
  if (!ra(i3)) return { elements: e12, captureUpdate: dr.EVENTUALLY };
  let l3 = at$1(e12, o3, { includeBoundTextElement: true }), s3 = l3.map((c3) => c3.id);
  return { elements: e12.map((c3) => {
    if (s3.includes(c3.id)) {
      let m3 = i3;
      if (k$2(c3) && c3.containerId && (m3 = a3), !m3) return c3;
      let d3 = vt$1(c3, { backgroundColor: m3?.backgroundColor, strokeWidth: m3?.strokeWidth, strokeColor: m3?.strokeColor, strokeStyle: m3?.strokeStyle, fillStyle: m3?.fillStyle, opacity: m3?.opacity, roughness: m3?.roughness, roundness: m3.roundness ? Ag$1(m3.roundness.type, c3) ? m3.roundness : Kg$1(c3) : null });
      if (k$2(d3)) {
        let p3 = m3.fontSize || ut, u3 = m3.fontFamily || Ft;
        d3 = vt$1(d3, { fontSize: p3, fontFamily: u3, textAlign: m3.textAlign || Vn, lineHeight: m3.lineHeight || ko(u3) });
        let h3 = null;
        d3.containerId && (h3 = l3.find((f3) => k$2(d3) && f3.id === d3.containerId) || null), Xa$1(d3, h3, r3.scene.getNonDeletedElementsMap());
      }
      return d3.type === "arrow" && ee(m3) && (d3 = vt$1(d3, { startArrowhead: m3.startArrowhead, endArrowhead: m3.endArrowhead })), de(c3) && (d3 = vt$1(d3, { roundness: null, backgroundColor: "transparent" })), d3;
    }
    return c3;
  }), captureUpdate: dr.IMMEDIATELY };
}, keyTest: (e12) => e12[Q.CTRL_OR_CMD] && e12.altKey && e12.code === D1.V });
L2({ name: "toggleCanvasMenu", label: "buttons.menu", trackEvent: { category: "menu" }, perform: (e12, o3) => ({ appState: { ...o3, openMenu: o3.openMenu === "canvas" ? null : "canvas" }, captureUpdate: dr.EVENTUALLY }), PanelComponent: ({ appState: e12, updateData: o3 }) => jsxRuntimeExports.jsx(X, { type: "button", icon: vx, "aria-label": g("buttons.menu"), onClick: o3, selected: e12.openMenu === "canvas" }) });
L2({ name: "toggleEditMenu", label: "buttons.edit", trackEvent: { category: "menu" }, perform: (e12, o3) => ({ appState: { ...o3, openMenu: o3.openMenu === "shape" ? null : "shape" }, captureUpdate: dr.EVENTUALLY }), PanelComponent: ({ elements: e12, appState: o3, updateData: t3 }) => jsxRuntimeExports.jsx(X, { visible: O9(o3, Es(e12)), type: "button", icon: Vx, "aria-label": g("buttons.edit"), onClick: t3, selected: o3.openMenu === "shape" }) });
var wn = L2({ name: "toggleShortcuts", label: "welcomeScreen.defaults.helpHint", icon: Nx, viewMode: true, trackEvent: { category: "menu", action: "toggleHelpDialog" }, perform: (e12, o3, t3, { focusContainer: r3 }) => (o3.openDialog?.name === "help" && r3(), { appState: { ...o3, openDialog: o3.openDialog?.name === "help" ? null : { name: "help" } }, captureUpdate: dr.EVENTUALLY }), keyTest: (e12) => e12.key === Q.QUESTION_MARK });
var pI = (e12) => {
  if (e12.length >= 2) {
    let o3 = e12[0].groupIds;
    for (let t3 of o3) if (e12.reduce((r3, n3) => r3 && Lb(n3, t3), true)) return true;
  }
  return false;
}, av = (e12, o3, t3) => {
  let r3 = t3.scene.getSelectedElements({ selectedElementIds: o3.selectedElementIds, includeBoundTextElement: true });
  return r3.length >= 2 && !pI(r3) && !IH(r3);
}, Xp = L2({ name: "group", label: "labels.group", icon: (e12) => jsxRuntimeExports.jsx(Mh, { theme: e12.theme }), trackEvent: { category: "element" }, perform: (e12, o3, t3, r3) => {
  let n3 = cs(r3.scene.getSelectedElements({ selectedElementIds: o3.selectedElementIds, includeBoundTextElement: true }));
  if (n3.length < 2) return { appState: o3, elements: e12, captureUpdate: dr.EVENTUALLY };
  let i3 = dF(o3);
  if (i3.length === 1) {
    let b3 = i3[0], x3 = new Set(an(e12, b3).map((w3) => w3.id)), T3 = new Set(n3.map((w3) => w3.id));
    if ((/* @__PURE__ */ new Set([...Array.from(x3), ...Array.from(T3)])).size === x3.size) return { appState: o3, elements: e12, captureUpdate: dr.EVENTUALLY };
  }
  let a3 = [...e12];
  new Set(n3.map((b3) => b3.frameId)).size > 1 && bH(n3).forEach((x3, T3) => {
    Xp$1(x3, r3.scene.getNonDeletedElementsMap());
  });
  let s3 = Dt(), c3 = te(n3);
  a3 = a3.map((b3) => c3.get(b3.id) ? vt$1(b3, { groupIds: UF(b3.groupIds, s3, o3.editingGroupId) }) : b3);
  let m3 = an(a3, s3), d3 = m3[m3.length - 1], p3 = a3.lastIndexOf(d3), u3 = a3.slice(p3 + 1), h3 = a3.slice(0, p3).filter((b3) => !Lb(b3, s3)), f3 = Zr([...h3, ...m3, ...u3], te(m3));
  return { appState: { ...o3, ...Tb(s3, { ...o3, selectedGroupIds: {} }, Es(a3)) }, elements: f3, captureUpdate: dr.IMMEDIATELY };
}, predicate: (e12, o3, t3, r3) => av(e12, o3, r3), keyTest: (e12) => !e12.shiftKey && e12[Q.CTRL_OR_CMD] && e12.key === Q.G, PanelComponent: ({ elements: e12, appState: o3, updateData: t3, app: r3 }) => jsxRuntimeExports.jsx(X, { hidden: !av(e12, o3, r3), type: "button", icon: jsxRuntimeExports.jsx(Mh, { theme: o3.theme }), onClick: () => t3(null), title: `${g("labels.group")}  ${cg$1("CtrlOrCmd+G")}`, "aria-label": g("labels.group"), visible: Ib(Es(e12), o3) }) }), $p = L2({ name: "ungroup", label: "labels.ungroup", icon: (e12) => jsxRuntimeExports.jsx(Lh, { theme: e12.theme }), trackEvent: { category: "element" }, perform: (e12, o3, t3, r3) => {
  let n3 = dF(o3), i3 = te(e12);
  if (n3.length === 0) return { appState: o3, elements: e12, captureUpdate: dr.EVENTUALLY };
  let a3 = [...e12], l3 = [];
  a3 = a3.map((p3) => {
    Ne(p3) && l3.push(p3.id);
    let u3 = fF(p3.groupIds, o3.selectedGroupIds);
    return u3.length === p3.groupIds.length ? p3 : vt$1(p3, { groupIds: u3 });
  });
  let s3 = aF(o3, Es(a3), o3, null), c3 = r3.scene.getSelectedElements(o3), m3 = new Set(c3.filter((p3) => p3.frameId).map((p3) => p3.frameId));
  return ds(e12).filter((p3) => m3.has(p3.id)).forEach((p3) => {
    p3 && (a3 = hH(a3, EH(a3, p3, o3, i3), p3, r3));
  }), s3.selectedElementIds = Object.entries(s3.selectedElementIds).reduce((p3, [u3, h3]) => (h3 && !l3.includes(u3) && (p3[u3] = true), p3), {}), { appState: { ...o3, ...s3 }, elements: a3, captureUpdate: dr.IMMEDIATELY };
}, keyTest: (e12) => e12.shiftKey && e12[Q.CTRL_OR_CMD] && e12.key === Q.G.toUpperCase(), predicate: (e12, o3) => dF(o3).length > 0, PanelComponent: ({ elements: e12, appState: o3, updateData: t3 }) => jsxRuntimeExports.jsx(X, { type: "button", hidden: dF(o3).length === 0, icon: jsxRuntimeExports.jsx(Lh, { theme: o3.theme }), onClick: () => t3(null), title: `${g("labels.ungroup")}  ${cg$1("CtrlOrCmd+Shift+G")}`, "aria-label": g("labels.ungroup"), visible: Ib(Es(e12), o3) }) });
var xc = (e12, o3, t3, r3, n3, i3, a3) => {
  e12.beginPath(), e12.moveTo(o3 + i3, t3), e12.lineTo(o3 + r3 - i3, t3), e12.quadraticCurveTo(o3 + r3, t3, o3 + r3, t3 + i3), e12.lineTo(o3 + r3, t3 + n3 - i3), e12.quadraticCurveTo(o3 + r3, t3 + n3, o3 + r3 - i3, t3 + n3), e12.lineTo(o3 + i3, t3 + n3), e12.quadraticCurveTo(o3, t3 + n3, o3, t3 + n3 - i3), e12.lineTo(o3, t3 + i3), e12.quadraticCurveTo(o3, t3, o3 + i3, t3), e12.closePath(), e12.fill(), a3 && (e12.strokeStyle = a3), e12.stroke();
};
function uI(e12) {
  let o3 = 0;
  if (e12.length === 0) return o3;
  for (let t3 = 0; t3 < e12.length; t3++) {
    let r3 = e12.charCodeAt(t3);
    o3 = (o3 << 5) - o3 + r3;
  }
  return o3;
}
var Tn = (e12, o3) => `hsl(${Math.abs(uI(o3?.id || e12)) % 37 * 10}, 100%, 83%)`, lv = (e12) => {
  let o3 = e12?.trim()?.codePointAt(0);
  return (o3 ? String.fromCodePoint(o3) : "?").toUpperCase();
}, sv = ({ context: e12, renderConfig: o3, appState: t3, normalizedWidth: r3, normalizedHeight: n3 }) => {
  for (let [i3, a3] of o3.remotePointerViewportCoords) {
    let { x: l3, y: s3 } = a3, c3 = t3.collaborators.get(i3);
    l3 -= t3.offsetLeft, s3 -= t3.offsetTop;
    let m3 = 11, d3 = 14, p3 = l3 < 0 || l3 > r3 - m3 || s3 < 0 || s3 > n3 - d3;
    l3 = Math.max(l3, 0), l3 = Math.min(l3, r3 - m3), s3 = Math.max(s3, 0), s3 = Math.min(s3, n3 - d3);
    let u3 = Tn(i3, c3);
    e12.save(), e12.strokeStyle = u3, e12.fillStyle = u3;
    let h3 = o3.remotePointerUserStates.get(i3), f3 = p3 || h3 === "idle" || h3 === "away";
    f3 && (e12.globalAlpha = 0.3), o3.remotePointerButton.get(i3) === "down" && (e12.beginPath(), e12.arc(l3, s3, 15, 0, 2 * Math.PI, false), e12.lineWidth = 3, e12.strokeStyle = "#ffffff88", e12.stroke(), e12.closePath(), e12.beginPath(), e12.arc(l3, s3, 15, 0, 2 * Math.PI, false), e12.lineWidth = 1, e12.strokeStyle = u3, e12.stroke(), e12.closePath());
    let b3 = t3.theme === ke.DARK ? "#2f6330" : IE, x3 = c3?.isSpeaking;
    x3 && (e12.fillStyle = b3, e12.strokeStyle = b3, e12.lineWidth = 10, e12.lineJoin = "round", e12.beginPath(), e12.moveTo(l3, s3), e12.lineTo(l3 + 0, s3 + 14), e12.lineTo(l3 + 4, s3 + 9), e12.lineTo(l3 + 11, s3 + 8), e12.closePath(), e12.stroke(), e12.fill()), e12.fillStyle = hE, e12.strokeStyle = hE, e12.lineWidth = 6, e12.lineJoin = "round", e12.beginPath(), e12.moveTo(l3, s3), e12.lineTo(l3 + 0, s3 + 14), e12.lineTo(l3 + 4, s3 + 9), e12.lineTo(l3 + 11, s3 + 8), e12.closePath(), e12.stroke(), e12.fill(), e12.fillStyle = u3, e12.strokeStyle = u3, e12.lineWidth = 2, e12.lineJoin = "round", e12.beginPath(), f3 ? (e12.moveTo(l3 - 1, s3 - 1), e12.lineTo(l3 - 1, s3 + 15), e12.lineTo(l3 + 5, s3 + 10), e12.lineTo(l3 + 12, s3 + 9), e12.closePath(), e12.fill()) : (e12.moveTo(l3, s3), e12.lineTo(l3 + 0, s3 + 14), e12.lineTo(l3 + 4, s3 + 9), e12.lineTo(l3 + 11, s3 + 8), e12.closePath(), e12.fill(), e12.stroke());
    let T3 = o3.remotePointerUsernames.get(i3) || "";
    if (!p3 && T3) {
      e12.font = "600 12px sans-serif";
      let E3 = (x3 ? l3 + 0 : l3) + m3 / 2, w3 = (x3 ? s3 + 0 : s3) + d3 + 2, S3 = 5, I3 = 3, _3 = e12.measureText(T3), k2 = _3.actualBoundingBoxDescent + _3.actualBoundingBoxAscent, R3 = Math.max(k2, 12), M = E3 - 1, N3 = w3 - 1, G3 = _3.width + 2 + S3 * 2 + 2, H3 = R3 + 2 + I3 * 2 + 2;
      if (e12.roundRect ? (e12.beginPath(), e12.roundRect(M, N3, G3, H3, 8), e12.fillStyle = u3, e12.fill(), e12.strokeStyle = hE, e12.stroke(), x3 && (e12.beginPath(), e12.roundRect(M - 2, N3 - 2, G3 + 4, H3 + 4, 8), e12.strokeStyle = b3, e12.stroke())) : xc(e12, M, N3, G3, H3, 8, hE), e12.fillStyle = yE, e12.fillText(T3, E3 + S3 + 1, w3 + I3 + _3.actualBoundingBoxAscent + Math.floor((R3 - k2) / 2) + 2), x3) {
        e12.fillStyle = b3;
        let V3 = 8, F3 = 8, O3 = 5;
        e12.fillRect(M + G3 + F3, N3 + (H3 / 2 - V3 / 2), 2, V3), e12.fillRect(M + G3 + F3 + O3, N3 + (H3 / 2 - V3 * 2 / 2), 2, V3 * 2), e12.fillRect(M + G3 + F3 + O3 * 2, N3 + (H3 / 2 - V3 / 2), 2, V3);
      }
    }
    e12.restore(), e12.closePath();
  }
};
var Zp = ({ color: e12, onClick: o3, name: t3, src: r3, className: n3 }) => {
  let i3 = lv(t3), [a3, l3] = reactExports.useState(false), s3 = !a3 && r3, c3 = s3 ? void 0 : { background: e12 };
  return jsxRuntimeExports.jsx("div", { className: dM("Avatar", n3), style: c3, onClick: o3, children: s3 ? jsxRuntimeExports.jsx("img", { className: "Avatar-img", src: r3, alt: i3, referrerPolicy: "no-referrer", onError: () => l3(true) }) : i3 });
};
L2({ name: "goToCollaborator", label: "Go to a collaborator", viewMode: true, trackEvent: { category: "collab" }, perform: (e12, o3, t3) => !t3.socketId || o3.userToFollow?.socketId === t3.socketId || t3.isCurrentUser ? { appState: { ...o3, userToFollow: null }, captureUpdate: dr.EVENTUALLY } : { appState: { ...o3, userToFollow: { socketId: t3.socketId, username: t3.username || "" }, openMenu: o3.openMenu === "canvas" ? null : o3.openMenu }, captureUpdate: dr.EVENTUALLY }, PanelComponent: ({ updateData: e12, data: o3, appState: t3 }) => {
  let { socketId: r3, collaborator: n3, withName: i3, isBeingFollowed: a3 } = o3, l3 = Tn(r3, n3), s3 = dM({ "is-followed": a3, "is-current-user": n3.isCurrentUser === true, "is-speaking": n3.isSpeaking, "is-in-call": n3.isInCall, "is-muted": n3.isMuted }), c3 = n3.isInCall ? n3.isSpeaking ? jsxRuntimeExports.jsxs("div", { className: "UserList__collaborator-status-icon-speaking-indicator", title: g("userList.hint.isSpeaking"), children: [jsxRuntimeExports.jsx("div", {}), jsxRuntimeExports.jsx("div", {}), jsxRuntimeExports.jsx("div", {})] }) : n3.isMuted ? jsxRuntimeExports.jsx("div", { className: "UserList__collaborator-status-icon-microphone-muted", title: g("userList.hint.micMuted"), children: J4 }) : jsxRuntimeExports.jsx("div", { title: g("userList.hint.inCall"), children: H4 }) : null;
  return i3 ? jsxRuntimeExports.jsxs("div", { className: `dropdown-menu-item dropdown-menu-item-base UserList__collaborator ${s3}`, style: { "--avatar-size": "1.5rem" }, onClick: () => e12(n3), children: [jsxRuntimeExports.jsx(Zp, { color: l3, onClick: () => {
  }, name: n3.username || "", src: n3.avatarUrl, className: s3 }), jsxRuntimeExports.jsx("div", { className: "UserList__collaborator-name", children: n3.username }), jsxRuntimeExports.jsxs("div", { className: "UserList__collaborator-status-icons", "aria-hidden": true, children: [a3 && jsxRuntimeExports.jsx("div", { className: "UserList__collaborator-status-icon-is-followed", title: g("userList.hint.followStatus"), children: F4 }), c3] })] }) : jsxRuntimeExports.jsxs("div", { className: `UserList__collaborator UserList__collaborator--avatar-only ${s3}`, children: [jsxRuntimeExports.jsx(Zp, { color: l3, onClick: () => {
    e12(n3);
  }, name: n3.username || "", src: n3.avatarUrl, className: s3 }), c3 && jsxRuntimeExports.jsx("div", { className: "UserList__collaborator-status-icon", children: c3 })] });
} });
var jp = L2({ name: "addToLibrary", trackEvent: { category: "element" }, perform: (e12, o3, t3, r3) => {
  let n3 = r3.scene.getSelectedElements({ selectedElementIds: o3.selectedElementIds, includeBoundTextElement: true, includeElementsInFrames: true });
  for (let i3 of JE$1) if (n3.some((a3) => a3.type === i3)) return { captureUpdate: dr.EVENTUALLY, appState: { ...o3, errorMessage: g(`errors.libraryElementTypeError.${i3}`) } };
  return r3.library.getLatestLibrary().then((i3) => r3.library.setLibrary([{ id: Dt(), status: "unpublished", elements: n3.map(Gr), created: Date.now() }, ...i3])).then(() => ({ captureUpdate: dr.EVENTUALLY, appState: { ...o3, toast: { message: g("toast.addedToLibrary") } } })).catch((i3) => ({ captureUpdate: dr.EVENTUALLY, appState: { ...o3, errorMessage: i3.message } }));
}, label: "labels.addToLibrary" });
var dv = (e12, o3, t3, r3) => {
  let n3 = Ja$1(e12, o3), i3 = Na$1(e12);
  return n3.flatMap((a3) => {
    let l3 = xI(a3, i3, t3);
    return a3.map((s3) => {
      let c3 = Y(s3, { x: s3.x + l3.x, y: s3.y + l3.y });
      return Jt(s3, r3.getNonDeletedElementsMap(), { simultaneouslyUpdated: a3 }), c3;
    });
  });
}, xI = (e12, o3, { axis: t3, position: r3 }) => {
  let n3 = Na$1(e12), [i3, a3] = t3 === "x" ? ["minX", "maxX"] : ["minY", "maxY"], l3 = { x: 0, y: 0 };
  return r3 === "start" ? { ...l3, [t3]: o3[i3] - n3[i3] } : r3 === "end" ? { ...l3, [t3]: o3[a3] - n3[a3] } : { ...l3, [t3]: (o3[i3] + o3[a3]) / 2 - (n3[i3] + n3[a3]) / 2 };
};
var _t = (e12, o3) => {
  let t3 = o3.scene.getSelectedElements(e12);
  return t3.length > 1 && !t3.some((r3) => de(r3));
}, Li = (e12, o3, t3, r3) => {
  let n3 = t3.scene.getSelectedElements(o3), i3 = te(e12), a3 = dv(n3, i3, r3, t3.scene), l3 = te(a3);
  return yH(e12.map((s3) => l3.get(s3.id) || s3), o3, t3);
};
L2({ name: "alignTop", label: "labels.alignTop", icon: Uh, trackEvent: { category: "element" }, predicate: (e12, o3, t3, r3) => _t(o3, r3), perform: (e12, o3, t3, r3) => ({ appState: o3, elements: Li(e12, o3, r3, { position: "start", axis: "y" }), captureUpdate: dr.IMMEDIATELY }), keyTest: (e12) => e12[Q.CTRL_OR_CMD] && e12.shiftKey && e12.key === Q.ARROW_UP, PanelComponent: ({ elements: e12, appState: o3, updateData: t3, app: r3 }) => jsxRuntimeExports.jsx(X, { hidden: !_t(o3, r3), type: "button", icon: Uh, onClick: () => t3(null), title: `${g("labels.alignTop")}  ${cg$1("CtrlOrCmd+Shift+Up")}`, "aria-label": g("labels.alignTop"), visible: Ib(Es(e12), o3) }) });
L2({ name: "alignBottom", label: "labels.alignBottom", icon: fh, trackEvent: { category: "element" }, predicate: (e12, o3, t3, r3) => _t(o3, r3), perform: (e12, o3, t3, r3) => ({ appState: o3, elements: Li(e12, o3, r3, { position: "end", axis: "y" }), captureUpdate: dr.IMMEDIATELY }), keyTest: (e12) => e12[Q.CTRL_OR_CMD] && e12.shiftKey && e12.key === Q.ARROW_DOWN, PanelComponent: ({ elements: e12, appState: o3, updateData: t3, app: r3 }) => jsxRuntimeExports.jsx(X, { hidden: !_t(o3, r3), type: "button", icon: fh, onClick: () => t3(null), title: `${g("labels.alignBottom")}  ${cg$1("CtrlOrCmd+Shift+Down")}`, "aria-label": g("labels.alignBottom"), visible: Ib(Es(e12), o3) }) });
L2({ name: "alignLeft", label: "labels.alignLeft", icon: ph, trackEvent: { category: "element" }, predicate: (e12, o3, t3, r3) => _t(o3, r3), perform: (e12, o3, t3, r3) => ({ appState: o3, elements: Li(e12, o3, r3, { position: "start", axis: "x" }), captureUpdate: dr.IMMEDIATELY }), keyTest: (e12) => e12[Q.CTRL_OR_CMD] && e12.shiftKey && e12.key === Q.ARROW_LEFT, PanelComponent: ({ elements: e12, appState: o3, updateData: t3, app: r3 }) => jsxRuntimeExports.jsx(X, { hidden: !_t(o3, r3), type: "button", icon: ph, onClick: () => t3(null), title: `${g("labels.alignLeft")}  ${cg$1("CtrlOrCmd+Shift+Left")}`, "aria-label": g("labels.alignLeft"), visible: Ib(Es(e12), o3) }) });
L2({ name: "alignRight", label: "labels.alignRight", icon: uh, trackEvent: { category: "element" }, predicate: (e12, o3, t3, r3) => _t(o3, r3), perform: (e12, o3, t3, r3) => ({ appState: o3, elements: Li(e12, o3, r3, { position: "end", axis: "x" }), captureUpdate: dr.IMMEDIATELY }), keyTest: (e12) => e12[Q.CTRL_OR_CMD] && e12.shiftKey && e12.key === Q.ARROW_RIGHT, PanelComponent: ({ elements: e12, appState: o3, updateData: t3, app: r3 }) => jsxRuntimeExports.jsx(X, { hidden: !_t(o3, r3), type: "button", icon: uh, onClick: () => t3(null), title: `${g("labels.alignRight")}  ${cg$1("CtrlOrCmd+Shift+Right")}`, "aria-label": g("labels.alignRight"), visible: Ib(Es(e12), o3) }) });
L2({ name: "alignVerticallyCentered", label: "labels.centerVertically", icon: Eh, trackEvent: { category: "element" }, predicate: (e12, o3, t3, r3) => _t(o3, r3), perform: (e12, o3, t3, r3) => ({ appState: o3, elements: Li(e12, o3, r3, { position: "center", axis: "y" }), captureUpdate: dr.IMMEDIATELY }), PanelComponent: ({ elements: e12, appState: o3, updateData: t3, app: r3 }) => jsxRuntimeExports.jsx(X, { hidden: !_t(o3, r3), type: "button", icon: Eh, onClick: () => t3(null), title: g("labels.centerVertically"), "aria-label": g("labels.centerVertically"), visible: Ib(Es(e12), o3) }) });
L2({ name: "alignHorizontallyCentered", label: "labels.centerHorizontally", icon: gh, trackEvent: { category: "element" }, predicate: (e12, o3, t3, r3) => _t(o3, r3), perform: (e12, o3, t3, r3) => ({ appState: o3, elements: Li(e12, o3, r3, { position: "center", axis: "x" }), captureUpdate: dr.IMMEDIATELY }), PanelComponent: ({ elements: e12, appState: o3, updateData: t3, app: r3 }) => jsxRuntimeExports.jsx(X, { hidden: !_t(o3, r3), type: "button", icon: gh, onClick: () => t3(null), title: g("labels.centerHorizontally"), "aria-label": g("labels.centerHorizontally"), visible: Ib(Es(e12), o3) }) });
var mv = (e12, o3, t3) => {
  let [r3, n3, i3, a3] = t3.axis === "x" ? ["minX", "midX", "maxX", "width"] : ["minY", "midY", "maxY", "height"], l3 = Na$1(e12), s3 = Ja$1(e12, o3).map((p3) => [p3, Na$1(p3)]).sort((p3, u3) => p3[1][n3] - u3[1][n3]), c3 = 0;
  for (let p3 of s3) c3 += p3[1][a3];
  let m3 = (l3[a3] - c3) / (s3.length - 1);
  if (m3 < 0) {
    let p3 = s3.findIndex((b3) => b3[1][r3] === l3[r3]), u3 = s3.findIndex((b3) => b3[1][i3] === l3[i3]), h3 = (s3[u3][1][n3] - s3[p3][1][n3]) / (s3.length - 1), f3 = s3[p3][1][n3];
    return s3.flatMap(([b3, x3], T3) => {
      let E3 = { x: 0, y: 0 };
      return T3 !== p3 && T3 !== u3 && (f3 += h3, E3[t3.axis] = f3 - x3[n3]), b3.map((w3) => vt$1(w3, { x: w3.x + E3.x, y: w3.y + E3.y }));
    });
  }
  let d3 = l3[r3];
  return s3.flatMap(([p3, u3]) => {
    let h3 = { x: 0, y: 0 };
    return h3[t3.axis] = d3 - u3[r3], d3 += m3, d3 += u3[a3], p3.map((f3) => vt$1(f3, { x: f3.x + h3.x, y: f3.y + h3.y }));
  });
};
var pv = (e12, o3) => {
  let t3 = o3.scene.getSelectedElements(e12);
  return t3.length > 1 && !t3.some((r3) => de(r3));
}, uv = (e12, o3, t3, r3) => {
  let n3 = t3.scene.getSelectedElements(o3), i3 = mv(n3, t3.scene.getNonDeletedElementsMap(), r3), a3 = te(i3);
  return yH(e12.map((l3) => a3.get(l3.id) || l3), o3, t3);
};
L2({ name: "distributeHorizontally", label: "labels.distributeHorizontally", trackEvent: { category: "element" }, perform: (e12, o3, t3, r3) => ({ appState: o3, elements: uv(e12, o3, r3, { axis: "x" }), captureUpdate: dr.IMMEDIATELY }), keyTest: (e12) => !e12[Q.CTRL_OR_CMD] && e12.altKey && e12.code === D1.H, PanelComponent: ({ elements: e12, appState: o3, updateData: t3, app: r3 }) => jsxRuntimeExports.jsx(X, { hidden: !pv(o3, r3), type: "button", icon: mh, onClick: () => t3(null), title: `${g("labels.distributeHorizontally")}  ${cg$1("Alt+H")}`, "aria-label": g("labels.distributeHorizontally"), visible: Ib(Es(e12), o3) }) });
L2({ name: "distributeVertically", label: "labels.distributeVertically", trackEvent: { category: "element" }, perform: (e12, o3, t3, r3) => ({ appState: o3, elements: uv(e12, o3, r3, { axis: "y" }), captureUpdate: dr.IMMEDIATELY }), keyTest: (e12) => !e12[Q.CTRL_OR_CMD] && e12.altKey && e12.code === D1.V, PanelComponent: ({ elements: e12, appState: o3, updateData: t3, app: r3 }) => jsxRuntimeExports.jsx(X, { hidden: !pv(o3, r3), type: "button", icon: bh, onClick: () => t3(null), title: `${g("labels.distributeVertically")}  ${cg$1("Alt+V")}`, "aria-label": g("labels.distributeVertically"), visible: Ib(Es(e12), o3) }) });
var Jp = L2({ name: "flipHorizontal", label: "labels.flipHorizontal", icon: X4, trackEvent: { category: "element" }, perform: (e12, o3, t3, r3) => ({ elements: yH(hv(e12, r3.scene.getNonDeletedElementsMap(), o3, "horizontal", r3), o3, r3), appState: o3, captureUpdate: dr.IMMEDIATELY }), keyTest: (e12) => e12.shiftKey && e12.code === D1.H }), qp = L2({ name: "flipVertical", label: "labels.flipVertical", icon: q4, trackEvent: { category: "element" }, perform: (e12, o3, t3, r3) => ({ elements: yH(hv(e12, r3.scene.getNonDeletedElementsMap(), o3, "vertical", r3), o3, r3), appState: o3, captureUpdate: dr.IMMEDIATELY }), keyTest: (e12) => e12.shiftKey && e12.code === D1.V && !e12[Q.CTRL_OR_CMD] }), hv = (e12, o3, t3, r3, n3) => {
  let i3 = at$1(Es(e12), t3, { includeBoundTextElement: true, includeElementsInFrames: true }), a3 = kI(i3, o3, t3, r3, n3), l3 = te(a3);
  return e12.map((s3) => l3.get(s3.id) || s3);
}, kI = (e12, o3, t3, r3, n3) => {
  if (e12.every((u3) => ee(u3) && (u3.startBinding || u3.endBinding))) return e12.map((u3) => {
    let h3 = u3;
    return vt$1(h3, { startArrowhead: h3.endArrowhead, endArrowhead: h3.startArrowhead });
  });
  let { midX: i3, midY: a3 } = Na$1(e12);
  P9(e12, o3, "nw", n3.scene, new Map(Array.from(o3.values()).map((u3) => [u3.id, Gr(u3)])), { flipByX: r3 === "horizontal", flipByY: r3 === "vertical", shouldResizeFromCenter: true, shouldMaintainAspectRatio: true }), BN(e12.filter(ae), o3, n3.scene.getNonDeletedElements(), n3.scene, Fa$1(t3), [], t3.zoom);
  let { elbowArrows: l3, otherElements: s3 } = e12.reduce((u3, h3) => X$1(h3) ? { ...u3, elbowArrows: u3.elbowArrows.concat(h3) } : { ...u3, otherElements: u3.otherElements.concat(h3) }, { elbowArrows: [], otherElements: [] }), { midX: c3, midY: m3 } = Na$1(e12), [d3, p3] = [i3 - c3, a3 - m3];
  return s3.forEach((u3) => Y(u3, { x: u3.x + d3, y: u3.y + p3 })), l3.forEach((u3) => Y(u3, { x: u3.x + d3, y: u3.y + p3 })), e12;
};
var _i = L2({ name: "copy", label: "labels.copy", icon: Lx, trackEvent: { category: "element" }, perform: async (e12, o3, t3, r3) => {
  let n3 = r3.scene.getSelectedElements({ selectedElementIds: o3.selectedElementIds, includeBoundTextElement: true, includeElementsInFrames: true });
  try {
    await Np(n3, r3.files, t3);
  } catch (i3) {
    return { captureUpdate: dr.EVENTUALLY, appState: { ...o3, errorMessage: i3.message } };
  }
  return { captureUpdate: dr.EVENTUALLY };
}, keyTest: void 0 }), Qp = L2({ name: "paste", label: "labels.paste", trackEvent: { category: "element" }, perform: async (e12, o3, t3, r3) => {
  let n3;
  try {
    n3 = await SK();
  } catch (i3) {
    return i3.name === "AbortError" || i3.name === "NotAllowedError" ? false : (console.error(`actionPaste ${i3.name}: ${i3.message}`), aE ? { captureUpdate: dr.EVENTUALLY, appState: { ...o3, errorMessage: g("hints.firefox_clipboard_write") } } : { captureUpdate: dr.EVENTUALLY, appState: { ...o3, errorMessage: g("errors.asyncPasteFailedOnRead") } });
  }
  try {
    r3.pasteFromClipboard(DK({ types: n3 }));
  } catch (i3) {
    return console.error(i3), { captureUpdate: dr.EVENTUALLY, appState: { ...o3, errorMessage: g("errors.asyncPasteFailedOnParse") } };
  }
  return { captureUpdate: dr.EVENTUALLY };
}, keyTest: void 0 }), yc = L2({ name: "cut", label: "labels.cut", icon: g4, trackEvent: { category: "element" }, perform: (e12, o3, t3, r3) => (_i.perform(e12, o3, t3, r3), _a.perform(e12, o3, null, r3)), keyTest: (e12) => e12[Q.CTRL_OR_CMD] && e12.key === Q.X }), vc = L2({ name: "copyAsSvg", label: "labels.copyAsSvg", icon: Z4, trackEvent: { category: "element" }, perform: async (e12, o3, t3, r3) => {
  if (!r3.canvas) return { captureUpdate: dr.EVENTUALLY };
  let { exportedElements: n3, exportingFrame: i3 } = yn(e12, o3, true);
  try {
    await vn("clipboard-svg", n3, o3, r3.files, { ...o3, exportingFrame: i3, name: r3.getName() });
    let a3 = r3.scene.getSelectedElements({ selectedElementIds: o3.selectedElementIds, includeBoundTextElement: true, includeElementsInFrames: true });
    return { appState: { toast: { message: g("toast.copyToClipboardAsSvg", { exportSelection: a3.length ? g("toast.selection") : g("toast.canvas"), exportColorScheme: o3.exportWithDarkMode ? g("buttons.darkMode") : g("buttons.lightMode") }) } }, captureUpdate: dr.EVENTUALLY };
  } catch (a3) {
    return console.error(a3), { appState: { errorMessage: a3.message }, captureUpdate: dr.EVENTUALLY };
  }
}, predicate: (e12) => k7 && e12.length > 0, keywords: ["svg", "clipboard", "copy"] }), wc = L2({ name: "copyAsPng", label: "labels.copyAsPng", icon: W4, trackEvent: { category: "element" }, perform: async (e12, o3, t3, r3) => {
  if (!r3.canvas) return { captureUpdate: dr.EVENTUALLY };
  let n3 = r3.scene.getSelectedElements({ selectedElementIds: o3.selectedElementIds, includeBoundTextElement: true, includeElementsInFrames: true }), { exportedElements: i3, exportingFrame: a3 } = yn(e12, o3, true);
  try {
    return await vn("clipboard", i3, o3, r3.files, { ...o3, exportingFrame: a3, name: r3.getName() }), { appState: { ...o3, toast: { message: g("toast.copyToClipboardAsPng", { exportSelection: n3.length ? g("toast.selection") : g("toast.canvas"), exportColorScheme: o3.exportWithDarkMode ? g("buttons.darkMode") : g("buttons.lightMode") }) } }, captureUpdate: dr.EVENTUALLY };
  } catch (l3) {
    return console.error(l3), { appState: { ...o3, errorMessage: l3.message }, captureUpdate: dr.EVENTUALLY };
  }
}, predicate: (e12) => LK && e12.length > 0, keyTest: (e12) => e12.code === D1.C && e12.altKey && e12.shiftKey, keywords: ["png", "clipboard", "copy"] }), Tc = L2({ name: "copyText", label: "labels.copyText", trackEvent: { category: "element" }, perform: (e12, o3, t3, r3) => {
  let n3 = r3.scene.getSelectedElements({ selectedElementIds: o3.selectedElementIds, includeBoundTextElement: true });
  try {
    hs(Bb(n3));
  } catch {
    throw new Error(g("errors.copyToSystemClipboardFailed"));
  }
  return { captureUpdate: dr.EVENTUALLY };
}, predicate: (e12, o3, t3, r3) => k7 && r3.scene.getSelectedElements({ selectedElementIds: o3.selectedElementIds, includeBoundTextElement: true }).some(k$2), keywords: ["text", "clipboard", "copy"] });
var Cc = L2({ name: "gridMode", icon: ny$1, keywords: ["snap"], label: "labels.toggleGrid", viewMode: true, trackEvent: { category: "canvas", predicate: (e12) => e12.gridModeEnabled }, perform(e12, o3) {
  return { appState: { ...o3, gridModeEnabled: !this.checked(o3), objectsSnapModeEnabled: false }, captureUpdate: dr.EVENTUALLY };
}, checked: (e12) => e12.gridModeEnabled, predicate: (e12, o3, t3) => t3.gridModeEnabled === void 0, keyTest: (e12) => e12[Q.CTRL_OR_CMD] && e12.code === D1.QUOTE });
var Mi = L2({ name: "zenMode", label: "buttons.zenMode", icon: Q4, paletteName: "Toggle zen mode", viewMode: true, trackEvent: { category: "canvas", predicate: (e12) => !e12.zenModeEnabled }, perform(e12, o3) {
  return { appState: { ...o3, zenModeEnabled: !this.checked(o3) }, captureUpdate: dr.EVENTUALLY };
}, checked: (e12) => e12.zenModeEnabled, predicate: (e12, o3, t3) => typeof t3.zenModeEnabled > "u", keyTest: (e12) => !e12[Q.CTRL_OR_CMD] && e12.altKey && e12.code === D1.Z });
var eu = L2({ name: "objectsSnapMode", label: "buttons.objectsSnapMode", icon: z4, viewMode: false, trackEvent: { category: "canvas", predicate: (e12) => !e12.objectsSnapModeEnabled }, perform(e12, o3) {
  return { appState: { ...o3, objectsSnapModeEnabled: !this.checked(o3), gridModeEnabled: false }, captureUpdate: dr.EVENTUALLY };
}, checked: (e12) => e12.objectsSnapModeEnabled, predicate: (e12, o3, t3) => typeof t3.objectsSnapModeEnabled > "u", keyTest: (e12) => !e12[Q.CTRL_OR_CMD] && e12.altKey && e12.code === D1.S });
var Di = L2({ name: "stats", label: "stats.fullTitle", icon: V4, paletteName: "Toggle stats", viewMode: true, trackEvent: { category: "menu" }, keywords: ["edit", "attributes", "customize"], perform(e12, o3) {
  return { appState: { ...o3, stats: { ...o3.stats, open: !this.checked(o3) } }, captureUpdate: dr.EVENTUALLY };
}, checked: (e12) => e12.stats.open, keyTest: (e12) => !e12[Q.CTRL_OR_CMD] && e12.altKey && e12.code === D1.SLASH });
var tu = L2({ name: "unbindText", label: "labels.unbindText", trackEvent: { category: "element" }, predicate: (e12, o3, t3, r3) => r3.scene.getSelectedElements(o3).some((i3) => bn(i3)), perform: (e12, o3, t3, r3) => {
  let n3 = r3.scene.getSelectedElements(o3), i3 = r3.scene.getNonDeletedElementsMap();
  return n3.forEach((a3) => {
    let l3 = oe(a3, i3);
    if (l3) {
      let { width: s3, height: c3 } = ht(l3.originalText, Ee(l3), l3.lineHeight), m3 = WF(a3.id);
      w2(a3.id);
      let { x: d3, y: p3 } = R2(a3, l3, i3);
      Y(l3, { containerId: null, width: s3, height: c3, text: l3.originalText, x: d3, y: p3 }), Y(a3, { boundElements: a3.boundElements?.filter((u3) => u3.id !== l3.id), height: m3 || a3.height });
    }
  }), { elements: e12, appState: o3, captureUpdate: dr.IMMEDIATELY };
} }), ou = L2({ name: "bindText", label: "labels.bindText", trackEvent: { category: "element" }, predicate: (e12, o3, t3, r3) => {
  let n3 = r3.scene.getSelectedElements(o3);
  if (n3.length === 2) {
    let i3 = k$2(n3[0]) || k$2(n3[1]), a3;
    if (F6(n3[0]) ? a3 = n3[0] : F6(n3[1]) && (a3 = n3[1]), i3 && a3 && oe(a3, r3.scene.getNonDeletedElementsMap()) === null) return true;
  }
  return false;
}, perform: (e12, o3, t3, r3) => {
  let n3 = r3.scene.getSelectedElements(o3), i3, a3;
  k$2(n3[0]) && F6(n3[1]) ? (i3 = n3[0], a3 = n3[1]) : (i3 = n3[1], a3 = n3[0]), Y(i3, { containerId: a3.id, verticalAlign: kt.MIDDLE, textAlign: Xi$1.CENTER, autoResize: true }), Y(a3, { boundElements: (a3.boundElements || []).concat({ type: "text", id: i3.id }) });
  let l3 = a3.height;
  return Xa$1(i3, a3, r3.scene.getNonDeletedElementsMap()), I2(a3.id, l3), { elements: LI(e12, a3, i3), appState: { ...o3, selectedElementIds: { [a3.id]: true } }, captureUpdate: dr.IMMEDIATELY };
} }), LI = (e12, o3, t3) => {
  let r3 = e12.slice(), n3 = r3.findIndex((a3) => a3.id === t3.id);
  r3.splice(n3, 1);
  let i3 = r3.findIndex((a3) => a3.id === o3.id);
  return r3.splice(i3 + 1, 0, t3), Zr(r3, te([o3, t3])), r3;
}, AI = (e12, o3, t3) => {
  let r3 = e12.slice(), n3 = r3.findIndex((a3) => a3.id === o3.id);
  r3.splice(n3, 1);
  let i3 = r3.findIndex((a3) => a3.id === t3.id);
  return r3.splice(i3, 0, o3), Zr(r3, te([o3, t3])), r3;
}, fv = L2({ name: "wrapTextInContainer", label: "labels.createContainerFromText", trackEvent: { category: "element" }, predicate: (e12, o3, t3, r3) => {
  let n3 = r3.scene.getSelectedElements(o3), i3 = n3.every((a3) => k$2(a3));
  return n3.length > 0 && i3;
}, perform: (e12, o3, t3, r3) => {
  let n3 = r3.scene.getSelectedElements(o3), i3 = e12.slice(), a3 = {};
  for (let l3 of n3) if (k$2(l3)) {
    let s3 = Xr({ type: "rectangle", backgroundColor: o3.currentItemBackgroundColor, boundElements: [...l3.boundElements || [], { id: l3.id, type: "text" }], angle: l3.angle, fillStyle: o3.currentItemFillStyle, strokeColor: o3.currentItemStrokeColor, roughness: o3.currentItemRoughness, strokeWidth: o3.currentItemStrokeWidth, strokeStyle: o3.currentItemStrokeStyle, roundness: o3.currentItemRoundness === "round" ? { type: Oo$1("rectangle") ? ot.ADAPTIVE_RADIUS : ot.PROPORTIONAL_RADIUS } : null, opacity: 100, locked: false, x: l3.x - Se, y: l3.y - Se, width: qa(l3.width, "rectangle"), height: qa(l3.height, "rectangle"), groupIds: l3.groupIds, frameId: l3.frameId });
    if (l3.boundElements?.length) {
      let c3 = l3.boundElements.filter((d3) => d3.type === "arrow").map((d3) => d3.id);
      i3.filter((d3) => c3.includes(d3.id)).forEach((d3) => {
        let p3 = d3.startBinding, u3 = d3.endBinding;
        p3?.elementId === l3.id && (p3 = { ...p3, elementId: s3.id }), u3?.elementId === l3.id && (u3 = { ...u3, elementId: s3.id }), (p3 || u3) && Y(d3, { startBinding: p3, endBinding: u3 }, false);
      });
    }
    Y(l3, { containerId: s3.id, verticalAlign: kt.MIDDLE, boundElements: null, textAlign: Xi$1.CENTER, autoResize: true }, false), Xa$1(l3, s3, r3.scene.getNonDeletedElementsMap()), i3 = AI([...i3, s3], s3, l3), a3[s3.id] = true;
  }
  return { elements: i3, appState: { ...o3, selectedElementIds: a3 }, captureUpdate: dr.IMMEDIATELY };
} });
var iu = 380, RI = 42, ru = 5, yv = 85, NI = 500, nu = false, Ic = /* @__PURE__ */ new Map(), vv = ({ element: e12, elementsMap: o3, setAppState: t3, onLinkOpen: r3, setToast: n3, updateEmbedValidationStatus: i3 }) => {
  let a3 = Mo(), l3 = Do(), s3 = me(), c3 = e12.link || "", [m3, d3] = reactExports.useState(c3), p3 = reactExports.useRef(null), u3 = a3.showHyperlinkPopup === "editor", h3 = reactExports.useCallback(() => {
    if (!p3.current) return;
    let E3 = dn(p3.current.value) || null;
    if (!e12.link && E3 && le("hyperlink", "create"), Bo(e12)) {
      if (a3.activeEmbeddable?.element === e12 && t3({ activeEmbeddable: null }), !E3) {
        Y(e12, { link: null }), i3(e12, false);
        return;
      }
      if (!Y_(E3, l3.validateEmbeddable)) E3 && n3({ message: g("toast.unableToEmbed"), closable: true }), e12.link && Ic.set(e12.id, e12.link), Y(e12, { link: E3 }), i3(e12, false);
      else {
        let { width: w3, height: S3 } = e12, I3 = V2(E3);
        I3?.error instanceof URIError && n3({ message: g("toast.unrecognizedLinkFormat"), closable: true });
        let _3 = I3 ? I3.intrinsicSize.w / I3.intrinsicSize.h : 1, k2 = Ic.get(e12.id) !== e12.link;
        Y(e12, { ...k2 ? { width: I3?.type === "video" ? w3 > S3 ? w3 : S3 * _3 : w3, height: I3?.type === "video" && w3 > S3 ? w3 / _3 : S3 } : {}, link: E3 }), i3(e12, true), Ic.has(e12.id) && Ic.delete(e12.id);
      }
    } else Y(e12, { link: E3 });
  }, [e12, n3, l3.validateEmbeddable, a3.activeEmbeddable, t3, i3]);
  reactExports.useLayoutEffect(() => () => {
    h3();
  }, [h3]), reactExports.useEffect(() => {
    u3 && p3?.current && !(s3.viewport.isMobile || s3.isTouchScreen) && p3.current.select();
  }, [u3, s3.viewport.isMobile, s3.isTouchScreen]), reactExports.useEffect(() => {
    let E3 = null, w3 = (S3) => {
      if (u3) return;
      E3 && clearTimeout(E3), FI(e12, o3, a3, u$1(S3.clientX, S3.clientY)) && (E3 = window.setTimeout(() => {
        t3({ showHyperlinkPopup: false });
      }, NI));
    };
    return window.addEventListener("pointermove", w3, false), () => {
      window.removeEventListener("pointermove", w3, false), E3 && clearTimeout(E3);
    };
  }, [a3, e12, u3, t3, o3]);
  let f3 = reactExports.useCallback(() => {
    le("hyperlink", "delete"), Y(e12, { link: null }), t3({ showHyperlinkPopup: false });
  }, [t3, e12]), b3 = () => {
    le("hyperlink", "edit", "popup-ui"), t3({ showHyperlinkPopup: "editor" });
  }, { x: x3, y: T3 } = wv(e12, a3, o3);
  return a3.contextMenu || a3.selectedElementsAreBeingDragged || a3.resizingElement || a3.isRotating || a3.openMenu || a3.viewModeEnabled ? null : jsxRuntimeExports.jsxs("div", { className: "excalidraw-hyperlinkContainer", style: { top: `${T3}px`, left: `${x3}px`, width: iu, padding: ru }, children: [u3 ? jsxRuntimeExports.jsx("input", { className: dM("excalidraw-hyperlinkContainer-input"), placeholder: g("labels.link.hint"), ref: p3, value: m3, onChange: (E3) => d3(E3.target.value), autoFocus: true, onKeyDown: (E3) => {
    E3.stopPropagation(), E3[Q.CTRL_OR_CMD] && E3.key === Q.K && E3.preventDefault(), (E3.key === Q.ENTER || E3.key === Q.ESCAPE) && (h3(), t3({ showHyperlinkPopup: "info" }));
  } }) : e12.link ? jsxRuntimeExports.jsx("a", { href: dn(e12.link || ""), className: "excalidraw-hyperlinkContainer-link", target: gB(e12.link) ? "_self" : "_blank", onClick: (E3) => {
    if (e12.link && r3) {
      let w3 = yg("excalidraw-link", E3.nativeEvent);
      r3({ ...e12, link: dn(e12.link) }, w3), w3.defaultPrevented && E3.preventDefault();
    }
  }, rel: "noopener noreferrer", children: e12.link }) : jsxRuntimeExports.jsx("div", { className: "excalidraw-hyperlinkContainer-link", children: g("labels.link.empty") }), jsxRuntimeExports.jsxs("div", { className: "excalidraw-hyperlinkContainer__buttons", children: [!u3 && jsxRuntimeExports.jsx(X, { type: "button", title: g("buttons.edit"), "aria-label": g("buttons.edit"), label: g("buttons.edit"), onClick: b3, className: "excalidraw-hyperlinkContainer--edit", icon: Nr$1 }), jsxRuntimeExports.jsx(X, { type: "button", title: g("labels.linkToElement"), "aria-label": g("labels.linkToElement"), label: g("labels.linkToElement"), onClick: () => {
    t3({ openDialog: { name: "elementLinkSelector", sourceElementId: e12.id } });
  }, icon: Uy$1 }), c3 && !Bo(e12) && jsxRuntimeExports.jsx(X, { type: "button", title: g("buttons.remove"), "aria-label": g("buttons.remove"), label: g("buttons.remove"), onClick: f3, className: "excalidraw-hyperlinkContainer--remove", icon: Tx })] })] });
}, wv = (e12, o3, t3) => {
  let [r3, n3] = C$1(e12, t3), { x: i3, y: a3 } = ta({ sceneX: r3 + e12.width / 2, sceneY: n3 }, o3), l3 = i3 - o3.offsetLeft - iu / 2, s3 = a3 - o3.offsetTop - yv;
  return { x: l3, y: s3 };
}, au = (e12, o3) => {
  let t3 = at$1(e12, o3);
  return Bo(t3[0]) ? "labels.link.editEmbed" : t3[0]?.link ? "labels.link.edit" : "labels.link.create";
}, Ha = null, Tv = (e12, o3, t3) => {
  Ha && clearTimeout(Ha), Ha = window.setTimeout(() => OI(e12, o3, t3), SE);
}, OI = (e12, o3, t3) => {
  if (!e12.link) return;
  let r3 = Ii();
  r3.classList.add("excalidraw-tooltip--visible"), r3.style.maxWidth = "20rem", r3.textContent = op(e12.link) ? g("labels.link.goToElement") : e12.link;
  let [n3, i3, a3, l3] = C$1(e12, t3), [s3, c3, m3, d3] = is([n3, i3, a3, l3], e12.angle, o3), p3 = ta({ sceneX: s3, sceneY: c3 }, o3);
  Gp(r3, { left: p3.x, top: p3.y, width: m3, height: d3 }, "top"), le("hyperlink", "tooltip", "link-icon"), nu = true;
}, lu = () => {
  Ha && clearTimeout(Ha), nu && (nu = false, Ii().classList.remove("excalidraw-tooltip--visible"));
}, FI = (e12, o3, t3, [r3, n3]) => {
  let { x: i3, y: a3 } = Dn({ clientX: r3, clientY: n3 }, t3), l3 = 15 / t3.zoom.value;
  if (ba(i3, a3, e12, o3)) return false;
  let [s3, c3, m3] = C$1(e12, o3);
  if (i3 >= s3 && i3 <= m3 && a3 >= c3 - yv && a3 <= c3) return false;
  let { x: d3, y: p3 } = wv(e12, t3, o3);
  return !(r3 >= d3 - l3 && r3 <= d3 + iu + ru * 2 + l3 && n3 >= p3 - l3 && n3 <= p3 + l3 + ru * 2 + RI);
};
var Ga = L2({ name: "hyperlink", label: (e12, o3) => au(e12, o3), icon: Kx, perform: (e12, o3) => o3.showHyperlinkPopup === "editor" ? false : { elements: e12, appState: { ...o3, showHyperlinkPopup: "editor", openMenu: null }, captureUpdate: dr.IMMEDIATELY }, trackEvent: { category: "hyperlink", action: "click" }, keyTest: (e12) => e12[Q.CTRL_OR_CMD] && e12.key === Q.K, predicate: (e12, o3) => at$1(e12, o3).length === 1, PanelComponent: ({ elements: e12, appState: o3, updateData: t3 }) => {
  let r3 = at$1(e12, o3);
  return jsxRuntimeExports.jsx(X, { type: "button", icon: Kx, "aria-label": g(au(e12, o3)), title: `${Bo(e12[0]) ? g("labels.link.labelEmbed") : g("labels.link.label")} - ${cg$1("CtrlOrCmd+K")}`, onClick: () => t3(null), selected: r3.length === 1 && !!r3[0].link });
} });
var su = (e12) => e12.every((o3) => !o3.locked), cu = L2({ name: "toggleElementLock", label: (e12, o3, t3) => {
  let r3 = t3.scene.getSelectedElements({ selectedElementIds: o3.selectedElementIds, includeBoundTextElement: false });
  return r3.length === 1 && !de(r3[0]) ? r3[0].locked ? "labels.elementLock.unlock" : "labels.elementLock.lock" : su(r3) ? "labels.elementLock.lockAll" : "labels.elementLock.unlockAll";
}, icon: (e12, o3) => {
  let t3 = at$1(o3, e12);
  return su(t3) ? bx : mx;
}, trackEvent: { category: "element" }, predicate: (e12, o3, t3, r3) => {
  let n3 = r3.scene.getSelectedElements(o3);
  return n3.length > 0 && !n3.some((i3) => i3.locked && i3.frameId);
}, perform: (e12, o3, t3, r3) => {
  let n3 = r3.scene.getSelectedElements({ selectedElementIds: o3.selectedElementIds, includeBoundTextElement: true, includeElementsInFrames: true });
  if (!n3.length) return false;
  let i3 = su(n3), a3 = te(n3);
  return { elements: e12.map((l3) => a3.has(l3.id) ? vt$1(l3, { locked: i3 }) : l3), appState: { ...o3, selectedLinearElement: i3 ? null : o3.selectedLinearElement }, captureUpdate: dr.IMMEDIATELY };
}, keyTest: (e12, o3, t3, r3) => e12.key.toLocaleLowerCase() === Q.L && e12[Q.CTRL_OR_CMD] && e12.shiftKey && r3.scene.getSelectedElements({ selectedElementIds: o3.selectedElementIds, includeBoundTextElement: false }).length > 0 }), Cv = L2({ name: "unlockAllElements", paletteName: "Unlock all elements", trackEvent: { category: "canvas" }, viewMode: false, icon: mx, predicate: (e12, o3) => at$1(e12, o3).length === 0 && e12.some((r3) => r3.locked), perform: (e12, o3) => {
  let t3 = e12.filter((r3) => r3.locked);
  return { elements: e12.map((r3) => r3.locked ? vt$1(r3, { locked: false }) : r3), appState: { ...o3, selectedElementIds: Object.fromEntries(t3.map((r3) => [r3.id, true])) }, captureUpdate: dr.IMMEDIATELY };
}, label: "labels.elementLock.unlockAll" });
var Iv = () => {
  let [e12, o3] = reactExports.useState(null), t3 = reactExports.useCallback((r3) => o3(r3), []);
  return [e12, t3];
};
var kv = (e12) => {
  let { closeOnClickOutside: o3 = true } = e12, t3 = ec({ className: "excalidraw-modal-container" }), r3 = reactExports.useRef(document.body.classList.contains("excalidraw-animations-disabled"));
  if (!t3) return null;
  let n3 = (i3) => {
    i3.key === Q.ESCAPE && (i3.nativeEvent.stopImmediatePropagation(), i3.stopPropagation(), e12.onCloseRequest());
  };
  return reactDomExports.createPortal(jsxRuntimeExports.jsxs("div", { className: dM("Modal", e12.className, { "animations-disabled": r3.current }), role: "dialog", "aria-modal": "true", onKeyDown: n3, "aria-labelledby": e12.labelledBy, "data-prevent-outside-click": true, children: [jsxRuntimeExports.jsx("div", { className: "Modal__background", onClick: o3 ? e12.onCloseRequest : void 0 }), jsxRuntimeExports.jsx("div", { className: "Modal__content", style: { "--max-width": `${e12.maxWidth}px` }, tabIndex: 0, children: e12.children })] }), t3);
};
var du = atom(/* @__PURE__ */ new Map()), Lv = async (e12) => await r9({ elements: e12, appState: { exportBackground: false, viewBackgroundColor: Z.white }, files: null, renderEmbeddables: false, skipInliningFonts: true }), Av = (e12, o3, t3) => {
  let [r3, n3] = reactExports.useState();
  return reactExports.useEffect(() => {
    if (o3) if (e12) {
      let i3 = t3.get(e12);
      i3 ? n3(i3) : (async () => {
        let a3 = await Lv(o3);
        a3.querySelector(".style-fonts")?.remove(), a3 && (t3.set(e12, a3), n3(a3));
      })();
    } else (async () => {
      let i3 = await Lv(o3);
      n3(i3);
    })();
  }, [e12, o3, t3, n3]), r3;
}, Sc = () => {
  let [e12] = ce(du);
  return { clearLibraryCache: () => e12.clear(), deleteItemsFromLibraryCache: (r3) => {
    r3.forEach((n3) => e12.delete(n3));
  }, svgCache: e12 };
};
var kc = class {
  constructor() {
    i$1(this, "jobs", []);
    i$1(this, "running", false);
  }
  tick() {
    if (this.running) return;
    let o3 = this.jobs.shift();
    o3 ? (this.running = true, o3.promise.resolve(mn(o3.jobFactory, ...o3.args).finally(() => {
      this.running = false, this.tick();
    }))) : this.running = false;
  }
  push(o3, ...t3) {
    let r3 = ug$1();
    return this.jobs.push({ jobFactory: o3, promise: r3, args: t3 }), this.tick(), r3;
  }
};
var Pv = new hi(), Cn = atom({ status: "loaded", isInitialized: false, libraryItems: [] }), Ya = (e12) => Lg$1(e12), $I = (e12, o3) => !e12.find((t3) => t3.elements.length !== o3.elements.length ? false : t3.elements.every((r3, n3) => r3.id === o3.elements[n3].id && r3.versionNonce === o3.elements[n3].versionNonce)), Rv = (e12, o3) => {
  let t3 = [];
  for (let r3 of o3) $I(e12, r3) && t3.push(r3);
  return [...t3, ...e12];
}, Nv = (e12, o3) => {
  let t3 = te(o3), r3 = { deletedItems: /* @__PURE__ */ new Map(), addedItems: /* @__PURE__ */ new Map() };
  for (let i3 of e12) t3.has(i3.id) || r3.deletedItems.set(i3.id, i3);
  let n3 = te(e12);
  for (let i3 of o3) n3.has(i3.id) || r3.addedItems.set(i3.id, i3);
  return r3;
}, mu = class {
  constructor(o3) {
    i$1(this, "currLibraryItems", []);
    i$1(this, "prevLibraryItems", Ya(this.currLibraryItems));
    i$1(this, "app");
    i$1(this, "updateQueue", []);
    i$1(this, "getLastUpdateTask", () => this.updateQueue[this.updateQueue.length - 1]);
    i$1(this, "notifyListeners", () => {
      if (this.updateQueue.length > 0) st.set(Cn, (o5) => ({ status: "loading", libraryItems: this.currLibraryItems, isInitialized: o5.isInitialized }));
      else {
        st.set(Cn, { status: "loaded", libraryItems: this.currLibraryItems, isInitialized: true });
        try {
          let o5 = this.prevLibraryItems;
          this.prevLibraryItems = Ya(this.currLibraryItems);
          let t3 = Ya(this.currLibraryItems);
          this.app.props.onLibraryChange?.(t3), Pv.trigger(Nv(o5, t3), t3);
        } catch (o5) {
          console.error(o5);
        }
      }
    });
    i$1(this, "destroy", () => {
      this.updateQueue = [], this.currLibraryItems = [], st.set(du, /* @__PURE__ */ new Map());
    });
    i$1(this, "resetLibrary", () => this.setLibrary([]));
    i$1(this, "getLatestLibrary", () => new Promise(async (o5) => {
      try {
        let t3 = await (this.getLastUpdateTask() || this.currLibraryItems);
        this.updateQueue.length > 0 ? o5(this.getLatestLibrary()) : o5(Ya(t3));
      } catch {
        return o5(this.currLibraryItems);
      }
    }));
    i$1(this, "updateLibrary", async ({ libraryItems: o5, prompt: t3 = false, merge: r3 = false, openLibraryMenu: n3 = false, defaultStatus: i3 = "unpublished" }) => (n3 && this.app.setState({ openSidebar: { name: ks.name, tab: b6 } }), this.setLibrary(() => new Promise(async (a3, l3) => {
      try {
        let s3 = await (typeof o5 == "function" && !(o5 instanceof Blob) ? o5(this.currLibraryItems) : o5), c3;
        s3 instanceof Blob ? c3 = await SY(s3, i3) : c3 = Lp(s3, i3), !t3 || window.confirm(g("alerts.confirmAddLibrary", { numShapes: c3.length })) ? (t3 && this.app.focusContainer(), a3(r3 ? Rv(this.currLibraryItems, c3) : c3)) : l3(new Co());
      } catch (s3) {
        l3(s3);
      }
    }))));
    i$1(this, "setLibrary", (o5) => {
      let t3 = new Promise(async (r3, n3) => {
        try {
          await this.getLastUpdateTask(), typeof o5 == "function" && (o5 = o5(this.currLibraryItems)), this.currLibraryItems = Ya(await o5), r3(this.currLibraryItems);
        } catch (i3) {
          n3(i3);
        }
      }).catch((r3) => {
        if (r3.name === "AbortError") return console.warn("Library update aborted by user"), this.currLibraryItems;
        throw r3;
      }).finally(() => {
        this.updateQueue = this.updateQueue.filter((r3) => r3 !== t3), this.notifyListeners();
      });
      return this.updateQueue.push(t3), this.notifyListeners(), t3;
    });
    this.app = o3;
  }
}, Ov = mu, _c = (e12) => {
  let t3 = Math.ceil(Math.sqrt(e12.length)), r3 = [], n3 = (u3) => e12.slice(u3 * t3, u3 * t3 + t3).reduce((f3, b3) => {
    let { height: x3 } = Na$1(b3.elements);
    return Math.max(f3, x3);
  }, 0), i3 = (u3) => {
    let h3 = 0, f3 = 0, b3 = 0;
    for (let x3 of e12) {
      if (h3 % t3 === 0 && (f3 = 0), f3 === u3) {
        let { width: T3 } = Na$1(x3.elements);
        b3 = Math.max(b3, T3);
      }
      h3++, f3++;
    }
    return b3;
  }, a3 = 0, l3 = 0, s3 = 0, c3 = 0, m3 = 0, d3 = 0, p3 = 0;
  for (let u3 of e12) {
    m3 && m3 % t3 === 0 && (l3 += s3 + 50, a3 = 0, d3 = 0, p3++), d3 === 0 && (s3 = n3(p3)), c3 = i3(d3);
    let { minX: h3, minY: f3, width: b3, height: x3 } = Na$1(u3.elements), T3 = (c3 - b3) / 2, E3 = (s3 - x3) / 2;
    r3.push(...u3.elements.map((w3) => ({ ...w3, x: w3.x + a3 + T3 - h3, y: w3.y + l3 + E3 - f3 }))), a3 += c3 + 50, m3++, d3++;
  }
  return r3;
}, _r = class _r2 {
  constructor(o3) {
    i$1(this, "adapter");
    this.adapter = o3;
  }
  static async getLibraryItems(o3, t3, r3 = true) {
    let n3 = () => new Promise(async (i3, a3) => {
      try {
        let l3 = await o3.load({ source: t3 });
        i3(Lp(l3?.libraryItems || [], "published"));
      } catch (l3) {
        a3(l3);
      }
    });
    return r3 ? _r2.queue.push(n3) : n3();
  }
  getLibraryItems(o3) {
    return _r2.getLibraryItems(this.adapter, o3, false);
  }
};
i$1(_r, "queue", new kc()), i$1(_r, "run", async (o3, t3) => {
  let r3 = new _r(o3);
  return _r.queue.push(() => t3(r3));
});
var JI = reactExports.forwardRef(({ children: e12, gap: o3, align: t3, justifyContent: r3, className: n3, style: i3 }, a3) => jsxRuntimeExports.jsx("div", { className: dM("Stack Stack_horizontal", n3), style: { "--gap": o3, alignItems: t3, justifyContent: r3, ...i3 }, ref: a3, children: e12 })), qI = reactExports.forwardRef(({ children: e12, gap: o3, align: t3, justifyContent: r3, className: n3, style: i3 }, a3) => jsxRuntimeExports.jsx("div", { className: dM("Stack Stack_vertical", n3), style: { "--gap": o3, justifyItems: t3, justifyContent: r3, ...i3 }, ref: a3, children: e12 })), it = { Row: JI, Col: qI };
var QI = ({ theme: e12, id: o3, libraryReturnUrl: t3 }) => {
  let r3 = t3 || window.location.origin + window.location.pathname;
  return jsxRuntimeExports.jsx("a", { className: "library-menu-browse-button", href: `${c$1.VITE_APP_LIBRARY_URL}?target=${window.name || "_blank"}&referrer=${r3}&useHash=true&token=${o3}&theme=${e12}&version=${qi.excalidrawLibrary}`, target: "_excalidraw_libraries", children: g("labels.libraries") });
}, Uv = QI;
var Mc = ({ libraryReturnUrl: e12, theme: o3, id: t3, style: r3, children: n3, className: i3 }) => jsxRuntimeExports.jsxs("div", { className: dM("library-menu-control-buttons", i3), style: r3, children: [jsxRuntimeExports.jsx(Uv, { id: t3, libraryReturnUrl: e12, theme: o3 }), n3] });
var nS = /({{[\w-]+}})|(<[\w-]+>)|(<\/[\w-]+>)/g, iS = /{{([\w-]+)}}/, aS = /<([\w-]+)>/, lS = /<\/([\w-]+)>/, sS = (e12, o3) => {
  let t3 = [{ name: "", children: [] }];
  return e12.split(nS).filter(Boolean).forEach((r3) => {
    let n3 = r3.match(aS), i3 = r3.match(lS), a3 = r3.match(iS);
    if (n3 !== null) {
      let l3 = n3[1];
      o3.hasOwnProperty(l3) ? t3.push({ name: l3, children: [] }) : console.warn(`Trans: missed to pass in prop ${l3} for interpolating ${e12}`);
    } else if (i3 !== null) if (i3[1] === t3[t3.length - 1].name) {
      let s3 = t3.pop(), c3 = React.createElement(React.Fragment, {}, ...s3.children), m3 = o3[s3.name];
      typeof m3 == "function" && t3[t3.length - 1].children.push(m3(c3));
    } else console.warn(`Trans: unexpected end tag ${r3} for interpolating ${e12}`);
    else if (a3 !== null) {
      let l3 = a3[1];
      o3.hasOwnProperty(l3) ? t3[t3.length - 1].children.push(o3[l3]) : console.warn(`Trans: key ${l3} not in props for interpolating ${e12}`);
    } else t3[t3.length - 1].children.push(r3);
  }), t3.length !== 1 && console.warn(`Trans: stack not empty for interpolating ${e12}`), t3[0].children;
}, cS = ({ i18nKey: e12, children: o3, ...t3 }) => {
  let { t: r3 } = Ve();
  return React.createElement(React.Fragment, {}, ...sS(r3(e12), t3));
}, Tt = cS;
var mS = ({ label: e12, onClick: o3, className: t3, children: r3, actionType: n3, type: i3 = "button", isLoading: a3, ...l3 }) => {
  let s3 = n3 ? `Dialog__action-button--${n3}` : "";
  return jsxRuntimeExports.jsxs("button", { className: dM("Dialog__action-button", s3, t3), type: i3, "aria-label": e12, onClick: o3, ...l3, children: [r3 && jsxRuntimeExports.jsx("div", { style: a3 ? { visibility: "hidden" } : {}, children: r3 }), jsxRuntimeExports.jsx("div", { style: a3 ? { visibility: "hidden" } : {}, children: e12 }), a3 && jsxRuntimeExports.jsx("div", { style: { position: "absolute", inset: 0 }, children: jsxRuntimeExports.jsx(ct, {}) })] });
}, or = mS;
var uS = (e12) => {
  let { onConfirm: o3, onCancel: t3, children: r3, confirmText: n3 = g("buttons.confirm"), cancelText: i3 = g("buttons.cancel"), className: a3 = "", ...l3 } = e12, s3 = pe(), c3 = Tr(Ni), { container: m3 } = Ke();
  return jsxRuntimeExports.jsxs(Ge, { onCloseRequest: t3, size: "small", ...l3, className: `confirm-dialog ${a3}`, children: [r3, jsxRuntimeExports.jsxs("div", { className: "confirm-dialog-buttons", children: [jsxRuntimeExports.jsx(or, { label: i3, onClick: () => {
    s3({ openMenu: null }), c3(false), reactDomExports.flushSync(() => {
      t3();
    }), m3?.focus();
  } }), jsxRuntimeExports.jsx(or, { label: n3, onClick: () => {
    s3({ openMenu: null }), c3(false), reactDomExports.flushSync(() => {
      o3();
    }), m3?.focus();
  }, actionType: "danger" })] })] });
}, Rc = uS;
var ro2 = class {
  static has(o3) {
    try {
      return !!window.localStorage.getItem(o3);
    } catch (t3) {
      return console.warn(`localStorage.getItem error: ${t3.message}`), false;
    }
  }
  static get(o3) {
    try {
      let t3 = window.localStorage.getItem(o3);
      return t3 ? JSON.parse(t3) : null;
    } catch (t3) {
      return console.warn(`localStorage.getItem error: ${t3.message}`), null;
    }
  }
};
i$1(ro2, "set", (o3, t3) => {
  try {
    return window.localStorage.setItem(o3, JSON.stringify(t3)), true;
  } catch (r3) {
    return console.warn(`localStorage.setItem error: ${r3.message}`), false;
  }
}), i$1(ro2, "delete", (o3) => {
  try {
    window.localStorage.removeItem(o3);
  } catch (t3) {
    console.warn(`localStorage.removeItem error: ${t3.message}`);
  }
});
var hS = async (e12) => {
  let r3 = Math.round(8), n3 = Math.max(Math.round(128 / 64), 2), i3 = dg(e12, 6), a3 = document.createElement("canvas");
  a3.width = i3[0].length * 128 + (i3[0].length + 1) * (r3 * 2) - r3 * 2, a3.height = i3.length * 128 + (i3.length + 1) * (r3 * 2) - r3 * 2;
  let l3 = a3.getContext("2d");
  l3.fillStyle = _d$1.white, l3.fillRect(0, 0, a3.width, a3.height);
  for (let [s3, c3] of e12.entries()) {
    let m3 = await t9({ elements: c3.elements, files: null, maxWidthOrHeight: 128 }), { width: d3, height: p3 } = m3, u3 = Math.floor(s3 / 6) * (128 + r3 * 2), h3 = s3 % 6 * (128 + r3 * 2);
    l3.drawImage(m3, h3 + (128 - d3) / 2 + r3, u3 + (128 - p3) / 2 + r3), l3.lineWidth = n3, l3.strokeStyle = _d$1.gray[4], l3.strokeRect(h3 + r3 / 2, u3 + r3 / 2, 128 + r3, 128 + r3);
  }
  return await _Y(new File([await vY(a3)], "preview", { type: H.png }), { outputType: H.jpg, maxWidthOrHeight: 5e3 });
}, fS = ({ libItem: e12, appState: o3, index: t3, onChange: r3, onRemove: n3 }) => {
  let i3 = reactExports.useRef(null), a3 = reactExports.useRef(null);
  return reactExports.useEffect(() => {
    let l3 = i3.current;
    l3 && (async () => {
      let s3 = await r9({ elements: e12.elements, appState: { ...o3, viewBackgroundColor: _d$1.white, exportBackground: true }, files: null, skipInliningFonts: true });
      l3.innerHTML = s3.outerHTML;
    })();
  }, [e12.elements, o3]), jsxRuntimeExports.jsxs("div", { className: "single-library-item", children: [e12.status === "published" && jsxRuntimeExports.jsx("span", { className: "single-library-item-status", children: g("labels.statusPublished") }), jsxRuntimeExports.jsx("div", { ref: i3, className: "single-library-item__svg" }), jsxRuntimeExports.jsx(X, { "aria-label": g("buttons.remove"), type: "button", icon: Ih, className: "single-library-item--remove", onClick: n3.bind(null, e12.id), title: g("buttons.remove") }), jsxRuntimeExports.jsxs("div", { style: { display: "flex", margin: "0.8rem 0", width: "100%", fontSize: "14px", fontWeight: 500, flexDirection: "column" }, children: [jsxRuntimeExports.jsxs("label", { style: { display: "flex", justifyContent: "space-between", flexDirection: "column" }, children: [jsxRuntimeExports.jsxs("div", { style: { padding: "0.5em 0" }, children: [jsxRuntimeExports.jsx("span", { style: { fontWeight: 500, color: _d$1.gray[6] }, children: g("publishDialog.itemName") }), jsxRuntimeExports.jsx("span", { "aria-hidden": "true", className: "required", children: "*" })] }), jsxRuntimeExports.jsx("input", { type: "text", ref: a3, style: { width: "80%", padding: "0.2rem" }, defaultValue: e12.name, placeholder: "Item name", onChange: (l3) => {
    r3(l3.target.value, t3);
  } })] }), jsxRuntimeExports.jsx("span", { className: "error", children: e12.error })] })] });
}, bS = ({ onClose: e12, libraryItems: o3, appState: t3, onSuccess: r3, onError: n3, updateItemsInStorage: i3, onRemove: a3 }) => {
  let [l3, s3] = reactExports.useState({ authorName: "", githubHandle: "", name: "", description: "", twitterHandle: "", website: "" }), [c3, m3] = reactExports.useState(false);
  reactExports.useEffect(() => {
    let E3 = ro2.get(YE$1.PUBLISH_LIBRARY);
    E3 && s3(E3);
  }, []);
  let [d3, p3] = reactExports.useState(o3.slice());
  reactExports.useEffect(() => {
    p3(o3.slice());
  }, [o3]);
  let u3 = (E3) => {
    s3({ ...l3, [E3.target.name]: E3.target.value });
  }, h3 = async (E3) => {
    E3.preventDefault(), m3(true);
    let w3 = [], S3 = false;
    if (d3.forEach((N3) => {
      let G3 = "";
      N3.name || (G3 = g("publishDialog.errors.required"), S3 = true), w3.push({ ...N3, error: G3 });
    }), S3) {
      p3(w3), m3(false);
      return;
    }
    let I3 = await hS(d3), _3 = { type: Ze.excalidrawLibrary, version: qi.excalidrawLibrary, source: Ci$1, libraryItems: d3 }, k2 = JSON.stringify(_3, null, 2), R3 = new Blob([k2], { type: "application/json" }), M = new FormData();
    M.append("excalidrawLib", R3), M.append("previewImage", I3), M.append("previewImageType", I3.type), M.append("title", l3.name), M.append("authorName", l3.authorName), M.append("githubHandle", l3.githubHandle), M.append("name", l3.name), M.append("description", l3.description), M.append("twitterHandle", l3.twitterHandle), M.append("website", l3.website), fetch(`${c$1.VITE_APP_LIBRARY_BACKEND}/submit`, { method: "post", body: M }).then((N3) => N3.ok ? N3.json().then(({ url: G3 }) => {
      ro2.delete(YE$1.PUBLISH_LIBRARY), r3({ url: G3, authorName: l3.authorName, items: d3 });
    }) : N3.json().catch(() => {
      throw new Error(N3.statusText || "something went wrong");
    }).then((G3) => {
      throw new Error(G3.message || N3.statusText || "something went wrong");
    }), (N3) => {
      console.error(N3), n3(N3), m3(false);
    }).catch((N3) => {
      console.error(N3), n3(N3), m3(false);
    });
  }, f3 = () => {
    let E3 = [];
    return d3.forEach((w3, S3) => {
      E3.push(jsxRuntimeExports.jsx("div", { className: "single-library-item-wrapper", children: jsxRuntimeExports.jsx(fS, { libItem: w3, appState: t3, index: S3, onChange: (I3, _3) => {
        let k2 = d3.slice();
        k2[_3].name = I3, p3(k2);
      }, onRemove: a3 }) }, S3));
    }), jsxRuntimeExports.jsx("div", { className: "selected-library-items", children: E3 });
  }, b3 = reactExports.useCallback(() => {
    i3(d3), ro2.set(YE$1.PUBLISH_LIBRARY, l3), e12();
  }, [d3, e12, i3, l3]), x3 = !!o3.length, T3 = o3.some((E3) => E3.status === "published");
  return jsxRuntimeExports.jsx(Ge, { onCloseRequest: b3, title: g("publishDialog.title"), className: "publish-library", children: x3 ? jsxRuntimeExports.jsxs("form", { onSubmit: h3, children: [jsxRuntimeExports.jsx("div", { className: "publish-library-note", children: jsxRuntimeExports.jsx(Tt, { i18nKey: "publishDialog.noteDescription", link: (E3) => jsxRuntimeExports.jsx("a", { href: "https://libraries.excalidraw.com", target: "_blank", rel: "noopener noreferrer", children: E3 }) }) }), jsxRuntimeExports.jsx("span", { className: "publish-library-note", children: jsxRuntimeExports.jsx(Tt, { i18nKey: "publishDialog.noteGuidelines", link: (E3) => jsxRuntimeExports.jsx("a", { href: "https://github.com/excalidraw/excalidraw-libraries#guidelines", target: "_blank", rel: "noopener noreferrer", children: E3 }) }) }), jsxRuntimeExports.jsx("div", { className: "publish-library-note", children: g("publishDialog.noteItems") }), T3 && jsxRuntimeExports.jsx("span", { className: "publish-library-note publish-library-warning", children: g("publishDialog.republishWarning") }), f3(), jsxRuntimeExports.jsxs("div", { className: "publish-library__fields", children: [jsxRuntimeExports.jsxs("label", { children: [jsxRuntimeExports.jsxs("div", { children: [jsxRuntimeExports.jsx("span", { children: g("publishDialog.libraryName") }), jsxRuntimeExports.jsx("span", { "aria-hidden": "true", className: "required", children: "*" })] }), jsxRuntimeExports.jsx("input", { type: "text", name: "name", required: true, value: l3.name, onChange: u3, placeholder: g("publishDialog.placeholder.libraryName") })] }), jsxRuntimeExports.jsxs("label", { style: { alignItems: "flex-start" }, children: [jsxRuntimeExports.jsxs("div", { children: [jsxRuntimeExports.jsx("span", { children: g("publishDialog.libraryDesc") }), jsxRuntimeExports.jsx("span", { "aria-hidden": "true", className: "required", children: "*" })] }), jsxRuntimeExports.jsx("textarea", { name: "description", rows: 4, required: true, value: l3.description, onChange: u3, placeholder: g("publishDialog.placeholder.libraryDesc") })] }), jsxRuntimeExports.jsxs("label", { children: [jsxRuntimeExports.jsxs("div", { children: [jsxRuntimeExports.jsx("span", { children: g("publishDialog.authorName") }), jsxRuntimeExports.jsx("span", { "aria-hidden": "true", className: "required", children: "*" })] }), jsxRuntimeExports.jsx("input", { type: "text", name: "authorName", required: true, value: l3.authorName, onChange: u3, placeholder: g("publishDialog.placeholder.authorName") })] }), jsxRuntimeExports.jsxs("label", { children: [jsxRuntimeExports.jsx("span", { children: g("publishDialog.githubUsername") }), jsxRuntimeExports.jsx("input", { type: "text", name: "githubHandle", value: l3.githubHandle, onChange: u3, placeholder: g("publishDialog.placeholder.githubHandle") })] }), jsxRuntimeExports.jsxs("label", { children: [jsxRuntimeExports.jsx("span", { children: g("publishDialog.twitterUsername") }), jsxRuntimeExports.jsx("input", { type: "text", name: "twitterHandle", value: l3.twitterHandle, onChange: u3, placeholder: g("publishDialog.placeholder.twitterHandle") })] }), jsxRuntimeExports.jsxs("label", { children: [jsxRuntimeExports.jsx("span", { children: g("publishDialog.website") }), jsxRuntimeExports.jsx("input", { type: "text", name: "website", pattern: "https?://.+", title: g("publishDialog.errors.website"), value: l3.website, onChange: u3, placeholder: g("publishDialog.placeholder.website") })] }), jsxRuntimeExports.jsx("span", { className: "publish-library-note", children: jsxRuntimeExports.jsx(Tt, { i18nKey: "publishDialog.noteLicense", link: (E3) => jsxRuntimeExports.jsx("a", { href: "https://github.com/excalidraw/excalidraw-libraries/blob/main/LICENSE", target: "_blank", rel: "noopener noreferrer", children: E3 }) }) })] }), jsxRuntimeExports.jsxs("div", { className: "publish-library__buttons", children: [jsxRuntimeExports.jsx(or, { label: g("buttons.cancel"), onClick: b3, "data-testid": "cancel-clear-canvas-button" }), jsxRuntimeExports.jsx(or, { type: "submit", label: g("buttons.submit"), actionType: "primary", isLoading: c3 })] })] }) : jsxRuntimeExports.jsx("p", { style: { padding: "1em", textAlign: "center", fontWeight: 500 }, children: g("publishDialog.atleastOneLibItem") }) });
}, Wv = bS;
var Kv = ({ className: e12 = "", children: o3, onToggle: t3, title: r3, ...n3 }) => {
  let i3 = me(), a3 = dM(`dropdown-menu-button ${e12}`, "zen-mode-transition", { "dropdown-menu-button--mobile": i3.editor.isMobile }).trim();
  return jsxRuntimeExports.jsx("button", { "data-prevent-outside-click": true, className: a3, onClick: t3, type: "button", "data-testid": "dropdown-menu-button", title: r3, ...n3, children: o3 });
}, Xv = Kv;
Kv.displayName = "DropdownMenuTrigger";
var $v = () => jsxRuntimeExports.jsx("div", { style: { height: "1px", backgroundColor: "var(--default-border-color)", margin: ".5rem 0" } }), Zv = $v;
$v.displayName = "DropdownMenuSeparator";
var jv = ({ children: e12, onClickOutside: o3, className: t3 = "", onSelect: r3, style: n3 }) => {
  let i3 = me(), a3 = reactExports.useRef(null), l3 = Ir({ onClickOutside: o3 });
  vi(a3, () => {
    l3.onClickOutside?.();
  }), reactExports.useEffect(() => {
    let c3 = (d3) => {
      d3.key === Q.ESCAPE && (d3.stopImmediatePropagation(), l3.onClickOutside?.());
    }, m3 = { capture: true };
    return document.addEventListener("keydown", c3, m3), () => {
      document.removeEventListener("keydown", c3, m3);
    };
  }, [l3]);
  let s3 = dM(`dropdown-menu ${t3}`, { "dropdown-menu--mobile": i3.editor.isMobile }).trim();
  return jsxRuntimeExports.jsx(Mp.Provider, { value: { onSelect: r3 }, children: jsxRuntimeExports.jsx("div", { ref: a3, className: s3, style: n3, "data-testid": "dropdown-menu", children: i3.editor.isMobile ? jsxRuntimeExports.jsx(it.Col, { className: "dropdown-menu-container", children: e12 }) : jsxRuntimeExports.jsx(Qe2, { className: "dropdown-menu-container", padding: 2, style: { zIndex: 2 }, children: e12 }) }) });
};
jv.displayName = "DropdownMenuContent";
var Jv = jv;
var Qv = ({ icon: e12, shortcut: o3, href: t3, children: r3, onSelect: n3, className: i3 = "", selected: a3, rel: l3 = "noreferrer", ...s3 }) => {
  let c3 = sc(s3.onClick, n3);
  return jsxRuntimeExports.jsx("a", { ...s3, href: t3, target: "_blank", rel: "noreferrer", className: lc(i3, a3), title: s3.title ?? s3["aria-label"], onClick: c3, children: jsxRuntimeExports.jsx(cc, { icon: e12, shortcut: o3, children: r3 }) });
}, Oi = Qv;
Qv.displayName = "DropdownMenuItemLink";
var CS = ({ children: e12, className: o3 = "", selected: t3, ...r3 }) => jsxRuntimeExports.jsx("div", { ...r3, className: `dropdown-menu-item-base dropdown-menu-item-custom ${o3} ${t3 ? "dropdown-menu-item--selected" : ""}`.trim(), children: e12 }), ew = CS;
var tw = (e12) => {
  let o3 = React.Children.toArray(e12).find((t3) => React.isValidElement(t3) && typeof t3.type != "string" && t3?.type.displayName && t3.type.displayName === "DropdownMenuTrigger");
  return o3 || null;
}, ow = (e12) => {
  let o3 = React.Children.toArray(e12).find((t3) => React.isValidElement(t3) && typeof t3.type != "string" && t3?.type.displayName && t3.type.displayName === "DropdownMenuContent");
  return o3 || null;
};
var rr2 = ({ children: e12, open: o3 }) => {
  let t3 = tw(e12), r3 = ow(e12);
  return jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [t3, o3 && r3] });
};
rr2.Trigger = Xv;
rr2.Content = Jv;
rr2.Item = vt;
rr2.ItemLink = Oi;
rr2.ItemCustom = ew;
rr2.Group = Na;
rr2.Separator = Zv;
var Ce = rr2;
rr2.displayName = "DropdownMenu";
var _S = (e12, o3) => e12.filter((t3) => o3.includes(t3.id)), MS = ({ setAppState: e12, selectedItems: o3, library: t3, onRemoveFromLibrary: r3, resetLibrary: n3, onSelectItems: i3, appState: a3, className: l3 }) => {
  let [s3] = ce(Cn), [c3, m3] = ce(Ni), d3 = () => {
    let M = o3.length ? g("alerts.removeItemsFromsLibrary", { count: o3.length }) : g("alerts.resetLibrary"), N3 = o3.length ? g("confirmDialog.removeItemsFromLib") : g("confirmDialog.resetLibrary");
    return jsxRuntimeExports.jsx(Rc, { onConfirm: () => {
      o3.length ? r3() : n3(), u3(false);
    }, onCancel: () => {
      u3(false);
    }, title: N3, children: jsxRuntimeExports.jsx("p", { children: M }) });
  }, [p3, u3] = reactExports.useState(false), h3 = !!o3.length, f3 = h3 ? s3.libraryItems.filter((M) => o3.includes(M.id)) : s3.libraryItems, b3 = h3 ? g("buttons.remove") : g("buttons.resetLibrary"), [x3, T3] = reactExports.useState(false), [E3, w3] = reactExports.useState(null), S3 = reactExports.useCallback(() => jsxRuntimeExports.jsxs(Ge, { onCloseRequest: () => w3(null), title: g("publishSuccessDialog.title"), className: "publish-library-success", size: "small", children: [jsxRuntimeExports.jsx("p", { children: jsxRuntimeExports.jsx(Tt, { i18nKey: "publishSuccessDialog.content", authorName: E3.authorName, link: (M) => jsxRuntimeExports.jsx("a", { href: E3?.url, target: "_blank", rel: "noopener noreferrer", children: M }) }) }), jsxRuntimeExports.jsx(X, { type: "button", title: g("buttons.close"), "aria-label": g("buttons.close"), label: g("buttons.close"), onClick: () => w3(null), "data-testid": "publish-library-success-close", className: "publish-library-success-close" })] }), [w3, E3]), I3 = (M, N3) => {
    T3(false), w3({ url: M.url, authorName: M.authorName });
    let G3 = N3.slice();
    G3.forEach((H3) => {
      o3.includes(H3.id) && (H3.status = "published");
    }), t3.setLibrary(G3);
  }, _3 = async () => {
    try {
      await t3.updateLibrary({ libraryItems: Z2({ description: "Excalidraw library files" }), merge: true, openLibraryMenu: true });
    } catch (M) {
      if (M?.name === "AbortError") {
        console.warn(M);
        return;
      }
      e12({ errorMessage: g("errors.importLibraryError") });
    }
  }, k2 = async () => {
    let M = h3 ? f3 : await t3.getLatestLibrary();
    IO(M).catch(Ug$1).catch((N3) => {
      e12({ errorMessage: N3.message });
    });
  }, R3 = () => jsxRuntimeExports.jsxs(Ce, { open: c3, children: [jsxRuntimeExports.jsx(Ce.Trigger, { onToggle: () => m3(!c3), children: px }), jsxRuntimeExports.jsxs(Ce.Content, { onClickOutside: () => m3(false), onSelect: () => m3(false), className: "library-menu", children: [!h3 && jsxRuntimeExports.jsx(Ce.Item, { onSelect: _3, icon: Yx, "data-testid": "lib-dropdown--load", children: g("buttons.load") }), !!f3.length && jsxRuntimeExports.jsx(Ce.Item, { onSelect: k2, icon: $x, "data-testid": "lib-dropdown--export", children: g("buttons.export") }), !!f3.length && jsxRuntimeExports.jsx(Ce.Item, { onSelect: () => u3(true), icon: Tx, children: b3 }), h3 && jsxRuntimeExports.jsx(Ce.Item, { icon: p4, onSelect: () => T3(true), "data-testid": "lib-dropdown--remove", children: g("buttons.publishLibrary") })] })] });
  return jsxRuntimeExports.jsxs("div", { className: dM("library-menu-dropdown-container", l3), children: [R3(), o3.length > 0 && jsxRuntimeExports.jsx("div", { className: "library-actions-counter", children: o3.length }), p3 && d3(), x3 && jsxRuntimeExports.jsx(Wv, { onClose: () => T3(false), libraryItems: _S(s3.libraryItems, o3), appState: a3, onSuccess: (M) => I3(M, s3.libraryItems), onError: (M) => window.alert(M), updateItemsInStorage: () => t3.setLibrary(s3.libraryItems), onRemove: (M) => i3(o3.filter((N3) => N3 !== M)) }), E3 && S3()] });
}, fu = ({ selectedItems: e12, onSelectItems: o3, className: t3 }) => {
  let { library: r3 } = He(), { clearLibraryCache: n3, deleteItemsFromLibraryCache: i3 } = Sc(), a3 = ve(), l3 = pe(), [s3] = ce(Cn), c3 = async (d3) => {
    let p3 = d3.filter((u3) => !e12.includes(u3.id));
    r3.setLibrary(p3).catch(() => {
      l3({ errorMessage: g("alerts.errorRemovingFromLibrary") });
    }), i3(e12), o3([]);
  };
  return jsxRuntimeExports.jsx(MS, { appState: a3, setAppState: l3, selectedItems: e12, onSelectItems: o3, library: r3, onRemoveFromLibrary: () => c3(s3.libraryItems), resetLibrary: () => {
    r3.resetLibrary(), n3();
  }, className: t3 });
};
var nw = reactExports.memo(({ id: e12, elements: o3, isPending: t3, onClick: r3, selected: n3, onToggle: i3, onDrag: a3, svgCache: l3 }) => {
  let s3 = reactExports.useRef(null), c3 = Av(e12, o3, l3);
  reactExports.useEffect(() => {
    let h3 = s3.current;
    if (h3) return c3 && (h3.innerHTML = c3.outerHTML), () => {
      h3.innerHTML = "";
    };
  }, [c3]);
  let [m3, d3] = reactExports.useState(false), p3 = me().editor.isMobile, u3 = t3 && jsxRuntimeExports.jsx("div", { className: "library-unit__adder", children: fx });
  return jsxRuntimeExports.jsxs("div", { className: dM("library-unit", { "library-unit__active": o3, "library-unit--hover": o3 && m3, "library-unit--selected": n3, "library-unit--skeleton": !c3 }), onMouseEnter: () => d3(true), onMouseLeave: () => d3(false), children: [jsxRuntimeExports.jsx("div", { className: dM("library-unit__dragger", { "library-unit__pulse": !!t3 }), ref: s3, draggable: !!o3, onClick: o3 || t3 ? (h3) => {
    e12 && h3.shiftKey ? i3(e12, h3) : r3(e12);
  } : void 0, onDragStart: (h3) => {
    if (!e12) {
      h3.preventDefault();
      return;
    }
    d3(false), a3(e12, h3);
  } }), u3, e12 && o3 && (m3 || p3 || n3) && jsxRuntimeExports.jsx(za, { checked: n3, onChange: (h3, f3) => i3(e12, f3), className: "library-unit__checkbox" })] });
}), iw = () => jsxRuntimeExports.jsx("div", { className: "library-unit library-unit--skeleton" });
function zS() {
  return [false, reactExports.useCallback((o3) => o3(), [])];
}
var aw = React.useTransition || zS;
var bu = ({ children: e12 }) => jsxRuntimeExports.jsx("div", { className: "library-menu-items-container__grid", children: e12 }), Hc = reactExports.memo(({ items: e12, onItemSelectToggle: o3, onItemDrag: t3, isItemSelected: r3, onClick: n3, svgCache: i3, itemsRenderedPerBatch: a3 }) => {
  let [, l3] = aw(), [s3, c3] = reactExports.useState(0);
  return reactExports.useEffect(() => {
    s3 < e12.length && l3(() => {
      c3(s3 + a3);
    });
  }, [s3, e12.length, l3, a3]), jsxRuntimeExports.jsx(jsxRuntimeExports.Fragment, { children: e12.map((m3, d3) => d3 < s3 ? jsxRuntimeExports.jsx(nw, { elements: m3?.elements, isPending: !m3?.id && !!m3?.elements, onClick: n3, svgCache: i3, id: m3?.id, selected: r3(m3.id), onToggle: o3, onDrag: t3 }, m3?.id ?? d3) : jsxRuntimeExports.jsx(iw, {}, d3)) });
});
var KS = atom(0), lw = (e12) => {
  let [o3, t3] = ce(KS);
  return reactExports.useEffect(() => {
    let { current: r3 } = e12;
    if (!r3) return;
    let n3 = gM(() => {
      let { scrollTop: i3 } = r3;
      t3(i3);
    }, 200);
    return r3.addEventListener("scroll", n3), () => {
      n3.cancel(), r3.removeEventListener("scroll", n3);
    };
  }, [e12, t3]), o3;
};
var jS = 17, JS = 64;
function xu({ isLoading: e12, libraryItems: o3, onAddToLibrary: t3, onInsertLibraryItems: r3, pendingElements: n3, theme: i3, id: a3, libraryReturnUrl: l3, onSelectItems: s3, selectedItems: c3 }) {
  let m3 = reactExports.useRef(null), d3 = lw(m3);
  reactExports.useEffect(() => {
    d3 > 0 && m3.current?.scrollTo(0, d3);
  }, []);
  let { svgCache: p3 } = Sc(), u3 = reactExports.useMemo(() => o3.filter((M) => M.status !== "published"), [o3]), h3 = reactExports.useMemo(() => o3.filter((M) => M.status === "published"), [o3]), f3 = !o3.length && !n3.length, b3 = !n3.length && !u3.length && !h3.length, [x3, T3] = reactExports.useState(null), E3 = reactExports.useCallback((M, N3) => {
    let G3 = !c3.includes(M), H3 = [...u3, ...h3];
    if (G3) {
      if (N3.shiftKey && x3) {
        let V3 = H3.findIndex((oe2) => oe2.id === x3), F3 = H3.findIndex((oe2) => oe2.id === M);
        if (V3 === -1 || F3 === -1) {
          s3([...c3, M]);
          return;
        }
        let O3 = te(c3), j = H3.reduce((oe2, W, ne3) => ((ne3 >= V3 && ne3 <= F3 || O3.has(W.id)) && oe2.push(W.id), oe2), []);
        s3(j);
      } else s3([...c3, M]);
      T3(M);
    } else T3(null), s3(c3.filter((V3) => V3 !== M));
  }, [x3, s3, h3, c3, u3]), w3 = reactExports.useCallback((M) => {
    let N3;
    return c3.includes(M) ? N3 = o3.filter((G3) => c3.includes(G3.id)) : N3 = o3.filter((G3) => G3.id === M), N3.map((G3) => ({ ...G3, elements: ZB(G3.elements, { randomizeSeed: true }) }));
  }, [o3, c3]), S3 = reactExports.useCallback((M, N3) => {
    N3.dataTransfer.setData(H.excalidrawlib, p7(w3(M)));
  }, [w3]), I3 = reactExports.useCallback((M) => M ? c3.includes(M) : false, [c3]), _3 = reactExports.useCallback(() => {
    t3(n3);
  }, [n3, t3]), k2 = reactExports.useCallback((M) => {
    M && r3(w3(M));
  }, [w3, r3]), R3 = p3.size >= o3.length ? JS : jS;
  return jsxRuntimeExports.jsxs("div", { className: "library-menu-items-container", style: n3.length || u3.length || h3.length ? { justifyContent: "flex-start" } : { borderBottom: 0 }, children: [!b3 && jsxRuntimeExports.jsx(fu, { selectedItems: c3, onSelectItems: s3, className: "library-menu-dropdown-container--in-heading" }), jsxRuntimeExports.jsxs(it.Col, { className: "library-menu-items-container__items", align: "start", gap: 1, style: { flex: h3.length > 0 ? 1 : "0 1 auto", marginBottom: 0 }, ref: m3, children: [jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [!b3 && jsxRuntimeExports.jsx("div", { className: "library-menu-items-container__header", children: g("labels.personalLib") }), e12 && jsxRuntimeExports.jsx("div", { style: { position: "absolute", top: "var(--container-padding-y)", right: "var(--container-padding-x)", transform: "translateY(50%)" }, children: jsxRuntimeExports.jsx(ct, {}) }), !n3.length && !u3.length ? jsxRuntimeExports.jsxs("div", { className: "library-menu-items__no-items", children: [jsxRuntimeExports.jsx("div", { className: "library-menu-items__no-items__label", children: g("library.noItems") }), jsxRuntimeExports.jsx("div", { className: "library-menu-items__no-items__hint", children: h3.length > 0 ? g("library.hint_emptyPrivateLibrary") : g("library.hint_emptyLibrary") })] }) : jsxRuntimeExports.jsxs(bu, { children: [n3.length > 0 && jsxRuntimeExports.jsx(Hc, { itemsRenderedPerBatch: R3, items: [{ id: null, elements: n3 }], onItemSelectToggle: E3, onItemDrag: S3, onClick: _3, isItemSelected: I3, svgCache: p3 }), jsxRuntimeExports.jsx(Hc, { itemsRenderedPerBatch: R3, items: u3, onItemSelectToggle: E3, onItemDrag: S3, onClick: k2, isItemSelected: I3, svgCache: p3 })] })] }), jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [(h3.length > 0 || n3.length > 0 || u3.length > 0) && jsxRuntimeExports.jsx("div", { className: "library-menu-items-container__header library-menu-items-container__header--excal", children: g("labels.excalidrawLib") }), h3.length > 0 ? jsxRuntimeExports.jsx(bu, { children: jsxRuntimeExports.jsx(Hc, { itemsRenderedPerBatch: R3, items: h3, onItemSelectToggle: E3, onItemDrag: S3, onClick: k2, isItemSelected: I3, svgCache: p3 }) }) : u3.length > 0 ? jsxRuntimeExports.jsx("div", { style: { margin: "1rem 0", display: "flex", flexDirection: "column", alignItems: "center", justifyContent: "center", width: "100%", fontSize: ".9rem" }, children: g("library.noItems") }) : null] }), f3 && jsxRuntimeExports.jsx(Mc, { style: { padding: "16px 0", width: "100%" }, id: a3, libraryReturnUrl: l3, theme: i3, children: jsxRuntimeExports.jsx(fu, { selectedItems: c3, onSelectItems: s3 }) })] })] });
}
var Ni = atom(false), mw = ({ children: e12 }) => jsxRuntimeExports.jsx("div", { className: "layer-ui__library", children: e12 }), QS = reactExports.memo(({ onInsertLibraryItems: e12, pendingElements: o3, onAddToLibrary: t3, setAppState: r3, libraryReturnUrl: n3, library: i3, id: a3, theme: l3, selectedItems: s3, onSelectItems: c3 }) => {
  let [m3] = ce(Cn), d3 = reactExports.useCallback((h3) => {
    (async (b3, x3) => {
      le("element", "addToLibrary", "ui");
      for (let E3 of JE$1) if (b3.some((w3) => w3.type === E3)) return r3({ errorMessage: g(`errors.libraryElementTypeError.${E3}`) });
      let T3 = [{ status: "unpublished", elements: b3, id: Dt(), created: Date.now() }, ...x3];
      t3(), i3.setLibrary(T3).catch(() => {
        r3({ errorMessage: g("alerts.errorAddingToLibrary") });
      });
    })(h3, m3.libraryItems);
  }, [t3, i3, r3, m3.libraryItems]), p3 = reactExports.useMemo(() => m3.libraryItems, [m3]);
  if (m3.status === "loading" && !m3.isInitialized) return jsxRuntimeExports.jsx(mw, { children: jsxRuntimeExports.jsx("div", { className: "layer-ui__library-message", children: jsxRuntimeExports.jsxs("div", { children: [jsxRuntimeExports.jsx(ct, { size: "2em" }), jsxRuntimeExports.jsx("span", { children: g("labels.libraryLoadingMessage") })] }) }) });
  let u3 = m3.libraryItems.length > 0 || o3.length > 0;
  return jsxRuntimeExports.jsxs(mw, { children: [jsxRuntimeExports.jsx(xu, { isLoading: m3.status === "loading", libraryItems: p3, onAddToLibrary: d3, onInsertLibraryItems: e12, pendingElements: o3, id: a3, libraryReturnUrl: n3, theme: l3, onSelectItems: c3, selectedItems: s3 }), u3 && jsxRuntimeExports.jsx(Mc, { className: "library-menu-control-buttons--at-bottom", style: { padding: "16px 12px 0 12px" }, id: a3, libraryReturnUrl: n3, theme: l3 })] });
}), Eu = (e12, o3) => ({ elements: e12, pending: at$1(e12, { selectedElementIds: o3 }, { includeBoundTextElement: true, includeElementsInFrames: true }), selectedElementIds: o3 }), ek = (e12, o3) => {
  let t3 = kr(), [r3, n3] = reactExports.useState(() => Eu(t3, e12.selectedElementIds)), i3 = reactExports.useRef(/* @__PURE__ */ new Map());
  return reactExports.useEffect(() => {
    for (let a3 of r3.pending) i3.current.set(a3.id, a3.version);
  }, [r3.pending]), reactExports.useEffect(() => {
    o3.state.cursorButton === "up" && o3.state.activeTool.type === "selection" && n3((a3) => {
      if (!Qt(a3.selectedElementIds, e12.selectedElementIds)) return i3.current.clear(), Eu(t3, e12.selectedElementIds);
      let l3 = o3.scene.getNonDeletedElementsMap();
      for (let s3 of Object.keys(e12.selectedElementIds)) {
        let c3 = l3.get(s3)?.version;
        if (c3 && c3 !== i3.current.get(s3)) return Eu(t3, e12.selectedElementIds);
      }
      return a3;
    });
  }, [o3, o3.state.cursorButton, o3.state.activeTool.type, e12.selectedElementIds, t3]), r3.pending;
}, fw = reactExports.memo(() => {
  let e12 = He(), { onInsertElements: o3 } = e12, t3 = Do(), r3 = ve(), n3 = pe(), [i3, a3] = reactExports.useState([]), l3 = reactExports.useMemo(() => e12.library, [e12.library]), s3 = ek(r3, e12), c3 = reactExports.useCallback((d3) => {
    o3(_c(d3));
  }, [o3]), m3 = reactExports.useCallback(() => {
    n3({ selectedElementIds: {}, selectedGroupIds: {}, activeEmbeddable: null });
  }, [n3]);
  return jsxRuntimeExports.jsx(QS, { pendingElements: s3, onInsertLibraryItems: c3, onAddToLibrary: m3, setAppState: n3, libraryReturnUrl: t3.libraryReturnUrl, library: l3, id: e12.id, theme: r3.theme, selectedItems: i3, onSelectItems: a3 });
});
function nk(e12) {
  if (e12 && typeof e12 == "number") return e12;
  switch (e12) {
    case "small":
      return 550;
    case "wide":
      return 1024;
    case "regular":
    default:
      return 800;
  }
}
var Ge = (e12) => {
  let [o3, t3] = Iv(), [r3] = reactExports.useState(document.activeElement), { id: n3 } = Ke(), i3 = me().viewport.isMobile;
  reactExports.useEffect(() => {
    if (!o3) return;
    let c3 = Rg$1(o3);
    setTimeout(() => {
      c3.length > 0 && e12.autofocus !== false && (c3[1] || c3[0]).focus();
    });
    let m3 = (d3) => {
      if (d3.key === Q.TAB) {
        let p3 = Rg$1(o3), { activeElement: u3 } = document, h3 = p3.findIndex((f3) => f3 === u3);
        h3 === 0 && d3.shiftKey ? (p3[p3.length - 1].focus(), d3.preventDefault()) : h3 === p3.length - 1 && !d3.shiftKey && (p3[0].focus(), d3.preventDefault());
      }
    };
    return o3.addEventListener("keydown", m3), () => o3.removeEventListener("keydown", m3);
  }, [o3, e12.autofocus]);
  let a3 = pe(), l3 = Tr(Ni), s3 = () => {
    a3({ openMenu: null }), l3(false), r3.focus(), e12.onCloseRequest();
  };
  return jsxRuntimeExports.jsx(kv, { className: dM("Dialog", e12.className, { "Dialog--fullscreen": i3 }), labelledBy: "dialog-title", maxWidth: nk(e12.size), onCloseRequest: s3, closeOnClickOutside: e12.closeOnClickOutside, children: jsxRuntimeExports.jsxs(Qe2, { ref: t3, children: [e12.title && jsxRuntimeExports.jsx("h2", { id: `${n3}-dialog-title`, className: "Dialog__title", children: jsxRuntimeExports.jsx("span", { className: "Dialog__titleContent", children: e12.title }) }), i3 && jsxRuntimeExports.jsx("button", { className: "Dialog__close", onClick: s3, title: g("buttons.close"), "aria-label": g("buttons.close"), type: "button", children: Ih }), jsxRuntimeExports.jsx("div", { className: "Dialog__content", children: e12.children })] }) });
};
var Gt = ({ type: e12 = "button", onSelect: o3, selected: t3, children: r3, className: n3 = "", ...i3 }) => jsxRuntimeExports.jsx("button", { onClick: Tg$1(i3.onClick, (a3) => {
  o3();
}), type: e12, className: dM("excalidraw-button", n3, { selected: t3 }), ...i3, children: r3 });
var zi = reactExports.forwardRef(({ onChange: e12, label: o3, fullWidth: t3, placeholder: r3, readonly: n3, selectOnRender: i3, onKeyDown: a3, isRedacted: l3 = false, icon: s3, className: c3, ...m3 }, d3) => {
  let p3 = reactExports.useRef(null);
  reactExports.useImperativeHandle(d3, () => p3.current), reactExports.useLayoutEffect(() => {
    i3 && (p3.current?.focus(), p3.current?.select());
  }, [i3]);
  let [u3, h3] = reactExports.useState(false);
  return jsxRuntimeExports.jsxs("div", { className: dM("ExcTextField", c3, { "ExcTextField--fullWidth": t3, "ExcTextField--hasIcon": !!s3 }), onClick: () => {
    p3.current?.focus();
  }, children: [s3, o3 && jsxRuntimeExports.jsx("div", { className: "ExcTextField__label", children: o3 }), jsxRuntimeExports.jsxs("div", { className: dM("ExcTextField__input", { "ExcTextField__input--readonly": n3 }), children: [jsxRuntimeExports.jsx("input", { className: dM({ "is-redacted": "value" in m3 && m3.value && l3 && !u3 }), readOnly: n3, value: "value" in m3 ? m3.value : void 0, defaultValue: "defaultValue" in m3 ? m3.defaultValue : void 0, placeholder: r3, ref: p3, onChange: (f3) => e12?.(f3.target.value), onKeyDown: a3 }), l3 && jsxRuntimeExports.jsx(Gt, { onSelect: () => h3(!u3), style: { border: 0, userSelect: "none" }, children: u3 ? B4 : F4 })] })] });
});
var uk = { toggleTheme: [cg$1("Shift+Alt+D")], saveScene: [cg$1("CtrlOrCmd+S")], loadScene: [cg$1("CtrlOrCmd+O")], clearCanvas: [cg$1("CtrlOrCmd+Delete")], imageExport: [cg$1("CtrlOrCmd+Shift+E")], commandPalette: [cg$1("CtrlOrCmd+/"), cg$1("CtrlOrCmd+Shift+P")], cut: [cg$1("CtrlOrCmd+X")], copy: [cg$1("CtrlOrCmd+C")], paste: [cg$1("CtrlOrCmd+V")], copyStyles: [cg$1("CtrlOrCmd+Alt+C")], pasteStyles: [cg$1("CtrlOrCmd+Alt+V")], selectAll: [cg$1("CtrlOrCmd+A")], deleteSelectedElements: [cg$1("Delete")], duplicateSelection: [cg$1("CtrlOrCmd+D"), cg$1(`Alt+${g("helpDialog.drag")}`)], sendBackward: [cg$1("CtrlOrCmd+[")], bringForward: [cg$1("CtrlOrCmd+]")], sendToBack: [uo ? cg$1("CtrlOrCmd+Alt+[") : cg$1("CtrlOrCmd+Shift+[")], bringToFront: [uo ? cg$1("CtrlOrCmd+Alt+]") : cg$1("CtrlOrCmd+Shift+]")], copyAsPng: [cg$1("Shift+Alt+C")], group: [cg$1("CtrlOrCmd+G")], ungroup: [cg$1("CtrlOrCmd+Shift+G")], gridMode: [cg$1("CtrlOrCmd+'")], zenMode: [cg$1("Alt+Z")], objectsSnapMode: [cg$1("Alt+S")], stats: [cg$1("Alt+/")], addToLibrary: [], flipHorizontal: [cg$1("Shift+H")], flipVertical: [cg$1("Shift+V")], viewMode: [cg$1("Alt+R")], hyperlink: [cg$1("CtrlOrCmd+K")], toggleElementLock: [cg$1("CtrlOrCmd+Shift+L")], resetZoom: [cg$1("CtrlOrCmd+0")], zoomOut: [cg$1("CtrlOrCmd+-")], zoomIn: [cg$1("CtrlOrCmd++")], zoomToFitSelection: [cg$1("Shift+3")], zoomToFit: [cg$1("Shift+1")], zoomToFitSelectionInViewport: [cg$1("Shift+2")], toggleEraserTool: [cg$1("E")], toggleHandTool: [cg$1("H")], setFrameAsActiveTool: [cg$1("F")], saveFileToDisk: [cg$1("CtrlOrCmd+S")], saveToActiveFile: [cg$1("CtrlOrCmd+S")], toggleShortcuts: [cg$1("?")], searchMenu: [cg$1("CtrlOrCmd+F")], wrapSelectionInFrame: [] }, Ye = (e12, o3 = 0) => {
  let t3 = uk[e12];
  return t3 && t3.length > 0 ? t3[o3] || t3[0] : "";
};
var gk = "\\u0300-\\u036f", hk = "\\ufe20-\\ufe2f", fk = "\\u20d0-\\u20ff", bk = gk + hk + fk, xk = `[${bk}]`, Ek = RegExp(xk, "g"), yk = /[\xc0-\xd6\xd8-\xf6\xf8-\xff\u0100-\u017f]/g, vk = { : "A", : "A", : "A", : "A", : "A", : "A", : "a", : "a", : "a", : "a", : "a", : "a", : "C", : "c", : "D", : "d", : "E", : "E", : "E", : "E", : "e", : "e", : "e", : "e", : "I", : "I", : "I", : "I", : "i", : "i", : "i", : "i", : "N", : "n", : "O", : "O", : "O", : "O", : "O", : "O", : "o", : "o", : "o", : "o", : "o", : "o", : "U", : "U", : "U", : "U", : "u", : "u", : "u", : "u", : "Y", : "y", : "y", : "E", : "e", : "T", : "t", : "s", : "A", : "A", : "A", : "a", : "a", : "a", : "C", : "C", : "C", : "C", : "c", : "c", : "c", : "c", : "D", : "D", : "d", : "d", : "E", : "E", : "E", : "E", : "E", : "e", : "e", : "e", : "e", : "e", : "G", : "G", : "G", : "G", : "g", : "g", : "g", : "g", : "H", : "H", : "h", : "h", : "I", : "I", : "I", : "I", : "I", : "i", : "i", : "i", : "i", : "i", : "J", : "j", : "K", : "k", : "k", : "L", : "L", : "L", : "L", : "L", : "l", : "l", : "l", : "l", : "l", : "N", : "N", : "N", : "N", : "n", : "n", : "n", : "n", : "O", : "O", : "O", : "o", : "o", : "o", : "R", : "R", : "R", : "r", : "r", : "r", : "S", : "S", : "S", : "S", : "s", : "s", : "s", : "s", : "T", : "T", : "T", : "t", : "t", : "t", : "U", : "U", : "U", : "U", : "U", : "U", : "u", : "u", : "u", : "u", : "u", : "u", : "W", : "w", : "Y", : "y", : "Y", : "Z", : "Z", : "Z", : "z", : "z", : "z", : "I", : "i", : "E", : "e", : "n", : "s" }, Tu = (e12) => e12.replace(yk, (o3) => vk[o3] || o3).replace(Ek, "");
var Iu = React.createContext(null), _e = () => React.useContext(Iu), Tk = createIsolation(), xw = () => React.useMemo(() => ({ MainMenuTunnel: tunnel(), WelcomeScreenMenuHintTunnel: tunnel(), WelcomeScreenToolbarHintTunnel: tunnel(), WelcomeScreenHelpHintTunnel: tunnel(), WelcomeScreenCenterTunnel: tunnel(), FooterCenterTunnel: tunnel(), DefaultSidebarTriggerTunnel: tunnel(), DefaultSidebarTabTriggersTunnel: tunnel(), OverwriteConfirmDialogTunnel: tunnel(), TTDDialogTriggerTunnel: tunnel(), tunnelsJotai: Tk }), []);
var ku = (e12, o3) => {
  let t3 = o3[0]?.type || null;
  for (let r3 of o3) if (r3.type !== t3) {
    t3 = null;
    break;
  }
  return NP(e12.activeTool.type) && e12.activeTool.type !== "image" && t3 !== "image" && t3 !== "frame" && t3 !== "magicframe" || o3.some((r3) => NP(r3.type));
}, Lu = (e12, o3) => Am(e12.activeTool.type) || o3.some((t3) => Am(t3.type)), Gc = ({ appState: e12, elementsMap: o3, renderAction: t3, app: r3 }) => {
  let n3 = Rb(o3, e12), i3 = false;
  n3.length === 2 && (bn(n3[0]) || bn(n3[1])) && (i3 = true);
  let a3 = !!(e12.editingTextElement || e12.newElement), l3 = me(), s3 = document.documentElement.getAttribute("dir") === "rtl", c3 = Am(e12.activeTool.type) && !Wt(e12.currentItemBackgroundColor) || n3.some((h3) => Am(h3.type) && !Wt(h3.backgroundColor)), m3 = n3.length === 1 || i3, d3 = !e12.editingLinearElement && n3.length === 1 && ae(n3[0]) && !X$1(n3[0]), p3 = !e12.croppingElementId && n3.length === 1 && Ye$1(n3[0]), u3 = !i3 && _t(e12, r3);
  return jsxRuntimeExports.jsxs("div", { className: "panelColumn", children: [jsxRuntimeExports.jsx("div", { children: ku(e12, n3) && t3("changeStrokeColor") }), Lu(e12, n3) && jsxRuntimeExports.jsx("div", { children: t3("changeBackgroundColor") }), c3 && t3("changeFillStyle"), (Km(e12.activeTool.type) || n3.some((h3) => Km(h3.type))) && t3("changeStrokeWidth"), (e12.activeTool.type === "freedraw" || n3.some((h3) => h3.type === "freedraw")) && t3("changeStrokeShape"), (Hm(e12.activeTool.type) || n3.some((h3) => Hm(h3.type))) && jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [t3("changeStrokeStyle"), t3("changeSloppiness")] }), (Ta(e12.activeTool.type) || n3.some((h3) => Ta(h3.type))) && jsxRuntimeExports.jsx(jsxRuntimeExports.Fragment, { children: t3("changeRoundness") }), (FP(e12.activeTool.type) || n3.some((h3) => FP(h3.type))) && jsxRuntimeExports.jsx(jsxRuntimeExports.Fragment, { children: t3("changeArrowType") }), (e12.activeTool.type === "text" || n3.some(k$2)) && jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [t3("changeFontFamily"), t3("changeFontSize"), (e12.activeTool.type === "text" || fB(n3, o3)) && t3("changeTextAlign")] }), UB(n3, o3) && t3("changeVerticalAlign"), (Jm(e12.activeTool.type) || n3.some((h3) => Jm(h3.type))) && jsxRuntimeExports.jsx(jsxRuntimeExports.Fragment, { children: t3("changeArrowhead") }), t3("changeOpacity"), jsxRuntimeExports.jsxs("fieldset", { children: [jsxRuntimeExports.jsx("legend", { children: g("labels.layers") }), jsxRuntimeExports.jsxs("div", { className: "buttonList", children: [t3("sendToBack"), t3("sendBackward"), t3("bringForward"), t3("bringToFront")] })] }), u3 && !i3 && jsxRuntimeExports.jsxs("fieldset", { children: [jsxRuntimeExports.jsx("legend", { children: g("labels.align") }), jsxRuntimeExports.jsxs("div", { className: "buttonList", children: [s3 ? jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [t3("alignRight"), t3("alignHorizontallyCentered"), t3("alignLeft")] }) : jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [t3("alignLeft"), t3("alignHorizontallyCentered"), t3("alignRight")] }), n3.length > 2 && t3("distributeHorizontally"), jsxRuntimeExports.jsx("div", { style: { flexBasis: "100%", height: 0 } }), jsxRuntimeExports.jsxs("div", { style: { display: "flex", flexWrap: "wrap", gap: ".5rem", marginTop: "-0.5rem" }, children: [t3("alignTop"), t3("alignVerticallyCentered"), t3("alignBottom"), n3.length > 2 && t3("distributeVertically")] })] })] }), !a3 && n3.length > 0 && jsxRuntimeExports.jsxs("fieldset", { children: [jsxRuntimeExports.jsx("legend", { children: g("labels.actions") }), jsxRuntimeExports.jsxs("div", { className: "buttonList", children: [!l3.editor.isMobile && t3("duplicateSelection"), !l3.editor.isMobile && t3("deleteSelectedElements"), t3("group"), t3("ungroup"), m3 && t3("hyperlink"), p3 && t3("cropEditor"), d3 && t3("toggleLinearEditor")] })] })] });
}, Yc = ({ activeTool: e12, appState: o3, app: t3, UIOptions: r3 }) => {
  let [n3, i3] = reactExports.useState(false), a3 = e12.type === "frame", l3 = e12.type === "laser", s3 = e12.type === "embeddable", { TTDDialogTriggerTunnel: c3 } = _e();
  return jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [Mm.map(({ value: m3, icon: d3, key: p3, numericKey: u3, fillable: h3 }, f3) => {
    if (r3.tools?.[m3] === false) return null;
    let b3 = g(`toolBar.${m3}`), x3 = p3 && rg$1(typeof p3 == "string" ? p3 : p3[0]), T3 = x3 ? `${x3} ${g("helpDialog.or")} ${u3}` : `${u3}`;
    return jsxRuntimeExports.jsx(X, { className: dM("Shape", { fillable: h3 }), type: "radio", icon: d3, checked: e12.type === m3, name: "editor-current-shape", title: `${rg$1(b3)}  ${T3}`, keyBindingLabel: u3 || x3, "aria-label": rg$1(b3), "aria-keyshortcuts": T3, "data-testid": `toolbar-${m3}`, onPointerDown: ({ pointerType: E3 }) => {
      !o3.penDetected && E3 === "pen" && t3.togglePenMode(true);
    }, onChange: ({ pointerType: E3 }) => {
      o3.activeTool.type !== m3 && le("toolbar", m3, "ui"), m3 === "image" ? t3.setActiveTool({ type: m3, insertOnCanvasDirectly: E3 !== "mouse" }) : t3.setActiveTool({ type: m3 });
    } }, m3);
  }), jsxRuntimeExports.jsx("div", { className: "App-toolbar__divider" }), jsxRuntimeExports.jsxs(Ce, { open: n3, children: [jsxRuntimeExports.jsx(Ce.Trigger, { className: dM("App-toolbar__extra-tools-trigger", { "App-toolbar__extra-tools-trigger--selected": a3 || s3 || l3 && !t3.props.isCollaborating }), onToggle: () => i3(!n3), title: g("toolBar.extraTools"), children: T4 }), jsxRuntimeExports.jsxs(Ce.Content, { onClickOutside: () => i3(false), onSelect: () => i3(false), className: "App-toolbar__extra-tools-dropdown", children: [jsxRuntimeExports.jsx(Ce.Item, { onSelect: () => t3.setActiveTool({ type: "frame" }), icon: M4, shortcut: Q.F.toLocaleUpperCase(), "data-testid": "toolbar-frame", selected: a3, children: g("toolBar.frame") }), jsxRuntimeExports.jsx(Ce.Item, { onSelect: () => t3.setActiveTool({ type: "embeddable" }), icon: Mx, "data-testid": "toolbar-embeddable", selected: s3, children: g("toolBar.embeddable") }), jsxRuntimeExports.jsx(Ce.Item, { onSelect: () => t3.setActiveTool({ type: "laser" }), icon: S4, "data-testid": "toolbar-laser", selected: l3, shortcut: Q.K.toLocaleUpperCase(), children: g("toolBar.laser") }), jsxRuntimeExports.jsx("div", { style: { margin: "6px 0", fontSize: 14, fontWeight: 600 }, children: "Generate" }), t3.props.aiEnabled !== false && jsxRuntimeExports.jsx(c3.Out, {}), jsxRuntimeExports.jsx(Ce.Item, { onSelect: () => t3.setOpenDialog({ name: "ttd", tab: "mermaid" }), icon: L4, "data-testid": "toolbar-embeddable", children: g("toolBar.mermaidToExcalidraw") }), t3.props.aiEnabled !== false && t3.plugins.diagramToCode && jsxRuntimeExports.jsx(jsxRuntimeExports.Fragment, { children: jsxRuntimeExports.jsxs(Ce.Item, { onSelect: () => t3.onMagicframeToolSelect(), icon: v4, "data-testid": "toolbar-magicframe", children: [g("toolBar.magicframe"), jsxRuntimeExports.jsx(Ce.Item.Badge, { children: "AI" })] }) })] })] })] });
}, Ew = ({ renderAction: e12, zoom: o3 }) => jsxRuntimeExports.jsx(it.Col, { gap: 1, className: gE.ZOOM_ACTIONS, children: jsxRuntimeExports.jsxs(it.Row, { align: "center", children: [e12("zoomOut"), e12("resetZoom"), e12("zoomIn")] }) }), yw = ({ renderAction: e12, className: o3 }) => jsxRuntimeExports.jsxs("div", { className: `undo-redo-buttons ${o3}`, children: [jsxRuntimeExports.jsx("div", { className: "undo-button-container", children: jsxRuntimeExports.jsx(Ut, { label: g("buttons.undo"), children: e12("undo") }) }), jsxRuntimeExports.jsx("div", { className: "redo-button-container", children: jsxRuntimeExports.jsxs(Ut, { label: g("buttons.redo"), children: [" ", e12("redo")] }) })] }), vw = ({ actionManager: e12, showExitZenModeBtn: o3 }) => jsxRuntimeExports.jsx("button", { type: "button", className: dM("disable-zen-mode", { "disable-zen-mode--visible": o3 }), onClick: () => e12.executeAction(Mi), children: g("buttons.exitZenMode") }), ww = ({ renderAction: e12, className: o3 }) => jsxRuntimeExports.jsx("div", { className: `finalize-button ${o3}`, children: e12("finalize", { size: "small" }) });
var Au = (e12) => {
  let o3 = reactExports.useRef({ userFn: e12 });
  return o3.current.userFn = e12, o3.current.stableFn || (o3.current.stableFn = (...t3) => o3.current.userFn(...t3)), o3.current.stableFn;
};
var In = atom(null), Tw = () => {
  let [e12, o3] = ce(In), t3 = Xe2();
  return e12 && e12 === "clearCanvas" ? jsxRuntimeExports.jsx(Rc, { onConfirm: () => {
    t3.executeAction(er), o3(null);
  }, onCancel: () => o3(null), title: g("clearCanvasDialog.title"), children: jsxRuntimeExports.jsxs("p", { className: "clear-canvas__content", children: [" ", g("alerts.clearReset")] }) }) : null;
};
var _u = {};
h$1(_u, { toggleTheme: () => Lk });
var Lk = { ...En, category: "App", label: "Toggle theme", perform: ({ actionManager: e12 }) => {
  e12.executeAction(En, "commandPalette");
} };
var Vc = L2({ name: "copyElementLink", label: "labels.copyElementLink", icon: E4, trackEvent: { category: "element" }, perform: async (e12, o3, t3, r3) => {
  let n3 = at$1(e12, o3);
  try {
    if (window.location) {
      let i3 = XO(n3, o3);
      return i3 ? (await hs(r3.props.generateLinkForSelection ? r3.props.generateLinkForSelection(i3.id, i3.type) : qO(i3.id, i3.type)), { appState: { toast: { message: g("toast.elementLinkCopied"), closable: true } }, captureUpdate: dr.EVENTUALLY }) : { appState: o3, elements: e12, app: r3, captureUpdate: dr.EVENTUALLY };
    }
  } catch (i3) {
    console.error(i3);
  }
  return { appState: o3, elements: e12, app: r3, captureUpdate: dr.EVENTUALLY };
}, predicate: (e12, o3) => E7(at$1(e12, o3)) }), Cw = L2({ name: "linkToElement", label: "labels.linkToElement", icon: Uy$1, perform: (e12, o3, t3, r3) => {
  let n3 = at$1(e12, o3);
  return n3.length !== 1 || !E7(n3) ? { elements: e12, appState: o3, app: r3, captureUpdate: dr.EVENTUALLY } : { appState: { ...o3, openDialog: { name: "elementLinkSelector", sourceElementId: at$1(e12, o3)[0].id } }, captureUpdate: dr.IMMEDIATELY };
}, predicate: (e12, o3, t3, r3) => {
  let n3 = at$1(e12, o3);
  return o3.openDialog?.name !== "elementLinkSelector" && n3.length === 1 && E7(n3);
}, trackEvent: false });
var Mk = atom(null), ze = { app: "App", export: "Export", tools: "Tools", editor: "Editor", elements: "Elements", links: "Links" }, Dk = (e12) => {
  switch (e12) {
    case ze.app:
      return 1;
    case ze.export:
      return 2;
    case ze.editor:
      return 3;
    case ze.tools:
      return 4;
    case ze.elements:
      return 5;
    case ze.links:
      return 6;
    default:
      return 10;
  }
}, Xc = ({ shortcut: e12, className: o3, children: t3 }) => {
  let r3 = e12.replace("++", "+$").split("+");
  return jsxRuntimeExports.jsxs("div", { className: dM("shortcut", o3), children: [r3.map((n3, i3) => jsxRuntimeExports.jsx("div", { className: "shortcut-wrapper", children: jsxRuntimeExports.jsx("div", { className: "shortcut-key", children: n3 === "$" ? "+" : n3 }) }, n3)), jsxRuntimeExports.jsx("div", { className: "shortcut-desc", children: t3 })] });
}, kw = (e12) => !e12.altKey && e12[Q.CTRL_OR_CMD] && (e12.shiftKey && e12.key.toLowerCase() === Q.P || e12.key === Q.SLASH);
Object.assign((e12) => {
  let o3 = ve(), t3 = pe();
  return reactExports.useEffect(() => {
    let r3 = (n3) => {
      kw(n3) && (n3.preventDefault(), n3.stopPropagation(), t3((i3) => {
        let a3 = i3.openDialog?.name === "commandPalette" ? null : { name: "commandPalette" };
        return a3 && le("command_palette", "open", "shortcut"), { openDialog: a3 };
      }));
    };
    return window.addEventListener("keydown", r3, { capture: true }), () => window.removeEventListener("keydown", r3, { capture: true });
  }, [t3]), o3.openDialog?.name !== "commandPalette" ? null : jsxRuntimeExports.jsx(Pk, { ...e12 });
}, { defaultItems: _u });
function Pk({ customCommandPaletteItems: e12 }) {
  let o3 = He(), t3 = ve(), r3 = pe(), n3 = Do(), i3 = Xe2(), [a3, l3] = ce(Mk), [s3, c3] = reactExports.useState(null), m3 = reactExports.useRef(null), d3 = Ir({ uiAppState: t3, customCommandPaletteItems: e12, appProps: n3 });
  reactExports.useEffect(() => {
    let { uiAppState: I3, customCommandPaletteItems: _3, appProps: k2 } = d3, R3 = (H3) => {
      let V3 = "";
      return H3.label && (typeof H3.label == "function" ? V3 = g(H3.label(o3.scene.getNonDeletedElements(), I3, o3)) : V3 = g(H3.label)), V3;
    }, M = (H3) => typeof H3.icon == "function" ? H3.icon(I3, o3.scene.getNonDeletedElements()) : H3.icon, N3 = [], G3 = (H3, V3, F3) => {
      let O3 = { label: R3(H3), icon: M(H3), category: V3, shortcut: Ye(H3.name), keywords: H3.keywords, predicate: H3.predicate, viewMode: H3.viewMode, perform: () => {
        i3.executeAction(H3, "commandPalette");
      } };
      return F3 ? F3(O3, H3) : O3;
    };
    if (I3 && o3.scene && i3) {
      let H3 = [i3.actions.group, i3.actions.ungroup, i3.actions.cut, i3.actions.copy, i3.actions.deleteSelectedElements, i3.actions.wrapSelectionInFrame, i3.actions.copyStyles, i3.actions.pasteStyles, i3.actions.bringToFront, i3.actions.bringForward, i3.actions.sendBackward, i3.actions.sendToBack, i3.actions.alignTop, i3.actions.alignBottom, i3.actions.alignLeft, i3.actions.alignRight, i3.actions.alignVerticallyCentered, i3.actions.alignHorizontallyCentered, i3.actions.duplicateSelection, i3.actions.flipHorizontal, i3.actions.flipVertical, i3.actions.zoomToFitSelection, i3.actions.zoomToFitSelectionInViewport, i3.actions.increaseFontSize, i3.actions.decreaseFontSize, i3.actions.toggleLinearEditor, i3.actions.cropEditor, Ga, Vc, Cw].map((W) => G3(W, ze.elements, (ne3, ge2) => ({ ...ne3, predicate: ge2.predicate ? ge2.predicate : (be, mt2, wo2, Dn2) => at$1(be, mt2).length > 0 }))), V3 = [i3.actions.toggleHandTool, i3.actions.setFrameAsActiveTool].map((W) => G3(W, ze.tools)), F3 = [i3.actions.undo, i3.actions.redo, i3.actions.zoomIn, i3.actions.zoomOut, i3.actions.resetZoom, i3.actions.zoomToFit, i3.actions.zenMode, i3.actions.viewMode, i3.actions.gridMode, i3.actions.objectsSnapMode, i3.actions.toggleShortcuts, i3.actions.selectAll, i3.actions.toggleElementLock, i3.actions.unlockAllElements, i3.actions.stats].map((W) => G3(W, ze.editor)), O3 = [i3.actions.saveToActiveFile, i3.actions.saveFileToDisk, i3.actions.copyAsPng, i3.actions.copyAsSvg].map((W) => G3(W, ze.export));
      N3 = [...H3, ...F3, { label: R3(er), icon: M(er), shortcut: Ye(er.name), category: ze.editor, keywords: ["delete", "destroy"], viewMode: false, perform: () => {
        st.set(In, "clearCanvas");
      } }, { label: g("buttons.exportImage"), category: ze.export, icon: Xx, shortcut: Ye("imageExport"), keywords: ["export", "image", "png", "jpeg", "svg", "clipboard", "picture"], perform: () => {
        r3({ openDialog: { name: "imageExport" } });
      } }, ...O3];
      let j = [{ label: g("toolBar.library"), category: ze.app, icon: Ux, viewMode: false, perform: () => {
        I3.openSidebar ? r3({ openSidebar: null }) : r3({ openSidebar: { name: ks.name, tab: ks.defaultTab } });
      } }, { label: g("search.title"), category: ze.app, icon: A4, viewMode: true, perform: () => {
        i3.executeAction(Ka);
      } }, { label: g("labels.changeStroke"), keywords: ["color", "outline"], category: ze.elements, icon: qx, viewMode: false, predicate: (W, ne3) => {
        let ge2 = at$1(W, ne3);
        return ge2.length > 0 && ku(ne3, ge2);
      }, perform: () => {
        r3((W) => ({ openMenu: W.openMenu === "shape" ? null : "shape", openPopup: "elementStroke" }));
      } }, { label: g("labels.changeBackground"), keywords: ["color", "fill"], icon: qx, category: ze.elements, viewMode: false, predicate: (W, ne3) => {
        let ge2 = at$1(W, ne3);
        return ge2.length > 0 && Lu(ne3, ge2);
      }, perform: () => {
        r3((W) => ({ openMenu: W.openMenu === "shape" ? null : "shape", openPopup: "elementBackground" }));
      } }, { label: g("labels.canvasBackground"), keywords: ["color"], icon: qx, category: ze.editor, viewMode: false, perform: () => {
        r3((W) => ({ openMenu: W.openMenu === "canvas" ? null : "canvas", openPopup: "canvasBackground" }));
      } }, ...Mm.reduce((W, ne3) => {
        let { value: ge2, icon: be, key: mt2, numericKey: wo2 } = ne3;
        if (k2.UIOptions.tools?.[ge2] === false) return W;
        let Pn2 = mt2 && rg$1(typeof mt2 == "string" ? mt2 : mt2[0]) || wo2, pl2 = { label: g(`toolBar.${ge2}`), category: ze.tools, shortcut: Pn2, icon: be, keywords: ["toolbar"], viewMode: false, perform: ({ event: ul2 }) => {
          ge2 === "image" ? o3.setActiveTool({ type: ge2, insertOnCanvasDirectly: ul2.type === "keydown" }) : o3.setActiveTool({ type: ge2 });
        } };
        return W.push(pl2), W;
      }, []), ...V3, { label: g("toolBar.lock"), category: ze.tools, icon: I3.activeTool.locked ? bx : mx, shortcut: Q.Q.toLocaleUpperCase(), viewMode: false, perform: () => {
        o3.toggleLock();
      } }, { label: `${g("labels.textToDiagram")}...`, category: ze.tools, icon: O4, viewMode: false, predicate: k2.aiEnabled, perform: () => {
        r3((W) => ({ ...W, openDialog: { name: "ttd", tab: "text-to-diagram" } }));
      } }, { label: `${g("toolBar.mermaidToExcalidraw")}...`, category: ze.tools, icon: L4, viewMode: false, predicate: k2.aiEnabled, perform: () => {
        r3((W) => ({ ...W, openDialog: { name: "ttd", tab: "mermaid" } }));
      } }], oe2 = [...N3, ...j, ..._3 || []].map((W) => ({ ...W, icon: W.icon || Y4, order: W.order ?? Dk(W.category), haystack: `${Tu(W.label.toLocaleLowerCase())} ${W.keywords?.join(" ") || ""}` }));
      c3(oe2), l3(oe2.find((W) => W.label === a3?.label) ?? null);
    }
  }, [d3, o3, i3, c3, a3?.label, l3, r3]);
  let [p3, u3] = reactExports.useState(""), [h3, f3] = reactExports.useState(null), [b3, x3] = reactExports.useState({}), T3 = (I3) => {
    r3({ openDialog: null }, I3), u3("");
  }, E3 = (I3, _3) => {
    t3.openDialog?.name === "commandPalette" && (_3.stopPropagation(), _3.preventDefault(), document.body.classList.add("excalidraw-animations-disabled"), T3(() => {
      I3.perform({ actionManager: i3, event: _3 }), l3(I3), requestAnimationFrame(() => {
        document.body.classList.remove("excalidraw-animations-disabled");
      });
    }));
  }, w3 = Au((I3) => I3.viewMode === false && t3.viewModeEnabled ? false : typeof I3.predicate == "function" ? I3.predicate(o3.scene.getNonDeletedElements(), t3, n3, o3) : I3.predicate === void 0 || I3.predicate), S3 = Au((I3) => {
    let _3 = ag(I3.target) || kw(I3) || I3.key === Q.ESCAPE;
    if (_3 && I3.key !== Q.ARROW_UP && I3.key !== Q.ARROW_DOWN && I3.key !== Q.ENTER) return;
    let k2 = Object.values(b3).flat(), R3 = a3 && !p3 && w3(a3);
    if (I3.key === Q.ARROW_UP) {
      I3.preventDefault();
      let M = k2.findIndex((H3) => H3.label === h3?.label);
      if (R3) {
        if (M === 0) {
          f3(a3);
          return;
        }
        if (h3 === a3) {
          let H3 = k2[k2.length - 1];
          H3 && f3(H3);
          return;
        }
      }
      let N3;
      M === -1 ? N3 = k2.length - 1 : N3 = M === 0 ? k2.length - 1 : (M - 1) % k2.length;
      let G3 = k2[N3];
      G3 && f3(G3);
      return;
    }
    if (I3.key === Q.ARROW_DOWN) {
      I3.preventDefault();
      let M = k2.findIndex((H3) => H3.label === h3?.label);
      if (R3) {
        if (!h3 || M === k2.length - 1) {
          f3(a3);
          return;
        }
        if (h3 === a3) {
          let H3 = k2[0];
          H3 && f3(H3);
          return;
        }
      }
      let N3 = (M + 1) % k2.length, G3 = k2[N3];
      G3 && f3(G3);
      return;
    }
    if (I3.key === Q.ENTER && h3 && setTimeout(() => {
      E3(h3, I3);
    }), !_3) {
      if (I3.stopPropagation(), /^[a-zA-Z0-9]$/.test(I3.key)) {
        m3?.current?.focus();
        return;
      }
      I3.preventDefault();
    }
  });
  return reactExports.useEffect(() => (window.addEventListener("keydown", S3, { capture: true }), () => window.removeEventListener("keydown", S3, { capture: true })), [S3]), reactExports.useEffect(() => {
    if (!s3) return;
    let I3 = (M) => {
      let N3 = {};
      for (let G3 of M) N3[G3.category] ? N3[G3.category].push(G3) : N3[G3.category] = [G3];
      return N3;
    }, _3 = s3.filter(w3).sort((M, N3) => M.order - N3.order), k2 = !p3 && a3 && w3(a3);
    if (!p3) {
      x3(I3(k2 ? _3.filter((M) => M.label !== a3?.label) : _3)), f3(k2 ? a3 : _3[0] || null);
      return;
    }
    let R3 = Tu(p3.toLocaleLowerCase().replace(/[<>_| -]/g, ""));
    _3 = _k.filter(R3, _3, { extract: (M) => M.haystack }).sort((M, N3) => N3.score - M.score).map((M) => M.original), x3(I3(_3)), f3(_3[0] ?? null);
  }, [p3, s3, w3, a3]), jsxRuntimeExports.jsxs(Ge, { onCloseRequest: () => T3(), closeOnClickOutside: true, title: false, size: 720, autofocus: true, className: "command-palette-dialog", children: [jsxRuntimeExports.jsx(zi, { value: p3, placeholder: g("commandPalette.search.placeholder"), onChange: (I3) => {
    u3(I3);
  }, selectOnRender: true, ref: m3 }), !o3.device.viewport.isMobile && jsxRuntimeExports.jsxs("div", { className: "shortcuts-wrapper", children: [jsxRuntimeExports.jsx(Xc, { shortcut: "", children: g("commandPalette.shortcuts.select") }), jsxRuntimeExports.jsx(Xc, { shortcut: "", children: g("commandPalette.shortcuts.confirm") }), jsxRuntimeExports.jsx(Xc, { shortcut: cg$1("Esc"), children: g("commandPalette.shortcuts.close") })] }), jsxRuntimeExports.jsxs("div", { className: "commands", children: [a3 && !p3 && jsxRuntimeExports.jsxs("div", { className: "command-category", children: [jsxRuntimeExports.jsxs("div", { className: "command-category-title", children: [g("commandPalette.recents"), jsxRuntimeExports.jsx("div", { className: "icon", style: { marginLeft: "6px" }, children: K4 })] }), jsxRuntimeExports.jsx(Iw, { command: a3, isSelected: a3.label === h3?.label, onClick: (I3) => E3(a3, I3), disabled: !w3(a3), onMouseMove: () => f3(a3), showShortcut: !o3.device.viewport.isMobile, appState: t3 })] }), Object.keys(b3).length > 0 ? Object.keys(b3).map((I3, _3) => jsxRuntimeExports.jsxs("div", { className: "command-category", children: [jsxRuntimeExports.jsx("div", { className: "command-category-title", children: I3 }), b3[I3].map((k2) => jsxRuntimeExports.jsx(Iw, { command: k2, isSelected: k2.label === h3?.label, onClick: (R3) => E3(k2, R3), onMouseMove: () => f3(k2), showShortcut: !o3.device.viewport.isMobile, appState: t3 }, k2.label))] }, I3)) : s3 ? jsxRuntimeExports.jsxs("div", { className: "no-match", children: [jsxRuntimeExports.jsx("div", { className: "icon", children: A4 }), " ", g("commandPalette.search.noMatch")] }) : null] })] });
}
var Iw = ({ command: e12, isSelected: o3, disabled: t3, onMouseMove: r3, onClick: n3, showShortcut: i3, appState: a3 }) => {
  let l3 = () => {
  };
  return jsxRuntimeExports.jsxs("div", { className: dM("command-item", { "item-selected": o3, "item-disabled": t3 }), ref: (s3) => {
    o3 && !t3 && s3?.scrollIntoView?.({ block: "nearest" });
  }, onClick: t3 ? l3 : n3, onMouseMove: t3 ? l3 : r3, title: t3 ? g("commandPalette.itemNotAvailable") : "", children: [jsxRuntimeExports.jsxs("div", { className: "name", children: [e12.icon && jsxRuntimeExports.jsx(Lr, { icon: typeof e12.icon == "function" ? e12.icon(a3) : e12.icon }), e12.label] }), i3 && e12.shortcut && jsxRuntimeExports.jsx(Xc, { shortcut: e12.shortcut })] });
};
var Mu = L2({ name: "toggleLinearEditor", category: ze.elements, label: (e12, o3, t3) => t3.scene.getSelectedElements({ selectedElementIds: o3.selectedElementIds })[0]?.type === "arrow" ? "labels.lineEditor.editArrow" : "labels.lineEditor.edit", keywords: ["line"], trackEvent: { category: "element" }, predicate: (e12, o3, t3, r3) => {
  let n3 = r3.scene.getSelectedElements(o3);
  return !!(!o3.editingLinearElement && n3.length === 1 && ae(n3[0]) && !X$1(n3[0]));
}, perform(e12, o3, t3, r3) {
  let n3 = r3.scene.getSelectedElements({ selectedElementIds: o3.selectedElementIds, includeBoundTextElement: true })[0], i3 = o3.editingLinearElement?.elementId === n3.id ? null : new z$1(n3);
  return { appState: { ...o3, editingLinearElement: i3 }, captureUpdate: dr.IMMEDIATELY };
}, PanelComponent: ({ appState: e12, updateData: o3, app: t3 }) => {
  let r3 = t3.scene.getSelectedElements({ selectedElementIds: e12.selectedElementIds })[0], n3 = g(r3.type === "arrow" ? "labels.lineEditor.editArrow" : "labels.lineEditor.edit");
  return jsxRuntimeExports.jsx(X, { type: "button", icon: ry$1, title: n3, "aria-label": n3, onClick: () => o3(null) });
} });
var Ka = L2({ name: "searchMenu", icon: A4, keywords: ["search", "find"], label: "search.title", viewMode: true, trackEvent: { category: "search_menu", action: "toggle", predicate: (e12) => e12.gridModeEnabled }, perform(e12, o3, t3, r3) {
  if (o3.openSidebar?.name === ks.name && o3.openSidebar.tab === HE) {
    let n3 = r3.excalidrawContainerValue.container?.querySelector(`.${gE.SEARCH_MENU_INPUT_WRAPPER} input`);
    return n3?.matches(":focus") ? { appState: { ...o3, openSidebar: null }, captureUpdate: dr.EVENTUALLY } : (n3?.focus(), n3?.select(), false);
  }
  return { appState: { ...o3, openSidebar: { name: ks.name, tab: HE }, openDialog: null }, captureUpdate: dr.EVENTUALLY };
}, checked: (e12) => e12.gridModeEnabled, predicate: (e12, o3, t3) => t3.gridModeEnabled === void 0, keyTest: (e12) => e12[Q.CTRL_OR_CMD] && e12.key === Q.F });
var Du = L2({ name: "cropEditor", label: "helpDialog.cropStart", icon: ly$1, viewMode: true, trackEvent: { category: "menu" }, keywords: ["image", "crop"], perform(e12, o3, t3, r3) {
  let n3 = r3.scene.getSelectedElements({ selectedElementIds: o3.selectedElementIds, includeBoundTextElement: true })[0];
  return { appState: { ...o3, isCropping: false, croppingElementId: n3.id }, captureUpdate: dr.IMMEDIATELY };
}, predicate: (e12, o3, t3, r3) => {
  let n3 = r3.scene.getSelectedElements(o3);
  return !!(!o3.croppingElementId && n3.length === 1 && Ye$1(n3[0]));
}, PanelComponent: ({ appState: e12, updateData: o3, app: t3 }) => {
  let r3 = g("helpDialog.cropStart");
  return jsxRuntimeExports.jsx(X, { type: "button", icon: ly$1, title: r3, "aria-label": r3, onClick: () => o3(null) });
} });
var Sn = class {
  constructor(o3 = true, t3 = true) {
    this.isUndoStackEmpty = o3;
    this.isRedoStackEmpty = t3;
  }
}, Xa = class e8 {
  constructor() {
    i$1(this, "onHistoryChangedEmitter", new hi());
    i$1(this, "undoStack", []);
    i$1(this, "redoStack", []);
  }
  get isUndoStackEmpty() {
    return this.undoStack.length === 0;
  }
  get isRedoStackEmpty() {
    return this.redoStack.length === 0;
  }
  clear() {
    this.undoStack.length = 0, this.redoStack.length = 0;
  }
  record(o3, t3) {
    let r3 = Pu.create(t3, o3);
    r3.isEmpty() || (this.undoStack.push(r3.inverse()), r3.elementsChange.isEmpty() || (this.redoStack.length = 0), this.onHistoryChangedEmitter.trigger(new Sn(this.isUndoStackEmpty, this.isRedoStackEmpty)));
  }
  undo(o3, t3, r3) {
    return this.perform(o3, t3, r3, () => e8.pop(this.undoStack), (n3) => e8.push(this.redoStack, n3, o3));
  }
  redo(o3, t3, r3) {
    return this.perform(o3, t3, r3, () => e8.pop(this.redoStack), (n3) => e8.push(this.undoStack, n3, o3));
  }
  perform(o3, t3, r3, n3, i3) {
    try {
      let a3 = n3();
      if (a3 === null) return;
      let l3 = o3, s3 = t3, c3 = false;
      for (; a3; ) {
        try {
          [l3, s3, c3] = a3.applyTo(l3, s3, r3);
        } finally {
          i3(a3);
        }
        if (c3) break;
        a3 = n3();
      }
      return [l3, s3];
    } finally {
      this.onHistoryChangedEmitter.trigger(new Sn(this.isUndoStackEmpty, this.isRedoStackEmpty));
    }
  }
  static pop(o3) {
    if (!o3.length) return null;
    let t3 = o3.pop();
    return t3 !== void 0 ? t3 : null;
  }
  static push(o3, t3, r3) {
    let n3 = t3.inverse().applyLatestChanges(r3);
    return o3.push(n3);
  }
}, Pu = class e10 {
  constructor(o3, t3) {
    this.appStateChange = o3;
    this.elementsChange = t3;
  }
  static create(o3, t3) {
    return new e10(o3, t3);
  }
  inverse() {
    return new e10(this.appStateChange.inverse(), this.elementsChange.inverse());
  }
  applyTo(o3, t3, r3) {
    let [n3, i3] = this.elementsChange.applyTo(o3, r3.elements), [a3, l3] = this.appStateChange.applyTo(t3, n3);
    return [n3, a3, i3 || l3];
  }
  applyLatestChanges(o3) {
    let t3 = this.elementsChange.applyLatestChanges(o3);
    return e10.create(this.appStateChange, t3);
  }
  isEmpty() {
    return this.appStateChange.isEmpty() && this.elementsChange.isEmpty();
  }
};
var Ru = (e12, o3) => {
  let [t3, r3] = reactExports.useState(o3);
  return reactExports.useEffect(() => {
    let n3 = e12.on((i3) => {
      r3(i3);
    });
    return () => {
      n3();
    };
  }, [e12]), t3;
};
var Lw = (e12, o3, t3) => {
  if (!o3.multiElement && !o3.resizingElement && !o3.editingTextElement && !o3.newElement && !o3.selectedElementsAreBeingDragged && !o3.selectionElement && !e12.flowChartCreator.isCreatingChart) {
    let r3 = t3();
    if (!r3) return { captureUpdate: dr.EVENTUALLY };
    let [n3, i3] = r3, a3 = Array.from(n3.values());
    return { appState: i3, elements: a3, captureUpdate: dr.NEVER };
  }
  return { captureUpdate: dr.EVENTUALLY };
}, Aw = (e12, o3) => ({ name: "undo", label: "buttons.undo", icon: Qx, trackEvent: { category: "history" }, viewMode: false, perform: (t3, r3, n3, i3) => Lw(i3, r3, () => e12.undo(te(t3), r3, o3.snapshot)), keyTest: (t3) => t3[Q.CTRL_OR_CMD] && Y$(t3, Q.Z) && !t3.shiftKey, PanelComponent: ({ updateData: t3, data: r3 }) => {
  let { isUndoStackEmpty: n3 } = Ru(e12.onHistoryChangedEmitter, new Sn(e12.isUndoStackEmpty, e12.isRedoStackEmpty));
  return jsxRuntimeExports.jsx(X, { type: "button", icon: Qx, "aria-label": g("buttons.undo"), onClick: t3, size: r3?.size || "medium", disabled: n3, "data-testid": "button-undo" });
} }), _w = (e12, o3) => ({ name: "redo", label: "buttons.redo", icon: jx, trackEvent: { category: "history" }, viewMode: false, perform: (t3, r3, n3, i3) => Lw(i3, r3, () => e12.redo(te(t3), r3, o3.snapshot)), keyTest: (t3) => t3[Q.CTRL_OR_CMD] && t3.shiftKey && Y$(t3, Q.Z) || iE && t3.ctrlKey && !t3.shiftKey && Y$(t3, Q.Y), PanelComponent: ({ updateData: t3, data: r3 }) => {
  let { isRedoStackEmpty: n3 } = Ru(e12.onHistoryChangedEmitter, new Sn(e12.isUndoStackEmpty, e12.isRedoStackEmpty));
  return jsxRuntimeExports.jsx(X, { type: "button", icon: jx, "aria-label": g("buttons.redo"), onClick: t3, size: r3?.size || "medium", disabled: n3, "data-testid": "button-redo" });
} });
var Nu = (e12, o3, t3, r3, n3, i3) => {
  if (e12.trackEvent) try {
    typeof e12.trackEvent == "object" && (!e12.trackEvent.predicate || e12.trackEvent.predicate(t3, r3, i3)) && le(e12.trackEvent.category, e12.trackEvent.action || e12.name, `${o3} (${n3.device.editor.isMobile ? "mobile" : "desktop"})`);
  } catch (a3) {
    console.error("error while logging action:", a3);
  }
}, $c = class {
  constructor(o3, t3, r3, n3) {
    i$1(this, "actions", {});
    i$1(this, "updater");
    i$1(this, "getAppState");
    i$1(this, "getElementsIncludingDeleted");
    i$1(this, "app");
    i$1(this, "renderAction", (o5, t5) => {
      let r5 = this.app.props.UIOptions.canvasActions;
      if (this.actions[o5] && "PanelComponent" in this.actions[o5] && (!(o5 in r5) || r5[o5])) {
        let n8 = this.actions[o5], i3 = n8.PanelComponent;
        i3.displayName = "PanelComponent";
        let a3 = this.getElementsIncludingDeleted(), l3 = this.getAppState(), s3 = (c3) => {
          Nu(n8, "ui", l3, a3, this.app, c3), this.updater(n8.perform(this.getElementsIncludingDeleted(), this.getAppState(), c3, this.app));
        };
        return jsxRuntimeExports.jsx(i3, { elements: this.getElementsIncludingDeleted(), appState: this.getAppState(), updateData: s3, appProps: this.app.props, app: this.app, data: t5 });
      }
      return null;
    });
    i$1(this, "isActionEnabled", (o5) => {
      let t5 = this.getElementsIncludingDeleted(), r5 = this.getAppState();
      return !o5.predicate || o5.predicate(t5, r5, this.app.props, this.app);
    });
    this.updater = (i3) => {
      if (Fo(i3)) i3.then((a3) => o3(a3));
      else return o3(i3);
    }, this.getAppState = t3, this.getElementsIncludingDeleted = r3, this.app = n3;
  }
  registerAction(o3) {
    this.actions[o3.name] = o3;
  }
  registerAll(o3) {
    o3.forEach((t3) => this.registerAction(t3));
  }
  handleKeyDown(o3) {
    let t3 = this.app.props.UIOptions.canvasActions, r3 = Object.values(this.actions).sort((s3, c3) => (c3.keyPriority || 0) - (s3.keyPriority || 0)).filter((s3) => (s3.name in t3 ? t3[s3.name] : true) && s3.keyTest && s3.keyTest(o3, this.getAppState(), this.getElementsIncludingDeleted(), this.app));
    if (r3.length !== 1) return r3.length > 1 && console.warn("Canceling as multiple actions match this shortcut", r3), false;
    let n3 = r3[0];
    if (this.getAppState().viewModeEnabled && n3.viewMode !== true) return false;
    let i3 = this.getElementsIncludingDeleted(), a3 = this.getAppState(), l3 = null;
    return Nu(n3, "keyboard", a3, i3, this.app, null), o3.preventDefault(), o3.stopPropagation(), this.updater(r3[0].perform(i3, a3, l3, this.app)), true;
  }
  executeAction(o3, t3 = "api", r3 = null) {
    let n3 = this.getElementsIncludingDeleted(), i3 = this.getAppState();
    Nu(o3, t3, i3, n3, this.app, r3), this.updater(o3.perform(n3, i3, r3, this.app));
  }
};
var Ou = (e12) => {
  let o3 = Array.from(e12.values());
  return { x: Dw(o3, (t3) => t3.x) / o3.length, y: Dw(o3, (t3) => t3.y) / o3.length };
}, Fu = ([e12, o3]) => Math.hypot(e12.x - o3.x, e12.y - o3.y), Dw = (e12, o3) => e12.reduce((t3, r3) => t3 + o3(r3), 0);
var Nw = ({ children: e12, left: o3, top: t3, onCloseRequest: r3, fitInViewport: n3 = false, offsetLeft: i3 = 0, offsetTop: a3 = 0, viewportWidth: l3 = window.innerWidth, viewportHeight: s3 = window.innerHeight }) => {
  let c3 = reactExports.useRef(null);
  reactExports.useEffect(() => {
    let d3 = c3.current;
    if (!d3) return;
    d3.contains(document.activeElement) || d3.focus();
    let p3 = (u3) => {
      if (u3.key === Q.TAB) {
        let h3 = Rg$1(d3), { activeElement: f3 } = document, b3 = h3.findIndex((x3) => x3 === f3);
        f3 === d3 ? (u3.shiftKey ? h3[h3.length - 1]?.focus() : h3[0].focus(), u3.preventDefault(), u3.stopImmediatePropagation()) : b3 === 0 && u3.shiftKey ? (h3[h3.length - 1]?.focus(), u3.preventDefault(), u3.stopImmediatePropagation()) : b3 === h3.length - 1 && !u3.shiftKey && (h3[0]?.focus(), u3.preventDefault(), u3.stopImmediatePropagation());
      }
    };
    return d3.addEventListener("keydown", p3), () => d3.removeEventListener("keydown", p3);
  }, []);
  let m3 = reactExports.useRef(null);
  return reactExports.useLayoutEffect(() => {
    if (n3 && c3.current && t3 != null && o3 != null) {
      let d3 = c3.current, { width: p3, height: u3 } = d3.getBoundingClientRect();
      if (m3.current?.top === t3 && m3.current?.left === o3) return;
      m3.current = { top: t3, left: o3 }, p3 >= l3 ? (d3.style.width = `${l3}px`, d3.style.left = "0px", d3.style.overflowX = "scroll") : o3 + p3 - i3 > l3 ? d3.style.left = `${l3 - p3 - 10}px` : d3.style.left = `${o3}px`, u3 >= s3 ? (d3.style.height = `${s3 - 20}px`, d3.style.top = "10px", d3.style.overflowY = "scroll") : t3 + u3 - a3 > s3 ? d3.style.top = `${s3 - u3}px` : d3.style.top = `${t3}px`;
    }
  }, [t3, o3, n3, l3, s3, i3, a3]), reactExports.useEffect(() => {
    if (r3) {
      let d3 = (p3) => {
        c3.current?.contains(p3.target) || reactDomExports.unstable_batchedUpdates(() => r3(p3));
      };
      return document.addEventListener("pointerdown", d3, false), () => document.removeEventListener("pointerdown", d3, false);
    }
  }, [r3]), jsxRuntimeExports.jsx("div", { className: "popover", ref: c3, tabIndex: -1, children: e12 });
};
var $e = "separator", Ow = React.memo(({ actionManager: e12, items: o3, top: t3, left: r3, onClose: n3 }) => {
  let i3 = Mo(), a3 = kr(), l3 = o3.reduce((s3, c3) => (c3 && (c3 === $e || !c3.predicate || c3.predicate(a3, i3, e12.app.props, e12.app)) && s3.push(c3), s3), []);
  return jsxRuntimeExports.jsx(Nw, { onCloseRequest: () => {
    n3();
  }, top: t3, left: r3, fitInViewport: true, offsetLeft: i3.offsetLeft, offsetTop: i3.offsetTop, viewportWidth: i3.width, viewportHeight: i3.height, children: jsxRuntimeExports.jsx("ul", { className: "context-menu", onContextMenu: (s3) => s3.preventDefault(), children: l3.map((s3, c3) => {
    if (s3 === $e) return !l3[c3 - 1] || l3[c3 - 1] === $e ? null : jsxRuntimeExports.jsx("hr", { className: "context-menu-item-separator" }, c3);
    let m3 = s3.name, d3 = "";
    return s3.label && (typeof s3.label == "function" ? d3 = g(s3.label(a3, i3, e12.app)) : d3 = g(s3.label)), jsxRuntimeExports.jsx("li", { "data-testid": m3, onClick: () => {
      n3(() => {
        e12.executeAction(s3, "contextMenu");
      });
    }, children: jsxRuntimeExports.jsxs("button", { type: "button", className: dM("context-menu-item", { dangerous: m3 === "deleteSelectedElements", checkmark: s3.checked?.(i3) }), children: [jsxRuntimeExports.jsx("div", { className: "context-menu-item__label", children: d3 }), jsxRuntimeExports.jsx("kbd", { className: "context-menu-item__shortcut", children: m3 ? Ye(m3) : "" })] }) }, c3);
  }) }) });
});
var Fw = ({ children: e12, onClose: o3 }) => {
  let [t3, r3] = reactExports.useState(!!e12), { container: n3 } = Ke(), i3 = React.useCallback(() => {
    r3(false), o3 && o3(), n3?.focus();
  }, [o3, n3]);
  return jsxRuntimeExports.jsx(jsxRuntimeExports.Fragment, { children: t3 && jsxRuntimeExports.jsx(Ge, { size: "small", onCloseRequest: i3, title: g("errorDialog.title"), children: jsxRuntimeExports.jsx("div", { style: { whiteSpace: "pre-wrap" }, children: e12 }) }) });
};
var Zc = function({ onChange: e12, value: o3, choices: t3, name: r3 }) {
  return jsxRuntimeExports.jsx("div", { className: "RadioGroup", children: t3.map((n3) => jsxRuntimeExports.jsxs("div", { className: dM("RadioGroup__choice", { active: n3.value === o3 }), title: n3.ariaLabel, children: [jsxRuntimeExports.jsx("input", { name: r3, type: "radio", checked: n3.value === o3, onChange: () => e12(n3.value), "aria-label": n3.ariaLabel }), n3.label] }, String(n3.value))) });
};
var $a = ({ title: e12, name: o3, checked: t3, onChange: r3, disabled: n3 = false }) => jsxRuntimeExports.jsx("div", { className: dM("Switch", { toggled: t3, disabled: n3 }), children: jsxRuntimeExports.jsx("input", { name: o3, id: o3, title: e12, type: "checkbox", checked: t3, disabled: n3, onChange: () => r3(!t3), onKeyDown: (i3) => {
  i3.key === " " && r3(!t3);
} }) });
var Dr = reactExports.forwardRef(({ children: e12, icon: o3, onClick: t3, label: r3, variant: n3 = "filled", color: i3 = "primary", size: a3 = "medium", fullWidth: l3, className: s3, status: c3 }, m3) => {
  let [d3, p3] = reactExports.useState(false), u3 = async (f3) => {
    let b3 = t3?.(f3);
    if (Fo(b3)) {
      let x3 = window.setTimeout(() => {
        p3(true);
      }, 50);
      try {
        await b3;
      } catch (T3) {
        if (T3 instanceof Co) console.warn(T3);
        else throw T3;
      } finally {
        clearTimeout(x3), p3(false);
      }
    }
  }, h3 = d3 ? "loading" : c3;
  return i3 = h3 === "success" ? "success" : i3, jsxRuntimeExports.jsx("button", { className: dM("ExcButton", `ExcButton--color-${i3}`, `ExcButton--variant-${n3}`, `ExcButton--size-${a3}`, `ExcButton--status-${h3}`, { "ExcButton--fullWidth": l3 }, s3), onClick: u3, type: "button", "aria-label": r3, ref: m3, disabled: h3 === "loading" || h3 === "success", children: jsxRuntimeExports.jsxs("div", { className: "ExcButton__contents", children: [h3 === "loading" ? jsxRuntimeExports.jsx(ct, { className: "ExcButton__statusIcon" }) : h3 === "success" && jsxRuntimeExports.jsx("div", { className: "ExcButton__statusIcon", children: I4 }), o3 && jsxRuntimeExports.jsx("div", { className: "ExcButton__icon", "aria-hidden": true, children: o3 }), n3 !== "icon" && (e12 ?? r3)] }) });
});
var nL = 2e3, Uw = () => {
  let [e12, o3] = reactExports.useState(null), t3 = reactExports.useRef(0), r3 = () => {
    clearTimeout(t3.current), o3("success"), t3.current = window.setTimeout(() => {
      o3(null);
    }, nL);
  }, n3 = reactExports.useCallback(() => {
    o3(null);
  }, []);
  return { copyStatus: e12, resetCopyStatus: n3, onCopy: r3 };
};
var aL = "filter" in document.createElement("canvas").getContext("2d"), lL = () => jsxRuntimeExports.jsxs("div", { children: [jsxRuntimeExports.jsx("h3", { children: g("canvasError.cannotShowPreview") }), jsxRuntimeExports.jsx("p", { children: jsxRuntimeExports.jsx("span", { children: g("canvasError.canvasTooBig") }) }), jsxRuntimeExports.jsxs("em", { children: ["(", g("canvasError.canvasTooBigTip"), ")"] })] }), sL = ({ appStateSnapshot: e$12, elementsSnapshot: o3, files: t3, actionManager: r3, onExportImage: n3, name: i3 }) => {
  let a3 = Ib(o3, e$12), [l3, s3] = reactExports.useState(i3), [c3, m3] = reactExports.useState(a3), [d3, p3] = reactExports.useState(e$12.exportBackground), [u3, h3] = reactExports.useState(e$12.exportWithDarkMode), [f3, b3] = reactExports.useState(e$12.exportEmbedScene), [x3, T3] = reactExports.useState(e$12.exportScale), E3 = reactExports.useRef(null), [w3, S3] = reactExports.useState(null), { onCopy: I3, copyStatus: _3, resetCopyStatus: k2 } = Uw();
  reactExports.useEffect(() => {
    k2();
  }, [l3, d3, u3, x3, f3, k2]);
  let { exportedElements: R3, exportingFrame: M } = yn(o3, e$12, c3);
  return reactExports.useEffect(() => {
    let N3 = E3.current;
    if (!N3) return;
    let G3 = N3.offsetWidth, H3 = N3.offsetHeight;
    G3 && t9({ elements: R3, appState: { ...e$12, name: l3, exportBackground: d3, exportWithDarkMode: u3, exportScale: x3, exportEmbedScene: f3 }, files: t3, exportPadding: Vi$1, maxWidthOrHeight: Math.max(G3, H3), exportingFrame: M }).then((V3) => (S3(null), vY(V3).then(() => {
      N3.replaceChildren(V3);
    }).catch((F3) => {
      throw F3.name === "CANVAS_POSSIBLY_TOO_BIG" ? new Error(g("canvasError.canvasTooBig")) : F3;
    }))).catch((V3) => {
      console.error(V3), S3(V3);
    });
  }, [e$12, t3, R3, M, l3, d3, u3, x3, f3]), jsxRuntimeExports.jsxs("div", { className: "ImageExportModal", children: [jsxRuntimeExports.jsx("h3", { children: g("imageExportDialog.header") }), jsxRuntimeExports.jsxs("div", { className: "ImageExportModal__preview", children: [jsxRuntimeExports.jsx("div", { className: "ImageExportModal__preview__canvas", ref: E3, children: w3 && jsxRuntimeExports.jsx(lL, {}) }), jsxRuntimeExports.jsx("div", { className: "ImageExportModal__preview__filename", children: !e && jsxRuntimeExports.jsx("input", { type: "text", className: "TextInput", value: l3, style: { width: "30ch" }, onChange: (N3) => {
    s3(N3.target.value), r3.executeAction(Yp, "ui", N3.target.value);
  } }) })] }), jsxRuntimeExports.jsxs("div", { className: "ImageExportModal__settings", children: [jsxRuntimeExports.jsx("h3", { children: g("imageExportDialog.header") }), a3 && jsxRuntimeExports.jsx(Za, { label: g("imageExportDialog.label.onlySelected"), name: "exportOnlySelected", children: jsxRuntimeExports.jsx($a, { name: "exportOnlySelected", checked: c3, onChange: (N3) => {
    m3(N3);
  } }) }), jsxRuntimeExports.jsx(Za, { label: g("imageExportDialog.label.withBackground"), name: "exportBackgroundSwitch", children: jsxRuntimeExports.jsx($a, { name: "exportBackgroundSwitch", checked: d3, onChange: (N3) => {
    p3(N3), r3.executeAction(Vp, "ui", N3);
  } }) }), aL && jsxRuntimeExports.jsx(Za, { label: g("imageExportDialog.label.darkMode"), name: "exportDarkModeSwitch", children: jsxRuntimeExports.jsx($a, { name: "exportDarkModeSwitch", checked: u3, onChange: (N3) => {
    h3(N3), r3.executeAction(rv, "ui", N3);
  } }) }), jsxRuntimeExports.jsx(Za, { label: g("imageExportDialog.label.embedScene"), tooltip: g("imageExportDialog.tooltip.embedScene"), name: "exportEmbedSwitch", children: jsxRuntimeExports.jsx($a, { name: "exportEmbedSwitch", checked: f3, onChange: (N3) => {
    b3(N3), r3.executeAction(fc, "ui", N3);
  } }) }), jsxRuntimeExports.jsx(Za, { label: g("imageExportDialog.label.scale"), name: "exportScale", children: jsxRuntimeExports.jsx(Zc, { name: "exportScale", value: x3, onChange: (N3) => {
    T3(N3), r3.executeAction(ov, "ui", N3);
  }, choices: Cs.map((N3) => ({ value: N3, label: `${N3}` })) }) }), jsxRuntimeExports.jsxs("div", { className: "ImageExportModal__settings__buttons", children: [jsxRuntimeExports.jsx(Dr, { className: "ImageExportModal__settings__buttons__button", label: g("imageExportDialog.title.exportToPng"), onClick: () => n3(wE.png, R3, { exportingFrame: M }), icon: b4, children: g("imageExportDialog.button.exportToPng") }), jsxRuntimeExports.jsx(Dr, { className: "ImageExportModal__settings__buttons__button", label: g("imageExportDialog.title.exportToSvg"), onClick: () => n3(wE.svg, R3, { exportingFrame: M }), icon: b4, children: g("imageExportDialog.button.exportToSvg") }), (LK || aE) && jsxRuntimeExports.jsx(Dr, { className: "ImageExportModal__settings__buttons__button", label: g("imageExportDialog.title.copyPngToClipboard"), status: _3, onClick: async () => {
    await n3(wE.clipboard, R3, { exportingFrame: M }), I3();
  }, icon: E4, children: g("imageExportDialog.button.copyPngToClipboard") })] })] })] });
}, Za = ({ label: e12, children: o3, tooltip: t3, name: r3 }) => jsxRuntimeExports.jsxs("div", { className: "ImageExportModal__settings__setting", title: e12, children: [jsxRuntimeExports.jsxs("label", { htmlFor: r3, className: "ImageExportModal__settings__setting__label", children: [e12, t3 && jsxRuntimeExports.jsx(Ut, { label: t3, long: true, children: x4 })] }), jsxRuntimeExports.jsx("div", { className: "ImageExportModal__settings__setting__content", children: o3 })] }), Gw = ({ elements: e12, appState: o3, files: t3, actionManager: r3, onExportImage: n3, onCloseRequest: i3, name: a3 }) => {
  let [{ appStateSnapshot: l3, elementsSnapshot: s3 }] = reactExports.useState(() => ({ appStateSnapshot: Lg$1(o3), elementsSnapshot: Lg$1(e12) }));
  return jsxRuntimeExports.jsx(Ge, { onCloseRequest: i3, size: "wide", title: false, children: jsxRuntimeExports.jsx(sL, { elementsSnapshot: s3, appStateSnapshot: l3, files: t3, actionManager: r3, onExportImage: n3, name: a3 }) });
};
var Jc = ({ children: e12, side: o3, className: t3 }) => jsxRuntimeExports.jsx("div", { className: dM("FixedSideContainer", `FixedSideContainer_side_${o3}`, t3), children: e12 });
var Hi = 100, kn = 100, Hu = (e12) => {
  switch (e12) {
    case Q.ARROW_UP:
      return "up";
    case Q.ARROW_DOWN:
      return "down";
    case Q.ARROW_RIGHT:
      return "right";
    case Q.ARROW_LEFT:
      return "left";
    default:
      return "right";
  }
}, Yw = (e12, o3, t3, r3) => {
  let n3 = [...t3.values()].reduce((i3, a3) => {
    let l3;
    if (X$1(a3) && (l3 = a3[e12 === "predecessors" ? "startBinding" : "endBinding"]) && a3[e12 === "predecessors" ? "endBinding" : "startBinding"]?.elementId === o3.id) {
      let s3 = t3.get(l3.elementId);
      if (!s3) return i3;
      Ae(xt(s3), "not an ExcalidrawBindableElement");
      let c3 = e12 === "predecessors" ? a3.points[a3.points.length - 1] : [0, 0], m3 = q1(o3, wt$1(o3), [c3[0] + a3.x, c3[1] + a3.y]);
      i3.push({ relative: s3, heading: m3 });
    }
    return i3;
  }, []);
  switch (r3) {
    case "up":
      return n3.filter((i3) => ve$1(i3.heading, ze$1)).map((i3) => i3.relative);
    case "down":
      return n3.filter((i3) => ve$1(i3.heading, Fe$1)).map((i3) => i3.relative);
    case "right":
      return n3.filter((i3) => ve$1(i3.heading, Re)).map((i3) => i3.relative);
    case "left":
      return n3.filter((i3) => ve$1(i3.heading, nt)).map((i3) => i3.relative);
  }
}, zu = (e12, o3, t3) => Yw("successors", e12, o3, t3), Uu = (e12, o3, t3) => Yw("predecessors", e12, o3, t3), mL = (e12, o3, t3) => {
  let r3 = kn + e12.width;
  if (t3 === "up" || t3 === "down") {
    let l3 = Hi + e12.height, s3 = e12.x, c3 = e12.x + e12.width;
    if (o3.every((m3) => m3.x + m3.width < s3 || m3.x > c3)) return { x: 0, y: l3 * (t3 === "up" ? -1 : 1) };
  } else if (t3 === "right" || t3 === "left") {
    let l3 = e12.y, s3 = e12.y + e12.height;
    if (o3.every((c3) => c3.y + c3.height < l3 || c3.y > s3)) return { x: (kn + e12.width) * (t3 === "left" ? -1 : 1), y: 0 };
  }
  if (t3 === "up" || t3 === "down") {
    let l3 = Hi + e12.height, s3 = (o3.length === 0, l3), c3 = o3.length === 0 ? 0 : (o3.length + 1) % 2 === 0 ? (o3.length + 1) / 2 * r3 : o3.length / 2 * r3 * -1;
    return t3 === "up" ? { x: c3, y: s3 * -1 } : { x: c3, y: s3 };
  }
  let n3 = Hi + e12.height, i3 = (o3.length === 0, kn + e12.width), a3 = o3.length === 0 ? 0 : (o3.length + 1) % 2 === 0 ? (o3.length + 1) / 2 * n3 : o3.length / 2 * n3 * -1;
  return t3 === "left" ? { x: i3 * -1, y: a3 } : { x: i3, y: a3 };
}, pL = (e12, o3, t3, r3) => {
  let n3 = zu(e12, o3, r3), i3 = Uu(e12, o3, r3), a3 = mL(e12, [...n3, ...i3], r3), l3 = Xr({ type: e12.type, x: e12.x + a3.x, y: e12.y + a3.y, width: e12.width, height: e12.height, roundness: e12.roundness, roughness: e12.roughness, backgroundColor: e12.backgroundColor, strokeColor: e12.strokeColor, strokeWidth: e12.strokeWidth, opacity: e12.opacity, fillStyle: e12.fillStyle, strokeStyle: e12.strokeStyle });
  Ae(Og$1(l3), "not an ExcalidrawFlowchartNodeElement");
  let s3 = Vw(e12, l3, o3, r3, t3);
  return { nextNode: l3, bindingArrow: s3 };
}, uL = (e12, o3, t3, r3, n3) => {
  let i3 = [];
  for (let a3 = 0; a3 < n3; a3++) {
    let l3, s3;
    if (r3 === "left" || r3 === "right") {
      let d3 = Hi * (n3 - 1) + n3 * e12.height, p3 = e12.y + e12.height / 2 - d3 / 2, u3 = kn + e12.width;
      r3 === "left" && (u3 *= -1), l3 = e12.x + u3;
      let h3 = (Hi + e12.height) * a3;
      s3 = p3 + h3;
    } else {
      let d3 = kn * (n3 - 1) + n3 * e12.width, p3 = e12.x + e12.width / 2 - d3 / 2, u3 = Hi + e12.height;
      r3 === "up" && (u3 *= -1), s3 = e12.y + u3;
      let h3 = (kn + e12.width) * a3;
      l3 = p3 + h3;
    }
    let c3 = Xr({ type: e12.type, x: l3, y: s3, width: e12.width, height: e12.height, roundness: e12.roundness, roughness: e12.roughness, backgroundColor: e12.backgroundColor, strokeColor: e12.strokeColor, strokeWidth: e12.strokeWidth, opacity: e12.opacity, fillStyle: e12.fillStyle, strokeStyle: e12.strokeStyle });
    Ae(Og$1(c3), "not an ExcalidrawFlowchartNodeElement");
    let m3 = Vw(e12, c3, o3, r3, t3);
    i3.push(c3), i3.push(m3);
  }
  return i3;
}, Vw = (e12, o3, t3, r3, n3) => {
  let i3, a3;
  switch (r3) {
    case "up": {
      i3 = e12.x + e12.width / 2, a3 = e12.y - 6;
      break;
    }
    case "down": {
      i3 = e12.x + e12.width / 2, a3 = e12.y + e12.height + 6;
      break;
    }
    case "right": {
      i3 = e12.x + e12.width + 6, a3 = e12.y + e12.height / 2;
      break;
    }
    case "left": {
      i3 = e12.x - 6, a3 = e12.y + e12.height / 2;
      break;
    }
  }
  let s3, c3;
  switch (r3) {
    case "up": {
      s3 = o3.x + o3.width / 2 - i3, c3 = o3.y + o3.height - a3 + 6;
      break;
    }
    case "down": {
      s3 = o3.x + o3.width / 2 - i3, c3 = o3.y - a3 - 6;
      break;
    }
    case "right": {
      s3 = o3.x - i3 - 6, c3 = o3.y - a3 + o3.height / 2;
      break;
    }
    case "left": {
      s3 = o3.x + o3.width - i3 + 6, c3 = o3.y - a3 + o3.height / 2;
      break;
    }
  }
  let m3 = Zb({ type: "arrow", x: i3, y: a3, startArrowhead: null, endArrowhead: n3.currentItemEndArrowhead, strokeColor: e12.strokeColor, strokeStyle: e12.strokeStyle, strokeWidth: e12.strokeWidth, opacity: e12.opacity, roughness: e12.roughness, points: [u$1(0, 0), u$1(s3, c3)], elbowed: true });
  di(m3, e12, "start", t3), di(m3, o3, "end", t3);
  let d3 = /* @__PURE__ */ new Map();
  d3.set(e12.id, e12), d3.set(o3.id, o3), d3.set(m3.id, m3), z$1.movePoints(m3, [{ index: 1, point: m3.points[1] }]);
  let p3 = Pi(m3, tt(new Map([...t3.entries(), [e12.id, e12], [o3.id, o3], [m3.id, m3]])), { points: m3.points });
  return { ...m3, ...p3 };
}, qc = class {
  constructor() {
    i$1(this, "isExploring", false);
    i$1(this, "sameLevelNodes", []);
    i$1(this, "sameLevelIndex", 0);
    i$1(this, "direction", null);
    i$1(this, "visitedNodes", /* @__PURE__ */ new Set());
  }
  clear() {
    this.isExploring = false, this.sameLevelNodes = [], this.sameLevelIndex = 0, this.direction = null, this.visitedNodes.clear();
  }
  exploreByDirection(o3, t3, r3) {
    if (!xt(o3)) return null;
    if (r3 !== this.direction && this.clear(), this.visitedNodes.has(o3.id) || this.visitedNodes.add(o3.id), this.isExploring && r3 === this.direction && this.sameLevelNodes.length > 1) return this.sameLevelIndex = (this.sameLevelIndex + 1) % this.sameLevelNodes.length, this.sameLevelNodes[this.sameLevelIndex].id;
    let n3 = [...zu(o3, t3, r3), ...Uu(o3, t3, r3)];
    if (n3.length > 0) return this.sameLevelIndex = 0, this.isExploring = true, this.sameLevelNodes = n3, this.direction = r3, this.visitedNodes.add(n3[0].id), n3[0].id;
    if (r3 === this.direction || !this.isExploring) {
      this.isExploring || this.visitedNodes.add(o3.id);
      let a3 = ["up", "right", "down", "left"].filter((l3) => l3 !== r3).map((l3) => [...zu(o3, t3, l3), ...Uu(o3, t3, l3)]).flat().filter((l3) => !this.visitedNodes.has(l3.id));
      for (let l3 of a3) if (!this.visitedNodes.has(l3.id)) return this.visitedNodes.add(l3.id), this.isExploring = true, this.direction = r3, l3.id;
    }
    return null;
  }
}, Qc = class {
  constructor() {
    i$1(this, "isCreatingChart", false);
    i$1(this, "numberOfNodes", 0);
    i$1(this, "direction", "right");
    i$1(this, "pendingNodes", null);
  }
  createNodes(o3, t3, r3, n3) {
    if (n3 !== this.direction) {
      let { nextNode: i3, bindingArrow: a3 } = pL(o3, t3, r3, n3);
      this.numberOfNodes = 1, this.isCreatingChart = true, this.direction = n3, this.pendingNodes = [i3, a3];
    } else {
      this.numberOfNodes += 1;
      let i3 = uL(o3, t3, r3, n3, this.numberOfNodes);
      this.isCreatingChart = true, this.direction = n3, this.pendingNodes = i3;
    }
    if (o3.frameId) {
      let i3 = t3.get(o3.frameId);
      Ae(i3 && hd$1(i3), "not an ExcalidrawFrameElement"), i3 && this.pendingNodes.every((a3) => Bi([a3], i3, t3) || hn(a3, i3, t3)) && (this.pendingNodes = this.pendingNodes.map((a3) => Y(a3, { frameId: o3.frameId }, false)));
    }
  }
  clear() {
    this.isCreatingChart = false, this.pendingNodes = null, this.direction = null, this.numberOfNodes = 0;
  }
}, Ww = (e12, o3) => {
  for (let [, t3] of o3) if (t3.type === "arrow" && (t3.startBinding?.elementId === e12.id || t3.endBinding?.elementId === e12.id)) return true;
  return false;
};
var gL = ({ appState: e12, isMobile: o3, device: t3, app: r3 }) => {
  let { activeTool: n3, isResizing: i3, isRotating: a3, lastPointerDownWith: l3 } = e12, s3 = e12.multiElement !== null;
  if (e12.openSidebar?.name === ks.name && e12.openSidebar.tab === HE && e12.searchMatches?.length) return g("hints.dismissSearch");
  if (e12.openSidebar && !t3.editor.canFitSidebar) return null;
  if (td$1(e12)) return g("hints.eraserRevert");
  if (n3.type === "arrow" || n3.type === "line") return s3 ? g("hints.linearElementMulti") : n3.type === "arrow" ? g("hints.arrowTool", { arrowShortcut: cg$1("A") }) : g("hints.linearElement");
  if (n3.type === "freedraw") return g("hints.freeDraw");
  if (n3.type === "text") return g("hints.text");
  if (n3.type === "embeddable") return g("hints.embeddable");
  if (e12.activeTool.type === "image" && e12.pendingImageElementId) return g("hints.placeImage");
  let c3 = r3.scene.getSelectedElements(e12);
  if (i3 && l3 === "mouse" && c3.length === 1) {
    let m3 = c3[0];
    return ae(m3) && m3.points.length === 2 ? g("hints.lockAngle") : Ye$1(m3) ? g("hints.resizeImage") : g("hints.resize");
  }
  if (a3 && l3 === "mouse") return g("hints.rotate");
  if (c3.length === 1 && k$2(c3[0])) return g("hints.text_selected");
  if (e12.editingTextElement) return g("hints.text_editing");
  if (e12.croppingElementId) return g("hints.leaveCropEditor");
  if (c3.length === 1 && Ye$1(c3[0])) return g("hints.enterCropEditor");
  if (n3.type === "selection") {
    if (e12.selectionElement && !c3.length && !e12.editingTextElement && !e12.editingLinearElement) return g("hints.deepBoxSelect");
    if (Sb(r3) && e12.selectedElementsAreBeingDragged) return g("hints.disableSnapping");
    if (!c3.length && !o3) return g("hints.canvasPanning");
    if (c3.length === 1) {
      if (ae(c3[0])) return e12.editingLinearElement ? e12.editingLinearElement.selectedPointsIndices ? g("hints.lineEditor_pointSelected") : g("hints.lineEditor_nothingSelected") : g("hints.lineEditor_info");
      if (!e12.newElement && !e12.selectedElementsAreBeingDragged && F6(c3[0])) return Og$1(c3[0]) ? Ww(c3[0], r3.scene.getNonDeletedElementsMap()) ? [g("hints.bindTextToElement"), g("hints.createFlowchart")] : [g("hints.bindTextToElement"), g("hints.createFlowchart")] : g("hints.bindTextToElement");
    }
  }
  return null;
}, ed = ({ appState: e12, isMobile: o3, device: t3, app: r3 }) => {
  let n3 = gL({ appState: e12, isMobile: o3, device: t3, app: r3 });
  if (!n3) return null;
  let i3 = Array.isArray(n3) ? n3.map((a3) => cg$1(a3).replace(/\. ?$/, "")).join(". ") : cg$1(n3);
  return jsxRuntimeExports.jsx("div", { className: "HintViewer", children: jsxRuntimeExports.jsx("span", { children: i3 }) });
};
var fL = "medium", Xw = { CHECKED: bx, UNCHECKED: mx }, td = (e12) => jsxRuntimeExports.jsxs("label", { className: dM("ToolIcon ToolIcon__lock", `ToolIcon_size_${fL}`, { "is-mobile": e12.isMobile }), title: `${e12.title}  Q`, children: [jsxRuntimeExports.jsx("input", { className: "ToolIcon_type_checkbox", type: "checkbox", name: e12.name, onChange: e12.onChange, checked: e12.checked, "aria-label": e12.title, "data-testid": "toolbar-lock" }), jsxRuntimeExports.jsx("div", { className: "ToolIcon__icon", children: e12.checked ? Xw.CHECKED : Xw.UNCHECKED })] });
var Nr = ({ heading: e12, children: o3, ...t3 }) => {
  let { id: r3 } = Ke(), n3 = jsxRuntimeExports.jsx("h2", { className: "visually-hidden", id: `${r3}-${e12}-title`, children: g(`headings.${e12}`) });
  return jsxRuntimeExports.jsx("section", { ...t3, "aria-labelledby": `${r3}-${e12}-title`, children: typeof o3 == "function" ? o3(n3) : jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [n3, o3] }) });
};
var Eo = 4, Oo = 6, jw = "rgba(0,0,0,0.3)", Jw = (e12, o3, t3, r3) => {
  if (!e12.length) return { horizontal: null, vertical: null };
  let [n3, i3, a3, l3] = $e$1(e12), s3 = o3 / r3.zoom.value, c3 = t3 / r3.zoom.value, m3 = o3 - s3, d3 = t3 - c3, p3 = { top: parseInt(lg$1("sat")) || 0, bottom: parseInt(lg$1("sab")) || 0, left: parseInt(lg$1("sal")) || 0, right: parseInt(lg$1("sar")) || 0 }, u3 = qo().rtl, h3 = -r3.scrollX + m3 / 2 + p3.left, f3 = -r3.scrollY + d3 / 2 + p3.top, b3 = h3 + s3 - p3.right, x3 = f3 + c3 - p3.bottom, T3 = Math.min(n3, h3), E3 = Math.min(i3, f3), w3 = Math.max(a3, b3), S3 = Math.max(l3, x3);
  return { horizontal: h3 === T3 && b3 === w3 ? null : { x: Math.max(p3.left, Eo) + (h3 - T3) / (w3 - T3) * o3, y: t3 - Oo - Math.max(Eo, p3.bottom), width: (b3 - h3) / (w3 - T3) * o3 - Math.max(Eo * 2, p3.left + p3.right), height: Oo }, vertical: f3 === E3 && x3 === S3 ? null : { x: u3 ? Math.max(p3.left, Eo) : o3 - Oo - Math.max(p3.right, Eo), y: (f3 - E3) / (S3 - E3) * t3 + Math.max(p3.top, Eo), width: Oo, height: (x3 - f3) / (S3 - E3) * t3 - Math.max(Eo * 2, p3.top + p3.bottom) } };
}, Gu = (e12, o3, t3) => {
  let [r3, n3] = [e12.horizontal, e12.vertical].map((a3) => a3 != null && a3.x <= o3 && o3 <= a3.x + a3.width && a3.y <= t3 && t3 <= a3.y + a3.height);
  return { isOverEither: r3 || n3, isOverHorizontal: r3, isOverVertical: n3 };
};
var vL = "medium", od = (e12) => e12.penDetected ? jsxRuntimeExports.jsxs("label", { className: dM("ToolIcon ToolIcon__penMode", `ToolIcon_size_${vL}`, { "is-mobile": e12.isMobile }), title: `${e12.title}`, children: [jsxRuntimeExports.jsx("input", { className: "ToolIcon_type_checkbox", type: "checkbox", name: e12.name, onChange: e12.onChange, checked: e12.checked, "aria-label": e12.title }), jsxRuntimeExports.jsx("div", { className: "ToolIcon__icon", children: yx })] }) : null;
var rd = (e12) => jsxRuntimeExports.jsx(X, { className: dM("Shape", { fillable: false }), type: "radio", icon: m4, name: "editor-current-shape", checked: e12.checked, title: `${e12.title}  H`, keyBindingLabel: e12.isMobile ? void 0 : Q.H.toLocaleUpperCase(), "aria-label": `${e12.title}  H`, "aria-keyshortcuts": Q.H, "data-testid": "toolbar-hand", onChange: () => e12.onChange?.() });
var Qw = ({ appState: e12, elements: o3, actionManager: t3, setAppState: r3, onLockToggle: n3, onHandToolToggle: i3, onPenModeToggle: a3, renderTopRightUI: l3, renderCustomStats: s3, renderSidebars: c3, device: m3, renderWelcomeScreen: d3, UIOptions: p3, app: u3 }) => {
  let { WelcomeScreenCenterTunnel: h3, MainMenuTunnel: f3, DefaultSidebarTriggerTunnel: b3 } = _e(), x3 = () => jsxRuntimeExports.jsxs(Jc, { side: "top", className: "App-top-bar", children: [d3 && jsxRuntimeExports.jsx(h3.Out, {}), jsxRuntimeExports.jsx(Nr, { heading: "shapes", children: (E3) => jsxRuntimeExports.jsx(it.Col, { gap: 4, align: "center", children: jsxRuntimeExports.jsxs(it.Row, { gap: 1, className: "App-toolbar-container", children: [jsxRuntimeExports.jsxs(Qe2, { padding: 1, className: "App-toolbar App-toolbar--mobile", children: [E3, jsxRuntimeExports.jsx(it.Row, { gap: 1, children: jsxRuntimeExports.jsx(Yc, { appState: e12, activeTool: e12.activeTool, UIOptions: p3, app: u3 }) })] }), l3 && l3(true, e12), jsxRuntimeExports.jsxs("div", { className: "mobile-misc-tools-container", children: [!e12.viewModeEnabled && e12.openDialog?.name !== "elementLinkSelector" && jsxRuntimeExports.jsx(b3.Out, {}), jsxRuntimeExports.jsx(od, { checked: e12.penMode, onChange: () => a3(null), title: g("toolBar.penMode"), isMobile: true, penDetected: e12.penDetected }), jsxRuntimeExports.jsx(td, { checked: e12.activeTool.locked, onChange: n3, title: g("toolBar.lock"), isMobile: true }), jsxRuntimeExports.jsx(rd, { checked: nd(e12), onChange: () => i3(), title: g("toolBar.hand"), isMobile: true })] })] }) }) }), jsxRuntimeExports.jsx(ed, { appState: e12, isMobile: true, device: m3, app: u3 })] }), T3 = () => e12.viewModeEnabled || e12.openDialog?.name === "elementLinkSelector" ? jsxRuntimeExports.jsx("div", { className: "App-toolbar-content", children: jsxRuntimeExports.jsx(f3.Out, {}) }) : jsxRuntimeExports.jsxs("div", { className: "App-toolbar-content", children: [jsxRuntimeExports.jsx(f3.Out, {}), t3.renderAction("toggleEditMenu"), t3.renderAction(e12.multiElement ? "finalize" : "duplicateSelection"), t3.renderAction("deleteSelectedElements"), jsxRuntimeExports.jsxs("div", { children: [t3.renderAction("undo"), t3.renderAction("redo")] })] });
  return jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [c3(), !e12.viewModeEnabled && e12.openDialog?.name !== "elementLinkSelector" && x3(), jsxRuntimeExports.jsx("div", { className: "App-bottom-bar", style: { marginBottom: Oo + Eo * 2, marginLeft: Oo + Eo * 2, marginRight: Oo + Eo * 2 }, children: jsxRuntimeExports.jsxs(Qe2, { padding: 0, children: [e12.openMenu === "shape" && !e12.viewModeEnabled && e12.openDialog?.name !== "elementLinkSelector" && O9(e12, o3) ? jsxRuntimeExports.jsx(Nr, { className: "App-mobile-menu", heading: "selectedShapeActions", children: jsxRuntimeExports.jsx(Gc, { appState: e12, elementsMap: u3.scene.getNonDeletedElementsMap(), renderAction: t3.renderAction, app: u3 }) }) : null, jsxRuntimeExports.jsxs("footer", { className: "App-toolbar", children: [T3(), e12.scrolledOutside && !e12.openMenu && !e12.openSidebar && jsxRuntimeExports.jsx("button", { type: "button", className: "scroll-back-to-content", onClick: () => {
    r3((E3) => ({ ..._a$1(o3, E3) }));
  }, children: g("buttons.scrollBackToContent") })] })] }) })] });
};
var e0 = (e12) => {
  let o3 = reactExports.useRef(null), [t3, r3] = reactExports.useState(null);
  return reactExports.useLayoutEffect(() => {
    if (!e12.spreadsheet) return;
    let n3 = uK(e12.chartType, e12.spreadsheet, 0, 0);
    r3(n3);
    let i3, a3 = o3.current;
    return (async () => (i3 = await up$1(n3, { exportBackground: false, viewBackgroundColor: _d$1.white }, null, { skipInliningFonts: true }), i3.querySelector(".style-fonts")?.remove(), a3.replaceChildren(), a3.appendChild(i3), e12.selected && a3.parentNode.focus()))(), () => {
      a3.replaceChildren();
    };
  }, [e12.spreadsheet, e12.chartType, e12.selected]), jsxRuntimeExports.jsx("button", { type: "button", className: "ChartPreview", onClick: () => {
    t3 && e12.onClick(e12.chartType, t3);
  }, children: jsxRuntimeExports.jsx("div", { ref: o3 }) });
}, t0 = ({ setAppState: e12, appState: o3, onClose: t3 }) => {
  let { onInsertElements: r3 } = He(), n3 = React.useCallback(() => {
    t3 && t3();
  }, [t3]), i3 = (a3, l3) => {
    r3(l3), le("paste", "chart", a3), e12({ currentChartType: a3, pasteDialog: { shown: false, data: null } });
  };
  return jsxRuntimeExports.jsx(Ge, { size: "small", onCloseRequest: n3, title: g("labels.pasteCharts"), className: "PasteChartDialog", autofocus: false, children: jsxRuntimeExports.jsxs("div", { className: "container", children: [jsxRuntimeExports.jsx(e0, { chartType: "bar", spreadsheet: o3.pasteDialog.data, selected: o3.currentChartType === "bar", onClick: i3 }), jsxRuntimeExports.jsx(e0, { chartType: "line", spreadsheet: o3.pasteDialog.data, selected: o3.currentChartType === "line", onClick: i3 })] }) });
};
var PL = () => jsxRuntimeExports.jsxs("div", { className: "HelpDialog__header", children: [jsxRuntimeExports.jsxs("a", { className: "HelpDialog__btn", href: "https://docs.excalidraw.com", target: "_blank", rel: "noopener noreferrer", children: [jsxRuntimeExports.jsx("div", { className: "HelpDialog__link-icon", children: Fx }), g("helpDialog.documentation")] }), jsxRuntimeExports.jsxs("a", { className: "HelpDialog__btn", href: "https://plus.excalidraw.com/blog", target: "_blank", rel: "noopener noreferrer", children: [jsxRuntimeExports.jsx("div", { className: "HelpDialog__link-icon", children: Fx }), g("helpDialog.blog")] }), jsxRuntimeExports.jsxs("a", { className: "HelpDialog__btn", href: "https://github.com/excalidraw/excalidraw/issues", target: "_blank", rel: "noopener noreferrer", children: [jsxRuntimeExports.jsx("div", { className: "HelpDialog__link-icon", children: Bx }), g("helpDialog.github")] }), jsxRuntimeExports.jsxs("a", { className: "HelpDialog__btn", href: "https://youtube.com/@excalidraw", target: "_blank", rel: "noopener noreferrer", children: [jsxRuntimeExports.jsx("div", { className: "HelpDialog__link-icon", children: ty$1 }), "YouTube"] })] }), RL = (e12) => jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [jsxRuntimeExports.jsx("h3", { children: e12.title }), jsxRuntimeExports.jsx("div", { className: "HelpDialog__islands-container", children: e12.children })] }), Yu = (e12) => jsxRuntimeExports.jsxs("div", { className: `HelpDialog__island ${e12.className}`, children: [jsxRuntimeExports.jsx("h4", { className: "HelpDialog__island-title", children: e12.caption }), jsxRuntimeExports.jsx("div", { className: "HelpDialog__island-content", children: e12.children })] });
function* NL(e12, o3) {
  let t3 = true;
  for (let r3 of e12) t3 || (yield o3), t3 = false, yield r3;
}
var OL = (e12) => e12.replace(/\b[a-z]\b/, (o3) => o3.toUpperCase()), U = ({ label: e12, shortcuts: o3, isOr: t3 = true }) => {
  let r3 = o3.map((n3) => (n3.endsWith("++") ? [...n3.slice(0, -2).split("+"), "+"] : n3.split("+")).map((a3) => jsxRuntimeExports.jsx(FL, { children: OL(a3) }, a3)));
  return jsxRuntimeExports.jsxs("div", { className: "HelpDialog__shortcut", children: [jsxRuntimeExports.jsx("div", { children: e12 }), jsxRuntimeExports.jsx("div", { className: "HelpDialog__key-container", children: [...NL(r3, t3 ? g("helpDialog.or") : null)] })] });
}, FL = (e12) => jsxRuntimeExports.jsx("kbd", { className: "HelpDialog__key", ...e12 }), o0 = ({ onClose: e12 }) => {
  let o3 = React.useCallback(() => {
    e12 && e12();
  }, [e12]);
  return jsxRuntimeExports.jsx(jsxRuntimeExports.Fragment, { children: jsxRuntimeExports.jsxs(Ge, { onCloseRequest: o3, title: g("helpDialog.title"), className: "HelpDialog", children: [jsxRuntimeExports.jsx(PL, {}), jsxRuntimeExports.jsxs(RL, { title: g("helpDialog.shortcuts"), children: [jsxRuntimeExports.jsxs(Yu, { className: "HelpDialog__island--tools", caption: g("helpDialog.tools"), children: [jsxRuntimeExports.jsx(U, { label: g("toolBar.hand"), shortcuts: [Q.H] }), jsxRuntimeExports.jsx(U, { label: g("toolBar.selection"), shortcuts: [Q.V, Q[1]] }), jsxRuntimeExports.jsx(U, { label: g("toolBar.rectangle"), shortcuts: [Q.R, Q[2]] }), jsxRuntimeExports.jsx(U, { label: g("toolBar.diamond"), shortcuts: [Q.D, Q[3]] }), jsxRuntimeExports.jsx(U, { label: g("toolBar.ellipse"), shortcuts: [Q.O, Q[4]] }), jsxRuntimeExports.jsx(U, { label: g("toolBar.arrow"), shortcuts: [Q.A, Q[5]] }), jsxRuntimeExports.jsx(U, { label: g("toolBar.line"), shortcuts: [Q.L, Q[6]] }), jsxRuntimeExports.jsx(U, { label: g("toolBar.freedraw"), shortcuts: [Q.P, Q[7]] }), jsxRuntimeExports.jsx(U, { label: g("toolBar.text"), shortcuts: [Q.T, Q[8]] }), jsxRuntimeExports.jsx(U, { label: g("toolBar.image"), shortcuts: [Q[9]] }), jsxRuntimeExports.jsx(U, { label: g("toolBar.eraser"), shortcuts: [Q.E, Q[0]] }), jsxRuntimeExports.jsx(U, { label: g("toolBar.frame"), shortcuts: [Q.F] }), jsxRuntimeExports.jsx(U, { label: g("toolBar.laser"), shortcuts: [Q.K] }), jsxRuntimeExports.jsx(U, { label: g("labels.eyeDropper"), shortcuts: [Q.I, "Shift+S", "Shift+G"] }), jsxRuntimeExports.jsx(U, { label: g("helpDialog.editLineArrowPoints"), shortcuts: [cg$1("CtrlOrCmd+Enter")] }), jsxRuntimeExports.jsx(U, { label: g("helpDialog.editText"), shortcuts: [cg$1("Enter")] }), jsxRuntimeExports.jsx(U, { label: g("helpDialog.textNewLine"), shortcuts: [cg$1("Enter"), cg$1("Shift+Enter")] }), jsxRuntimeExports.jsx(U, { label: g("helpDialog.textFinish"), shortcuts: [cg$1("Esc"), cg$1("CtrlOrCmd+Enter")] }), jsxRuntimeExports.jsx(U, { label: g("helpDialog.curvedArrow"), shortcuts: ["A", g("helpDialog.click"), g("helpDialog.click"), g("helpDialog.click")], isOr: false }), jsxRuntimeExports.jsx(U, { label: g("helpDialog.curvedLine"), shortcuts: ["L", g("helpDialog.click"), g("helpDialog.click"), g("helpDialog.click")], isOr: false }), jsxRuntimeExports.jsx(U, { label: g("helpDialog.cropStart"), shortcuts: [g("helpDialog.doubleClick"), cg$1("Enter")], isOr: true }), jsxRuntimeExports.jsx(U, { label: g("helpDialog.cropFinish"), shortcuts: [cg$1("Enter"), cg$1("Escape")], isOr: true }), jsxRuntimeExports.jsx(U, { label: g("toolBar.lock"), shortcuts: [Q.Q] }), jsxRuntimeExports.jsx(U, { label: g("helpDialog.preventBinding"), shortcuts: [cg$1("CtrlOrCmd")] }), jsxRuntimeExports.jsx(U, { label: g("toolBar.link"), shortcuts: [cg$1("CtrlOrCmd+K")] })] }), jsxRuntimeExports.jsxs(Yu, { className: "HelpDialog__island--view", caption: g("helpDialog.view"), children: [jsxRuntimeExports.jsx(U, { label: g("buttons.zoomIn"), shortcuts: [cg$1("CtrlOrCmd++")] }), jsxRuntimeExports.jsx(U, { label: g("buttons.zoomOut"), shortcuts: [cg$1("CtrlOrCmd+-")] }), jsxRuntimeExports.jsx(U, { label: g("buttons.resetZoom"), shortcuts: [cg$1("CtrlOrCmd+0")] }), jsxRuntimeExports.jsx(U, { label: g("helpDialog.zoomToFit"), shortcuts: ["Shift+1"] }), jsxRuntimeExports.jsx(U, { label: g("helpDialog.zoomToSelection"), shortcuts: ["Shift+2"] }), jsxRuntimeExports.jsx(U, { label: g("helpDialog.movePageUpDown"), shortcuts: ["PgUp/PgDn"] }), jsxRuntimeExports.jsx(U, { label: g("helpDialog.movePageLeftRight"), shortcuts: ["Shift+PgUp/PgDn"] }), jsxRuntimeExports.jsx(U, { label: g("buttons.zenMode"), shortcuts: [cg$1("Alt+Z")] }), jsxRuntimeExports.jsx(U, { label: g("buttons.objectsSnapMode"), shortcuts: [cg$1("Alt+S")] }), jsxRuntimeExports.jsx(U, { label: g("labels.toggleGrid"), shortcuts: [cg$1("CtrlOrCmd+'")] }), jsxRuntimeExports.jsx(U, { label: g("labels.viewMode"), shortcuts: [cg$1("Alt+R")] }), jsxRuntimeExports.jsx(U, { label: g("labels.toggleTheme"), shortcuts: [cg$1("Alt+Shift+D")] }), jsxRuntimeExports.jsx(U, { label: g("stats.fullTitle"), shortcuts: [cg$1("Alt+/")] }), jsxRuntimeExports.jsx(U, { label: g("search.title"), shortcuts: [Ye("searchMenu")] }), jsxRuntimeExports.jsx(U, { label: g("commandPalette.title"), shortcuts: aE ? [Ye("commandPalette")] : [Ye("commandPalette"), Ye("commandPalette", 1)] })] }), jsxRuntimeExports.jsxs(Yu, { className: "HelpDialog__island--editor", caption: g("helpDialog.editor"), children: [jsxRuntimeExports.jsx(U, { label: g("helpDialog.createFlowchart"), shortcuts: [cg$1("CtrlOrCmd+Arrow Key")], isOr: true }), jsxRuntimeExports.jsx(U, { label: g("helpDialog.navigateFlowchart"), shortcuts: [cg$1("Alt+Arrow Key")], isOr: true }), jsxRuntimeExports.jsx(U, { label: g("labels.moveCanvas"), shortcuts: [cg$1(`Space+${g("helpDialog.drag")}`), cg$1(`Wheel+${g("helpDialog.drag")}`)], isOr: true }), jsxRuntimeExports.jsx(U, { label: g("buttons.clearReset"), shortcuts: [cg$1("CtrlOrCmd+Delete")] }), jsxRuntimeExports.jsx(U, { label: g("labels.delete"), shortcuts: [cg$1("Delete")] }), jsxRuntimeExports.jsx(U, { label: g("labels.cut"), shortcuts: [cg$1("CtrlOrCmd+X")] }), jsxRuntimeExports.jsx(U, { label: g("labels.copy"), shortcuts: [cg$1("CtrlOrCmd+C")] }), jsxRuntimeExports.jsx(U, { label: g("labels.paste"), shortcuts: [cg$1("CtrlOrCmd+V")] }), jsxRuntimeExports.jsx(U, { label: g("labels.pasteAsPlaintext"), shortcuts: [cg$1("CtrlOrCmd+Shift+V")] }), jsxRuntimeExports.jsx(U, { label: g("labels.selectAll"), shortcuts: [cg$1("CtrlOrCmd+A")] }), jsxRuntimeExports.jsx(U, { label: g("labels.multiSelect"), shortcuts: [cg$1(`Shift+${g("helpDialog.click")}`)] }), jsxRuntimeExports.jsx(U, { label: g("helpDialog.deepSelect"), shortcuts: [cg$1(`CtrlOrCmd+${g("helpDialog.click")}`)] }), jsxRuntimeExports.jsx(U, { label: g("helpDialog.deepBoxSelect"), shortcuts: [cg$1(`CtrlOrCmd+${g("helpDialog.drag")}`)] }), (LK || aE) && jsxRuntimeExports.jsx(U, { label: g("labels.copyAsPng"), shortcuts: [cg$1("Shift+Alt+C")] }), jsxRuntimeExports.jsx(U, { label: g("labels.copyStyles"), shortcuts: [cg$1("CtrlOrCmd+Alt+C")] }), jsxRuntimeExports.jsx(U, { label: g("labels.pasteStyles"), shortcuts: [cg$1("CtrlOrCmd+Alt+V")] }), jsxRuntimeExports.jsx(U, { label: g("labels.sendToBack"), shortcuts: [uo ? cg$1("CtrlOrCmd+Alt+[") : cg$1("CtrlOrCmd+Shift+[")] }), jsxRuntimeExports.jsx(U, { label: g("labels.bringToFront"), shortcuts: [uo ? cg$1("CtrlOrCmd+Alt+]") : cg$1("CtrlOrCmd+Shift+]")] }), jsxRuntimeExports.jsx(U, { label: g("labels.sendBackward"), shortcuts: [cg$1("CtrlOrCmd+[")] }), jsxRuntimeExports.jsx(U, { label: g("labels.bringForward"), shortcuts: [cg$1("CtrlOrCmd+]")] }), jsxRuntimeExports.jsx(U, { label: g("labels.alignTop"), shortcuts: [cg$1("CtrlOrCmd+Shift+Up")] }), jsxRuntimeExports.jsx(U, { label: g("labels.alignBottom"), shortcuts: [cg$1("CtrlOrCmd+Shift+Down")] }), jsxRuntimeExports.jsx(U, { label: g("labels.alignLeft"), shortcuts: [cg$1("CtrlOrCmd+Shift+Left")] }), jsxRuntimeExports.jsx(U, { label: g("labels.alignRight"), shortcuts: [cg$1("CtrlOrCmd+Shift+Right")] }), jsxRuntimeExports.jsx(U, { label: g("labels.duplicateSelection"), shortcuts: [cg$1("CtrlOrCmd+D"), cg$1(`Alt+${g("helpDialog.drag")}`)] }), jsxRuntimeExports.jsx(U, { label: g("helpDialog.toggleElementLock"), shortcuts: [cg$1("CtrlOrCmd+Shift+L")] }), jsxRuntimeExports.jsx(U, { label: g("buttons.undo"), shortcuts: [cg$1("CtrlOrCmd+Z")] }), jsxRuntimeExports.jsx(U, { label: g("buttons.redo"), shortcuts: iE ? [cg$1("CtrlOrCmd+Y"), cg$1("CtrlOrCmd+Shift+Z")] : [cg$1("CtrlOrCmd+Shift+Z")] }), jsxRuntimeExports.jsx(U, { label: g("labels.group"), shortcuts: [cg$1("CtrlOrCmd+G")] }), jsxRuntimeExports.jsx(U, { label: g("labels.ungroup"), shortcuts: [cg$1("CtrlOrCmd+Shift+G")] }), jsxRuntimeExports.jsx(U, { label: g("labels.flipHorizontal"), shortcuts: [cg$1("Shift+H")] }), jsxRuntimeExports.jsx(U, { label: g("labels.flipVertical"), shortcuts: [cg$1("Shift+V")] }), jsxRuntimeExports.jsx(U, { label: g("labels.showStroke"), shortcuts: [cg$1("S")] }), jsxRuntimeExports.jsx(U, { label: g("labels.showBackground"), shortcuts: [cg$1("G")] }), jsxRuntimeExports.jsx(U, { label: g("labels.showFonts"), shortcuts: [cg$1("Shift+F")] }), jsxRuntimeExports.jsx(U, { label: g("labels.decreaseFontSize"), shortcuts: [cg$1("CtrlOrCmd+Shift+<")] }), jsxRuntimeExports.jsx(U, { label: g("labels.increaseFontSize"), shortcuts: [cg$1("CtrlOrCmd+Shift+>")] })] })] })] }) });
};
var zL = 4, UL = 8, HL = ({ shouldWrap: e12, children: o3, username: t3 }) => e12 ? jsxRuntimeExports.jsx(Ut, { label: t3 || "Unknown user", children: o3 }) : jsxRuntimeExports.jsx(jsxRuntimeExports.Fragment, { children: o3 }), Vu = ({ actionManager: e12, collaborator: o3, socketId: t3, withName: r3 = false, shouldWrapWithTooltip: n3 = false, isBeingFollowed: i3 }) => {
  let a3 = { socketId: t3, collaborator: o3, withName: r3, isBeingFollowed: i3 }, l3 = e12.renderAction("goToCollaborator", a3);
  return jsxRuntimeExports.jsx(HL, { username: o3.username, shouldWrap: n3, children: l3 }, t3);
}, GL = ["avatarUrl", "id", "socketId", "username", "isInCall", "isSpeaking", "isMuted"], ad = React.memo(({ className: e12, mobile: o3, collaborators: t3, userToFollow: r3 }) => {
  let n3 = Xe2(), i3 = /* @__PURE__ */ new Map();
  t3.forEach((f3, b3) => {
    let x3 = f3.id || b3;
    i3.set(x3, { ...f3, socketId: b3 });
  });
  let a3 = Array.from(i3.values()).filter((f3) => f3.username?.trim()), [l3, s3] = React.useState(""), c3 = a3.filter((f3) => f3.username?.toLowerCase().includes(l3)), m3 = React.useRef(null);
  reactExports.useLayoutEffect(() => {
    if (m3.current) {
      let f3 = (x3) => {
        let T3 = Math.max(1, Math.min(8, Math.floor(x3 / 38)));
        p3(T3);
      };
      if (f3(m3.current.clientWidth), !cE) return;
      let b3 = new ResizeObserver((x3) => {
        for (let T3 of x3) {
          let { width: E3 } = T3.contentRect;
          f3(E3);
        }
      });
      return b3.observe(m3.current), () => {
        b3.disconnect();
      };
    }
  }, []);
  let [d3, p3] = React.useState(zL), h3 = a3.slice(0, d3 - 1).map((f3) => Vu({ actionManager: n3, collaborator: f3, socketId: f3.socketId, shouldWrapWithTooltip: true, isBeingFollowed: f3.socketId === r3 }));
  return o3 ? jsxRuntimeExports.jsx("div", { className: dM("UserList UserList_mobile", e12), children: a3.map((f3) => Vu({ actionManager: n3, collaborator: f3, socketId: f3.socketId, shouldWrapWithTooltip: true, isBeingFollowed: f3.socketId === r3 })) }) : jsxRuntimeExports.jsx("div", { className: "UserList__wrapper", ref: m3, children: jsxRuntimeExports.jsxs("div", { className: dM("UserList", e12), style: { "--max-avatars": d3 }, children: [h3, a3.length > d3 - 1 && jsxRuntimeExports.jsxs(Root2, { children: [jsxRuntimeExports.jsxs(Trigger, { className: "UserList__more", children: ["+", a3.length - d3 + 1] }), jsxRuntimeExports.jsx(Content2, { style: { zIndex: 2, width: "15rem", textAlign: "left" }, align: "end", sideOffset: 10, children: jsxRuntimeExports.jsxs(Qe2, { padding: 2, children: [a3.length >= UL && jsxRuntimeExports.jsx(ic, { placeholder: g("quickSearch.placeholder"), onChange: s3 }), jsxRuntimeExports.jsx(ac, { className: "dropdown-menu UserList__collaborators", placeholder: g("userList.empty"), children: c3.length > 0 ? [jsxRuntimeExports.jsx("div", { className: "hint", children: g("userList.hint.text") }), c3.map((f3) => Vu({ actionManager: n3, collaborator: f3, socketId: f3.socketId, withName: true, isBeingFollowed: f3.socketId === r3 }))] : [] }), jsxRuntimeExports.jsx(Arrow2, { width: 20, height: 10, style: { fill: "var(--popup-bg-color)", filter: "drop-shadow(rgba(0, 0, 0, 0.05) 0px 3px 2px)" } })] }) })] })] }) });
}, (e12, o3) => {
  if (e12.collaborators.size !== o3.collaborators.size || e12.mobile !== o3.mobile || e12.className !== o3.className || e12.userToFollow !== o3.userToFollow) return false;
  let t3 = o3.collaborators.keys();
  for (let [r3, n3] of e12.collaborators) {
    let i3 = o3.collaborators.get(r3);
    if (!i3 || r3 !== t3.next().value || !Qt(n3, i3, GL)) return false;
  }
  return true;
});
var Ku = ({ children: e12, color: o3 }) => jsxRuntimeExports.jsx("div", { className: "Card", style: { "--card-color": o3 === "primary" ? "var(--color-primary)" : _d$1[o3][7], "--card-color-darker": o3 === "primary" ? "var(--color-primary-darker)" : _d$1[o3][8], "--card-color-darkest": o3 === "primary" ? "var(--color-primary-darkest)" : _d$1[o3][9] }, children: e12 });
var KL = ({ elements: e$12, appState: o3, setAppState: t3, files: r3, actionManager: n3, exportOpts: i3, canvas: a3, onCloseRequest: l3 }) => {
  let { onExportToBackend: s3 } = i3;
  return jsxRuntimeExports.jsx("div", { className: "ExportDialog ExportDialog--json", children: jsxRuntimeExports.jsxs("div", { className: "ExportDialog-cards", children: [i3.saveFileToDisk && jsxRuntimeExports.jsxs(Ku, { color: "lime", children: [jsxRuntimeExports.jsx("div", { className: "Card-icon", children: Gx }), jsxRuntimeExports.jsx("h2", { children: g("exportDialog.disk_title") }), jsxRuntimeExports.jsxs("div", { className: "Card-details", children: [g("exportDialog.disk_details"), !e && n3.renderAction("changeProjectName")] }), jsxRuntimeExports.jsx(X, { className: "Card-button", type: "button", title: g("exportDialog.disk_button"), "aria-label": g("exportDialog.disk_button"), showAriaLabel: true, onClick: () => {
    n3.executeAction(Ua, "ui");
  } })] }), s3 && jsxRuntimeExports.jsxs(Ku, { color: "pink", children: [jsxRuntimeExports.jsx("div", { className: "Card-icon", children: Kx }), jsxRuntimeExports.jsx("h2", { children: g("exportDialog.link_title") }), jsxRuntimeExports.jsx("div", { className: "Card-details", children: g("exportDialog.link_details") }), jsxRuntimeExports.jsx(X, { className: "Card-button", type: "button", title: g("exportDialog.link_button"), "aria-label": g("exportDialog.link_button"), showAriaLabel: true, onClick: async () => {
    try {
      le("export", "link", `ui (${wg$1()})`), await s3(e$12, o3, r3), l3();
    } catch (c3) {
      t3({ errorMessage: c3.message });
    }
  } })] }), i3.renderCustomUI && i3.renderCustomUI(e$12, o3, r3, a3)] }) });
}, i0 = ({ elements: e12, appState: o3, files: t3, actionManager: r3, exportOpts: n3, canvas: i3, setAppState: a3 }) => {
  let l3 = React.useCallback(() => {
    a3({ openDialog: null });
  }, [a3]);
  return jsxRuntimeExports.jsx(jsxRuntimeExports.Fragment, { children: o3.openDialog?.name === "jsonExport" && jsxRuntimeExports.jsx(Ge, { onCloseRequest: l3, title: g("buttons.export"), children: jsxRuntimeExports.jsx(KL, { elements: e12, appState: o3, setAppState: a3, files: t3, actionManager: r3, onCloseRequest: l3, exportOpts: n3, canvas: i3 }) }) });
};
var a0 = (e12) => jsxRuntimeExports.jsx("button", { className: "help-icon", onClick: e12.onClick, type: "button", title: `${g("helpDialog.title")}  ?`, "aria-label": g("helpDialog.title"), children: Px });
var l0 = ({ appState: e12, actionManager: o3, showExitZenModeBtn: t3, renderWelcomeScreen: r3 }) => {
  let { FooterCenterTunnel: n3, WelcomeScreenHelpHintTunnel: i3 } = _e(), a3 = me(), l3 = !e12.viewModeEnabled && e12.multiElement && a3.isTouchScreen;
  return jsxRuntimeExports.jsxs("footer", { role: "contentinfo", className: "layer-ui__wrapper__footer App-menu App-menu_bottom", children: [jsxRuntimeExports.jsx("div", { className: dM("layer-ui__wrapper__footer-left zen-mode-transition", { "layer-ui__wrapper__footer-left--transition-left": e12.zenModeEnabled }), children: jsxRuntimeExports.jsx(it.Col, { gap: 2, children: jsxRuntimeExports.jsxs(Nr, { heading: "canvasActions", children: [jsxRuntimeExports.jsx(Ew, { renderAction: o3.renderAction, zoom: e12.zoom }), !e12.viewModeEnabled && jsxRuntimeExports.jsx(yw, { renderAction: o3.renderAction, className: dM("zen-mode-transition", { "layer-ui__wrapper__footer-left--transition-bottom": e12.zenModeEnabled }) }), l3 && jsxRuntimeExports.jsx(ww, { renderAction: o3.renderAction, className: dM("zen-mode-transition", { "layer-ui__wrapper__footer-left--transition-left": e12.zenModeEnabled }) })] }) }) }), jsxRuntimeExports.jsx(n3.Out, {}), jsxRuntimeExports.jsx("div", { className: dM("layer-ui__wrapper__footer-right zen-mode-transition", { "transition-right": e12.zenModeEnabled }), children: jsxRuntimeExports.jsxs("div", { style: { position: "relative" }, children: [r3 && jsxRuntimeExports.jsx(i3.Out, {}), jsxRuntimeExports.jsx(a0, { onClick: () => o3.executeAction(wn) })] }) }), jsxRuntimeExports.jsx(vw, { actionManager: o3, showExitZenModeBtn: t3 })] });
}, s0 = l0;
l0.displayName = "Footer";
var cd = React.createContext({});
var Zu = ({ children: e12, className: o3 }) => {
  let t3 = me(), r3 = reactExports.useContext(cd), n3 = !!(t3.editor.canFitSidebar && r3.shouldRenderDockButton);
  return jsxRuntimeExports.jsxs("div", { className: dM("sidebar__header", o3), "data-testid": "sidebar-header", children: [e12, jsxRuntimeExports.jsxs("div", { className: "sidebar__header__buttons", children: [n3 && jsxRuntimeExports.jsx(Ut, { label: g("labels.sidebarLock"), children: jsxRuntimeExports.jsx(Gt, { onSelect: () => r3.onDock?.(!r3.docked), selected: !!r3.docked, className: "sidebar__dock", "data-testid": "sidebar-dock", "aria-label": g("labels.sidebarLock"), children: ux }) }), jsxRuntimeExports.jsx(Gt, { "data-testid": "sidebar-close", className: "sidebar__close", onSelect: r3.onCloseRequest, "aria-label": g("buttons.close"), children: Ih })] })] });
};
Zu.displayName = "SidebarHeader";
var Ju = ({ name: e12, tab: o3, icon: t3, title: r3, children: n3, onToggle: i3, className: a3, style: l3 }) => {
  let s3 = pe(), c3 = ve();
  return jsxRuntimeExports.jsxs("label", { title: r3, className: "sidebar-trigger__label-element", children: [jsxRuntimeExports.jsx("input", { className: "ToolIcon_type_checkbox", type: "checkbox", onChange: (m3) => {
    document.querySelector(".layer-ui__wrapper")?.classList.remove("animate");
    let d3 = m3.target.checked;
    s3({ openSidebar: d3 ? { name: e12, tab: o3 } : null }), i3?.(d3);
  }, checked: c3.openSidebar?.name === e12, "aria-label": r3, "aria-keyshortcuts": "0" }), jsxRuntimeExports.jsxs("div", { className: dM("sidebar-trigger", a3), style: l3, children: [t3 && jsxRuntimeExports.jsx("div", { children: t3 }), n3 && jsxRuntimeExports.jsx("div", { className: "sidebar-trigger__label", children: n3 })] })] });
};
Ju.displayName = "SidebarTrigger";
var qu = ({ children: e12, ...o3 }) => jsxRuntimeExports.jsx($69cb30bb0017df05$export$54c2e3dc7acea9f5, { className: "sidebar-triggers", ...o3, children: e12 });
qu.displayName = "SidebarTabTriggers";
var Qu = ({ children: e12, tab: o3, onSelect: t3, ...r3 }) => jsxRuntimeExports.jsx($69cb30bb0017df05$export$41fb9f06171c75f4, { value: o3, asChild: true, onSelect: t3, children: jsxRuntimeExports.jsx("button", { type: "button", className: "excalidraw-button sidebar-tab-trigger", ...r3, children: e12 }) });
Qu.displayName = "SidebarTabTrigger";
var eg = ({ children: e12, ...o3 }) => {
  let t3 = ve(), r3 = pe();
  if (!t3.openSidebar) return null;
  let { name: n3 } = t3.openSidebar;
  return jsxRuntimeExports.jsx($69cb30bb0017df05$export$be92b6f5f03c0fe9, { className: "sidebar-tabs-root", value: t3.openSidebar.tab, onValueChange: (i3) => r3((a3) => ({ ...a3, openSidebar: { ...a3.openSidebar, name: n3, tab: i3 } })), ...o3, children: e12 });
};
eg.displayName = "SidebarTabs";
var tg = ({ tab: e12, children: o3, ...t3 }) => jsxRuntimeExports.jsx($69cb30bb0017df05$export$7c6e2c02157bb7d2, { ...t3, value: e12, "data-testid": e12, children: o3 });
tg.displayName = "SidebarTab";
var Ja = atom(false), v0 = reactExports.forwardRef(({ name: e12, children: o3, onDock: t3, docked: r3, className: n3, ...i3 }, a3) => {
  c$1.DEV && t3 && r3 == null && console.warn("Sidebar: `docked` must be set when `onDock` is supplied for the sidebar to be user-dockable. To hide this message, either pass `docked` or remove `onDock`");
  let l3 = pe(), s3 = Tr(Ja);
  reactExports.useLayoutEffect(() => (s3(!!r3), () => {
    s3(false);
  }), [s3, r3]);
  let c3 = reactExports.useRef({});
  c3.current.onCloseRequest = () => {
    l3({ openSidebar: null });
  }, c3.current.onDock = (u3) => t3?.(u3), c3.current = Ig$1(c3.current, { docked: r3, shouldRenderDockButton: !!t3 && r3 != null });
  let m3 = reactExports.useRef(null);
  reactExports.useImperativeHandle(a3, () => m3.current);
  let d3 = me(), p3 = reactExports.useCallback(() => {
    document.querySelector(".Dialog") || l3({ openSidebar: null });
  }, [l3]);
  return vi(m3, reactExports.useCallback((u3) => {
    u3.target.closest(".sidebar-trigger") || (!r3 || !d3.editor.canFitSidebar) && p3();
  }, [p3, r3, d3.editor.canFitSidebar])), reactExports.useEffect(() => {
    let u3 = (h3) => {
      h3.key === Q.ESCAPE && (!r3 || !d3.editor.canFitSidebar) && p3();
    };
    return document.addEventListener("keydown", u3), () => {
      document.removeEventListener("keydown", u3);
    };
  }, [p3, r3, d3.editor.canFitSidebar]), jsxRuntimeExports.jsx(Qe2, { ...i3, className: dM("sidebar", { "sidebar--docked": r3 }, n3), ref: m3, children: jsxRuntimeExports.jsx(cd.Provider, { value: c3.current, children: o3 }) });
});
v0.displayName = "SidebarInner";
var no = Object.assign(reactExports.forwardRef((e12, o3) => {
  let t3 = ve(), { onStateChange: r3 } = e12, n3 = reactExports.useRef(t3.openSidebar);
  reactExports.useEffect(() => {
    (!t3.openSidebar && n3?.current?.name === e12.name || t3.openSidebar?.name === e12.name && n3?.current?.name !== e12.name || n3.current?.name === e12.name) && t3.openSidebar !== n3.current && r3?.(t3.openSidebar?.name !== e12.name ? null : t3.openSidebar), n3.current = t3.openSidebar;
  }, [t3.openSidebar, r3, e12.name]);
  let [i3, a3] = reactExports.useState(false);
  return reactExports.useLayoutEffect(() => (a3(true), () => a3(false)), []), i3 && t3.openSidebar?.name === e12.name ? reactExports.createElement(v0, { ...e12, ref: o3, key: e12.name }) : null;
}), { Header: Zu, TabTriggers: qu, TabTrigger: Qu, Tabs: eg, Tab: tg, Trigger: Ju });
no.displayName = "Sidebar";
var ig = {};
h$1(ig, { ChangeCanvasBackground: () => R0, ClearCanvas: () => D0, CommandPalette: () => A0, Export: () => N0, Help: () => M0, LiveCollaborationTrigger: () => F0, LoadScene: () => S0, SaveAsImage: () => L0, SaveToActiveFile: () => k0, SearchMenu: () => _0, Socials: () => O0, ToggleTheme: () => P0 });
var rg = atom({ active: false });
async function w0({ title: e12, description: o3, actionLabel: t3, color: r3 }) {
  return new Promise((n3) => {
    st.set(rg, { active: true, onConfirm: () => n3(true), onClose: () => n3(false), onReject: () => n3(false), title: e12, description: o3, actionLabel: t3, color: r3 });
  });
}
var C0 = ({ value: e12, shortcut: o3, onChange: t3, choices: r3, children: n3, name: i3 }) => {
  let a3 = me();
  return jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [jsxRuntimeExports.jsxs("div", { className: "dropdown-menu-item-base dropdown-menu-item-bare", children: [jsxRuntimeExports.jsx("label", { className: "dropdown-menu-item__text", htmlFor: i3, children: n3 }), jsxRuntimeExports.jsx(Zc, { name: i3, value: e12, onChange: t3, choices: r3 })] }), o3 && !a3.editor.isMobile && jsxRuntimeExports.jsx("div", { className: "dropdown-menu-item__shortcut dropdown-menu-item__shortcut--orphaned", children: o3 })] });
};
C0.displayName = "DropdownMenuItemContentRadio";
var I0 = C0;
var S0 = () => {
  let { t: e12 } = Ve(), o3 = Xe2(), t3 = kr();
  return o3.isActionEnabled(Si) ? jsxRuntimeExports.jsx(vt, { icon: Yx, onSelect: async () => {
    (!t3.length || await w0({ title: e12("overwriteConfirm.modal.loadFromFile.title"), actionLabel: e12("overwriteConfirm.modal.loadFromFile.button"), color: "warning", description: jsxRuntimeExports.jsx(Tt, { i18nKey: "overwriteConfirm.modal.loadFromFile.description", bold: (n3) => jsxRuntimeExports.jsx("strong", { children: n3 }), br: () => jsxRuntimeExports.jsx("br", {}) }) })) && o3.executeAction(Si);
  }, "data-testid": "load-button", shortcut: Ye("loadScene"), "aria-label": e12("buttons.load"), children: e12("buttons.load") }) : null;
};
S0.displayName = "LoadScene";
var k0 = () => {
  let { t: e12 } = Ve(), o3 = Xe2();
  return o3.isActionEnabled(bc) ? jsxRuntimeExports.jsx(vt, { shortcut: Ye("saveScene"), "data-testid": "save-button", onSelect: () => o3.executeAction(bc), icon: Hx, "aria-label": `${e12("buttons.save")}`, children: `${e12("buttons.save")}` }) : null;
};
k0.displayName = "SaveToActiveFile";
var L0 = () => {
  let e12 = pe(), { t: o3 } = Ve();
  return jsxRuntimeExports.jsx(vt, { icon: Xx, "data-testid": "image-export-button", onSelect: () => e12({ openDialog: { name: "imageExport" } }), shortcut: Ye("imageExport"), "aria-label": o3("buttons.exportImage"), children: o3("buttons.exportImage") });
};
L0.displayName = "SaveAsImage";
var A0 = (e12) => {
  let o3 = pe(), { t: t3 } = Ve();
  return jsxRuntimeExports.jsx(vt, { icon: Y4, "data-testid": "command-palette-button", onSelect: () => {
    le("command_palette", "open", "menu"), o3({ openDialog: { name: "commandPalette" } });
  }, shortcut: Ye("commandPalette"), "aria-label": t3("commandPalette.title"), className: e12?.className, children: t3("commandPalette.title") });
};
A0.displayName = "CommandPalette";
var _0 = (e12) => {
  let { t: o3 } = Ve(), t3 = Xe2();
  return jsxRuntimeExports.jsx(vt, { icon: A4, "data-testid": "search-menu-button", onSelect: () => {
    t3.executeAction(Ka);
  }, shortcut: Ye("searchMenu"), "aria-label": o3("search.title"), className: e12?.className, children: o3("search.title") });
};
_0.displayName = "SearchMenu";
var M0 = () => {
  let { t: e12 } = Ve(), o3 = Xe2();
  return jsxRuntimeExports.jsx(vt, { "data-testid": "help-menu-item", icon: Px, onSelect: () => o3.executeAction(wn), shortcut: "?", "aria-label": e12("helpDialog.title"), children: e12("helpDialog.title") });
};
M0.displayName = "Help";
var D0 = () => {
  let { t: e12 } = Ve(), o3 = Tr(In);
  return Xe2().isActionEnabled(er) ? jsxRuntimeExports.jsx(vt, { icon: Tx, onSelect: () => o3("clearCanvas"), "data-testid": "clear-canvas-button", "aria-label": e12("buttons.clearReset"), children: e12("buttons.clearReset") }) : null;
};
D0.displayName = "ClearCanvas";
var P0 = (e12) => {
  let { t: o3 } = Ve(), t3 = ve(), r3 = Xe2(), n3 = Ye("toggleTheme");
  return r3.isActionEnabled(En) ? e12?.allowSystemTheme ? jsxRuntimeExports.jsx(I0, { name: "theme", value: e12.theme, onChange: (i3) => e12.onSelect(i3), choices: [{ value: ke.LIGHT, label: Sx, ariaLabel: `${o3("buttons.lightMode")} - ${n3}` }, { value: ke.DARK, label: Dx, ariaLabel: `${o3("buttons.darkMode")} - ${n3}` }, { value: "system", label: j4, ariaLabel: o3("buttons.systemMode") }], children: o3("labels.theme") }) : jsxRuntimeExports.jsx(vt, { onSelect: (i3) => {
    if (i3.preventDefault(), e12?.onSelect) e12.onSelect(t3.theme === ke.DARK ? ke.LIGHT : ke.DARK);
    else return r3.executeAction(En);
  }, icon: t3.theme === ke.DARK ? Sx : Dx, "data-testid": "toggle-dark-mode", shortcut: n3, "aria-label": t3.theme === ke.DARK ? o3("buttons.lightMode") : o3("buttons.darkMode"), children: t3.theme === ke.DARK ? o3("buttons.lightMode") : o3("buttons.darkMode") }) : null;
};
P0.displayName = "ToggleTheme";
var R0 = () => {
  let { t: e12 } = Ve(), o3 = ve(), t3 = Xe2(), r3 = Do();
  return o3.viewModeEnabled || !r3.UIOptions.canvasActions.changeViewBackgroundColor ? null : jsxRuntimeExports.jsxs("div", { style: { marginTop: "0.5rem" }, children: [jsxRuntimeExports.jsx("div", { "data-testid": "canvas-background-label", style: { fontSize: ".75rem", marginBottom: ".5rem" }, children: e12("labels.canvasBackground") }), jsxRuntimeExports.jsx("div", { style: { padding: "0 0.625rem" }, children: t3.renderAction("changeViewBackgroundColor") })] });
};
R0.displayName = "ChangeCanvasBackground";
var N0 = () => {
  let { t: e12 } = Ve(), o3 = pe();
  return jsxRuntimeExports.jsx(vt, { icon: $x, onSelect: () => {
    o3({ openDialog: { name: "jsonExport" } });
  }, "data-testid": "json-export-button", "aria-label": e12("buttons.export"), children: e12("buttons.export") });
};
N0.displayName = "Export";
var O0 = () => {
  let { t: e12 } = Ve();
  return jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [jsxRuntimeExports.jsx(Oi, { icon: Bx, href: "https://github.com/excalidraw/excalidraw", "aria-label": "GitHub", children: "GitHub" }), jsxRuntimeExports.jsx(Oi, { icon: Ox, href: "https://x.com/excalidraw", "aria-label": "X", children: e12("labels.followUs") }), jsxRuntimeExports.jsx(Oi, { icon: _x, href: "https://discord.gg/UexuTaE", "aria-label": "Discord", children: e12("labels.discordChat") })] });
};
O0.displayName = "Socials";
var F0 = ({ onSelect: e12, isCollaborating: o3 }) => {
  let { t: t3 } = Ve();
  return jsxRuntimeExports.jsx(vt, { "data-testid": "collab-button", icon: xh, className: dM({ "active-collab": o3 }), onSelect: e12, children: t3("labels.liveCollaboration") });
};
F0.displayName = "LiveCollaborationTrigger";
var ar = (e12, o3) => {
  let t3 = atom(0), r3 = (n3) => {
    let { tunnelsJotai: { useAtom: i3 } } = _e(), [, a3] = i3(t3), l3 = reactExports.useRef({ preferHost: false, counter: 0 });
    return reactExports.useLayoutEffect(() => {
      let s3 = l3.current;
      return a3((c3) => {
        let m3 = c3 + 1;
        return s3.counter = m3, m3;
      }), () => {
        a3((c3) => {
          let m3 = c3 - 1;
          return s3.counter = m3, m3 || (s3.preferHost = false), m3;
        });
      };
    }, [a3]), n3.__fallback || (l3.current.preferHost = true), !l3.current.counter && n3.__fallback && l3.current.preferHost || l3.current.counter > 1 && n3.__fallback ? null : jsxRuntimeExports.jsx(o3, { ...n3 });
  };
  return r3.displayName = e12, r3;
};
var pA = Object.assign(ar("MainMenu", ({ children: e12, onSelect: o3 }) => {
  let { MainMenuTunnel: t3 } = _e(), r3 = me(), n3 = ve(), i3 = pe(), a3 = r3.editor.isMobile ? void 0 : () => i3({ openMenu: null });
  return jsxRuntimeExports.jsx(t3.In, { children: jsxRuntimeExports.jsxs(Ce, { open: n3.openMenu === "canvas", children: [jsxRuntimeExports.jsx(Ce.Trigger, { onToggle: () => {
    i3({ openMenu: n3.openMenu === "canvas" ? null : "canvas" });
  }, "data-testid": "main-menu-trigger", className: "main-menu-trigger", children: vx }), jsxRuntimeExports.jsxs(Ce.Content, { onClickOutside: a3, onSelect: Tg$1(o3, () => {
    i3({ openMenu: null });
  }), children: [e12, r3.editor.isMobile && n3.collaborators.size > 0 && jsxRuntimeExports.jsxs("fieldset", { className: "UserList-Wrapper", children: [jsxRuntimeExports.jsx("legend", { children: g("labels.collaborators") }), jsxRuntimeExports.jsx(ad, { mobile: true, collaborators: n3.collaborators, userToFollow: n3.userToFollow?.socketId || null })] })] })] }) });
}), { Trigger: Ce.Trigger, Item: Ce.Item, ItemLink: Ce.ItemLink, ItemCustom: Ce.ItemCustom, Group: Ce.Group, Separator: Ce.Separator, DefaultItems: ig }), ft = pA;
var md = ({ title: e12, children: o3, actionLabel: t3, onClick: r3 }) => jsxRuntimeExports.jsxs("div", { className: "OverwriteConfirm__Actions__Action", children: [jsxRuntimeExports.jsx("h4", { children: e12 }), jsxRuntimeExports.jsx("div", { className: "OverwriteConfirm__Actions__Action__content", children: o3 }), jsxRuntimeExports.jsx(Dr, { variant: "outlined", color: "muted", label: t3, size: "large", fullWidth: true, onClick: r3 })] }), uA = () => {
  let { t: e12 } = Ve(), o3 = Xe2(), t3 = pe();
  return jsxRuntimeExports.jsx(md, { title: e12("overwriteConfirm.action.exportToImage.title"), actionLabel: e12("overwriteConfirm.action.exportToImage.button"), onClick: () => {
    o3.executeAction(fc, "ui", true), t3({ openDialog: { name: "imageExport" } });
  }, children: e12("overwriteConfirm.action.exportToImage.description") });
}, gA = () => {
  let { t: e12 } = Ve(), o3 = Xe2();
  return jsxRuntimeExports.jsx(md, { title: e12("overwriteConfirm.action.saveToDisk.title"), actionLabel: e12("overwriteConfirm.action.saveToDisk.button"), onClick: () => {
    o3.executeAction(Ua, "ui");
  }, children: e12("overwriteConfirm.action.saveToDisk.description") });
}, lg = Object.assign(({ children: e12 }) => jsxRuntimeExports.jsx("div", { className: "OverwriteConfirm__Actions", children: e12 }), { ExportToImage: uA, SaveToDisk: gA });
var pd = Object.assign(ar("OverwriteConfirmDialog", ({ children: e12 }) => {
  let { OverwriteConfirmDialogTunnel: o3 } = _e(), [t3, r3] = ce(rg);
  if (!t3.active) return null;
  let n3 = () => {
    t3.onClose(), r3((a3) => ({ ...a3, active: false }));
  }, i3 = () => {
    t3.onConfirm(), r3((a3) => ({ ...a3, active: false }));
  };
  return jsxRuntimeExports.jsx(o3.In, { children: jsxRuntimeExports.jsx(Ge, { onCloseRequest: n3, title: false, size: 916, children: jsxRuntimeExports.jsxs("div", { className: "OverwriteConfirm", children: [jsxRuntimeExports.jsx("h3", { children: t3.title }), jsxRuntimeExports.jsxs("div", { className: `OverwriteConfirm__Description OverwriteConfirm__Description--color-${t3.color}`, children: [jsxRuntimeExports.jsx("div", { className: "OverwriteConfirm__Description__icon", children: w4 }), jsxRuntimeExports.jsx("div", { children: t3.description }), jsxRuntimeExports.jsx("div", { className: "OverwriteConfirm__Description__spacer" }), jsxRuntimeExports.jsx(Dr, { color: t3.color, size: "large", label: t3.actionLabel, onClick: i3 })] }), jsxRuntimeExports.jsx(lg, { children: e12 })] }) }) });
}), { Actions: lg, Action: md });
var yA = atom(""), cg = atom(null), vA = 350, G0 = () => {
  let e12 = He(), o3 = pe(), t3 = reactExports.useRef(null), [r3, n3] = ce(yA), i3 = r3.trim(), [a3, l3] = reactExports.useState(false), [s3, c3] = reactExports.useState({ nonce: null, items: [] }), m3 = reactExports.useRef(null), d3 = reactExports.useRef(void 0), [p3, u3] = ce(cg), h3 = e12.scene.getNonDeletedElementsMap();
  reactExports.useEffect(() => {
    a3 || (i3 !== m3.current || e12.scene.getSceneNonce() !== d3.current) && (m3.current = null, H0(i3, e12, (E3, w3) => {
      c3({ nonce: Vt(), items: E3 }), m3.current = i3, d3.current = e12.scene.getSceneNonce(), o3({ searchMatches: E3.map((S3) => ({ id: S3.textElement.id, focus: false, matchedLines: S3.matchedLines })) });
    }));
  }, [a3, i3, h3, e12, o3, u3, d3]);
  let f3 = () => {
    s3.items.length > 0 && u3((E3) => E3 === null ? 0 : (E3 + 1) % s3.items.length);
  }, b3 = () => {
    s3.items.length > 0 && u3((E3) => E3 === null ? 0 : E3 - 1 < 0 ? s3.items.length - 1 : E3 - 1);
  };
  reactExports.useEffect(() => {
    o3((E3) => ({ searchMatches: E3.searchMatches.map((w3, S3) => S3 === p3 ? { ...w3, focus: true } : { ...w3, focus: false }) }));
  }, [p3, o3]), reactExports.useEffect(() => {
    if (s3.items.length > 0 && p3 !== null) {
      let E3 = s3.items[p3];
      if (E3) {
        let w3 = e12.state.zoom.value, S3 = qt({ text: E3.searchQuery, x: E3.textElement.x + (E3.matchedLines[0]?.offsetX ?? 0), y: E3.textElement.y + (E3.matchedLines[0]?.offsetY ?? 0), width: E3.matchedLines[0]?.width, height: E3.matchedLines[0]?.height, fontSize: E3.textElement.fontSize, fontFamily: E3.textElement.fontFamily }), I3 = 14, _3 = E3.textElement.fontSize, k2 = _3 * w3 < I3;
        if (!iJ([S3], e12.canvas.width / window.devicePixelRatio, e12.canvas.height / window.devicePixelRatio, { offsetLeft: e12.state.offsetLeft, offsetTop: e12.state.offsetTop, scrollX: e12.state.scrollX, scrollY: e12.state.scrollY, zoom: e12.state.zoom }, e12.scene.getNonDeletedElementsMap(), e12.getEditorUIOffsets()) || k2) {
          let R3;
          k2 ? _3 >= I3 ? R3 = { fitToContent: true } : R3 = { fitToViewport: true, maxZoom: To(I3 / _3, 1) } : R3 = { fitToContent: true }, e12.scrollToContent(S3, { animate: true, duration: 300, ...R3, canvasOffsets: e12.getEditorUIOffsets() });
        }
      }
    }
  }, [p3, s3, e12]), reactExports.useEffect(() => () => {
    u3(null), m3.current = null, d3.current = void 0, o3({ searchMatches: [] }), l3(false);
  }, [o3, u3]);
  let x3 = Ir({ goToNextItem: f3, goToPreviousItem: b3, searchMatches: s3 });
  reactExports.useEffect(() => {
    let E3 = (w3) => {
      if (w3.key === Q.ESCAPE && !e12.state.openDialog && !e12.state.openPopup) {
        w3.preventDefault(), w3.stopPropagation(), o3({ openSidebar: null });
        return;
      }
      w3[Q.CTRL_OR_CMD] && w3.key === Q.F && (w3.preventDefault(), w3.stopPropagation(), t3.current?.matches(":focus") ? o3({ openSidebar: null }) : (e12.state.openDialog && o3({ openDialog: null }), t3.current?.focus(), t3.current?.select())), w3.target instanceof HTMLElement && w3.target.closest(".layer-ui__search") && x3.searchMatches.items.length && (w3.key === Q.ENTER && (w3.stopPropagation(), x3.goToNextItem()), w3.key === Q.ARROW_UP ? (w3.stopPropagation(), x3.goToPreviousItem()) : w3.key === Q.ARROW_DOWN && (w3.stopPropagation(), x3.goToNextItem()));
    };
    return Sg$1(window, "keydown", E3, { capture: true, passive: false });
  }, [o3, x3, e12]);
  let T3 = `${s3.items.length} ${s3.items.length === 1 ? g("search.singleResult") : g("search.multipleResults")}`;
  return jsxRuntimeExports.jsxs("div", { className: "layer-ui__search", children: [jsxRuntimeExports.jsx("div", { className: "layer-ui__search-header", children: jsxRuntimeExports.jsx(zi, { className: gE.SEARCH_MENU_INPUT_WRAPPER, value: r3, ref: t3, placeholder: g("search.placeholder"), icon: A4, onChange: (E3) => {
    n3(E3), l3(true);
    let w3 = E3.trim();
    H0(w3, e12, (S3, I3) => {
      c3({ nonce: Vt(), items: S3 }), u3(I3), m3.current = w3, d3.current = e12.scene.getSceneNonce(), o3({ searchMatches: S3.map((_3) => ({ id: _3.textElement.id, focus: false, matchedLines: _3.matchedLines })) }), l3(false);
    });
  }, selectOnRender: true }) }), jsxRuntimeExports.jsxs("div", { className: "layer-ui__search-count", children: [s3.items.length > 0 && jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [p3 !== null && p3 > -1 ? jsxRuntimeExports.jsxs("div", { children: [p3 + 1, " / ", T3] }) : jsxRuntimeExports.jsx("div", { children: T3 }), jsxRuntimeExports.jsxs("div", { className: "result-nav", children: [jsxRuntimeExports.jsx(Gt, { onSelect: () => {
    f3();
  }, className: "result-nav-btn", children: sy$1 }), jsxRuntimeExports.jsx(Gt, { onSelect: () => {
    b3();
  }, className: "result-nav-btn", children: cy$1 })] })] }), s3.items.length === 0 && i3 && m3.current && jsxRuntimeExports.jsx("div", { style: { margin: "1rem auto" }, children: g("search.noMatch") })] }), jsxRuntimeExports.jsx(IA, { matches: s3, onItemClick: u3, focusIndex: p3, searchQuery: i3 })] });
}, wA = (e12) => {
  let o3 = [e12.preview.moreBefore ? "..." : "", e12.preview.previewText.slice(0, e12.preview.indexInSearchQuery), e12.preview.previewText.slice(e12.preview.indexInSearchQuery, e12.preview.indexInSearchQuery + e12.searchQuery.length), e12.preview.previewText.slice(e12.preview.indexInSearchQuery + e12.searchQuery.length), e12.preview.moreAfter ? "..." : ""];
  return jsxRuntimeExports.jsx("div", { tabIndex: -1, className: dM("layer-ui__result-item", { active: e12.highlighted }), onClick: e12.onClick, ref: (t3) => {
    e12.highlighted && t3?.scrollIntoView({ behavior: "auto", block: "nearest" });
  }, children: jsxRuntimeExports.jsx("div", { className: "preview-text", children: o3.flatMap((t3, r3) => jsxRuntimeExports.jsx(reactExports.Fragment, { children: r3 === 2 ? jsxRuntimeExports.jsx("b", { children: t3 }) : t3 }, r3)) }) });
}, TA = (e12) => jsxRuntimeExports.jsx("div", { className: "layer-ui__search-result-container", children: e12.matches.items.map((o3, t3) => jsxRuntimeExports.jsx(wA, { searchQuery: e12.searchQuery, preview: o3.preview, highlighted: t3 === e12.focusIndex, onClick: () => e12.onItemClick(t3) }, o3.textElement.id + o3.index)) }), CA = (e12, o3) => e12.matches.nonce === o3.matches.nonce && e12.focusIndex === o3.focusIndex, IA = reactExports.memo(TA, CA), SA = (e12, o3, t3) => {
  let i3 = e12.slice(0, o3), a3 = i3.split(/\s+/), l3 = i3.endsWith(" "), s3 = a3.length - 2 - 1 - (l3 ? 0 : 1), c3 = a3.slice(s3 <= 0 ? 0 : s3).join(" ") + (l3 ? " " : ""), m3 = 20;
  c3 = c3.length > m3 ? c3.slice(-m3) : c3;
  let d3 = e12.slice(o3 + t3.length), p3 = d3.split(/\s+/), u3 = !d3.startsWith(" "), h3 = u3 ? 6 : 5, f3 = (u3 ? "" : " ") + p3.slice(0, h3).join(" ");
  return { indexInSearchQuery: c3.length, previewText: c3 + t3 + f3, moreBefore: s3 > 0, moreAfter: p3.length > h3 };
}, kA = (e12, o3) => {
  let t3 = e12.split(`
`), r3 = [], n3 = 0;
  for (let i3 = 0; i3 < t3.length; i3++) {
    let a3 = t3[i3], l3 = t3[i3 + 1];
    if (l3) {
      let s3 = o3.indexOf(l3, n3);
      if (s3 > a3.length + n3) {
        let c3 = s3 - (a3.length + n3);
        for (; c3 > 0; ) a3 += " ", c3--;
      }
    }
    r3.push(a3), n3 = n3 + a3.length;
  }
  return r3.join(`
`);
}, LA = (e12, o3, t3) => {
  let n3 = kA(e12.text, e12.originalText).split(`
`), i3 = [], a3 = 0, l3 = 0;
  for (let d3 of n3) {
    let p3 = a3, u3 = p3 + d3.length - 1;
    i3.push({ line: d3, startIndex: p3, endIndex: u3, lineNumber: l3 }), a3 = u3 + 1, l3++;
  }
  let s3 = t3, c3 = e12.originalText.slice(t3, t3 + o3.length), m3 = [];
  for (let d3 of i3) {
    if (c3 === "") break;
    if (s3 >= d3.startIndex && s3 <= d3.endIndex) {
      let p3 = d3.endIndex + 1 - s3, u3 = d3.line.slice(0, s3 - d3.startIndex), h3 = c3.slice(0, p3);
      c3 = c3.slice(p3);
      let f3 = ht(u3, Ee(e12), e12.lineHeight);
      if (u3 === "" && (f3.width = 0), e12.textAlign !== "left" && d3.line.length > 0) {
        let w3 = ht(d3.line, Ee(e12), e12.lineHeight), S3 = e12.textAlign === "center" ? (e12.width - w3.width) / 2 : e12.width - w3.width;
        f3.width += S3;
      }
      let { width: b3, height: x3 } = ht(h3, Ee(e12), e12.lineHeight), T3 = f3.width, E3 = d3.lineNumber * f3.height;
      m3.push({ offsetX: T3, offsetY: E3, width: b3, height: x3 }), s3 += p3;
    }
  }
  return m3;
}, AA = (e12) => e12.replace(/[.*+?^${}()|[\]\\-]/g, "\\$&"), H0 = xA((e12, o3, t3) => {
  if (!e12 || e12 === "") {
    t3([], null);
    return;
  }
  let n3 = o3.scene.getNonDeletedElements().filter((c3) => k$2(c3));
  n3.sort((c3, m3) => c3.y - m3.y);
  let i3 = [], a3 = new RegExp(AA(e12), "gi");
  for (let c3 of n3) {
    let m3 = null, d3 = c3.originalText;
    for (; (m3 = a3.exec(d3)) !== null; ) {
      let p3 = SA(d3, m3.index, e12), u3 = LA(c3, e12, m3.index);
      u3.length > 0 && i3.push({ textElement: c3, searchQuery: e12, preview: p3, index: m3.index, matchedLines: u3 });
    }
  }
  let l3 = new Set(o3.visibleElements.map((c3) => c3.id)), s3 = i3.findIndex((c3) => l3.has(c3.textElement.id)) ?? null;
  t3(i3, s3);
}, vA);
var V0 = ar("DefaultSidebarTrigger", (e12) => {
  let { DefaultSidebarTriggerTunnel: o3 } = _e();
  return jsxRuntimeExports.jsx(o3.In, { children: jsxRuntimeExports.jsx(no.Trigger, { ...e12, className: "default-sidebar-trigger", name: ks.name }) });
});
V0.displayName = "DefaultSidebarTrigger";
var W0 = ({ children: e12 }) => {
  let { DefaultSidebarTabTriggersTunnel: o3 } = _e();
  return jsxRuntimeExports.jsx(o3.In, { children: e12 });
};
W0.displayName = "DefaultTabTriggers";
var ud = Object.assign(ar("DefaultSidebar", ({ children: e12, className: o3, onDock: t3, docked: r3, ...n3 }) => {
  let i3 = ve(), a3 = pe(), { DefaultSidebarTabTriggersTunnel: l3 } = _e(), s3 = i3.openSidebar?.tab === HE;
  return reactExports.createElement(no, { ...n3, name: "default", key: "default", className: dM("default-sidebar", o3), docked: s3 || (r3 ?? i3.defaultSidebarDockedPreference), onDock: s3 || t3 === false || !t3 && r3 != null ? void 0 : Tg$1(t3, (c3) => {
    a3({ defaultSidebarDockedPreference: c3 });
  }) }, jsxRuntimeExports.jsxs(no.Tabs, { children: [jsxRuntimeExports.jsx(no.Header, { children: jsxRuntimeExports.jsxs(no.TabTriggers, { children: [jsxRuntimeExports.jsx(no.TabTrigger, { tab: HE, children: A4 }), jsxRuntimeExports.jsx(no.TabTrigger, { tab: b6, children: Ux }), jsxRuntimeExports.jsx(l3.Out, {})] }) }), jsxRuntimeExports.jsx(no.Tab, { tab: b6, children: jsxRuntimeExports.jsx(fw, {}) }), jsxRuntimeExports.jsx(no.Tab, { tab: HE, children: jsxRuntimeExports.jsx(G0, {}) }), e12] }));
}), { Trigger: V0, TabTriggers: W0 });
var RA = "small", X0 = (e12) => jsxRuntimeExports.jsxs("label", { className: dM("ToolIcon ToolIcon__LaserPointer", `ToolIcon_size_${RA}`, { "is-mobile": e12.isMobile }), title: `${e12.title}`, children: [jsxRuntimeExports.jsx("input", { className: "ToolIcon_type_checkbox", type: "checkbox", name: e12.name, onChange: e12.onChange, checked: e12.checked, "aria-label": e12.title, "data-testid": "toolbar-LaserPointer" }), jsxRuntimeExports.jsx("div", { className: "ToolIcon__icon", children: S4 })] });
var OA = ({ canvasRef: e12, setError: o3 }) => {
  let t3 = e12.current;
  if (!t3) return;
  let r3 = t3.parentElement;
  r3 && (r3.style.background = "", o3(null), t3.replaceChildren());
}, gd = async ({ canvasRef: e12, mermaidToExcalidrawLib: o3, mermaidDefinition: t3, setError: r3, data: n3 }) => {
  let i3 = e12.current, a3 = i3?.parentElement;
  if (!(!i3 || !a3)) {
    if (!t3) {
      OA({ canvasRef: e12, setError: r3 });
      return;
    }
    try {
      let l3 = await o3.api, s3;
      try {
        s3 = await l3.parseMermaidToExcalidraw(t3);
      } catch {
        s3 = await l3.parseMermaidToExcalidraw(t3.replace(/"/g, "'"));
      }
      let { elements: c3, files: m3 } = s3;
      r3(null), n3.current = { elements: Yi(c3, { regenerateIds: true }), files: m3 };
      let d3 = await t9({ elements: n3.current.elements, files: n3.current.files, exportPadding: Vi$1, maxWidthOrHeight: Math.max(a3.offsetWidth, a3.offsetHeight) * window.devicePixelRatio });
      try {
        await vY(d3);
      } catch (p3) {
        throw p3.name === "CANVAS_POSSIBLY_TOO_BIG" ? new Error(g("canvasError.canvasTooBig")) : p3;
      }
      a3.style.background = "var(--default-bg-color)", i3.replaceChildren(d3);
    } catch (l3) {
      throw a3.style.background = "var(--default-bg-color)", t3 && r3(l3), l3;
    }
  }
}, el = (e12) => {
  ro2.set(YE$1.MERMAID_TO_EXCALIDRAW, e12);
}, hd = ({ app: e12, data: o3, text: t3, shouldSaveMermaidDataToStorage: r3 }) => {
  let { elements: n3, files: i3 } = o3.current;
  n3.length && (e12.addElementsFromPasteOrLibrary({ elements: n3, files: i3, position: "center", fitToContent: true }), e12.setOpenDialog(null), r3 && t3 && el(t3));
};
var fd = ({ children: e12 }) => jsxRuntimeExports.jsx("div", { className: "ttd-dialog-panels", children: e12 });
var Vi = ({ label: e12, children: o3, panelAction: t3, panelActionDisabled: r3 = false, onTextSubmitInProgess: n3, renderTopRight: i3, renderSubmitShortcut: a3, renderBottomRight: l3 }) => jsxRuntimeExports.jsxs("div", { className: "ttd-dialog-panel", children: [jsxRuntimeExports.jsxs("div", { className: "ttd-dialog-panel__header", children: [jsxRuntimeExports.jsx("label", { children: e12 }), i3?.()] }), o3, jsxRuntimeExports.jsxs("div", { className: dM("ttd-dialog-panel-button-container", { invisible: !t3 }), style: { display: "flex", alignItems: "center" }, children: [jsxRuntimeExports.jsxs(Gt, { className: "ttd-dialog-panel-button", onSelect: t3 ? t3.action : () => {
}, disabled: r3 || n3, children: [jsxRuntimeExports.jsxs("div", { className: dM({ invisible: n3 }), children: [t3?.label, t3?.icon && jsxRuntimeExports.jsx("span", { children: t3.icon })] }), n3 && jsxRuntimeExports.jsx(ct, {})] }), !r3 && !n3 && a3?.(), l3?.()] })] });
var bd = ({ input: e12, placeholder: o3, onChange: t3, onKeyboardSubmit: r3 }) => {
  let n3 = reactExports.useRef(null), i3 = reactExports.useRef(r3);
  return i3.current = r3, reactExports.useEffect(() => {
    if (!i3.current) return;
    let a3 = n3.current;
    if (a3) {
      let l3 = (s3) => {
        s3[Q.CTRL_OR_CMD] && s3.key === Q.ENTER && (s3.preventDefault(), i3.current?.());
      };
      return a3.addEventListener("keydown", l3), () => {
        a3.removeEventListener("keydown", l3);
      };
    }
  }, []), jsxRuntimeExports.jsx("textarea", { className: "ttd-dialog-input", onChange: t3, value: e12, placeholder: o3, autoFocus: true, ref: n3 });
};
var UA = ({ error: e12 }) => jsxRuntimeExports.jsxs("div", { "data-testid": "ttd-dialog-output-error", className: "ttd-dialog-output-error", children: ["Error! ", jsxRuntimeExports.jsx("p", { children: e12 })] }), Ed = ({ error: e12, canvasRef: o3, loaded: t3 }) => jsxRuntimeExports.jsxs("div", { className: "ttd-dialog-output-wrapper", children: [e12 && jsxRuntimeExports.jsx(UA, { error: e12.message }), t3 ? jsxRuntimeExports.jsx("div", { ref: o3, style: { opacity: e12 ? "0.15" : 1 }, className: "ttd-dialog-output-canvas-container" }) : jsxRuntimeExports.jsx(ct, { size: "2rem" })] });
var yd = () => jsxRuntimeExports.jsxs("div", { className: "ttd-dialog-submit-shortcut", children: [jsxRuntimeExports.jsx("div", { className: "ttd-dialog-submit-shortcut__key", children: cg$1("CtrlOrCmd") }), jsxRuntimeExports.jsx("div", { className: "ttd-dialog-submit-shortcut__key", children: cg$1("Enter") })] });
var YA = `flowchart TD
 A[Christmas] -->|Get money| B(Go shopping)
 B --> C{Let me think}
 C -->|One| D[Laptop]
 C -->|Two| E[iPhone]
 C -->|Three| F[Car]`, t1 = $o(el, 300), VA = ({ mermaidToExcalidrawLib: e12 }) => {
  let [o3, t3] = reactExports.useState(() => ro2.get(YE$1.MERMAID_TO_EXCALIDRAW) || YA), r3 = reactExports.useDeferredValue(o3.trim()), [n3, i3] = reactExports.useState(null), a3 = reactExports.useRef(null), l3 = reactExports.useRef({ elements: [], files: null }), s3 = He();
  reactExports.useEffect(() => {
    gd({ canvasRef: a3, data: l3, mermaidToExcalidrawLib: e12, setError: i3, mermaidDefinition: r3 }).catch((m3) => {
      hg() && console.error("Failed to parse mermaid definition", m3);
    }), t1(r3);
  }, [r3, e12]), reactExports.useEffect(() => () => {
    t1.flush();
  }, []);
  let c3 = () => {
    hd({ app: s3, data: l3, text: o3, shouldSaveMermaidDataToStorage: true });
  };
  return jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [jsxRuntimeExports.jsx("div", { className: "ttd-dialog-desc", children: jsxRuntimeExports.jsx(Tt, { i18nKey: "mermaid.description", flowchartLink: (m3) => jsxRuntimeExports.jsx("a", { href: "https://mermaid.js.org/syntax/flowchart.html", children: m3 }), sequenceLink: (m3) => jsxRuntimeExports.jsx("a", { href: "https://mermaid.js.org/syntax/sequenceDiagram.html", children: m3 }), classLink: (m3) => jsxRuntimeExports.jsx("a", { href: "https://mermaid.js.org/syntax/classDiagram.html", children: m3 }) }) }), jsxRuntimeExports.jsxs(fd, { children: [jsxRuntimeExports.jsx(Vi, { label: g("mermaid.syntax"), children: jsxRuntimeExports.jsx(bd, { input: o3, placeholder: "Write Mermaid diagram defintion here...", onChange: (m3) => t3(m3.target.value), onKeyboardSubmit: () => {
    c3();
  } }) }), jsxRuntimeExports.jsx(Vi, { label: g("mermaid.preview"), panelAction: { action: () => {
    c3();
  }, label: g("mermaid.button"), icon: D4 }, renderSubmitShortcut: () => jsxRuntimeExports.jsx(yd, {}), children: jsxRuntimeExports.jsx(Ed, { canvasRef: a3, loaded: e12.loaded, error: n3 }) })] })] });
}, r1 = VA;
var a1 = (e12) => {
  let o3 = pe(), t3 = reactExports.useRef(null), r3 = reactExports.useRef(0);
  return jsxRuntimeExports.jsx($69cb30bb0017df05$export$be92b6f5f03c0fe9, { ref: t3, className: "ttd-dialog-tabs-root", value: e12.tab, onValueChange: (n3) => {
    if (!n3) return;
    let i3 = t3.current?.closest(".Modal__content");
    if (i3) {
      let a3 = i3.offsetHeight || 0;
      a3 > r3.current && (r3.current = a3, i3.style.minHeight = `min(${r3.current}px, 100%)`);
    }
    e12.dialog === "ttd" && Ed$1(["text-to-diagram", "mermaid"], n3) && o3({ openDialog: { name: e12.dialog, tab: n3 } });
  }, children: e12.children });
};
a1.displayName = "TTDDialogTabs";
var l1 = a1;
var mg = ({ children: e12, ...o3 }) => jsxRuntimeExports.jsx($69cb30bb0017df05$export$54c2e3dc7acea9f5, { className: "ttd-dialog-triggers", ...o3, children: e12 });
mg.displayName = "TTDDialogTabTriggers";
var vd = ({ children: e12, tab: o3, onSelect: t3, ...r3 }) => jsxRuntimeExports.jsx($69cb30bb0017df05$export$41fb9f06171c75f4, { value: o3, asChild: true, onSelect: t3, children: jsxRuntimeExports.jsx("button", { type: "button", className: "ttd-dialog-tab-trigger", ...r3, children: e12 }) });
vd.displayName = "TTDDialogTabTrigger";
var wd = ({ tab: e12, children: o3, ...t3 }) => jsxRuntimeExports.jsx($69cb30bb0017df05$export$7c6e2c02157bb7d2, { ...t3, value: e12, children: o3 });
wd.displayName = "TTDDialogTab";
var ug = 3, Wi = 1e3, jA = atom(null), JA = atom(null), gg = (e12) => {
  let o3 = ve();
  return o3.openDialog?.name !== "ttd" ? null : jsxRuntimeExports.jsx(qA, { ...e12, tab: o3.openDialog.tab });
}, qA = ar("TTDDialogBase", ({ tab: e12, ...o3 }) => {
  let t3 = He(), r3 = pe(), n3 = reactExports.useRef(null), [i3, a3] = ce(JA), [l3, s3] = reactExports.useState(i3?.prompt ?? ""), c3 = l3.trim(), m3 = (I3) => {
    s3(I3.target.value), a3((_3) => ({ generatedResponse: _3?.generatedResponse ?? null, prompt: I3.target.value }));
  }, [d3, p3] = reactExports.useState(false), [u3, h3] = ce(jA), f3 = async () => {
    if (c3.length > Wi || c3.length < ug || d3 || u3?.rateLimitRemaining === 0 || "__fallback" in o3) {
      c3.length < ug && S3(new Error(`Prompt is too short (min ${ug} characters)`)), c3.length > Wi && S3(new Error(`Prompt is too long (max ${Wi} characters)`));
      return;
    }
    try {
      p3(true), le("ai", "generate", "ttd");
      let { generatedResponse: I3, error: _3, rateLimit: k2, rateLimitRemaining: R3 } = await o3.onTextSubmit(c3);
      if (typeof I3 == "string" && a3((M) => ({ generatedResponse: I3, prompt: M?.prompt ?? null })), Mo$1(k2) && Mo$1(R3) && h3({ rateLimit: k2, rateLimitRemaining: R3 }), _3) {
        S3(_3);
        return;
      }
      if (!I3) {
        S3(new Error("Generation failed"));
        return;
      }
      try {
        await gd({ canvasRef: n3, data: E3, mermaidToExcalidrawLib: x3, setError: S3, mermaidDefinition: I3 }), le("ai", "mermaid parse success", "ttd");
      } catch (M) {
        console.info(`%cTTD mermaid render errror: ${M.message}`, "color: red"), console.info(`>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
TTD mermaid definition render errror: ${M.message}`, "color: yellow"), le("ai", "mermaid parse failed", "ttd"), S3(new Error("Generated an invalid diagram :(. You may also try a different prompt."));
      }
    } catch (I3) {
      let _3 = I3.message;
      (!_3 || _3 === "Failed to fetch") && (_3 = "Request failed"), S3(new Error(_3));
    } finally {
      p3(false);
    }
  }, b3 = reactExports.useRef(f3);
  b3.current = f3;
  let [x3, T3] = reactExports.useState({ loaded: false, api: __vitePreload(() => import("./index-TZwSmFf6.js").then((n8) => n8.b5), true ? [] : void 0, import.meta.url) });
  reactExports.useEffect(() => {
    (async () => {
      await x3.api, T3((_3) => ({ ..._3, loaded: true }));
    })();
  }, [x3.api]);
  let E3 = reactExports.useRef({ elements: [], files: null }), [w3, S3] = reactExports.useState(null);
  return jsxRuntimeExports.jsx(Ge, { className: "ttd-dialog", onCloseRequest: () => {
    t3.setOpenDialog(null);
  }, size: 1200, title: false, ...o3, autofocus: false, children: jsxRuntimeExports.jsxs(l1, { dialog: "ttd", tab: e12, children: ["__fallback" in o3 && o3.__fallback ? jsxRuntimeExports.jsx("p", { className: "dialog-mermaid-title", children: g("mermaid.title") }) : jsxRuntimeExports.jsxs(mg, { children: [jsxRuntimeExports.jsx(vd, { tab: "text-to-diagram", children: jsxRuntimeExports.jsxs("div", { style: { display: "flex", alignItems: "center" }, children: [g("labels.textToDiagram"), jsxRuntimeExports.jsx("div", { style: { display: "flex", alignItems: "center", justifyContent: "center", padding: "1px 6px", marginLeft: "10px", fontSize: 10, borderRadius: "12px", background: "var(--color-promo)", color: "var(--color-surface-lowest)" }, children: "AI Beta" })] }) }), jsxRuntimeExports.jsx(vd, { tab: "mermaid", children: "Mermaid" })] }), jsxRuntimeExports.jsx(wd, { className: "ttd-dialog-content", tab: "mermaid", children: jsxRuntimeExports.jsx(r1, { mermaidToExcalidrawLib: x3 }) }), !("__fallback" in o3) && jsxRuntimeExports.jsxs(wd, { className: "ttd-dialog-content", tab: "text-to-diagram", children: [jsxRuntimeExports.jsx("div", { className: "ttd-dialog-desc", children: "Currently we use Mermaid as a middle step, so you'll get best results if you describe a diagram, workflow, flow chart, and similar." }), jsxRuntimeExports.jsxs(fd, { children: [jsxRuntimeExports.jsx(Vi, { label: g("labels.prompt"), panelAction: { action: f3, label: "Generate", icon: D4 }, onTextSubmitInProgess: d3, panelActionDisabled: c3.length > Wi || u3?.rateLimitRemaining === 0, renderTopRight: () => u3 ? jsxRuntimeExports.jsxs("div", { className: "ttd-dialog-rate-limit", style: { fontSize: 12, marginLeft: "auto", color: u3.rateLimitRemaining === 0 ? "var(--color-danger)" : void 0 }, children: [u3.rateLimitRemaining, " requests left today"] }) : null, renderSubmitShortcut: () => jsxRuntimeExports.jsx(yd, {}), renderBottomRight: () => {
    if (typeof i3?.generatedResponse == "string") return jsxRuntimeExports.jsxs("div", { className: "excalidraw-link", style: { marginLeft: "auto", fontSize: 14 }, onClick: () => {
      typeof i3?.generatedResponse == "string" && (el(i3.generatedResponse), r3({ openDialog: { name: "ttd", tab: "mermaid" } }));
    }, children: ["View as Mermaid", jsxRuntimeExports.jsx(Lr, { icon: D4 })] });
    let I3 = c3.length / Wi;
    return I3 > 0.8 ? jsxRuntimeExports.jsxs("div", { style: { marginLeft: "auto", fontSize: 12, fontFamily: "monospace", color: I3 > 1 ? "var(--color-danger)" : void 0 }, children: ["Length: ", c3.length, "/", Wi] }) : null;
  }, children: jsxRuntimeExports.jsx(bd, { onChange: m3, input: l3, placeholder: "Describe what you want to see...", onKeyboardSubmit: () => {
    b3.current();
  } }) }), jsxRuntimeExports.jsx(Vi, { label: "Preview", panelAction: { action: () => {
    console.info("Panel action clicked"), hd({ app: t3, data: E3 });
  }, label: "Insert", icon: D4 }, children: jsxRuntimeExports.jsx(Ed, { canvasRef: n3, error: w3, loaded: x3.loaded }) })] })] })] }) });
});
var p1 = 0.01, Pt = (e12, o3) => !(o3 === "height" && k$2(e12) || o3 === "width" && k$2(e12) || o3 === "angle" && de(e12)), Oe = (e12, o3) => {
  let t3 = e12 + o3 / 2;
  return t3 - t3 % o3;
}, Ki = (e12, o3, t3) => Object.keys(e12).map((r3) => ({ original: (t3 ?? o3).get(r3), latest: o3.get(r3) })).filter((r3) => r3.original !== void 0 && r3.latest !== void 0);
var Ln = (e12, o3, t3, r3, n3, i3, a3, l3 = true) => {
  let s3 = r3.get(t3.id);
  if (!s3) return;
  let [c3, m3] = [t3.x + t3.width / 2, t3.y + t3.height / 2], [d3, p3] = T$1(u$1(t3.x, t3.y), u$1(c3, m3), t3.angle), u3 = e12 - d3, h3 = o3 - p3, [f3, b3] = T$1(u$1(e12, o3), u$1(c3 + u3, m3 + h3), -t3.angle);
  Y(s3, { x: f3, y: b3 }, l3), Cd(s3, r3, n3, i3);
  let x3 = oe(t3, a3);
  if (x3) {
    let T3 = r3.get(x3.id);
    T3 && Y(T3, { x: x3.x + u3, y: x3.y + h3 }, l3);
  }
}, Xi = (e12, o3) => {
  let r3 = dF(o3).map((n3) => an(e12, n3).reduce((i3, a3) => (i3[a3.id] = true, i3), {}));
  return e12.filter((n3) => !E2(n3)).forEach((n3) => {
    r3.push({ [n3.id]: true });
  }), r3;
}, Cd = (e12, o3, t3, r3, n3) => {
  ae(e12) ? BN([e12], o3, t3, r3, true, [], n3?.zoom) : Jt(e12, o3, n3);
};
var t_ = ({ label: e12, icon: o3, dragInputCallback: t3, value: r3, elements: n3, editable: i3 = true, shouldKeepAspectRatio: a3, property: l3, scene: s3, appState: c3, sensitivity: m3 = 1 }) => {
  let d3 = He(), p3 = reactExports.useRef(null), u3 = reactExports.useRef(null), [h3, f3] = reactExports.useState(r3.toString()), b3 = reactExports.useRef(null);
  b3.current || (b3.current = { originalAppState: Lg$1(c3), originalElements: n3, lastUpdatedValue: h3, updatePending: false }), reactExports.useEffect(() => {
    let E3 = r3.toString();
    f3(E3), b3.current.lastUpdatedValue = E3;
  }, [r3]);
  let x3 = (E3, w3, S3) => {
    if (!b3.current.updatePending) return false;
    b3.current.updatePending = false;
    let I3 = Number(E3);
    if (isNaN(I3)) {
      f3(r3.toString());
      return;
    }
    let _3 = Number(I3.toFixed(2)), k2 = Number(r3);
    (isNaN(k2) || Math.abs(_3 - k2) >= p1) && (b3.current.lastUpdatedValue = E3, t3({ accumulatedChange: 0, instantChange: 0, originalElements: w3, originalElementsMap: d3.scene.getNonDeletedElementsMap(), shouldKeepAspectRatio: a3, shouldChangeByStepSize: false, scene: s3, nextValue: _3, property: l3, originalAppState: S3, setInputValue: (R3) => f3(String(R3)) }), d3.syncActionResult({ captureUpdate: dr.IMMEDIATELY }));
  }, T3 = reactExports.useRef({});
  return T3.current.handleInputValue = x3, reactExports.useEffect(() => {
    let E3 = p3.current, w3 = T3.current;
    return () => {
      let S3 = E3?.value;
      S3 && w3.handleInputValue?.(S3, b3.current.originalElements, b3.current.originalAppState), window.removeEventListener("pointermove", w3.onPointerMove, false), window.removeEventListener("pointerup", w3.onPointerUp, false);
    };
  }, [i3]), i3 ? jsxRuntimeExports.jsxs("div", { className: dM("drag-input-container", !i3 && "disabled"), "data-testid": e12, children: [jsxRuntimeExports.jsx("div", { className: "drag-input-label", ref: u3, onPointerDown: (E3) => {
    if (p3.current && i3) {
      document.body.classList.add("excalidraw-cursor-resize");
      Number(p3.current.value);
      let S3 = null, I3 = d3.scene.getNonDeletedElements().reduce((H3, V3) => (H3.set(V3.id, Gr(V3)), H3), /* @__PURE__ */ new Map()), _3 = n3.map((H3) => I3.get(H3.id)), k2 = Lg$1(c3), R3 = 0, M = 0, N3 = (H3) => {
        if (S3 && I3 !== null && _3 !== null) {
          let V3 = H3.clientX - S3.x;
          V3 !== 0 && (M += V3, Math.abs(M) >= m3 && (M = Math.sign(M) * Math.floor(Math.abs(M) / m3), R3 += M, t3({ accumulatedChange: R3, instantChange: M, originalElements: _3, originalElementsMap: I3, shouldKeepAspectRatio: a3, shouldChangeByStepSize: H3.shiftKey, property: l3, scene: s3, originalAppState: k2, setInputValue: (F3) => f3(String(F3)) }), M = 0));
        }
        S3 = { x: H3.clientX, y: H3.clientY };
      }, G3 = () => {
        window.removeEventListener("pointermove", N3, false), d3.syncActionResult({ captureUpdate: dr.IMMEDIATELY }), S3 = null, R3 = 0, M = 0, _3 = null, I3 = null, document.body.classList.remove("excalidraw-cursor-resize"), window.removeEventListener("pointerup", G3, false);
      };
      T3.current.onPointerMove = N3, T3.current.onPointerUp = G3, window.addEventListener("pointermove", N3, false), window.addEventListener("pointerup", G3, false);
    }
  }, onPointerEnter: () => {
    u3.current && (u3.current.style.cursor = "ew-resize");
  }, children: o3 ? jsxRuntimeExports.jsx(Lr, { icon: o3 }) : e12 }), jsxRuntimeExports.jsx("input", { className: "drag-input", autoComplete: "off", spellCheck: "false", onKeyDown: (E3) => {
    if (i3) {
      let w3 = E3.target;
      w3 instanceof HTMLInputElement && E3.key === Q.ENTER && (x3(w3.value, n3, c3), d3.focusContainer());
    }
  }, ref: p3, value: h3, onChange: (E3) => {
    b3.current.updatePending = true, f3(E3.target.value);
  }, onFocus: (E3) => {
    E3.target.select(), b3.current.originalElements = n3, b3.current.originalAppState = Lg$1(c3);
  }, onBlur: (E3) => {
    h3 ? i3 && x3(E3.target.value, b3.current.originalElements, b3.current.originalAppState) : f3(r3.toString());
  }, disabled: !i3 })] }) : null;
}, at = t_;
var g1 = 10, r_ = (e12) => e12.type === "image", n_ = ({ accumulatedChange: e12, originalElements: o3, originalElementsMap: t3, shouldKeepAspectRatio: r3, shouldChangeByStepSize: n3, nextValue: i3, property: a3, originalAppState: l3, instantChange: s3, scene: c3 }) => {
  let m3 = c3.getNonDeletedElementsMap(), d3 = o3[0], p3 = m3.get(d3.id);
  if (d3 && p3) {
    let u3 = r3 || r_(d3), h3 = d3.width / d3.height;
    if (l3.croppingElementId === d3.id) {
      let E3 = m3.get(d3.id);
      if (!E3 || !Ye$1(E3) || !E3.crop) return;
      let w3 = E3.crop, S3 = { ...w3 }, I3 = E3.scale[0] === -1, _3 = E3.scale[1] === -1, { width: k2, height: R3 } = er$1(E3), M = w3.naturalWidth / k2, N3 = w3.naturalHeight / R3, G3 = I3 ? w3.width + w3.x : w3.naturalWidth - w3.x, H3 = _3 ? w3.height + w3.y : w3.naturalHeight - w3.y, V3 = Ge$1 * M, F3 = Ge$1 * N3;
      if (i3 !== void 0) {
        if (a3 === "width") {
          let ne3 = i3 * M, ge2 = se(ne3, V3, G3);
          S3 = { ...S3, width: ge2, x: I3 ? w3.x + w3.width - ge2 : w3.x };
        } else if (a3 === "height") {
          let ne3 = i3 * N3, ge2 = se(ne3, F3, H3);
          S3 = { ...S3, height: ge2, y: _3 ? w3.y + w3.height - ge2 : w3.y };
        }
        Y(E3, { crop: S3, width: S3.width / (w3.naturalWidth / k2), height: S3.height / (w3.naturalHeight / R3) });
        return;
      }
      let O3 = a3 === "width" ? s3 : 0, j = a3 === "height" ? s3 : 0, oe2 = se(w3.width + O3, V3, G3), W = se(w3.height + j, V3, H3);
      S3 = { ...w3, x: I3 ? w3.x + w3.width - oe2 : w3.x, y: _3 ? w3.y + w3.height - W : w3.y, width: oe2, height: W }, Y(E3, { crop: S3, width: S3.width / (w3.naturalWidth / k2), height: S3.height / (w3.naturalHeight / R3) });
      return;
    }
    if (i3 !== void 0) {
      let E3 = Math.max(a3 === "width" ? i3 : u3 ? i3 * h3 : d3.width, CE), w3 = Math.max(a3 === "height" ? i3 : u3 ? i3 / h3 : d3.height, CE);
      S9(E3, w3, p3, d3, m3, t3, a3 === "width" ? "e" : "s", { shouldMaintainAspectRatio: u3 });
      return;
    }
    let f3 = a3 === "width" ? e12 : 0, b3 = a3 === "height" ? e12 : 0, x3 = Math.max(0, d3.width + f3);
    a3 === "width" && (n3 ? x3 = Oe(x3, g1) : x3 = Math.round(x3));
    let T3 = Math.max(0, d3.height + b3);
    a3 === "height" && (n3 ? T3 = Oe(T3, g1) : T3 = Math.round(T3)), u3 && (a3 === "width" ? T3 = Math.round(x3 / h3 * 100) / 100 : x3 = Math.round(T3 * h3 * 100) / 100), T3 = Math.max(CE, T3), x3 = Math.max(CE, x3), S9(x3, T3, p3, d3, m3, t3, a3 === "width" ? "e" : "s", { shouldMaintainAspectRatio: u3 });
  }
}, i_ = ({ property: e12, element: o3, scene: t3, appState: r3 }) => {
  let n3 = To(e12 === "width" ? o3.width : o3.height, 2);
  if (r3.croppingElementId && r3.croppingElementId === o3.id && Ye$1(o3) && o3.crop) {
    let { width: i3, height: a3 } = er$1(o3);
    if (e12 === "width") {
      let l3 = i3 / o3.crop.naturalWidth;
      n3 = To(o3.crop.width * l3, 2);
    }
    if (e12 === "height") {
      let l3 = a3 / o3.crop.naturalHeight;
      n3 = To(o3.crop.height * l3, 2);
    }
  }
  return jsxRuntimeExports.jsx(at, { label: e12 === "width" ? "W" : "H", elements: [o3], dragInputCallback: n_, value: n3, editable: Pt(o3, e12), scene: t3, appState: r3, property: e12 });
}, fg = i_;
var l_ = 15, s_ = ({ accumulatedChange: e12, originalElements: o3, shouldChangeByStepSize: t3, nextValue: r3, scene: n3 }) => {
  let i3 = n3.getNonDeletedElementsMap(), a3 = n3.getNonDeletedElements(), l3 = o3[0];
  if (l3 && !X$1(l3)) {
    let s3 = i3.get(l3.id);
    if (!s3) return;
    if (r3 !== void 0) {
      let h3 = yr(r3);
      Y(s3, { angle: h3 }), Cd(s3, i3, a3, n3);
      let f3 = oe(s3, i3);
      f3 && !ee(s3) && Y(f3, { angle: h3 });
      return;
    }
    let c3 = Math.round(rd$1(l3.angle) * 100) / 100, m3 = Math.round(e12), d3 = (c3 + m3) % 360;
    t3 && (d3 = Oe(d3, l_)), d3 = d3 < 0 ? d3 + 360 : d3;
    let p3 = yr(d3);
    Y(s3, { angle: p3 }), Cd(s3, i3, a3, n3);
    let u3 = oe(s3, i3);
    u3 && !ee(s3) && Y(u3, { angle: p3 });
  }
}, c_ = ({ element: e12, scene: o3, appState: t3, property: r3 }) => jsxRuntimeExports.jsx(at, { label: "A", icon: f4, value: Math.round(rd$1(e12.angle) % 360 * 100) / 100, elements: [e12], dragInputCallback: s_, editable: Pt(e12, "angle"), scene: o3, appState: t3, property: r3 }), h1 = c_;
var f1 = 4, m_ = 4, p_ = ({ accumulatedChange: e12, originalElements: o3, shouldChangeByStepSize: t3, nextValue: r3, scene: n3 }) => {
  let i3 = n3.getNonDeletedElementsMap(), a3 = o3[0];
  if (a3) {
    let l3 = i3.get(a3.id);
    if (!l3 || !k$2(l3)) return;
    let s3;
    if (r3 !== void 0) s3 = Math.max(Math.round(r3), f1);
    else if (a3.type === "text") {
      let c3 = Math.round(a3.fontSize), m3 = Math.round(e12);
      s3 = Math.max(c3 + m3, f1), t3 && (s3 = Oe(s3, m_));
    }
    s3 && (Y(l3, { fontSize: s3 }), Xa$1(l3, n3.getContainerElement(l3), n3.getNonDeletedElementsMap()));
  }
}, u_ = ({ element: e12, scene: o3, appState: t3, property: r3 }) => {
  let n3 = k$2(e12) ? e12 : bn(e12) ? oe(e12, o3.getNonDeletedElementsMap()) : null;
  return n3 ? jsxRuntimeExports.jsx(at, { label: "F", value: Math.round(n3.fontSize * 10) / 10, elements: [n3], dragInputCallback: p_, icon: i4, appState: t3, scene: o3, property: r3 }) : null;
}, b1 = u_;
var $i = 10, f_ = (e12, o3, t3, r3) => {
  let n3 = r3.x - e12, i3 = r3.y - o3, a3 = r3.width * t3, l3 = r3.height * t3, s3 = e12 + n3 * t3, c3 = o3 + i3 * t3;
  return { width: a3, height: l3, x: s3, y: c3, ...r6(r3, a3, l3, false), ...k$2(r3) ? { fontSize: r3.fontSize * t3 } : {} };
}, b_ = (e12, o3, t3, r3, n3, i3, a3, l3) => {
  let s3 = f_(e12, o3, r3, i3);
  Y(n3, s3, false);
  let c3 = oe(i3, l3);
  if (c3) {
    let m3 = c3.fontSize * r3;
    Jt(n3, a3, { newSize: { width: s3.width, height: s3.height } });
    let d3 = a3.get(c3.id);
    d3 && k$2(d3) && (Y(d3, { fontSize: m3 }, false), _n(n3, a3, t3 === "width" ? "e" : "s", true));
  }
}, x1 = (e12, o3, t3, r3, n3, i3, a3, l3, s3, c3) => {
  i3 === "width" ? o3 = Math.round(e12 / r3 * 100) / 100 : e12 = Math.round(o3 * r3 * 100) / 100;
  let m3 = o3 / t3;
  for (let d3 = 0; d3 < l3.length; d3++) {
    let p3 = l3[d3], u3 = a3[d3];
    b_(n3[0], n3[1], i3, m3, u3, p3, s3, c3);
  }
}, x_ = ({ accumulatedChange: e12, originalElements: o3, originalElementsMap: t3, originalAppState: r3, shouldChangeByStepSize: n3, nextValue: i3, scene: a3, property: l3 }) => {
  let s3 = a3.getNonDeletedElementsMap(), c3 = Xi(o3, r3);
  if (i3 !== void 0) {
    for (let p3 of c3) {
      let u3 = Ki(p3, s3, t3);
      if (u3.length > 1) {
        let h3 = u3.map((R3) => R3.latest), f3 = u3.map((R3) => R3.original), [b3, x3, T3, E3] = $e$1(f3), w3 = T3 - b3, S3 = E3 - x3, I3 = w3 / S3, _3 = Math.max(CE, l3 === "width" ? Math.max(0, i3) : w3), k2 = Math.max(CE, l3 === "height" ? Math.max(0, i3) : S3);
        x1(_3, k2, S3, I3, u$1(b3, x3), l3, h3, f3, s3, t3);
      } else {
        let [h3] = u3, f3 = h3?.latest, b3 = h3?.original;
        if (f3 && b3 && Pt(f3, l3)) {
          let x3 = l3 === "width" ? Math.max(0, i3) : f3.width;
          l3 === "width" && (n3 ? x3 = Oe(x3, $i) : x3 = Math.round(x3));
          let T3 = l3 === "height" ? Math.max(0, i3) : f3.height;
          l3 === "height" && (n3 ? T3 = Oe(T3, $i) : T3 = Math.round(T3)), x3 = Math.max(CE, x3), T3 = Math.max(CE, T3), S9(x3, T3, f3, b3, s3, t3, l3 === "width" ? "e" : "s", { shouldInformMutation: false });
        }
      }
    }
    a3.triggerUpdate();
    return;
  }
  let m3 = l3 === "width" ? e12 : 0, d3 = l3 === "height" ? e12 : 0;
  for (let p3 of c3) {
    let u3 = Ki(p3, s3, t3);
    if (u3.length > 1) {
      let h3 = u3.map((R3) => R3.latest), f3 = u3.map((R3) => R3.original), [b3, x3, T3, E3] = $e$1(f3), w3 = T3 - b3, S3 = E3 - x3, I3 = w3 / S3, _3 = Math.max(0, w3 + m3);
      l3 === "width" && (n3 ? _3 = Oe(_3, $i) : _3 = Math.round(_3));
      let k2 = Math.max(0, S3 + d3);
      l3 === "height" && (n3 ? k2 = Oe(k2, $i) : k2 = Math.round(k2)), _3 = Math.max(CE, _3), k2 = Math.max(CE, k2), x1(_3, k2, S3, I3, u$1(b3, x3), l3, h3, f3, s3, t3);
    } else {
      let [h3] = u3, f3 = h3?.latest, b3 = h3?.original;
      if (f3 && b3 && Pt(f3, l3)) {
        let x3 = Math.max(0, b3.width + m3);
        l3 === "width" && (n3 ? x3 = Oe(x3, $i) : x3 = Math.round(x3));
        let T3 = Math.max(0, b3.height + d3);
        l3 === "height" && (n3 ? T3 = Oe(T3, $i) : T3 = Math.round(T3)), x3 = Math.max(CE, x3), T3 = Math.max(CE, T3), S9(x3, T3, f3, b3, s3, t3, l3 === "width" ? "e" : "s", { shouldInformMutation: false });
      }
    }
  }
  a3.triggerUpdate();
}, E_ = ({ property: e12, elements: o3, elementsMap: t3, atomicUnits: r3, scene: n3, appState: i3 }) => {
  let a3 = reactExports.useMemo(() => r3.map((c3) => {
    let m3 = Ki(c3, t3);
    if (m3.length > 1) {
      let [p3, u3, h3, f3] = $e$1(m3.map((b3) => b3.latest));
      return Math.round((e12 === "width" ? h3 - p3 : f3 - u3) * 100) / 100;
    }
    let [d3] = m3;
    return Math.round((e12 === "width" ? d3.latest.width : d3.latest.height) * 100) / 100;
  }), [t3, r3, e12]), l3 = new Set(a3).size === 1 ? Math.round(a3[0] * 100) / 100 : "Mixed", s3 = a3.length > 0;
  return jsxRuntimeExports.jsx(at, { label: e12 === "width" ? "W" : "H", elements: o3, dragInputCallback: x_, value: l3, editable: s3, appState: i3, property: e12, scene: n3 });
}, bg = E_;
var v_ = 15, w_ = ({ accumulatedChange: e12, originalElements: o3, shouldChangeByStepSize: t3, nextValue: r3, property: n3, scene: i3 }) => {
  let a3 = i3.getNonDeletedElementsMap(), l3 = o3.map((c3) => a3.get(c3.id)).filter((c3) => c3 && !E2(c3) && Pt(c3, n3)), s3 = o3.filter((c3) => !E2(c3) && Pt(c3, n3));
  if (r3 !== void 0) {
    let c3 = yr(r3);
    for (let m3 of l3) {
      if (!m3) continue;
      Y(m3, { angle: c3 }, false);
      let d3 = oe(m3, a3);
      d3 && !ee(m3) && Y(d3, { angle: c3 }, false);
    }
    i3.triggerUpdate();
    return;
  }
  for (let c3 = 0; c3 < l3.length; c3++) {
    let m3 = l3[c3];
    if (!m3) continue;
    let d3 = s3[c3], p3 = Math.round(rd$1(d3.angle) * 100) / 100, u3 = Math.round(e12), h3 = (p3 + u3) % 360;
    t3 && (h3 = Oe(h3, v_)), h3 = h3 < 0 ? h3 + 360 : h3;
    let f3 = yr(h3);
    Y(m3, { angle: f3 }, false);
    let b3 = oe(m3, a3);
    b3 && !ee(m3) && Y(b3, { angle: f3 }, false);
  }
  i3.triggerUpdate();
}, T_ = ({ elements: e12, scene: o3, appState: t3, property: r3 }) => {
  let n3 = e12.filter((s3) => !E2(s3) && Pt(s3, "angle")), i3 = n3.map((s3) => Math.round(rd$1(s3.angle) % 360 * 100) / 100), a3 = new Set(i3).size === 1 ? i3[0] : "Mixed", l3 = n3.some((s3) => Pt(s3, "angle"));
  return jsxRuntimeExports.jsx(at, { label: "A", icon: f4, value: a3, elements: e12, dragInputCallback: w_, editable: l3, appState: t3, scene: o3, property: r3 });
}, E1 = T_;
var y1 = 4, I_ = 4, S_ = (e12, o3) => e12.reduce((t3, r3) => {
  if (!r3 || E2(r3)) return t3;
  if (k$2(r3)) return t3.push(r3), t3;
  if (bn(r3)) {
    let n3 = oe(r3, o3);
    if (n3) return t3.push(n3), t3;
  }
  return t3;
}, []), k_ = ({ accumulatedChange: e12, originalElements: o3, shouldChangeByStepSize: t3, nextValue: r3, scene: n3 }) => {
  let i3 = n3.getNonDeletedElementsMap(), a3 = o3.map((s3) => i3.get(s3.id)), l3;
  if (r3) {
    l3 = Math.max(Math.round(r3), y1);
    for (let s3 of a3) Y(s3, { fontSize: l3 }, false), Xa$1(s3, n3.getContainerElement(s3), i3, false);
    n3.triggerUpdate();
  } else {
    let s3 = o3;
    for (let c3 = 0; c3 < a3.length; c3++) {
      let m3 = a3[c3], d3 = s3[c3], p3 = Math.round(d3.fontSize), u3 = Math.round(e12), h3 = Math.max(p3 + u3, y1);
      t3 && (h3 = Oe(h3, I_)), Y(m3, { fontSize: h3 }, false), Xa$1(m3, n3.getContainerElement(m3), i3, false);
    }
    n3.triggerUpdate();
  }
}, L_ = ({ elements: e12, scene: o3, appState: t3, property: r3, elementsMap: n3 }) => {
  let i3 = S_(e12, n3);
  if (!i3.length) return null;
  let a3 = i3.map((c3) => Math.round(c3.fontSize * 10) / 10), l3 = new Set(a3).size === 1 ? a3[0] : "Mixed", s3 = a3.length > 0;
  return jsxRuntimeExports.jsx(at, { label: "F", icon: i4, elements: i3, dragInputCallback: k_, value: l3, editable: s3, scene: o3, property: r3, appState: t3 });
}, v1 = L_;
var w1 = 10, __ = ({ accumulatedChange: e12, instantChange: o3, originalElements: t3, originalElementsMap: r3, shouldChangeByStepSize: n3, nextValue: i3, property: a3, scene: l3, originalAppState: s3 }) => {
  let c3 = l3.getNonDeletedElementsMap(), m3 = l3.getNonDeletedElements(), d3 = t3[0], [p3, u3] = [d3.x + d3.width / 2, d3.y + d3.height / 2], [h3, f3] = T$1(u$1(d3.x, d3.y), u$1(p3, u3), d3.angle);
  if (s3.croppingElementId === d3.id) {
    let w3 = c3.get(d3.id);
    if (!w3 || !Ye$1(w3) || !w3.crop) return;
    let S3 = w3.crop, I3 = S3, _3 = w3.scale[0] === -1, k2 = w3.scale[1] === -1, { width: R3, height: M } = er$1(w3);
    if (i3 !== void 0) {
      if (a3 === "x") {
        let H3 = i3 * (S3.naturalWidth / R3);
        _3 ? I3 = { ...S3, x: se(S3.naturalWidth - H3 - S3.width, 0, S3.naturalWidth - S3.width) } : I3 = { ...S3, x: se(i3 * (S3.naturalWidth / R3), 0, S3.naturalWidth - S3.width) };
      }
      a3 === "y" && (I3 = { ...S3, y: se(i3 * (S3.naturalHeight / M), 0, S3.naturalHeight - S3.height) }), Y(w3, { crop: I3 });
      return;
    }
    let N3 = (a3 === "x" ? o3 : 0) * (_3 ? -1 : 1), G3 = (a3 === "y" ? o3 : 0) * (k2 ? -1 : 1);
    I3 = { ...S3, x: se(S3.x + N3, 0, S3.naturalWidth - S3.width), y: se(S3.y + G3, 0, S3.naturalHeight - S3.height) }, Y(w3, { crop: I3 });
    return;
  }
  if (i3 !== void 0) {
    Ln(a3 === "x" ? i3 : h3, a3 === "y" ? i3 : f3, d3, c3, m3, l3, r3);
    return;
  }
  let b3 = a3 === "x" ? e12 : 0, x3 = a3 === "y" ? e12 : 0, T3 = a3 === "x" ? Math.round(n3 ? Oe(d3.x + b3, w1) : h3 + b3) : h3, E3 = a3 === "y" ? Math.round(n3 ? Oe(d3.y + x3, w1) : f3 + x3) : f3;
  Ln(T3, E3, d3, c3, m3, l3, r3);
}, M_ = ({ property: e12, element: o3, elementsMap: t3, scene: r3, appState: n3 }) => {
  let [i3, a3] = T$1(u$1(o3.x, o3.y), u$1(o3.x + o3.width / 2, o3.y + o3.height / 2), o3.angle), l3 = To(e12 === "x" ? i3 : a3, 2);
  if (n3.croppingElementId === o3.id && Ye$1(o3) && o3.crop) {
    let s3 = UP(o3);
    s3 && (l3 = To(e12 === "x" ? s3.x : s3.y, 2));
  }
  return jsxRuntimeExports.jsx(at, { label: e12 === "x" ? "X" : "Y", elements: [o3], dragInputCallback: __, scene: r3, value: l3, property: e12, appState: n3 });
}, xg = M_;
var R_ = 10, N_ = (e12, o3, t3, r3, n3, i3, a3, l3) => {
  for (let s3 = 0; s3 < r3.length; s3++) {
    let c3 = n3[s3], [m3, d3] = [c3.x + c3.width / 2, c3.y + c3.height / 2], [p3, u3] = T$1(u$1(c3.x, c3.y), u$1(m3, d3), c3.angle), h3 = e12 === "x" ? Math.round(p3 + o3) : p3, f3 = e12 === "y" ? Math.round(u3 + t3) : u3;
    Ln(h3, f3, c3, i3, r3, l3, a3, false);
  }
}, O_ = (e12, o3, t3, r3, n3, i3, a3) => {
  let [l3, s3, ,] = $e$1(t3), c3 = e12 - l3, m3 = o3 - s3;
  for (let d3 = 0; d3 < t3.length; d3++) {
    let p3 = t3[d3], u3 = r3.get(p3.id);
    if (u3 && (!k$2(u3) || !u3.containerId)) {
      let [h3, f3] = [u3.x + u3.width / 2, u3.y + u3.height / 2], [b3, x3] = T$1(u$1(u3.x, u3.y), u$1(h3, f3), u3.angle);
      Ln(b3 + c3, x3 + m3, p3, r3, n3, a3, i3, false);
    }
  }
}, F_ = ({ accumulatedChange: e12, originalElements: o3, originalElementsMap: t3, shouldChangeByStepSize: r3, nextValue: n3, property: i3, scene: a3, originalAppState: l3 }) => {
  let s3 = a3.getNonDeletedElementsMap(), c3 = a3.getNonDeletedElements();
  if (n3 !== void 0) {
    for (let u3 of Xi(o3, l3)) {
      let h3 = Ki(u3, s3, t3);
      if (h3.length > 1) {
        let [f3, b3, ,] = $e$1(h3.map((E3) => E3.latest));
        O_(i3 === "x" ? n3 : f3, i3 === "y" ? n3 : b3, h3.map((E3) => E3.original), s3, c3, t3, a3);
      } else {
        let f3 = h3[0]?.original, b3 = h3[0]?.latest;
        if (f3 && b3 && Pt(b3, i3)) {
          let [x3, T3] = [f3.x + f3.width / 2, f3.y + f3.height / 2], [E3, w3] = T$1(u$1(f3.x, f3.y), u$1(x3, T3), f3.angle);
          Ln(i3 === "x" ? n3 : E3, i3 === "y" ? n3 : w3, f3, s3, c3, a3, t3, false);
        }
      }
    }
    a3.triggerUpdate();
    return;
  }
  let m3 = r3 ? Oe(e12, R_) : e12;
  N_(i3, i3 === "x" ? m3 : 0, i3 === "y" ? m3 : 0, o3, o3, s3, t3, a3), a3.triggerUpdate();
}, B_ = ({ property: e12, elements: o3, elementsMap: t3, atomicUnits: r3, scene: n3, appState: i3 }) => {
  let a3 = reactExports.useMemo(() => r3.map((s3) => {
    let c3 = Object.keys(s3).map((f3) => t3.get(f3)).filter((f3) => f3 !== void 0);
    if (c3.length > 1) {
      let [f3, b3] = $e$1(c3);
      return Math.round((e12 === "x" ? f3 : b3) * 100) / 100;
    }
    let [m3] = c3, [d3, p3] = [m3.x + m3.width / 2, m3.y + m3.height / 2], [u3, h3] = T$1(u$1(m3.x, m3.y), u$1(d3, p3), m3.angle);
    return Math.round((e12 === "x" ? u3 : h3) * 100) / 100;
  }), [r3, t3, e12]), l3 = new Set(a3).size === 1 ? a3[0] : "Mixed";
  return jsxRuntimeExports.jsx(at, { label: e12 === "x" ? "X" : "Y", elements: o3, dragInputCallback: F_, value: l3, property: e12, scene: n3, appState: i3 });
}, Eg = B_;
var T1 = 5, U_ = ({ property: e12, scene: o3, appState: t3, setAppState: r3 }) => jsxRuntimeExports.jsx(at, { label: "Grid step", sensitivity: 8, elements: [], dragInputCallback: ({ nextValue: n3, instantChange: i3, shouldChangeByStepSize: a3, setInputValue: l3 }) => {
  r3((s3) => {
    let c3;
    return n3 ? c3 = n3 : i3 && (c3 = a3 ? Oe(s3.gridStep + T1 * Math.sign(i3), T1) : s3.gridStep + i3), c3 ? (c3 = Ka$1(c3), l3(c3), { gridStep: c3 }) : (l3(s3.gridStep), null);
  });
}, scene: o3, value: t3.gridStep, property: e12, appState: t3 }), C1 = U_;
var K_ = 50, ol = (e12) => {
  let o3 = Mo(), t3 = e12.app.scene.getSceneNonce() || 1, r3 = e12.app.scene.getSelectedElements({ selectedElementIds: o3.selectedElementIds, includeBoundTextElement: false }), n3 = Sb(e12.app);
  return jsxRuntimeExports.jsx(X_, { ...e12, appState: o3, sceneNonce: t3, selectedElements: r3, gridModeEnabled: n3 });
}, Pe = ({ children: e12, columns: o3 = 1, heading: t3, style: r3, ...n3 }) => jsxRuntimeExports.jsx("div", { className: dM("exc-stats__row", { "exc-stats__row--heading": t3 }), style: { gridTemplateColumns: `repeat(${o3}, 1fr)`, ...r3 }, ...n3, children: e12 });
Pe.displayName = "StatsRow";
var Sd = ({ children: e12, order: o3, style: t3, ...r3 }) => jsxRuntimeExports.jsx("div", { className: "exc-stats__rows", style: { order: o3, ...t3 }, ...r3, children: e12 });
Sd.displayName = "StatsRows";
ol.StatsRow = Pe;
ol.StatsRows = Sd;
var X_ = reactExports.memo(({ app: e12, onClose: o3, renderCustomStats: t3, selectedElements: r3, appState: n3, sceneNonce: i3, gridModeEnabled: a3 }) => {
  let l3 = e12.scene, s3 = l3.getNonDeletedElements(), c3 = l3.getNonDeletedElementsMap(), m3 = pe(), d3 = r3.length === 1 ? r3[0] : null, p3 = r3.length > 1 ? r3 : null, u3 = n3.croppingElementId && Ye$1(d3), h3 = u3 ? er$1(d3) : null, [f3, b3] = reactExports.useState({ width: 0, height: 0 }), x3 = reactExports.useMemo(() => gM((w3) => {
    let S3 = $e$1(w3);
    b3({ width: Math.round(S3[2]) - Math.round(S3[0]), height: Math.round(S3[3]) - Math.round(S3[1]) });
  }, K_), []);
  reactExports.useEffect(() => {
    x3(s3);
  }, [i3, s3, x3]), reactExports.useEffect(() => () => x3.cancel(), [x3]);
  let T3 = reactExports.useMemo(() => Xi(r3, n3), [r3, n3]), E3 = reactExports.useMemo(() => IH(r3), [r3]);
  return jsxRuntimeExports.jsx("div", { className: "exc-stats", children: jsxRuntimeExports.jsxs(Qe2, { padding: 3, children: [jsxRuntimeExports.jsxs("div", { className: "title", children: [jsxRuntimeExports.jsx("h2", { children: g("stats.title") }), jsxRuntimeExports.jsx("div", { className: "close", onClick: o3, children: Ih })] }), jsxRuntimeExports.jsxs(Ra, { label: jsxRuntimeExports.jsx("h3", { children: g("stats.generalStats") }), open: !!(n3.stats.panels & ki.generalStats), openTrigger: () => m3((w3) => ({ stats: { open: true, panels: w3.stats.panels ^ ki.generalStats } })), children: [jsxRuntimeExports.jsxs(Sd, { children: [jsxRuntimeExports.jsx(Pe, { heading: true, children: g("stats.scene") }), jsxRuntimeExports.jsxs(Pe, { columns: 2, children: [jsxRuntimeExports.jsx("div", { children: g("stats.shapes") }), jsxRuntimeExports.jsx("div", { children: s3.length })] }), jsxRuntimeExports.jsxs(Pe, { columns: 2, children: [jsxRuntimeExports.jsx("div", { children: g("stats.width") }), jsxRuntimeExports.jsx("div", { children: f3.width })] }), jsxRuntimeExports.jsxs(Pe, { columns: 2, children: [jsxRuntimeExports.jsx("div", { children: g("stats.height") }), jsxRuntimeExports.jsx("div", { children: f3.height })] }), a3 && jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [jsxRuntimeExports.jsx(Pe, { heading: true, children: "Canvas" }), jsxRuntimeExports.jsx(Pe, { children: jsxRuntimeExports.jsx(C1, { property: "gridStep", scene: l3, appState: n3, setAppState: m3 }) })] })] }), t3?.(s3, n3)] }), !E3 && r3.length > 0 && jsxRuntimeExports.jsx("div", { id: "elementStats", style: { marginTop: 12 }, children: jsxRuntimeExports.jsx(Ra, { label: jsxRuntimeExports.jsx("h3", { children: g("stats.elementProperties") }), open: !!(n3.stats.panels & ki.elementProperties), openTrigger: () => m3((w3) => ({ stats: { open: true, panels: w3.stats.panels ^ ki.elementProperties } })), children: jsxRuntimeExports.jsxs(Sd, { children: [d3 && jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [u3 && jsxRuntimeExports.jsx(Pe, { heading: true, children: g("labels.unCroppedDimension") }), n3.croppingElementId && Ye$1(d3) && h3 && jsxRuntimeExports.jsxs(Pe, { columns: 2, children: [jsxRuntimeExports.jsx("div", { children: g("stats.width") }), jsxRuntimeExports.jsx("div", { children: To(h3.width, 2) })] }), n3.croppingElementId && Ye$1(d3) && h3 && jsxRuntimeExports.jsxs(Pe, { columns: 2, children: [jsxRuntimeExports.jsx("div", { children: g("stats.height") }), jsxRuntimeExports.jsx("div", { children: To(h3.height, 2) })] }), jsxRuntimeExports.jsx(Pe, { heading: true, "data-testid": "stats-element-type", children: n3.croppingElementId ? g("labels.imageCropping") : g(`element.${d3.type}`) }), jsxRuntimeExports.jsx(Pe, { children: jsxRuntimeExports.jsx(xg, { element: d3, property: "x", elementsMap: c3, scene: l3, appState: n3 }) }), jsxRuntimeExports.jsx(Pe, { children: jsxRuntimeExports.jsx(xg, { element: d3, property: "y", elementsMap: c3, scene: l3, appState: n3 }) }), jsxRuntimeExports.jsx(Pe, { children: jsxRuntimeExports.jsx(fg, { property: "width", element: d3, scene: l3, appState: n3 }) }), jsxRuntimeExports.jsx(Pe, { children: jsxRuntimeExports.jsx(fg, { property: "height", element: d3, scene: l3, appState: n3 }) }), !X$1(d3) && jsxRuntimeExports.jsx(Pe, { children: jsxRuntimeExports.jsx(h1, { property: "angle", element: d3, scene: l3, appState: n3 }) }), jsxRuntimeExports.jsx(Pe, { children: jsxRuntimeExports.jsx(b1, { property: "fontSize", element: d3, scene: l3, appState: n3 }) })] }), p3 && jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [b2(p3) && jsxRuntimeExports.jsx(Pe, { heading: true, children: g("element.group") }), jsxRuntimeExports.jsxs(Pe, { columns: 2, style: { margin: "0.3125rem 0" }, children: [jsxRuntimeExports.jsx("div", { children: g("stats.shapes") }), jsxRuntimeExports.jsx("div", { children: r3.length })] }), jsxRuntimeExports.jsx(Pe, { children: jsxRuntimeExports.jsx(Eg, { property: "x", elements: p3, elementsMap: c3, atomicUnits: T3, scene: l3, appState: n3 }) }), jsxRuntimeExports.jsx(Pe, { children: jsxRuntimeExports.jsx(Eg, { property: "y", elements: p3, elementsMap: c3, atomicUnits: T3, scene: l3, appState: n3 }) }), jsxRuntimeExports.jsx(Pe, { children: jsxRuntimeExports.jsx(bg, { property: "width", elements: p3, elementsMap: c3, atomicUnits: T3, scene: l3, appState: n3 }) }), jsxRuntimeExports.jsx(Pe, { children: jsxRuntimeExports.jsx(bg, { property: "height", elements: p3, elementsMap: c3, atomicUnits: T3, scene: l3, appState: n3 }) }), jsxRuntimeExports.jsx(Pe, { children: jsxRuntimeExports.jsx(E1, { property: "angle", elements: p3, scene: l3, appState: n3 }) }), jsxRuntimeExports.jsx(Pe, { children: jsxRuntimeExports.jsx(v1, { property: "fontSize", elements: p3, scene: l3, appState: n3, elementsMap: c3 }) })] })] }) }) })] }) });
}, (e12, o3) => e12.sceneNonce === o3.sceneNonce && e12.selectedElements === o3.selectedElements && e12.appState.stats.panels === o3.appState.stats.panels && e12.gridModeEnabled === o3.gridModeEnabled && e12.appState.gridStep === o3.appState.gridStep && e12.appState.croppingElementId === o3.appState.croppingElementId);
var Z_ = ({ sourceElementId: e12, onClose: o3, elementsMap: t3, appState: r3, generateLinkForSelection: n3 = qO }) => {
  let i3 = t3.get(e12)?.link ?? null, [a3, l3] = reactExports.useState(i3), [s3, c3] = reactExports.useState(false);
  reactExports.useEffect(() => {
    let d3 = at$1(t3, r3), p3 = i3;
    if (d3.length > 0 && n3) {
      let u3 = XO(d3, r3);
      u3 && (p3 = dn(n3(u3.id, u3.type)));
    }
    l3(p3);
  }, [t3, r3, r3.selectedElementIds, i3, n3]);
  let m3 = reactExports.useCallback(() => {
    if (a3 && a3 !== t3.get(e12)?.link) {
      let d3 = t3.get(e12);
      d3 && Y(d3, { link: a3 });
    }
    if (!a3 && s3 && e12) {
      let d3 = t3.get(e12);
      d3 && Y(d3, { link: null });
    }
    o3?.();
  }, [e12, a3, t3, s3, o3]);
  return reactExports.useEffect(() => {
    let d3 = (p3) => {
      r3.openDialog?.name === "elementLinkSelector" && p3.key === Q.ENTER && m3(), r3.openDialog?.name === "elementLinkSelector" && p3.key === Q.ESCAPE && o3?.();
    };
    return window.addEventListener("keydown", d3), () => {
      window.removeEventListener("keydown", d3);
    };
  }, [r3, o3, m3]), jsxRuntimeExports.jsxs("div", { className: "ElementLinkDialog", children: [jsxRuntimeExports.jsxs("div", { className: "ElementLinkDialog__header", children: [jsxRuntimeExports.jsx("h2", { children: g("elementLink.title") }), jsxRuntimeExports.jsx("p", { children: g("elementLink.desc") })] }), jsxRuntimeExports.jsxs("div", { className: "ElementLinkDialog__input", children: [jsxRuntimeExports.jsx(zi, { value: a3 ?? "", onChange: (d3) => {
    s3 || c3(true), l3(d3);
  }, onKeyDown: (d3) => {
    d3.key === Q.ENTER && m3();
  }, className: "ElementLinkDialog__input-field", selectOnRender: true }), i3 && a3 && jsxRuntimeExports.jsx(X, { type: "button", title: g("buttons.remove"), "aria-label": g("buttons.remove"), label: g("buttons.remove"), onClick: () => {
    l3(null), c3(true);
  }, className: "ElementLinkDialog__remove", icon: Tx })] }), jsxRuntimeExports.jsxs("div", { className: "ElementLinkDialog__actions", children: [jsxRuntimeExports.jsx(or, { label: g("buttons.cancel"), onClick: () => {
    o3?.();
  }, style: { marginRight: 10 } }), jsxRuntimeExports.jsx(or, { label: g("buttons.confirm"), onClick: m3, actionType: "primary" })] })] });
}, L1 = Z_;
var J_ = ({ UIOptions: e12 }) => jsxRuntimeExports.jsxs(ft, { __fallback: true, children: [jsxRuntimeExports.jsx(ft.DefaultItems.LoadScene, {}), jsxRuntimeExports.jsx(ft.DefaultItems.SaveToActiveFile, {}), e12.canvasActions.export && jsxRuntimeExports.jsx(ft.DefaultItems.Export, {}), e12.canvasActions.saveAsImage && jsxRuntimeExports.jsx(ft.DefaultItems.SaveAsImage, {}), jsxRuntimeExports.jsx(ft.DefaultItems.SearchMenu, {}), jsxRuntimeExports.jsx(ft.DefaultItems.Help, {}), jsxRuntimeExports.jsx(ft.DefaultItems.ClearCanvas, {}), jsxRuntimeExports.jsx(ft.Separator, {}), jsxRuntimeExports.jsx(ft.Group, { title: "Excalidraw links", children: jsxRuntimeExports.jsx(ft.DefaultItems.Socials, {}) }), jsxRuntimeExports.jsx(ft.Separator, {}), jsxRuntimeExports.jsx(ft.DefaultItems.ToggleTheme, {}), jsxRuntimeExports.jsx(ft.DefaultItems.ChangeCanvasBackground, {})] }), q_ = () => jsxRuntimeExports.jsxs(pd, { __fallback: true, children: [jsxRuntimeExports.jsx(pd.Actions.SaveToDisk, {}), jsxRuntimeExports.jsx(pd.Actions.ExportToImage, {})] }), Q_ = ({ actionManager: e12, appState: o3, files: t3, setAppState: r3, elements: n3, canvas: i3, onLockToggle: a3, onHandToolToggle: l3, onPenModeToggle: s3, showExitZenModeBtn: c3, renderTopRightUI: m3, renderCustomStats: d3, UIOptions: p3, onExportImage: u3, renderWelcomeScreen: h3, children: f3, app: b3, isCollaborating: x3, generateLinkForSelection: T3 }) => {
  let E3 = me(), w3 = xw(), S3 = w3.tunnelsJotai.Provider, [I3, _3] = ce(Sr), k2 = () => p3.canvasActions.export ? jsxRuntimeExports.jsx(i0, { elements: n3, appState: o3, files: t3, actionManager: e12, exportOpts: p3.canvasActions.export, canvas: i3, setAppState: r3 }) : null, R3 = () => !p3.canvasActions.saveAsImage || o3.openDialog?.name !== "imageExport" ? null : jsxRuntimeExports.jsx(Gw, { elements: n3, appState: o3, files: t3, actionManager: e12, onExportImage: u3, onCloseRequest: () => r3({ openDialog: null }), name: b3.getName() }), M = () => jsxRuntimeExports.jsxs("div", { style: { position: "relative" }, children: [jsxRuntimeExports.jsx(w3.MainMenuTunnel.Out, {}), h3 && jsxRuntimeExports.jsx(w3.WelcomeScreenMenuHintTunnel.Out, {})] }), N3 = () => jsxRuntimeExports.jsx(Nr, { heading: "selectedShapeActions", className: dM("selected-shape-actions zen-mode-transition", { "transition-left": o3.zenModeEnabled }), children: jsxRuntimeExports.jsx(Qe2, { className: gE.SHAPE_ACTIONS_MENU, padding: 2, style: { maxHeight: `${o3.height - 166}px` }, children: jsxRuntimeExports.jsx(Gc, { appState: o3, elementsMap: b3.scene.getNonDeletedElementsMap(), renderAction: e12.renderAction, app: b3 }) }) }), G3 = () => {
    let O3 = O9(o3, n3), j = o3.stats.open && !o3.zenModeEnabled && !o3.viewModeEnabled && o3.openDialog?.name !== "elementLinkSelector";
    return jsxRuntimeExports.jsx(Jc, { side: "top", children: jsxRuntimeExports.jsxs("div", { className: "App-menu App-menu_top", children: [jsxRuntimeExports.jsxs(it.Col, { gap: 6, className: dM("App-menu_top__left"), children: [M(), O3 && N3()] }), !o3.viewModeEnabled && o3.openDialog?.name !== "elementLinkSelector" && jsxRuntimeExports.jsx(Nr, { heading: "shapes", className: "shapes-section", children: (oe2) => jsxRuntimeExports.jsxs("div", { style: { position: "relative" }, children: [h3 && jsxRuntimeExports.jsx(w3.WelcomeScreenToolbarHintTunnel.Out, {}), jsxRuntimeExports.jsx(it.Col, { gap: 4, align: "start", children: jsxRuntimeExports.jsxs(it.Row, { gap: 1, className: dM("App-toolbar-container", { "zen-mode": o3.zenModeEnabled }), children: [jsxRuntimeExports.jsxs(Qe2, { padding: 1, className: dM("App-toolbar", { "zen-mode": o3.zenModeEnabled }), children: [jsxRuntimeExports.jsx(ed, { appState: o3, isMobile: E3.editor.isMobile, device: E3, app: b3 }), oe2, jsxRuntimeExports.jsxs(it.Row, { gap: 1, children: [jsxRuntimeExports.jsx(od, { zenModeEnabled: o3.zenModeEnabled, checked: o3.penMode, onChange: () => s3(null), title: g("toolBar.penMode"), penDetected: o3.penDetected }), jsxRuntimeExports.jsx(td, { checked: o3.activeTool.locked, onChange: a3, title: g("toolBar.lock") }), jsxRuntimeExports.jsx("div", { className: "App-toolbar__divider" }), jsxRuntimeExports.jsx(rd, { checked: nd(o3), onChange: () => l3(), title: g("toolBar.hand"), isMobile: true }), jsxRuntimeExports.jsx(Yc, { appState: o3, activeTool: o3.activeTool, UIOptions: p3, app: b3 })] })] }), x3 && jsxRuntimeExports.jsx(Qe2, { style: { marginLeft: 8, alignSelf: "center", height: "fit-content" }, children: jsxRuntimeExports.jsx(X0, { title: g("toolBar.laser"), checked: o3.activeTool.type === fn.laser, onChange: () => b3.setActiveTool({ type: fn.laser }), isMobile: true }) })] }) })] }) }), jsxRuntimeExports.jsxs("div", { className: dM("layer-ui__wrapper__top-right zen-mode-transition", { "transition-right": o3.zenModeEnabled }), children: [o3.collaborators.size > 0 && jsxRuntimeExports.jsx(ad, { collaborators: o3.collaborators, userToFollow: o3.userToFollow?.socketId || null }), m3?.(E3.editor.isMobile, o3), !o3.viewModeEnabled && o3.openDialog?.name !== "elementLinkSelector" && (!V3 || o3.openSidebar?.name !== ks.name) && jsxRuntimeExports.jsx(w3.DefaultSidebarTriggerTunnel.Out, {}), j && jsxRuntimeExports.jsx(ol, { app: b3, onClose: () => {
      e12.executeAction(Di);
    }, renderCustomStats: d3 })] })] }) });
  }, H3 = () => jsxRuntimeExports.jsx(ud, { __fallback: true, onDock: (O3) => {
    le("sidebar", `toggleDock (${O3 ? "dock" : "undock"})`, `(${E3.editor.isMobile ? "mobile" : "desktop"})`);
  } }), V3 = Ws(Ja), F3 = jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [f3, jsxRuntimeExports.jsx(J_, { UIOptions: p3 }), jsxRuntimeExports.jsx(ud.Trigger, { __fallback: true, icon: Ux, title: rg$1(g("toolBar.library")), onToggle: (O3) => {
    O3 && le("sidebar", `${ks.name} (open)`, `button (${E3.editor.isMobile ? "mobile" : "desktop"})`);
  }, tab: ks.defaultTab, children: g("toolBar.library") }), jsxRuntimeExports.jsx(q_, {}), o3.openDialog?.name === "ttd" && jsxRuntimeExports.jsx(gg, { __fallback: true }), o3.isLoading && jsxRuntimeExports.jsx(Zs, { delay: 250 }), o3.errorMessage && jsxRuntimeExports.jsx(Fw, { onClose: () => r3({ errorMessage: null }), children: o3.errorMessage }), I3 && !E3.editor.isMobile && jsxRuntimeExports.jsx(wy, { colorPickerType: I3.colorPickerType, onCancel: () => {
    _3(null);
  }, onChange: (O3, j, oe2, { altKey: W }) => {
    if (!(O3 !== "elementBackground" && O3 !== "elementStroke")) if (oe2.length) {
      for (let ne3 of oe2) Y(ne3, { [W && I3.swapPreviewOnAlt ? O3 === "elementBackground" ? "strokeColor" : "backgroundColor" : O3 === "elementBackground" ? "backgroundColor" : "strokeColor"]: j }, false), he.delete(ne3);
      Ts.getScene(oe2[0])?.triggerUpdate();
    } else r3(O3 === "elementBackground" ? { currentItemBackgroundColor: j } : { currentItemStrokeColor: j });
  }, onSelect: (O3, j) => {
    _3((oe2) => oe2?.keepOpenOnAlt && j.altKey ? oe2 : null), I3?.onSelect?.(O3, j);
  } }), o3.openDialog?.name === "help" && jsxRuntimeExports.jsx(o0, { onClose: () => {
    r3({ openDialog: null });
  } }), jsxRuntimeExports.jsx(Tw, {}), o3.openDialog?.name === "elementLinkSelector" && jsxRuntimeExports.jsx(L1, { sourceElementId: o3.openDialog.sourceElementId, onClose: () => {
    r3({ openDialog: null });
  }, elementsMap: b3.scene.getNonDeletedElementsMap(), appState: o3, generateLinkForSelection: T3 }), jsxRuntimeExports.jsx(w3.OverwriteConfirmDialogTunnel.Out, {}), R3(), k2(), o3.pasteDialog.shown && jsxRuntimeExports.jsx(t0, { setAppState: r3, appState: o3, onClose: () => r3({ pasteDialog: { shown: false, data: null } }) }), E3.editor.isMobile && jsxRuntimeExports.jsx(Qw, { app: b3, appState: o3, elements: n3, actionManager: e12, renderJSONExportDialog: k2, renderImageExportDialog: R3, setAppState: r3, onLockToggle: a3, onHandToolToggle: l3, onPenModeToggle: s3, renderTopRightUI: m3, renderCustomStats: d3, renderSidebars: H3, device: E3, renderWelcomeScreen: h3, UIOptions: p3 }), !E3.editor.isMobile && jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [jsxRuntimeExports.jsxs("div", { className: "layer-ui__wrapper", style: o3.openSidebar && V3 && E3.editor.canFitSidebar ? { width: "calc(100% - var(--right-sidebar-width))" } : {}, children: [h3 && jsxRuntimeExports.jsx(w3.WelcomeScreenCenterTunnel.Out, {}), G3(), jsxRuntimeExports.jsx(s0, { appState: o3, actionManager: e12, showExitZenModeBtn: c3, renderWelcomeScreen: h3 }), o3.scrolledOutside && jsxRuntimeExports.jsx("button", { type: "button", className: "scroll-back-to-content", onClick: () => {
    r3((O3) => ({ ..._a$1(n3, O3) }));
  }, children: g("buttons.scrollBackToContent") })] }), H3()] })] });
  return jsxRuntimeExports.jsx(Ip.Provider, { value: o3, children: jsxRuntimeExports.jsx(S3, { children: jsxRuntimeExports.jsx(Iu.Provider, { value: w3, children: F3 }) }) });
}, A1 = (e12) => {
  let { suggestedBindings: o3, startBoundElement: t3, cursorButton: r3, scrollX: n3, scrollY: i3, ...a3 } = e12;
  return a3;
}, e52 = (e12, o3) => {
  if (e12.children !== o3.children) return false;
  let { canvas: t3, appState: r3, ...n3 } = e12, { canvas: i3, appState: a3, ...l3 } = o3;
  return Qt(A1(r3), A1(a3), { selectedElementIds: Qt, selectedGroupIds: Qt }) && Qt(n3, l3);
}, M1 = React.memo(Q_, e52);
var n5 = 5e3, P1 = ({ message: e12, onClose: o3, closable: t3 = false, duration: r3 = n5, style: n3 }) => {
  let i3 = reactExports.useRef(0), a3 = r3 !== 1 / 0, l3 = reactExports.useCallback(() => {
    a3 && (i3.current = window.setTimeout(() => o3(), r3));
  }, [o3, r3, a3]);
  return reactExports.useEffect(() => {
    if (a3) return l3(), () => clearTimeout(i3.current);
  }, [l3, e12, r3, a3]), jsxRuntimeExports.jsxs("div", { className: "Toast", onMouseEnter: a3 ? () => clearTimeout(i3?.current) : void 0, onMouseLeave: a3 ? l3 : void 0, style: n3, children: [jsxRuntimeExports.jsx("p", { className: "Toast__message", children: e12 }), t3 && jsxRuntimeExports.jsx(X, { icon: Ih, "aria-label": "close", type: "icon", onClick: o3, className: "close" })] });
};
var wg = L2({ name: "viewMode", label: "labels.viewMode", paletteName: "Toggle view mode", icon: F4, viewMode: true, trackEvent: { category: "canvas", predicate: (e12) => !e12.viewModeEnabled }, perform(e12, o3) {
  return { appState: { ...o3, viewModeEnabled: !this.checked(o3) }, captureUpdate: dr.EVENTUALLY };
}, checked: (e12) => e12.viewModeEnabled, predicate: (e12, o3, t3) => typeof t3.viewModeEnabled > "u", keyTest: (e12) => !e12[Q.CTRL_OR_CMD] && e12.altKey && e12.code === D1.R });
var R1 = (e12, o3) => {
  let t3 = o3.scene.getSelectedElements(e12);
  return t3.length === 1 && de(t3[0]);
}, N1 = L2({ name: "selectAllElementsInFrame", label: "labels.selectAllElementsInFrame", trackEvent: { category: "canvas" }, perform: (e12, o3, t3, r3) => {
  let n3 = r3.scene.getSelectedElements(o3).at(0) || null;
  if (de(n3)) {
    let i3 = co(Es(e12), n3.id).filter((a3) => !(a3.type === "text" && a3.containerId));
    return { elements: e12, appState: { ...o3, selectedElementIds: i3.reduce((a3, l3) => (a3[l3.id] = true, a3), {}) }, captureUpdate: dr.IMMEDIATELY };
  }
  return { elements: e12, appState: o3, captureUpdate: dr.EVENTUALLY };
}, predicate: (e12, o3, t3, r3) => R1(o3, r3) }), O1 = L2({ name: "removeAllElementsFromFrame", label: "labels.removeAllElementsFromFrame", trackEvent: { category: "history" }, perform: (e12, o3, t3, r3) => {
  let n3 = r3.scene.getSelectedElements(o3).at(0) || null;
  return de(n3) ? { elements: U9(e12, n3), appState: { ...o3, selectedElementIds: { [n3.id]: true } }, captureUpdate: dr.IMMEDIATELY } : { elements: e12, appState: o3, captureUpdate: dr.EVENTUALLY };
}, predicate: (e12, o3, t3, r3) => R1(o3, r3) });
L2({ name: "updateFrameRendering", label: "labels.updateFrameRendering", viewMode: true, trackEvent: { category: "canvas" }, perform: (e12, o3) => ({ elements: e12, appState: { ...o3, frameRendering: { ...o3.frameRendering, enabled: !o3.frameRendering.enabled } }, captureUpdate: dr.EVENTUALLY }), checked: (e12) => e12.frameRendering.enabled });
L2({ name: "setFrameAsActiveTool", label: "toolBar.frame", trackEvent: { category: "toolbar" }, icon: M4, viewMode: false, perform: (e12, o3, t3, r3) => {
  let n3 = $r(o3, { type: "frame" });
  return $2(r3.interactiveCanvas, { ...o3, activeTool: n3 }), { elements: e12, appState: { ...o3, activeTool: $r(o3, { type: "frame" }) }, captureUpdate: dr.EVENTUALLY };
}, keyTest: (e12) => !e12[Q.CTRL_OR_CMD] && !e12.shiftKey && !e12.altKey && e12.key.toLocaleLowerCase() === Q.F });
var F1 = L2({ name: "wrapSelectionInFrame", label: "labels.wrapSelectionInFrame", trackEvent: { category: "element" }, predicate: (e12, o3, t3, r3) => {
  let n3 = at$1(e12, o3);
  return n3.length > 0 && !n3.some((i3) => de(i3));
}, perform: (e12, o3, t3, r3) => {
  let n3 = at$1(e12, o3), [i3, a3, l3, s3] = $e$1(n3, r3.scene.getNonDeletedElementsMap()), c3 = 16, m3 = XB({ x: i3 - c3, y: a3 - c3, width: l3 - i3 + c3 * 2, height: s3 - a3 + c3 * 2 });
  if (o3.editingGroupId) {
    let p3 = an(n3, o3.editingGroupId);
    for (let u3 of p3) {
      let h3 = u3.groupIds.indexOf(o3.editingGroupId);
      Y(u3, { groupIds: u3.groupIds.slice(0, h3) }, false);
    }
  }
  return { elements: l9([...r3.scene.getElementsIncludingDeleted(), m3], n3, m3, o3), appState: { selectedElementIds: { [m3.id]: true } }, captureUpdate: dr.IMMEDIATELY };
} });
var a5 = () => jsxRuntimeExports.jsxs("div", { "data-testid": "brave-measure-text-error", children: [jsxRuntimeExports.jsx("p", { children: jsxRuntimeExports.jsx(Tt, { i18nKey: "errors.brave_measure_text_error.line1", bold: (e12) => jsxRuntimeExports.jsx("span", { style: { fontWeight: 600 }, children: e12 }) }) }), jsxRuntimeExports.jsx("p", { children: jsxRuntimeExports.jsx(Tt, { i18nKey: "errors.brave_measure_text_error.line2", bold: (e12) => jsxRuntimeExports.jsx("span", { style: { fontWeight: 600 }, children: e12 }) }) }), jsxRuntimeExports.jsx("p", { children: jsxRuntimeExports.jsx(Tt, { i18nKey: "errors.brave_measure_text_error.line3", link: (e12) => jsxRuntimeExports.jsx("a", { href: "http://docs.excalidraw.com/docs/@excalidraw/excalidraw/faq#turning-off-aggresive-block-fingerprinting-in-brave-browser", children: e12 }) }) }), jsxRuntimeExports.jsx("p", { children: jsxRuntimeExports.jsx(Tt, { i18nKey: "errors.brave_measure_text_error.line4", issueLink: (e12) => jsxRuntimeExports.jsx("a", { href: "https://github.com/excalidraw/excalidraw/issues/new", children: e12 }), discordLink: (e12) => jsxRuntimeExports.jsxs("a", { href: "https://discord.gg/UexuTaE", children: [e12, "."] }) }) })] }), z1 = a5;
var Ld = { width: 100, height: 0 }, zr = 100, l5 = (e12, o3, t3) => {
  let r3 = qt({ x: 0, y: 0, textAlign: Xi$1.CENTER, verticalAlign: kt.MIDDLE, ...o3, containerId: e12.id, strokeColor: o3.strokeColor || e12.strokeColor });
  return Object.assign(e12, { boundElements: (e12.boundElements || []).concat({ type: "text", id: r3.id }) }), Xa$1(r3, e12, t3), [e12, r3];
}, U1 = (e12, o3, t3, r3, n3) => {
  let i3, a3;
  if (Object.assign(e12, { startBinding: e12?.startBinding || null, endBinding: e12.endBinding || null }), o3) {
    let m3 = o3?.width ?? zr, d3 = o3?.height ?? zr, p3;
    o3.id && (p3 = r3.getElement(o3.id), p3 || console.error(`No element for start binding with id ${o3.id} found`));
    let u3 = o3.x || e12.x - m3, h3 = o3.y || e12.y - d3 / 2, f3 = p3 ? p3.type : o3.type;
    if (f3) {
      if (f3 === "text") {
        let b3 = "";
        p3 && p3.type === "text" ? b3 = p3.text : o3.type === "text" && (b3 = o3.text), b3 || console.error(`No text found for start binding text element for ${e12.id}`), i3 = qt({ x: u3, y: h3, type: "text", ...p3, ...o3, text: b3 }), Object.assign(i3, { x: o3.x || e12.x - i3.width, y: o3.y || e12.y - i3.height / 2 });
      } else switch (f3) {
        case "rectangle":
        case "ellipse":
        case "diamond": {
          i3 = Xr({ x: u3, y: h3, width: m3, height: d3, ...p3, ...o3, type: f3 });
          break;
        }
        default:
          Sn$1(e12, `Unhandled element start type "${o3.type}"`, true);
      }
      di(e12, i3, "start", n3);
    }
  }
  if (t3) {
    let m3 = t3?.height ?? zr, d3 = t3?.width ?? zr, p3;
    t3.id && (p3 = r3.getElement(t3.id), p3 || console.error(`No element for end binding with id ${t3.id} found`));
    let u3 = t3.x || e12.x + e12.width, h3 = t3.y || e12.y - m3 / 2, f3 = p3 ? p3.type : t3.type;
    if (f3) {
      if (f3 === "text") {
        let b3 = "";
        p3 && p3.type === "text" ? b3 = p3.text : t3.type === "text" && (b3 = t3.text), b3 || console.error(`No text found for end binding text element for ${e12.id}`), a3 = qt({ x: u3, y: h3, type: "text", ...p3, ...t3, text: b3 }), Object.assign(a3, { y: t3.y || e12.y - a3.height / 2 });
      } else switch (f3) {
        case "rectangle":
        case "ellipse":
        case "diamond": {
          a3 = Xr({ x: u3, y: h3, width: d3, height: m3, ...p3, ...t3, type: f3 });
          break;
        }
        default:
          Sn$1(e12, `Unhandled element end type "${f3}"`, true);
      }
      di(e12, a3, "end", n3);
    }
  }
  if (e12.points.length < 2) return { linearElement: e12, startBoundElement: i3, endBoundElement: a3 };
  let l3 = e12.points.length - 1, s3 = 0.5, c3 = Lg$1(e12.points);
  return e12.points[l3][0] > e12.points[l3 - 1][0] && (c3[0][0] = s3, c3[l3][0] -= s3), e12.points[l3][0] < e12.points[l3 - 1][0] && (c3[0][0] = -s3, c3[l3][0] += s3), e12.points[l3][1] > e12.points[l3 - 1][1] && (c3[0][1] = s3, c3[l3][1] -= s3), e12.points[l3][1] < e12.points[l3 - 1][1] && (c3[0][1] = -s3, c3[l3][1] += s3), Object.assign(e12, { points: c3 }), { linearElement: e12, startBoundElement: i3, endBoundElement: a3 };
}, Tg = class {
  constructor() {
    i$1(this, "excalidrawElements", /* @__PURE__ */ new Map());
    i$1(this, "add", (o3) => {
      o3 && this.excalidrawElements.set(o3.id, o3);
    });
    i$1(this, "getElements", () => An$1(Array.from(this.excalidrawElements.values())));
    i$1(this, "getElementsMap", () => tt(te(this.getElements())));
    i$1(this, "getElement", (o3) => this.excalidrawElements.get(o3));
  }
}, Yi = (e12, o3) => {
  if (!e12) return [];
  let t3 = Lg$1(e12), r3 = new Tg(), n3 = /* @__PURE__ */ new Map(), i3 = /* @__PURE__ */ new Map();
  for (let l3 of t3) {
    let s3, c3 = l3.id;
    switch (o3?.regenerateIds !== false && Object.assign(l3, { id: Dt() }), l3.type) {
      case "rectangle":
      case "ellipse":
      case "diamond": {
        let d3 = l3?.label?.text && l3.width === void 0 ? 0 : l3?.width || zr, p3 = l3?.label?.text && l3.height === void 0 ? 0 : l3?.height || zr;
        s3 = Xr({ ...l3, width: d3, height: p3 });
        break;
      }
      case "line": {
        let d3 = l3.width || Ld.width, p3 = l3.height || Ld.height;
        s3 = On({ width: d3, height: p3, points: [u$1(0, 0), u$1(d3, p3)], ...l3 });
        break;
      }
      case "arrow": {
        let d3 = l3.width || Ld.width, p3 = l3.height || Ld.height;
        s3 = Zb({ width: d3, height: p3, endArrowhead: "arrow", points: [u$1(0, 0), u$1(d3, p3)], ...l3, type: "arrow" }), Object.assign(s3, xn(s3.points));
        break;
      }
      case "text": {
        let d3 = l3?.fontFamily || Ft, p3 = l3?.fontSize || ut, u3 = l3?.lineHeight || ko(d3), h3 = l3.text ?? "", f3 = ia(h3), b3 = ht(f3, Ee({ fontFamily: d3, fontSize: p3 }), u3);
        s3 = qt({ width: b3.width, height: b3.height, fontFamily: d3, fontSize: p3, ...l3 });
        break;
      }
      case "image": {
        s3 = Wb({ width: l3?.width || zr, height: l3?.height || zr, ...l3 });
        break;
      }
      case "frame": {
        s3 = XB({ x: 0, y: 0, ...l3 });
        break;
      }
      case "magicframe": {
        s3 = GB({ x: 0, y: 0, ...l3 });
        break;
      }
      case "freedraw":
      case "iframe":
      case "embeddable": {
        s3 = l3;
        break;
      }
      default:
        s3 = l3, Sn$1(l3, `Unhandled element type "${l3.type}"`, true);
    }
    r3.getElement(s3.id) ? console.error(`Duplicate id found for ${s3.id}`) : (r3.add(s3), n3.set(s3.id, l3), c3 && i3.set(c3, s3.id));
  }
  let a3 = r3.getElementsMap();
  for (let [l3, s3] of n3) {
    let c3 = r3.getElement(l3);
    switch (s3.type) {
      case "rectangle":
      case "ellipse":
      case "diamond":
      case "arrow": {
        if (s3.label?.text) {
          let [m3, d3] = l5(c3, s3?.label, a3);
          if (r3.add(m3), r3.add(d3), ee(m3)) {
            let p3 = s3.type === "arrow" ? s3?.start : void 0, u3 = s3.type === "arrow" ? s3?.end : void 0;
            if (p3 && p3.id) {
              let x3 = i3.get(p3.id);
              x3 && Object.assign(p3, { id: x3 });
            }
            if (u3 && u3.id) {
              let x3 = i3.get(u3.id);
              x3 && Object.assign(u3, { id: x3 });
            }
            let { linearElement: h3, startBoundElement: f3, endBoundElement: b3 } = U1(m3, p3, u3, r3, a3);
            m3 = h3, r3.add(h3), r3.add(f3), r3.add(b3);
          }
        } else switch (s3.type) {
          case "arrow": {
            let { start: m3, end: d3 } = s3;
            if (m3 && m3.id) {
              let f3 = i3.get(m3.id);
              Object.assign(m3, { id: f3 });
            }
            if (d3 && d3.id) {
              let f3 = i3.get(d3.id);
              Object.assign(d3, { id: f3 });
            }
            let { linearElement: p3, startBoundElement: u3, endBoundElement: h3 } = U1(c3, m3, d3, r3, a3);
            r3.add(p3), r3.add(u3), r3.add(h3);
            break;
          }
        }
        break;
      }
    }
  }
  for (let [l3, s3] of n3) {
    if (s3.type !== "frame" && s3.type !== "magicframe") continue;
    let c3 = r3.getElement(l3);
    if (!c3) throw new Error(`Excalidraw element with id ${l3} doesn't exist`);
    let m3 = [];
    s3.children.forEach((w3) => {
      let S3 = i3.get(w3);
      if (!S3) throw new Error(`Element with ${w3} wasn't mapped correctly`);
      let I3 = r3.getElement(S3);
      if (!I3) throw new Error(`Frame element with id ${S3} doesn't exist`);
      Object.assign(I3, { frameId: c3.id }), I3?.boundElements?.forEach((_3) => {
        let k2 = r3.getElement(_3.id);
        if (!k2) throw new Error(`Bound element with id ${_3.id} doesn't exist`);
        Object.assign(k2, { frameId: c3.id }), m3.push(k2);
      }), m3.push(I3);
    });
    let [d3, p3, u3, h3] = $e$1(m3), f3 = 10;
    d3 = d3 - f3, p3 = p3 - f3, u3 = u3 + f3, h3 = h3 + f3;
    let b3 = c3?.x || d3, x3 = c3?.y || p3, T3 = c3?.width || u3 - d3, E3 = c3?.height || h3 - p3;
    Object.assign(c3, { x: b3, y: x3, width: T3, height: E3 }), hg() && s3.children.length && (c3?.x || c3?.y || c3?.width || c3?.height) && console.info("User provided frame attributes are being considered, if you find this inaccurate, please remove any of the attributes - x, y, width and height so frame coordinates and dimensions are calculated automatically");
  }
  return r3.getElements();
};
var Fe = (e12) => (o3) => {
  reactDomExports.unstable_batchedUpdates(e12, o3);
}, Ad = (e12) => pd$1((o3) => {
  reactDomExports.unstable_batchedUpdates(e12, o3);
}), ji = (() => {
  let e12;
  try {
    let t3 = reactExports.version.split(".");
    e12 = Number(t3[0]) > 17;
  } catch {
    e12 = false;
  }
  let o3 = false;
  return () => window.EXCALIDRAW_THROTTLE_RENDER === true ? e12 ? true : (o3 || (o3 = true, console.warn("Excalidraw: render throttling is disabled on React versions < 18.")), false) : false;
})();
var c5 = "#ff6b6b", d5 = "#ff0000", G1 = 1, Y1 = 2, V1 = (e12, o3) => {
  if (!o3.snapLines.length) return;
  let t3 = o3.theme === ke.LIGHT || o3.zenModeEnabled ? c5 : d5, r3 = (o3.zenModeEnabled ? G1 * 1.5 : G1) / o3.zoom.value;
  e12.save(), e12.translate(o3.scrollX, o3.scrollY);
  for (let n3 of o3.snapLines) n3.type === "pointer" ? (e12.lineWidth = r3, e12.strokeStyle = t3, p5(n3, e12, o3)) : n3.type === "gap" ? (e12.lineWidth = r3, e12.strokeStyle = t3, u5(n3.points[0], n3.points[1], n3.direction, o3, e12)) : n3.type === "points" && (e12.lineWidth = r3, e12.strokeStyle = t3, m5(n3, e12, o3));
  e12.restore();
}, m5 = (e12, o3, t3) => {
  if (!t3.zenModeEnabled) {
    let r3 = e12.points[0], n3 = e12.points[e12.points.length - 1];
    ao(r3, n3, o3);
  }
  for (let r3 of e12.points) W1(r3, t3, o3);
}, p5 = (e12, o3, t3) => {
  W1(e12.points[0], t3, o3), t3.zenModeEnabled || ao(e12.points[0], e12.points[1], o3);
}, W1 = ([e12, o3], t3, r3) => {
  r3.save();
  let n3 = (t3.zenModeEnabled ? Y1 * 1.5 : Y1) / t3.zoom.value;
  r3.beginPath(), r3.moveTo(e12 - n3, o3 - n3), r3.lineTo(e12 + n3, o3 + n3), r3.moveTo(e12 + n3, o3 - n3), r3.lineTo(e12 - n3, o3 + n3), r3.stroke(), r3.restore();
}, ao = (e12, o3, t3) => {
  t3.beginPath(), t3.lineTo(e12[0], e12[1]), t3.lineTo(o3[0], o3[1]), t3.stroke();
}, u5 = (e12, o3, t3, r3, n3) => {
  let i3 = 8 / r3.zoom.value, a3 = i3 / 2, l3 = i3 / 4;
  if (t3 === "horizontal") {
    let s3 = [(e12[0] + o3[0]) / 2, e12[1]];
    r3.zenModeEnabled || ao(u$1(e12[0], e12[1] - i3), u$1(e12[0], e12[1] + i3), n3), ao(u$1(s3[0] - l3, s3[1] - a3), u$1(s3[0] - l3, s3[1] + a3), n3), ao(u$1(s3[0] + l3, s3[1] - a3), u$1(s3[0] + l3, s3[1] + a3), n3), r3.zenModeEnabled || (ao(u$1(o3[0], o3[1] - i3), u$1(o3[0], o3[1] + i3), n3), ao(e12, o3, n3));
  } else {
    let s3 = [e12[0], (e12[1] + o3[1]) / 2];
    r3.zenModeEnabled || ao(u$1(e12[0] - i3, e12[1]), u$1(e12[0] + i3, e12[1]), n3), ao(u$1(s3[0] - a3, s3[1] - l3), u$1(s3[0] + a3, s3[1] - l3), n3), ao(u$1(s3[0] - a3, s3[1] + l3), u$1(s3[0] + a3, s3[1] + l3), n3), r3.zenModeEnabled || (ao(u$1(o3[0] - i3, o3[1]), u$1(o3[0] + i3, o3[1]), n3), ao(e12, o3, n3));
  }
};
var g5 = (e12, o3) => {
  Ae(o3.selectedLinearElement, "selectedLinearElement is null");
  let { segmentMidPointHoveredCoords: t3 } = o3.selectedLinearElement;
  Ae(t3, "midPointCoords is null"), e12.save(), e12.translate(o3.scrollX, o3.scrollY), X1(t3, e12, o3), e12.restore();
}, h5 = (e12, o3, t3) => {
  let { elementId: r3, hoverPointIndex: n3 } = o3.selectedLinearElement;
  if (o3.editingLinearElement?.selectedPointsIndices?.includes(n3)) return;
  let i3 = z$1.getElement(r3, t3);
  if (!i3) return;
  let a3 = z$1.getPointAtIndexGlobalCoordinates(i3, n3, t3);
  e12.save(), e12.translate(o3.scrollX, o3.scrollY), X1(a3, e12, o3), e12.restore();
}, X1 = (e12, o3, t3) => {
  o3.fillStyle = "rgba(105, 101, 219, 0.4)", KO(o3, e12[0], e12[1], z$1.POINT_HANDLE_SIZE / t3.zoom.value, false);
}, nl = (e12, o3, t3, r3, n3, i3, a3, l3, s3 = false, c3 = 0) => {
  e12.save(), e12.translate(i3, a3), e12.rotate(l3), s3 && e12.fillRect(o3 - i3, t3 - a3, r3, n3), c3 && e12.roundRect ? (e12.beginPath(), e12.roundRect(o3 - i3, t3 - a3, r3, n3, c3), e12.stroke(), e12.closePath()) : e12.strokeRect(o3 - i3, t3 - a3, r3, n3), e12.restore();
}, f5 = (e12, o3, t3, r3, n3, i3) => {
  e12.save(), e12.translate(r3, n3), e12.rotate(i3), e12.beginPath(), e12.moveTo(0, t3 / 2), e12.lineTo(o3 / 2, 0), e12.lineTo(0, -t3 / 2), e12.lineTo(-o3 / 2, 0), e12.closePath(), e12.stroke(), e12.restore();
}, Cg = (e12, o3, t3, r3, n3, i3 = false) => {
  e12.strokeStyle = "#5e5ad8", e12.setLineDash([]), e12.fillStyle = "rgba(255, 255, 255, 0.9)", n3 ? e12.fillStyle = "rgba(134, 131, 226, 0.9)" : i3 && (e12.fillStyle = "rgba(177, 151, 252, 0.7)"), KO(e12, t3[0], t3[1], r3 / o3.zoom.value, !i3);
}, b5 = (e12, o3, t3, r3, n3, i3) => {
  e12.beginPath(), e12.ellipse(r3, n3, o3 / 2, t3 / 2, i3, 0, Math.PI * 2), e12.stroke();
}, x5 = (e12, o3, t3, r3) => {
  let [n3, i3, a3, l3] = C$1(o3, t3), s3 = a3 - n3, c3 = l3 - i3;
  e12.strokeStyle = "rgba(0,0,0,.05)";
  let m3 = r3.value < 1 ? r3.value : 1;
  e12.lineWidth = t2 / m3;
  let d3 = e12.lineWidth / 2 + n2, p3 = it$1(Math.min(o3.width, o3.height), o3);
  switch (o3.type) {
    case "rectangle":
    case "text":
    case "image":
    case "iframe":
    case "embeddable":
    case "frame":
    case "magicframe":
      nl(e12, n3 - d3, i3 - d3, s3 + d3 * 2, c3 + d3 * 2, n3 + s3 / 2, i3 + c3 / 2, o3.angle, void 0, p3);
      break;
    case "diamond":
      let u3 = Math.hypot(s3, c3), h3 = d3 * u3 / c3, f3 = d3 * u3 / s3;
      f5(e12, s3 + h3 * 2, c3 + f3 * 2, n3 + s3 / 2, i3 + c3 / 2, o3.angle);
      break;
    case "ellipse":
      b5(e12, s3 + d3 * 2, c3 + d3 * 2, n3 + s3 / 2, i3 + c3 / 2, o3.angle);
      break;
  }
}, E5 = (e12, o3, t3, r3) => {
  let [n3, i3, a3] = o3, l3 = pi(a3, a3.width, a3.height, r3);
  e12.strokeStyle = "rgba(0,0,0,0)", e12.fillStyle = "rgba(0,0,0,.05)", (i3 === "both" ? [0, -1] : i3 === "start" ? [0] : [-1]).forEach((c3) => {
    let [m3, d3] = z$1.getPointAtIndexGlobalCoordinates(n3, c3, t3);
    KO(e12, m3, d3, l3);
  });
}, $1 = (e12, o3, t3) => {
  let { angle: r3, x1: n3, y1: i3, x2: a3, y2: l3, selectionColors: s3, cx: c3, cy: m3, dashed: d3, activeEmbeddable: p3 } = t3, u3 = a3 - n3, h3 = l3 - i3, b3 = (t3.padding ?? br * 2) / o3.zoom.value, x3 = 8 / o3.zoom.value, T3 = 4 / o3.zoom.value;
  e12.save(), e12.translate(o3.scrollX, o3.scrollY), e12.lineWidth = (p3 ? 4 : 1) / o3.zoom.value;
  let E3 = s3.length;
  for (let w3 = 0; w3 < E3; ++w3) e12.strokeStyle = s3[w3], d3 && e12.setLineDash([x3, T3 + (x3 + T3) * (E3 - 1)]), e12.lineDashOffset = (x3 + T3) * w3, nl(e12, n3 - b3, i3 - b3, u3 + b3 * 2, h3 + b3 * 2, c3, m3, r3);
  e12.restore();
}, y5 = (e12, o3, t3, r3) => {
  let n3 = Array.isArray(t3) ? E5 : x5;
  e12.save(), e12.translate(o3.scrollX, o3.scrollY), n3(e12, t3, r3, o3.zoom), e12.restore();
}, v5 = (e12, o3, t3, r3) => {
  let [n3, i3, a3, l3] = C$1(t3, r3), s3 = a3 - n3, c3 = l3 - i3;
  e12.strokeStyle = "rgb(0,118,255)", e12.lineWidth = Pe$1.strokeWidth / o3.zoom.value, e12.save(), e12.translate(o3.scrollX, o3.scrollY), nl(e12, n3, i3, s3, c3, n3 + s3 / 2, i3 + c3 / 2, t3.angle, false, Pe$1.radius / o3.zoom.value), e12.restore();
}, w5 = (e12, o3, t3) => {
  let r3 = t3.filter((l3) => l3.groupIds.length === 0), n3 = t3.filter((l3) => l3.groupIds.length > 0), i3 = (l3) => {
    let [s3, c3, m3, d3] = $e$1(l3);
    return { angle: 0, x1: s3, x2: m3, y1: c3, y2: d3, selectionColors: ["rgb(0,118,255)"], dashed: false, cx: s3 + (m3 - s3) / 2, cy: c3 + (d3 - c3) / 2, activeEmbeddable: false };
  }, a3 = (l3) => {
    let s3 = an(t3, l3);
    return i3(s3);
  };
  Object.entries(p2(n3, o3)).filter(([l3, s3]) => s3).map(([l3, s3]) => l3).map((l3) => a3(l3)).concat(r3.map((l3) => i3([l3]))).forEach((l3) => $1(e12, o3, l3));
}, Ig = (e12, o3, t3, r3) => {
  if (!o3.selectedLinearElement) return;
  e12.save(), e12.translate(o3.scrollX, o3.scrollY), e12.lineWidth = 1 / o3.zoom.value;
  let n3 = z$1.getPointsGlobalCoordinates(t3, r3), { POINT_HANDLE_SIZE: i3 } = z$1, a3 = o3.editingLinearElement ? i3 : i3 / 2;
  if (n3.forEach((l3, s3) => {
    if (X$1(t3) && s3 !== 0 && s3 !== n3.length - 1) return;
    let c3 = !!o3.editingLinearElement?.selectedPointsIndices?.includes(s3);
    Cg(e12, o3, l3, a3, c3);
  }), X$1(t3)) {
    let l3 = t3.fixedSegments?.map((s3) => s3.index) || [];
    n3.slice(0, -1).forEach((s3, c3) => {
      z$1.isSegmentTooShort(t3, n3[c3 + 1], n3[c3], c3, o3.zoom) || Cg(e12, o3, u$1((s3[0] + n3[c3 + 1][0]) / 2, (s3[1] + n3[c3 + 1][1]) / 2), i3 / 2, false, !l3.includes(c3 + 1));
    });
  } else z$1.getEditorMidPoints(t3, r3, o3).filter((s3, c3, m3) => s3 !== null && !(X$1(t3) && (c3 === 0 || c3 === m3.length - 1))).forEach((s3) => {
    (o3.editingLinearElement || n3.length === 2) && Cg(e12, o3, s3, i3 / 2, false, true);
  });
  e12.restore();
}, K1 = (e12, o3, t3, r3, n3) => {
  Object.keys(r3).forEach((i3) => {
    let a3 = r3[i3];
    if (a3 !== void 0) {
      let [l3, s3, c3, m3] = a3;
      e12.save(), e12.lineWidth = 1 / t3.zoom.value, o3.selectionColor && (e12.strokeStyle = o3.selectionColor), i3 === "rotation" ? KO(e12, l3 + c3 / 2, s3 + m3 / 2, c3 / 2) : e12.roundRect ? (e12.beginPath(), e12.roundRect(l3, s3, c3, m3, 2 / t3.zoom.value), e12.fill(), e12.stroke()) : nl(e12, l3, s3, c3, m3, l3 + c3 / 2, s3 + m3 / 2, n3, true), e12.restore();
    }
  });
}, T5 = (e12, o3, t3, r3, n3) => {
  let [i3, a3, , , l3, s3] = C$1(r3, n3), c3 = 3, m3 = 20, d3 = c3 / t3.zoom.value, p3 = d3 / 2, u3 = l3 - i3 + d3, h3 = s3 - a3 + d3, f3 = Math.min(m3 / t3.zoom.value, u3), b3 = Math.min(m3 / t3.zoom.value, h3);
  e12.save(), e12.fillStyle = o3.selectionColor, e12.strokeStyle = o3.selectionColor, e12.lineWidth = d3, [[[-u3, -h3], [0, p3], [f3, p3], [p3, 0], [p3, b3]], [[u3 - p3, -h3], [p3, p3], [-f3 + p3, p3], [0, 0], [0, b3]], [[-u3, h3], [0, -p3], [f3, -p3], [p3, 0], [p3, -b3]], [[u3 - p3, h3], [p3, -p3], [-f3 + p3, -p3], [0, 0], [0, -b3]]].forEach((T3) => {
    let [[E3, w3], [S3, I3], [_3, k2], [R3, M], [N3, G3]] = T3;
    e12.save(), e12.translate(l3, s3), e12.rotate(r3.angle), e12.beginPath(), e12.moveTo(E3 + S3, w3 + I3), e12.lineTo(E3 + _3, w3 + k2), e12.stroke(), e12.beginPath(), e12.moveTo(E3 + R3, w3 + M), e12.lineTo(E3 + N3, w3 + G3), e12.stroke(), e12.restore();
  }), e12.restore();
}, C5 = (e12, o3, t3, r3) => {
  o3.save();
  let n3 = br * 2 / t3.zoom.value, i3 = e12.width + n3 * 2, a3 = e12.height + n3 * 2, l3 = e12.x + i3 / 2, s3 = e12.y + a3 / 2, c3 = -(i3 / 2 + n3), m3 = -(a3 / 2 + n3);
  o3.translate(l3 + t3.scrollX, s3 + t3.scrollY), o3.rotate(e12.angle), o3.lineWidth = 1 / t3.zoom.value, o3.strokeStyle = r3, o3.strokeRect(c3, m3, i3, a3), o3.restore();
}, Z1 = ({ canvas: e12, elementsMap: o3, visibleElements: t3, selectedElements: r3, allElementsMap: n3, scale: i3, appState: a3, renderConfig: l3, device: s3 }) => {
  if (e12 === null) return { atLeastOneVisibleElement: false, elementsMap: o3 };
  let [c3, m3] = np(e12, i3), d3 = rp({ canvas: e12, scale: i3, normalizedWidth: c3, normalizedHeight: m3 });
  d3.save(), d3.scale(a3.zoom.value, a3.zoom.value);
  let p3;
  if (t3.forEach((f3) => {
    a3.editingLinearElement?.elementId === f3.id && f3 && (p3 = f3);
  }), p3 && Ig(d3, a3, p3, o3), a3.selectionElement && !a3.isCropping) try {
    vP(a3.selectionElement, d3, a3, l3.selectionColor);
  } catch (f3) {
    console.error(f3);
  }
  if (a3.editingTextElement && k$2(a3.editingTextElement)) {
    let f3 = n3.get(a3.editingTextElement.id);
    f3 && !f3.autoResize && C5(f3, d3, a3, l3.selectionColor);
  }
  a3.isBindingEnabled && a3.suggestedBindings.filter((f3) => f3 != null).forEach((f3) => {
    y5(d3, a3, f3, o3);
  }), a3.frameToHighlight && v5(d3, a3, a3.frameToHighlight, o3), a3.elementsToHighlight && w5(d3, a3, a3.elementsToHighlight);
  let u3 = r3.some((f3) => de(f3));
  if (r3.length === 1 && a3.editingLinearElement?.elementId === r3[0].id && Ig(d3, a3, r3[0], o3), X$1(r3[0]) && a3.selectedLinearElement && a3.selectedLinearElement.segmentMidPointHoveredCoords ? g5(d3, a3) : a3.selectedLinearElement && a3.selectedLinearElement.hoverPointIndex >= 0 && !(X$1(r3[0]) && a3.selectedLinearElement.hoverPointIndex > 0 && a3.selectedLinearElement.hoverPointIndex < r3[0].points.length - 1) && h5(d3, a3, o3), !a3.multiElement && !a3.editingLinearElement) {
    let f3 = fJ(r3, a3), b3 = r3.length === 1 && ae(r3[0]);
    b3 && a3.selectedLinearElement?.elementId === r3[0].id && !r3[0].locked && Ig(d3, a3, r3[0], o3);
    let x3 = l3.selectionColor || _d$1.black;
    if (f3) {
      let T3 = te(r3), E3 = [];
      for (let S3 of o3.values()) {
        let I3 = [], _3 = l3.remoteSelectedElementIds.get(S3.id);
        if (b3 && X$1(S3) && (S3.startBinding || S3.endBinding) || (T3.has(S3.id) && !sF(a3, S3) && I3.push(x3), _3 && I3.push(..._3.map((k2) => Tn(k2, a3.collaborators.get(k2))))), I3.length) {
          let [k2, R3, M, N3, G3, H3] = C$1(S3, o3, true);
          E3.push({ angle: S3.angle, x1: k2, y1: R3, x2: M, y2: N3, selectionColors: I3, dashed: !!_3, cx: G3, cy: H3, activeEmbeddable: a3.activeEmbeddable?.element === S3 && a3.activeEmbeddable.state === "active", padding: S3.id === a3.croppingElementId || Ye$1(S3) ? 0 : void 0 });
        }
      }
      let w3 = (S3) => {
        let I3 = an(o3, S3), [_3, k2, R3, M] = $e$1(I3);
        E3.push({ angle: 0, x1: _3, x2: R3, y1: k2, y2: M, selectionColors: [_d$1.black], dashed: true, cx: _3 + (R3 - _3) / 2, cy: k2 + (M - k2) / 2, activeEmbeddable: false });
      };
      for (let S3 of dF(a3)) w3(S3);
      a3.editingGroupId && w3(a3.editingGroupId), E3.forEach((S3) => $1(d3, a3, S3));
    }
    if (d3.save(), d3.translate(a3.scrollX, a3.scrollY), r3.length === 1) {
      d3.fillStyle = _d$1.white;
      let T3 = Ds(r3[0], a3.zoom, o3, "mouse", Ls(s3));
      if (!a3.viewModeEnabled && f3 && !k$2(a3.editingTextElement) && !a3.croppingElementId && K1(d3, l3, a3, T3, r3[0].angle), a3.croppingElementId && !a3.isCropping) {
        let E3 = o3.get(a3.croppingElementId);
        E3 && Ye$1(E3) && T5(d3, l3, a3, E3, o3);
      }
    } else if (r3.length > 1 && !a3.isRotating) {
      let T3 = br * 2 / a3.zoom.value;
      d3.fillStyle = _d$1.white;
      let [E3, w3, S3, I3] = $e$1(r3), _3 = d3.getLineDash();
      d3.setLineDash([2 / a3.zoom.value]);
      let k2 = d3.lineWidth;
      d3.lineWidth = 1 / a3.zoom.value, d3.strokeStyle = x3, nl(d3, E3 - T3, w3 - T3, S3 - E3 + T3 * 2, I3 - w3 + T3 * 2, (E3 + S3) / 2, (w3 + I3) / 2, 0), d3.lineWidth = k2, d3.setLineDash(_3);
      let R3 = Ki$1([E3, w3, S3, I3, (E3 + S3) / 2, (w3 + I3) / 2], 0, a3.zoom, "mouse", u3 ? { ...Ls(s3), rotation: true } : Ls(s3));
      r3.some((M) => !M.locked) && K1(d3, l3, a3, R3, 0);
    }
    d3.restore();
  }
  a3.searchMatches.forEach(({ id: f3, focus: b3, matchedLines: x3 }) => {
    let T3 = o3.get(f3);
    if (T3 && k$2(T3)) {
      let [E3, w3, , , S3, I3] = C$1(T3, o3, true);
      d3.save(), a3.theme === ke.LIGHT ? b3 ? d3.fillStyle = "rgba(255, 124, 0, 0.4)" : d3.fillStyle = "rgba(255, 226, 0, 0.4)" : b3 ? d3.fillStyle = "rgba(229, 82, 0, 0.4)" : d3.fillStyle = "rgba(99, 52, 0, 0.4)", d3.translate(a3.scrollX, a3.scrollY), d3.translate(S3, I3), d3.rotate(T3.angle), x3.forEach((_3) => {
        d3.fillRect(E3 + _3.offsetX - S3, w3 + _3.offsetY - I3, _3.width, _3.height);
      }), d3.restore();
    }
  }), V1(d3, a3), d3.restore(), sv({ context: d3, renderConfig: l3, appState: a3, normalizedWidth: c3, normalizedHeight: m3 });
  let h3;
  return l3.renderScrollbars && (h3 = Jw(t3, c3, m3, a3), d3.save(), d3.fillStyle = jw, d3.strokeStyle = "rgba(255,255,255,0.8)", [h3.horizontal, h3.vertical].forEach((f3) => {
    f3 && xc(d3, f3.x, f3.y, f3.width, f3.height, Oo / 2);
  }), d3.restore()), { scrollBars: h3, atLeastOneVisibleElement: t3.length > 0, elementsMap: o3 };
}, Sg = pd$1((e12) => {
  let o3 = Z1(e12);
  e12.callback?.(o3);
}, { trailing: true }), j1 = (e12, o3) => {
  if (o3) {
    Sg(e12);
    return;
  }
  let t3 = Z1(e12);
  return e12.callback(t3), t3;
};
var L5 = (e12) => {
  let o3 = reactExports.useRef(false);
  return reactExports.useEffect(() => {
    if (!o3.current) {
      o3.current = true;
      return;
    }
    let t3 = /* @__PURE__ */ new Map(), r3 = /* @__PURE__ */ new Map(), n3 = /* @__PURE__ */ new Map(), i3 = /* @__PURE__ */ new Map(), a3 = /* @__PURE__ */ new Map();
    e12.appState.collaborators.forEach((s3, c3) => {
      if (s3.selectedElementIds) for (let m3 of Object.keys(s3.selectedElementIds)) n3.has(m3) || n3.set(m3, []), n3.get(m3).push(c3);
      !s3.pointer || s3.pointer.renderCursor === false || (s3.username && i3.set(c3, s3.username), s3.userState && a3.set(c3, s3.userState), r3.set(c3, ta({ sceneX: s3.pointer.x, sceneY: s3.pointer.y }, e12.appState)), t3.set(c3, s3.button));
    });
    let l3 = e12.containerRef?.current && getComputedStyle(e12.containerRef.current).getPropertyValue("--color-selection") || "#6965db";
    j1({ canvas: e12.canvas, elementsMap: e12.elementsMap, visibleElements: e12.visibleElements, selectedElements: e12.selectedElements, allElementsMap: e12.allElementsMap, scale: window.devicePixelRatio, appState: e12.appState, renderConfig: { remotePointerViewportCoords: r3, remotePointerButton: t3, remoteSelectedElementIds: n3, remotePointerUsernames: i3, remotePointerUserStates: a3, selectionColor: l3, renderScrollbars: false }, device: e12.device, callback: e12.renderInteractiveSceneCallback }, ji());
  }), jsxRuntimeExports.jsx("canvas", { className: "excalidraw__canvas interactive", style: { width: e12.appState.width, height: e12.appState.height, cursor: e12.appState.viewModeEnabled ? mo.GRAB : mo.AUTO }, width: e12.appState.width * e12.scale, height: e12.appState.height * e12.scale, ref: e12.handleCanvasRef, onContextMenu: e12.onContextMenu, onPointerMove: e12.onPointerMove, onPointerUp: e12.onPointerUp, onPointerCancel: e12.onPointerCancel, onTouchMove: e12.onTouchMove, onPointerDown: e12.onPointerDown, onDoubleClick: e12.appState.viewModeEnabled ? void 0 : e12.onDoubleClick, children: g("labels.drawingCanvas") });
}, J1 = (e12) => ({ zoom: e12.zoom, scrollX: e12.scrollX, scrollY: e12.scrollY, width: e12.width, height: e12.height, viewModeEnabled: e12.viewModeEnabled, openDialog: e12.openDialog, editingGroupId: e12.editingGroupId, editingLinearElement: e12.editingLinearElement, selectedElementIds: e12.selectedElementIds, frameToHighlight: e12.frameToHighlight, offsetLeft: e12.offsetLeft, offsetTop: e12.offsetTop, theme: e12.theme, pendingImageElementId: e12.pendingImageElementId, selectionElement: e12.selectionElement, selectedGroupIds: e12.selectedGroupIds, selectedLinearElement: e12.selectedLinearElement, multiElement: e12.multiElement, isBindingEnabled: e12.isBindingEnabled, suggestedBindings: e12.suggestedBindings, isRotating: e12.isRotating, elementsToHighlight: e12.elementsToHighlight, collaborators: e12.collaborators, activeEmbeddable: e12.activeEmbeddable, snapLines: e12.snapLines, zenModeEnabled: e12.zenModeEnabled, editingTextElement: e12.editingTextElement, isCropping: e12.isCropping, croppingElementId: e12.croppingElementId, searchMatches: e12.searchMatches }), A5 = (e12, o3) => e12.selectionNonce !== o3.selectionNonce || e12.sceneNonce !== o3.sceneNonce || e12.scale !== o3.scale || e12.elementsMap !== o3.elementsMap || e12.visibleElements !== o3.visibleElements || e12.selectedElements !== o3.selectedElements ? false : Qt(J1(e12.appState), J1(o3.appState)), kg = React.memo(L5, A5);
var P5 = (e12) => {
  let o3 = reactExports.useRef(null), t3 = reactExports.useRef(false);
  return reactExports.useEffect(() => {
    let r3 = o3.current;
    if (!r3) return;
    let n3 = e12.canvas;
    t3.current || (t3.current = true, r3.replaceChildren(n3), n3.classList.add("excalidraw__canvas", "static"));
    let i3 = `${e12.appState.width}px`, a3 = `${e12.appState.height}px`;
    n3.style.width !== i3 && (n3.style.width = i3), n3.style.height !== a3 && (n3.style.height = a3);
    let l3 = e12.appState.width * e12.scale, s3 = e12.appState.height * e12.scale;
    n3.width !== l3 && (n3.width = l3), n3.height !== s3 && (n3.height = s3), cp({ canvas: n3, rc: e12.rc, scale: e12.scale, elementsMap: e12.elementsMap, allElementsMap: e12.allElementsMap, visibleElements: e12.visibleElements, appState: e12.appState, renderConfig: e12.renderConfig }, ji());
  }), jsxRuntimeExports.jsx("div", { className: "excalidraw__canvas-wrapper", ref: o3 });
}, Q1 = (e12) => ({ zoom: e12.zoom, scrollX: e12.scrollX, scrollY: e12.scrollY, width: e12.width, height: e12.height, viewModeEnabled: e12.viewModeEnabled, openDialog: e12.openDialog, hoveredElementIds: e12.hoveredElementIds, offsetLeft: e12.offsetLeft, offsetTop: e12.offsetTop, theme: e12.theme, pendingImageElementId: e12.pendingImageElementId, shouldCacheIgnoreZoom: e12.shouldCacheIgnoreZoom, viewBackgroundColor: e12.viewBackgroundColor, exportScale: e12.exportScale, selectedElementsAreBeingDragged: e12.selectedElementsAreBeingDragged, gridSize: e12.gridSize, gridStep: e12.gridStep, frameRendering: e12.frameRendering, selectedElementIds: e12.selectedElementIds, frameToHighlight: e12.frameToHighlight, editingGroupId: e12.editingGroupId, currentHoveredFontFamily: e12.currentHoveredFontFamily, croppingElementId: e12.croppingElementId }), R5 = (e12, o3) => e12.sceneNonce !== o3.sceneNonce || e12.scale !== o3.scale || e12.elementsMap !== o3.elementsMap || e12.visibleElements !== o3.visibleElements ? false : Qt(Q1(e12.appState), Q1(o3.appState)) && Qt(e12.renderConfig, o3.renderConfig), Lg = React.memo(P5, R5);
var il = class {
  constructor(o3) {
    i$1(this, "scene");
    i$1(this, "getRenderableElements", (() => {
      let o5 = ({ elementsMap: r3, zoom: n3, offsetLeft: i3, offsetTop: a3, scrollX: l3, scrollY: s3, height: c3, width: m3 }) => {
        let d3 = [];
        for (let p3 of r3.values()) kp(p3, m3, c3, { zoom: n3, offsetLeft: i3, offsetTop: a3, scrollX: l3, scrollY: s3 }, r3) && d3.push(p3);
        return d3;
      }, t3 = ({ elements: r3, editingTextElement: n3, newElementId: i3, pendingImageElementId: a3 }) => {
        let l3 = tt(/* @__PURE__ */ new Map());
        for (let s3 of r3) Ye$1(s3) && a3 === s3.id || i3 !== s3.id && (!n3 || n3.type !== "text" || s3.id !== n3.id) && l3.set(s3.id, s3);
        return l3;
      };
      return Mg$1(({ zoom: r3, offsetLeft: n3, offsetTop: i3, scrollX: a3, scrollY: l3, height: s3, width: c3, editingTextElement: m3, newElementId: d3, pendingImageElementId: p3, sceneNonce: u3 }) => {
        let h3 = this.scene.getNonDeletedElements(), f3 = t3({ elements: h3, editingTextElement: m3, newElementId: d3, pendingImageElementId: p3 }), b3 = o5({ elementsMap: f3, zoom: r3, offsetLeft: n3, offsetTop: i3, scrollX: a3, scrollY: l3, height: s3, width: c3 });
        return { elementsMap: f3, visibleElements: b3 };
      });
    })());
    this.scene = o3;
  }
  destroy() {
    Sg.cancel(), x7.cancel(), this.getRenderableElements.clear();
  }
};
var tT = ({ trails: e12 }) => {
  let o3 = reactExports.useRef(null);
  return reactExports.useEffect(() => {
    if (o3.current) for (let t3 of e12) t3.start(o3.current);
    return () => {
      for (let t3 of e12) t3.stop();
    };
  }, e12), jsxRuntimeExports.jsx("div", { className: "SVGLayer", children: jsxRuntimeExports.jsx("svg", { ref: o3 }) });
};
var B5 = 5, z5 = (e12, o3, t3) => {
  let [r3, n3] = C$1(e12, t3), { x: i3, y: a3 } = ta({ sceneX: r3 + e12.width, sceneY: n3 }, o3), l3 = i3 - o3.offsetLeft + 10, s3 = a3 - o3.offsetTop;
  return { x: l3, y: s3 };
}, Ag = ({ children: e12, element: o3, elementsMap: t3 }) => {
  let r3 = Mo();
  if (r3.contextMenu || r3.newElement || r3.resizingElement || r3.isRotating || r3.openMenu || r3.viewModeEnabled) return null;
  let { x: n3, y: i3 } = z5(o3, r3, t3);
  return jsxRuntimeExports.jsx("div", { className: "excalidraw-canvas-buttons", style: { top: `${i3}px`, left: `${n3}px`, padding: B5 }, children: e12 });
};
var G5 = "small", Md = (e12) => jsxRuntimeExports.jsxs("label", { className: dM("ToolIcon ToolIcon__MagicButton", `ToolIcon_size_${G5}`, { "is-mobile": e12.isMobile }), title: `${e12.title}`, children: [jsxRuntimeExports.jsx("input", { className: "ToolIcon_type_checkbox", type: "checkbox", name: e12.name, onChange: e12.onChange, checked: e12.checked, "aria-label": e12.title }), jsxRuntimeExports.jsx("div", { className: "ToolIcon__icon", children: e12.icon })] });
var V5 = ({ height: e12, width: o3, userToFollow: t3, onDisconnect: r3 }) => jsxRuntimeExports.jsx("div", { className: "follow-mode", style: { width: o3, height: e12 }, children: jsxRuntimeExports.jsxs("div", { className: "follow-mode__badge", children: [jsxRuntimeExports.jsxs("div", { className: "follow-mode__badge__label", children: ["Following", " ", jsxRuntimeExports.jsx("span", { className: "follow-mode__badge__username", title: t3.username, children: t3.username })] }), jsxRuntimeExports.jsx("button", { type: "button", onClick: r3, className: "follow-mode__disconnect-btn", children: Ih })] }) }), nT = V5;
var Dd = class {
  constructor() {
    i$1(this, "targets", /* @__PURE__ */ new WeakMap());
    i$1(this, "rafIds", /* @__PURE__ */ new WeakMap());
  }
  register(o3, t3) {
    this.targets.set(o3, { callback: t3, stopped: true });
  }
  start(o3) {
    let t3 = this.targets.get(o3);
    t3 && (this.rafIds.has(o3) || (this.targets.set(o3, { ...t3, stopped: false }), this.scheduleFrame(o3)));
  }
  stop(o3) {
    let t3 = this.targets.get(o3);
    t3 && !t3.stopped && this.targets.set(o3, { ...t3, stopped: true }), this.cancelFrame(o3);
  }
  constructFrame(o3) {
    return (t3) => {
      let r3 = this.targets.get(o3);
      if (!r3) return;
      let n3 = this.onFrame(r3, t3);
      !r3.stopped && !n3 ? this.scheduleFrame(o3) : this.cancelFrame(o3);
    };
  }
  scheduleFrame(o3) {
    let t3 = requestAnimationFrame(this.constructFrame(o3));
    this.rafIds.set(o3, t3);
  }
  cancelFrame(o3) {
    if (this.rafIds.has(o3)) {
      let t3 = this.rafIds.get(o3);
      cancelAnimationFrame(t3);
    }
    this.rafIds.delete(o3);
  }
  onFrame(o3, t3) {
    return o3.callback(t3) ?? false;
  }
};
var An = class {
  constructor(o3, t3, r3) {
    this.animationFrameHandler = o3;
    this.app = t3;
    this.options = r3;
    i$1(this, "currentTrail");
    i$1(this, "pastTrails", []);
    i$1(this, "container");
    i$1(this, "trailElement");
    this.animationFrameHandler.register(this, this.onFrame.bind(this)), this.trailElement = document.createElementNS(re, "path");
  }
  get hasCurrentTrail() {
    return !!this.currentTrail;
  }
  hasLastPoint(o3, t3) {
    if (this.currentTrail) {
      let r3 = this.currentTrail.originalPoints.length;
      return this.currentTrail.originalPoints[r3 - 1][0] === o3 && this.currentTrail.originalPoints[r3 - 1][1] === t3;
    }
    return false;
  }
  start(o3) {
    o3 && (this.container = o3), this.trailElement.parentNode !== this.container && this.container && this.container.appendChild(this.trailElement), this.animationFrameHandler.start(this);
  }
  stop() {
    this.animationFrameHandler.stop(this), this.trailElement.parentNode === this.container && this.container?.removeChild(this.trailElement);
  }
  startPath(o3, t3) {
    this.currentTrail = new $94cfa2cfccc8cc22$export$6531021b3bf36eae(this.options), this.currentTrail.addPoint([o3, t3, performance.now()]), this.update();
  }
  addPointToPath(o3, t3) {
    this.currentTrail && (this.currentTrail.addPoint([o3, t3, performance.now()]), this.update());
  }
  endPath() {
    this.currentTrail && (this.currentTrail.close(), this.currentTrail.options.keepHead = false, this.pastTrails.push(this.currentTrail), this.currentTrail = void 0, this.update());
  }
  update() {
    this.start();
  }
  onFrame() {
    let o3 = [];
    for (let r3 of this.pastTrails) o3.push(this.drawTrail(r3, this.app.state));
    if (this.currentTrail) {
      let r3 = this.drawTrail(this.currentTrail, this.app.state);
      o3.push(r3);
    }
    this.pastTrails = this.pastTrails.filter((r3) => r3.getStrokeOutline().length !== 0), o3.length === 0 && this.stop();
    let t3 = o3.join(" ").trim();
    this.trailElement.setAttribute("d", t3), this.trailElement.setAttribute("fill", (this.options.fill ?? (() => "black"))(this));
  }
  drawTrail(o3, t3) {
    let r3 = o3.getStrokeOutline(o3.options.size / t3.zoom.value).map(([n3, i3]) => {
      let a3 = ta({ sceneX: n3, sceneY: i3 }, t3);
      return [a3.x, a3.y];
    });
    return vg(r3, true);
  }
};
var Pd = class {
  constructor(o3, t3) {
    this.animationFrameHandler = o3;
    this.app = t3;
    i$1(this, "localTrail");
    i$1(this, "collabTrails", /* @__PURE__ */ new Map());
    i$1(this, "container");
    this.animationFrameHandler.register(this, this.onFrame.bind(this)), this.localTrail = new An(o3, t3, { ...this.getTrailOptions(), fill: () => uE });
  }
  getTrailOptions() {
    return { simplify: 0, streamline: 0.4, sizeMapping: (o3) => {
      let n3 = Math.max(0, 1 - (performance.now() - o3.pressure) / 1e3), i3 = (50 - Math.min(50, o3.totalLength - o3.currentIndex)) / 50;
      return Math.min(ud$1(i3), ud$1(n3));
    } };
  }
  startPath(o3, t3) {
    this.localTrail.startPath(o3, t3);
  }
  addPointToPath(o3, t3) {
    this.localTrail.addPointToPath(o3, t3);
  }
  endPath() {
    this.localTrail.endPath();
  }
  start(o3) {
    this.container = o3, this.animationFrameHandler.start(this), this.localTrail.start(o3);
  }
  stop() {
    this.animationFrameHandler.stop(this), this.localTrail.stop();
  }
  onFrame() {
    this.updateCollabTrails();
  }
  updateCollabTrails() {
    if (!(!this.container || this.app.state.collaborators.size === 0)) {
      for (let [o3, t3] of this.app.state.collaborators.entries()) {
        let r3;
        this.collabTrails.has(o3) ? r3 = this.collabTrails.get(o3) : (r3 = new An(this.animationFrameHandler, this.app, { ...this.getTrailOptions(), fill: () => t3.pointer?.laserColor || Tn(o3, t3) }), r3.start(this.container), this.collabTrails.set(o3, r3)), t3.pointer && t3.pointer.tool === "laser" && (t3.button === "down" && !r3.hasCurrentTrail && r3.startPath(t3.pointer.x, t3.pointer.y), t3.button === "down" && r3.hasCurrentTrail && !r3.hasLastPoint(t3.pointer.x, t3.pointer.y) && r3.addPointToPath(t3.pointer.x, t3.pointer.y), t3.button === "up" && r3.hasCurrentTrail && (r3.addPointToPath(t3.pointer.x, t3.pointer.y), r3.endPath()));
      }
      for (let o3 of this.collabTrails.keys()) this.app.state.collaborators.has(o3) || (this.collabTrails.get(o3).stop(), this.collabTrails.delete(o3));
    }
  }
};
var K5 = (e12, o3, t3, r3, n3, i3) => {
  let { zoom: a3 } = r3, l3 = 180 * t3 / Math.PI, s3 = e12 * (a3.value - 1) / 2, c3 = o3 * (a3.value - 1) / 2;
  return e12 > n3 && a3.value !== 1 && (s3 = n3 * (a3.value - 1) / 2), o3 > i3 && a3.value !== 1 && (c3 = i3 * (a3.value - 1) / 2), `translate(${s3}px, ${c3}px) scale(${a3.value}) rotate(${l3}deg)`;
}, iT = ({ id: e12, onChange: o3, onSubmit: t3, getViewportCoords: r3, element: n3, canvas: i3, excalidrawContainer: a3, app: l3, autoSelect: s3 = true }) => {
  let c3 = (F3, O3) => {
    if (!O3.style.fontFamily || !O3.style.fontSize) return false;
    let j = O3.style.fontFamily.replace(/"/g, "");
    return ea({ fontFamily: F3.fontFamily }) !== j || `${F3.fontSize}px` !== O3.style.fontSize;
  }, m3 = () => {
    let F3 = l3.state, O3 = Ts.getScene(n3)?.getElement(e12);
    if (!O3) return;
    let { textAlign: j, verticalAlign: oe2 } = O3, W = l3.scene.getNonDeletedElementsMap();
    if (O3 && k$2(O3)) {
      let ne3 = O3.x, ge2 = O3.y, be = qe(O3, l3.scene.getNonDeletedElementsMap()), mt2 = O3.width, wo2 = O3.height, Dn2 = O3.width, Pn2 = O3.height;
      if (be && O3.containerId) {
        if (ee(be)) {
          let lr2 = z$1.getBoundTextElementPosition(be, O3, W);
          ne3 = lr2.x, ge2 = lr2.y;
        }
        let gl2 = c3(O3, d3), qi2;
        if (gl2 ? qi2 = I2(be.id, be.height) : (qi2 = qr[be.id], qi2 || (qi2 = I2(be.id, be.height))), Dn2 = Tt$1(be, O3), Pn2 = Ar(be, O3), !ee(be) && wo2 > Pn2) {
          let lr2 = qa(wo2, be.type);
          Y(be, { height: lr2 });
          return;
        } else if (!ee(be) && be.height > qi2.height && wo2 < Pn2) {
          let lr2 = qa(wo2, be.type);
          Y(be, { height: lr2 });
        } else {
          let { y: lr2 } = R2(be, O3, W);
          ge2 = lr2;
        }
      }
      let [pl2, ul2] = r3(ne3, ge2), _T = d3.selectionStart, Ud2 = d3.selectionEnd, Jg = d3.value.length;
      if (_T === Ud2 && Ud2 !== Jg) {
        let gl2 = Jg - Ud2;
        d3.selectionStart = d3.value.length - gl2, d3.selectionEnd = d3.value.length - gl2;
      }
      be ? mt2 += 0.5 : (Dn2 = (F3.width - 8 - pl2) / F3.zoom.value, mt2 = Math.min(mt2, Dn2)), wo2 *= 1.05;
      let MT = Ee(O3), qg = (F3.height - ul2) / F3.zoom.value;
      Object.assign(d3.style, { font: MT, lineHeight: O3.lineHeight, width: `${mt2}px`, height: `${wo2}px`, left: `${pl2}px`, top: `${ul2}px`, transform: K5(mt2, wo2, lB(O3, be), F3, Dn2, qg), textAlign: j, verticalAlign: oe2, color: O3.strokeColor, opacity: O3.opacity / 100, filter: "var(--theme-filter)", maxHeight: `${qg}px` }), d3.scrollTop = 0, Ot() && (d3.style.fontFamily = ea(O3)), Y(O3, { x: ne3, y: ge2 });
    }
  }, d3 = document.createElement("textarea");
  d3.dir = "auto", d3.tabIndex = 0, d3.dataset.type = "wysiwyg", d3.wrap = "off", d3.classList.add("excalidraw-wysiwyg");
  let p3 = "pre", u3 = "normal";
  (Ne(n3) || !n3.autoResize) && (p3 = "pre-wrap", u3 = "break-word"), Object.assign(d3.style, { position: "absolute", display: "inline-block", minHeight: "1em", backfaceVisibility: "hidden", margin: 0, padding: 0, border: 0, outline: 0, resize: "none", background: "transparent", overflow: "hidden", zIndex: "var(--zIndex-wysiwyg)", wordBreak: u3, whiteSpace: p3, overflowWrap: "break-word", boxSizing: "content-box" }), d3.value = n3.originalText, m3(), o3 && (d3.onpaste = async (F3) => {
    let O3 = await vK(F3, true);
    if (!O3.text) return;
    let j = ia(O3.text);
    if (!j) return;
    let oe$1 = qe(n3, l3.scene.getNonDeletedElementsMap()), W = Ee({ fontSize: l3.state.currentItemFontSize, fontFamily: l3.state.currentItemFontFamily });
    if (oe$1) {
      let ne3 = oe(oe$1, l3.scene.getNonDeletedElementsMap()), ge2 = en(`${d3.value}${j}`, W, Tt$1(oe$1, ne3)), be = Dd$1(ge2, W);
      d3.style.width = `${be}px`;
    }
  }, d3.oninput = () => {
    let F3 = ia(d3.value);
    if (d3.value !== F3) {
      let O3 = d3.selectionStart;
      d3.value = F3, d3.selectionStart = O3, d3.selectionEnd = O3;
    }
    o3(d3.value);
  }), d3.onkeydown = (F3) => {
    if (!F3.shiftKey && pc.keyTest(F3)) F3.preventDefault(), l3.actionManager.executeAction(pc), m3();
    else if (!F3.shiftKey && uc.keyTest(F3)) F3.preventDefault(), l3.actionManager.executeAction(uc), m3();
    else if (!F3.shiftKey && gc.keyTest(F3)) F3.preventDefault(), l3.actionManager.executeAction(gc), m3();
    else if (Up.keyTest(F3)) l3.actionManager.executeAction(Up);
    else if (Hp.keyTest(F3)) l3.actionManager.executeAction(Hp);
    else if (F3.key === Q.ESCAPE) F3.preventDefault(), S3 = true, I3();
    else if (F3.key === Q.ENTER && F3[Q.CTRL_OR_CMD]) {
      if (F3.preventDefault(), F3.isComposing || F3.keyCode === 229) return;
      S3 = true, I3();
    } else if (F3.key === Q.TAB || F3[Q.CTRL_OR_CMD] && (F3.code === D1.BRACKET_LEFT || F3.code === D1.BRACKET_RIGHT)) {
      if (F3.preventDefault(), F3.isComposing) return;
      F3.shiftKey || F3.code === D1.BRACKET_LEFT ? T3() : x3(), d3.dispatchEvent(new Event("input"));
    }
  };
  let h3 = 4, f3 = " ".repeat(h3), b3 = new RegExp(`^ {1,${h3}}`), x3 = () => {
    let { selectionStart: F3, selectionEnd: O3 } = d3, j = E3(), oe2 = d3.value;
    j.forEach((W) => {
      let ne3 = oe2.slice(0, W), ge2 = oe2.slice(W);
      oe2 = `${ne3}${f3}${ge2}`;
    }), d3.value = oe2, d3.selectionStart = F3 + h3, d3.selectionEnd = O3 + h3 * j.length;
  }, T3 = () => {
    let { selectionStart: F3, selectionEnd: O3 } = d3, j = E3(), oe2 = [], W = d3.value;
    j.forEach((ne3) => {
      let ge2 = W.slice(ne3, ne3 + h3).match(b3);
      if (ge2) {
        let be = W.slice(0, ne3), mt2 = W.slice(ne3 + ge2[0].length);
        W = `${be}${mt2}`, oe2.push(ne3);
      }
    }), d3.value = W, oe2.length && (F3 > oe2[oe2.length - 1] ? d3.selectionStart = Math.max(F3 - h3, oe2[oe2.length - 1]) : d3.selectionStart = F3, d3.selectionEnd = Math.max(d3.selectionStart, O3 - h3 * oe2.length));
  }, E3 = () => {
    let { selectionStart: F3, selectionEnd: O3, value: j } = d3, oe2 = j.slice(0, F3).match(/[^\n]*$/)[0].length;
    return F3 = F3 - oe2, j.slice(F3, O3).split(`
`).reduce((ne3, ge2, be, mt2) => ne3.concat(be ? ne3[be - 1] + mt2[be - 1].length + 1 : F3), []).reverse();
  }, w3 = (F3) => {
    F3.target instanceof HTMLCanvasElement && (F3.preventDefault(), F3.stopPropagation());
  }, S3 = false, I3 = () => {
    if (H3) return;
    H3 = true, _3();
    let F3 = Ts.getScene(n3)?.getElement(n3.id);
    if (!F3) return;
    let O3 = qe(F3, l3.scene.getNonDeletedElementsMap());
    if (O3) {
      if (d3.value.trim()) {
        let j = Yt(O3);
        !j || j !== n3.id ? Y(O3, { boundElements: (O3.boundElements || []).concat({ type: "text", id: n3.id }) }) : ee(O3) && kr$1(O3);
      } else Y(O3, { boundElements: O3.boundElements?.filter((j) => !k$2(j)) });
      Xa$1(F3, O3, l3.scene.getNonDeletedElementsMap());
    }
    t3({ viaKeyboard: S3, nextOriginalText: d3.value });
  }, _3 = () => {
    d3.onblur = null, d3.oninput = null, d3.onkeydown = null, V3 && V3.disconnect(), window.removeEventListener("resize", m3), window.removeEventListener("wheel", w3, true), window.removeEventListener("pointerdown", M), window.removeEventListener("pointerup", k2), window.removeEventListener("blur", I3), window.removeEventListener("beforeunload", I3), N3(), G3(), d3.remove();
  }, k2 = (F3) => {
    window.removeEventListener("pointerup", k2);
    let O3 = F3?.target, j = O3 instanceof HTMLElement && O3.classList.contains("properties-trigger");
    setTimeout(() => {
      d3.onblur = I3, j || d3.focus();
    });
  }, R3 = () => {
    d3.onblur = null, window.addEventListener("pointerup", k2), window.addEventListener("blur", I3);
  }, M = (F3) => {
    let O3 = F3?.target;
    if (F3.button === mE.WHEEL) {
      O3 instanceof HTMLTextAreaElement && (F3.preventDefault(), l3.handleCanvasPanUsingWheelOrSpaceDrag(F3)), R3();
      return;
    }
    let j = O3 instanceof HTMLElement && O3.classList.contains("properties-trigger");
    (F3.target instanceof HTMLElement || F3.target instanceof SVGElement) && F3.target.closest(`.${gE.SHAPE_ACTIONS_MENU}, .${gE.ZOOM_ACTIONS}`) && !ag(F3.target) || j ? R3() : F3.target instanceof HTMLCanvasElement && !Ot() && requestAnimationFrame(() => {
      I3();
    });
  }, N3 = l3.scene.onUpdate(() => {
    m3(), !!document.activeElement?.closest(".properties-content") || d3.focus();
  }), G3 = l3.onScrollChangeEmitter.on(() => {
    m3();
  }), H3 = false;
  s3 && d3.select(), k2();
  let V3 = null;
  i3 && "ResizeObserver" in window ? (V3 = new window.ResizeObserver(() => {
    m3();
  }), V3.observe(i3)) : window.addEventListener("resize", m3), d3.onpointerdown = (F3) => F3.stopPropagation(), requestAnimationFrame(() => {
    window.addEventListener("pointerdown", M, { capture: true });
  }), window.addEventListener("beforeunload", I3), a3?.querySelector(".excalidraw-textEditorContainer").appendChild(d3);
};
var aT = L2({ name: "autoResize", label: "labels.autoResize", icon: null, trackEvent: { category: "element" }, predicate: (e12, o3, t3, r3) => {
  let n3 = at$1(e12, o3);
  return n3.length === 1 && k$2(n3[0]) && !n3[0].autoResize;
}, perform: (e12, o3, t3, r3) => {
  let n3 = at$1(e12, o3);
  return { appState: o3, elements: e12.map((i3) => {
    if (i3.id === n3[0].id && k$2(i3)) {
      let a3 = ht(i3.originalText, Ee(i3), i3.lineHeight);
      return vt$1(i3, { autoResize: true, width: a3.width, height: a3.height, text: i3.originalText });
    }
    return i3;
  }), captureUpdate: dr.IMMEDIATELY };
} });
var lT = (e12) => {
  let o3 = ["flowchart", "graph", "sequenceDiagram", "classDiagram", "stateDiagram", "stateDiagram-v2", "erDiagram", "journey", "gantt", "pie", "quadrantChart", "requirementDiagram", "gitGraph", "C4Context", "mindmap", "timeline", "zenuml", "sankey", "xychart", "block"];
  return new RegExp(`^(?:%%{.*?}%%[\\s\\n]*)?\\b(?:${o3.map((r3) => `\\s*${r3}(-beta)?`).join("|")})\\b`).test(e12.trim());
};
var sT = ({ canvas: e12, rc: o3, newElement: t3, elementsMap: r3, allElementsMap: n3, scale: i3, appState: a3, renderConfig: l3 }) => {
  if (e12) {
    let [s3, c3] = np(e12, i3), m3 = rp({ canvas: e12, scale: i3, normalizedWidth: s3, normalizedHeight: c3 });
    m3.save(), m3.scale(a3.zoom.value, a3.zoom.value), t3 && t3.type !== "selection" ? Fn(t3, r3, n3, o3, m3, l3, a3) : m3.clearRect(0, 0, s3, c3);
  }
}, X5 = pd$1((e12) => {
  sT(e12);
}, { trailing: true }), cT = (e12, o3) => {
  if (o3) {
    X5(e12);
    return;
  }
  sT(e12);
};
var j5 = (e12) => {
  let o3 = reactExports.useRef(null);
  return reactExports.useEffect(() => {
    o3.current && cT({ canvas: o3.current, scale: e12.scale, newElement: e12.appState.newElement, elementsMap: e12.elementsMap, allElementsMap: e12.allElementsMap, rc: e12.rc, renderConfig: e12.renderConfig, appState: e12.appState }, ji());
  }), jsxRuntimeExports.jsx("canvas", { className: "excalidraw__canvas", style: { width: e12.appState.width, height: e12.appState.height }, width: e12.appState.width * e12.scale, height: e12.appState.height * e12.scale, ref: o3 });
}, dT = j5;
var gT = React.createContext(null), hT = React.createContext(null), fT = { viewport: { isMobile: false, isLandscape: false }, editor: { isMobile: false, canFitSidebar: false }, isTouchScreen: false }, Og = React.createContext(fT);
Og.displayName = "DeviceContext";
var Fg = React.createContext({ container: null, id: null });
Fg.displayName = "ExcalidrawContainerContext";
var Bg = React.createContext([]);
Bg.displayName = "ExcalidrawElementsContext";
var zg = React.createContext({ ...mt(), width: 0, height: 0, offsetLeft: 0, offsetTop: 0 });
zg.displayName = "ExcalidrawAppStateContext";
var Ug = React.createContext(() => {
  console.warn("Uninitialized ExcalidrawSetAppStateContext context!");
});
Ug.displayName = "ExcalidrawSetAppStateContext";
var Hg = React.createContext(null);
Hg.displayName = "ExcalidrawActionManagerContext";
var He = () => reactExports.useContext(gT), Do = () => reactExports.useContext(hT), me = () => reactExports.useContext(Og), Ke = () => reactExports.useContext(Fg), kr = () => reactExports.useContext(Bg), Mo = () => reactExports.useContext(zg), pe = () => reactExports.useContext(Ug), Xe2 = () => reactExports.useContext(Hg), al = false, Mg = 0, Mn = false, ll = false, Dg = false, Pg = { horizontal: null, vertical: null }, Ur = 0, sl = false, Rg = /* @__PURE__ */ new Map(), Rd = false, pT = 0, uT = false, cl = null, fe = { pointers: /* @__PURE__ */ new Map(), lastCenter: null, initialDistance: null, initialScale: null }, Ng = class e11 extends React.Component {
  constructor(t3) {
    super(t3);
    i$1(this, "canvas");
    i$1(this, "interactiveCanvas", null);
    i$1(this, "rc");
    i$1(this, "unmounted", false);
    i$1(this, "actionManager");
    i$1(this, "device", fT);
    i$1(this, "excalidrawContainerRef", React.createRef());
    i$1(this, "scene");
    i$1(this, "fonts");
    i$1(this, "renderer");
    i$1(this, "visibleElements");
    i$1(this, "resizeObserver");
    i$1(this, "nearestScrollableContainer");
    i$1(this, "library");
    i$1(this, "libraryItemsFromStorage");
    i$1(this, "id");
    i$1(this, "store");
    i$1(this, "history");
    i$1(this, "excalidrawContainerValue");
    i$1(this, "files", {});
    i$1(this, "imageCache", /* @__PURE__ */ new Map());
    i$1(this, "iFrameRefs", /* @__PURE__ */ new Map());
    i$1(this, "embedsValidationStatus", /* @__PURE__ */ new Map());
    i$1(this, "initializedEmbeds", /* @__PURE__ */ new Set());
    i$1(this, "elementsPendingErasure", /* @__PURE__ */ new Set());
    i$1(this, "flowChartCreator", new Qc());
    i$1(this, "flowChartNavigator", new qc());
    i$1(this, "hitLinkElement");
    i$1(this, "lastPointerDownEvent", null);
    i$1(this, "lastPointerUpEvent", null);
    i$1(this, "lastPointerMoveEvent", null);
    i$1(this, "lastPointerMoveCoords", null);
    i$1(this, "lastViewportPosition", { x: 0, y: 0 });
    i$1(this, "animationFrameHandler", new Dd());
    i$1(this, "laserTrails", new Pd(this.animationFrameHandler, this));
    i$1(this, "eraserTrail", new An(this.animationFrameHandler, this, { streamline: 0.2, size: 5, keepHead: true, sizeMapping: (t5) => {
      let i5 = Math.max(0, 1 - (performance.now() - t5.pressure) / 200), a8 = (10 - Math.min(10, t5.totalLength - t5.currentIndex)) / 10;
      return Math.min(ud$1(a8), ud$1(i5));
    }, fill: () => this.state.theme === ke.LIGHT ? "rgba(0, 0, 0, 0.2)" : "rgba(255, 255, 255, 0.2)" }));
    i$1(this, "onChangeEmitter", new hi());
    i$1(this, "onPointerDownEmitter", new hi());
    i$1(this, "onPointerUpEmitter", new hi());
    i$1(this, "onUserFollowEmitter", new hi());
    i$1(this, "onScrollChangeEmitter", new hi());
    i$1(this, "missingPointerEventCleanupEmitter", new hi());
    i$1(this, "onRemoveEventListenersEmitter", new hi());
    i$1(this, "getEffectiveGridSize", () => Sb(this) ? this.state.gridSize : null);
    i$1(this, "updateEmbedValidationStatus", (t5, r5) => {
      this.embedsValidationStatus.set(t5.id, r5), he.delete(t5);
    });
    i$1(this, "updateEmbeddables", () => {
      let t5 = /* @__PURE__ */ new Set(), r5 = false;
      this.scene.getNonDeletedElements().filter((n8) => {
        if (Bo(n8)) {
          if (t5.add(n8.id), !this.embedsValidationStatus.has(n8.id)) {
            r5 = true;
            let i5 = Y_(n8.link, this.props.validateEmbeddable);
            this.updateEmbedValidationStatus(n8, i5);
          }
        } else _o$1(n8) && t5.add(n8.id);
        return false;
      }), r5 && this.scene.triggerUpdate(), this.iFrameRefs.forEach((n8, i5) => {
        t5.has(i5) || this.iFrameRefs.delete(i5);
      });
    });
    i$1(this, "getFrameNameDOMId", (t5) => `${this.id}-frame-name-${t5.id}`);
    i$1(this, "frameNameBoundsCache", { get: (t5) => {
      let r5 = this.frameNameBoundsCache._cache.get(t5.id);
      if (!r5 || r5.zoom !== this.state.zoom.value || r5.versionNonce !== t5.versionNonce) {
        let n8 = document.getElementById(this.getFrameNameDOMId(t5));
        if (n8) {
          let i5 = n8.getBoundingClientRect(), a8 = Dn({ clientX: i5.x, clientY: i5.y }, this.state), l7 = Dn({ clientX: i5.right, clientY: i5.bottom }, this.state);
          return r5 = { x: a8.x, y: a8.y, width: l7.x - a8.x, height: l7.y - a8.y, angle: 0, zoom: this.state.zoom.value, versionNonce: t5.versionNonce }, this.frameNameBoundsCache._cache.set(t5.id, r5), r5;
        }
        return null;
      }
      return r5;
    }, _cache: /* @__PURE__ */ new Map() });
    i$1(this, "resetEditingFrame", (t5) => {
      t5 && Y(t5, { name: t5.name?.trim() || null }), this.setState({ editingFrame: null });
    });
    i$1(this, "renderFrameNames", () => {
      if (!this.state.frameRendering.enabled || !this.state.frameRendering.name) return this.state.editingFrame && this.resetEditingFrame(null), null;
      let t5 = this.state.theme === ke.DARK;
      return this.scene.getNonDeletedFramesLikes().map((r5) => {
        if (!kp(r5, this.canvas.width / window.devicePixelRatio, this.canvas.height / window.devicePixelRatio, { offsetLeft: this.state.offsetLeft, offsetTop: this.state.offsetTop, scrollX: this.state.scrollX, scrollY: this.state.scrollY, zoom: this.state.zoom }, this.scene.getNonDeletedElementsMap())) return this.state.editingFrame === r5.id && this.resetEditingFrame(r5), null;
        let { x: n8, y: i5 } = ta({ sceneX: r5.x, sceneY: r5.y }, this.state), a8 = 6, l7, s5 = bp$1(r5);
        if (r5.id === this.state.editingFrame) {
          let c8 = s5;
          l7 = jsxRuntimeExports.jsx("input", { autoFocus: true, value: c8, onChange: (m8) => {
            Y(r5, { name: m8.target.value });
          }, onFocus: (m8) => m8.target.select(), onBlur: () => this.resetEditingFrame(r5), onKeyDown: (m8) => {
            (m8.key === Q.ESCAPE || m8.key === Q.ENTER) && this.resetEditingFrame(r5);
          }, style: { background: this.state.viewBackgroundColor, filter: t5 ? Io : "none", zIndex: 2, border: "none", display: "block", padding: `${a8}px`, borderRadius: 4, boxShadow: "inset 0 0 0 1px var(--color-primary)", fontFamily: "Assistant", fontSize: "14px", transform: `translate(-${a8}px, ${a8}px)`, color: "var(--color-gray-80)", overflow: "hidden", maxWidth: `${document.body.clientWidth - n8 - a8}px` }, size: c8.length + 1 || 1, dir: "auto", autoComplete: "off", autoCapitalize: "off", autoCorrect: "off" });
        } else l7 = s5;
        return jsxRuntimeExports.jsx("div", { id: this.getFrameNameDOMId(r5), style: { position: "absolute", bottom: `${this.state.height + Pe$1.nameOffsetY - i5 + this.state.offsetTop}px`, left: `${n8 - this.state.offsetLeft}px`, zIndex: 2, fontSize: Pe$1.nameFontSize, color: t5 ? Pe$1.nameColorDarkTheme : Pe$1.nameColorLightTheme, lineHeight: Pe$1.nameLineHeight, width: "max-content", maxWidth: `${r5.width}px`, overflow: r5.id === this.state.editingFrame ? "visible" : "hidden", whiteSpace: "nowrap", textOverflow: "ellipsis", cursor: mo.MOVE, pointerEvents: this.state.viewModeEnabled ? bE.disabled : bE.enabled }, onPointerDown: (c8) => this.handleCanvasPointerDown(c8), onWheel: (c8) => this.handleWheel(c8), onContextMenu: this.handleCanvasContextMenu, onDoubleClick: () => {
          this.setState({ editingFrame: r5.id });
        }, children: l7 }, r5.id);
      });
    });
    i$1(this, "focusContainer", () => {
      this.excalidrawContainerRef.current?.focus();
    });
    i$1(this, "getSceneElementsIncludingDeleted", () => this.scene.getElementsIncludingDeleted());
    i$1(this, "getSceneElements", () => this.scene.getNonDeletedElements());
    i$1(this, "onInsertElements", (t5) => {
      this.addElementsFromPasteOrLibrary({ elements: t5, position: "center", files: null });
    });
    i$1(this, "onExportImage", async (t5, r5, n8) => {
      le("export", t5, "ui");
      let i5 = await vn(t5, r5, this.state, this.files, { exportBackground: this.state.exportBackground, name: this.getName(), viewBackgroundColor: this.state.viewBackgroundColor, exportingFrame: n8.exportingFrame }).catch(Ug$1).catch((a8) => {
        console.error(a8), this.setState({ errorMessage: a8.message });
      });
      this.state.exportEmbedScene && i5 && W2(i5) && this.setState({ fileHandle: i5 });
    });
    i$1(this, "magicGenerations", /* @__PURE__ */ new Map());
    i$1(this, "updateMagicGeneration", ({ frameElement: t5, data: r5 }) => {
      r5.status === "pending" ? Y(t5, { customData: { generationData: void 0 } }, false) : Y(t5, { customData: { generationData: r5 } }, false), this.magicGenerations.set(t5.id, r5), this.triggerRender();
    });
    i$1(this, "plugins", {});
    i$1(this, "onMagicframeToolSelect", () => {
      let t5 = this.scene.getSelectedElements({ selectedElementIds: this.state.selectedElementIds });
      if (t5.length === 0) this.setActiveTool({ type: fn.magicframe }), le("ai", "tool-select (empty-selection)", "d2c");
      else {
        let r5 = t5.length === 1 && yd$1(t5[0]) && t5[0];
        if (!r5 && t5.some((i5) => de(i5) || i5.frameId)) {
          this.setActiveTool({ type: fn.magicframe });
          return;
        }
        le("ai", "tool-select (existing selection)", "d2c");
        let n8;
        if (r5) n8 = r5;
        else {
          let [i5, a8, l7, s5] = $e$1(t5), c8 = 50;
          n8 = GB({ ...Pe$1, x: i5 - c8, y: a8 - c8, width: l7 - i5 + c8 * 2, height: s5 - a8 + c8 * 2, opacity: 100, locked: false }), this.scene.insertElement(n8);
          for (let m8 of t5) Y(m8, { frameId: n8.id });
          this.setState({ selectedElementIds: { [n8.id]: true } });
        }
        this.onMagicFrameGenerate(n8, "upstream");
      }
    });
    i$1(this, "openEyeDropper", ({ type: t5 }) => {
      st.set(Sr, { swapPreviewOnAlt: true, colorPickerType: t5 === "stroke" ? "elementStroke" : "elementBackground", onSelect: (r5, n8) => {
        let i5 = t5 === "background" && n8.altKey || t5 === "stroke" && !n8.altKey;
        !this.scene.getSelectedElements(this.state).length || this.state.activeTool.type !== "selection" ? i5 ? this.syncActionResult({ appState: { ...this.state, currentItemStrokeColor: r5 }, captureUpdate: dr.IMMEDIATELY }) : this.syncActionResult({ appState: { ...this.state, currentItemBackgroundColor: r5 }, captureUpdate: dr.IMMEDIATELY }) : this.updateScene({ elements: this.scene.getElementsIncludingDeleted().map((l7) => this.state.selectedElementIds[l7.id] ? vt$1(l7, { [i5 ? "strokeColor" : "backgroundColor"]: r5 }) : l7), captureUpdate: dr.IMMEDIATELY });
      }, keepOpenOnAlt: false });
    });
    i$1(this, "dismissLinearEditor", () => {
      setTimeout(() => {
        this.setState({ editingLinearElement: null });
      });
    });
    i$1(this, "syncActionResult", Fe((t5) => {
      if (this.unmounted || t5 === false) return;
      t5.captureUpdate === dr.NEVER ? this.store.shouldUpdateSnapshot() : t5.captureUpdate === dr.IMMEDIATELY && this.store.shouldCaptureIncrement();
      let r5 = false, n8 = null;
      if (t5.elements && (this.scene.replaceAllElements(t5.elements), r5 = true), t5.files && (this.addMissingFiles(t5.files, t5.replaceFiles), this.addNewImagesToImageCache()), t5.appState || n8 || this.state.contextMenu) {
        let i5 = t5?.appState?.viewModeEnabled || false, a8 = t5?.appState?.zenModeEnabled || false, l7 = t5?.appState?.theme || this.props.theme || ke.LIGHT, s5 = t5?.appState?.name ?? this.state.name, c8 = t5?.appState?.errorMessage ?? this.state.errorMessage;
        typeof this.props.viewModeEnabled < "u" && (i5 = this.props.viewModeEnabled), typeof this.props.zenModeEnabled < "u" && (a8 = this.props.zenModeEnabled), n8 = t5.appState?.editingTextElement || null, t5.elements && n8 && t5.elements.forEach((m8) => {
          n8?.id === m8.id && n8 !== m8 && zp$1(m8) && k$2(m8) && (n8 = m8);
        }), n8?.isDeleted && (n8 = null), this.setState((m8) => {
          let d3 = t5.appState || {};
          return { ...m8, ...d3, contextMenu: null, editingTextElement: n8, viewModeEnabled: i5, zenModeEnabled: a8, theme: l7, name: s5, errorMessage: c8 };
        }), r5 = true;
      }
      !r5 && t5.captureUpdate !== dr.EVENTUALLY && this.scene.triggerUpdate();
    }));
    i$1(this, "onBlur", Fe(() => {
      Mn = false, this.setState({ isBindingEnabled: true });
    }));
    i$1(this, "onUnload", () => {
      this.onBlur();
    });
    i$1(this, "disableEvent", (t5) => {
      t5.preventDefault();
    });
    i$1(this, "resetHistory", () => {
      this.history.clear();
    });
    i$1(this, "resetStore", () => {
      this.store.clear();
    });
    i$1(this, "resetScene", Fe((t5) => {
      this.scene.replaceAllElements([]), this.setState((r5) => ({ ...mt(), isLoading: t5?.resetLoadingState ? false : r5.isLoading, theme: this.state.theme })), this.resetStore(), this.resetHistory();
    }));
    i$1(this, "initializeScene", async () => {
      "launchQueue" in window && "LaunchParams" in window && window.launchQueue.setConsumer(async (n8) => {
        if (!n8.files.length) return;
        let i5 = n8.files[0], a8 = await i5.getFile();
        this.loadFileToCanvas(new File([a8], a8.name || "", { type: a8.type }), i5);
      }), this.props.theme && this.setState({ theme: this.props.theme }), this.state.isLoading || this.setState({ isLoading: true });
      let t5 = null;
      try {
        typeof this.props.initialData == "function" ? t5 = await this.props.initialData() || null : t5 = await this.props.initialData || null, t5?.libraryItems && this.library.updateLibrary({ libraryItems: t5.libraryItems, merge: true }).catch((n8) => {
          console.error(n8);
        });
      } catch (n8) {
        console.error(n8), t5 = { appState: { errorMessage: n8.message || "Encountered an error during importing or restoring scene data" } };
      }
      let r5 = io(t5, null, null, { repairBindings: true });
      r5.appState = { ...r5.appState, theme: this.props.theme || r5.appState.theme, openSidebar: r5.appState?.openSidebar || this.state.openSidebar, activeTool: r5.appState.activeTool.type === "image" ? { ...r5.appState.activeTool, type: "selection" } : r5.appState.activeTool, isLoading: false, toast: this.state.toast }, t5?.scrollToContent && (r5.appState = { ...r5.appState, ..._a$1(r5.elements, { ...r5.appState, width: this.state.width, height: this.state.height, offsetTop: this.state.offsetTop, offsetLeft: this.state.offsetLeft }) }), this.resetStore(), this.resetHistory(), this.syncActionResult({ ...r5, captureUpdate: dr.NEVER }), this.clearImageShapeCache(), this.fonts.loadSceneFonts().then((n8) => {
        this.fonts.onLoaded(n8);
      }), op(window.location.href) && this.scrollToContent(window.location.href, { animate: false });
    });
    i$1(this, "isMobileBreakpoint", (t5, r5) => t5 < NE || r5 < BE && t5 < FE);
    i$1(this, "refreshViewportBreakpoints", () => {
      if (!this.excalidrawContainerRef.current) return;
      let { clientWidth: r5, clientHeight: n8 } = document.body, i5 = this.device.viewport, a8 = Ig$1(i5, { isLandscape: r5 > n8, isMobile: this.isMobileBreakpoint(r5, n8) });
      return i5 !== a8 ? (this.device = { ...this.device, viewport: a8 }, true) : false;
    });
    i$1(this, "refreshEditorBreakpoints", () => {
      let t5 = this.excalidrawContainerRef.current;
      if (!t5) return;
      let { width: r5, height: n8 } = t5.getBoundingClientRect(), i5 = this.props.UIOptions.dockedSidebarBreakpoint != null ? this.props.UIOptions.dockedSidebarBreakpoint : _E, a8 = this.device.editor, l7 = Ig$1(a8, { isMobile: this.isMobileBreakpoint(r5, n8), canFitSidebar: r5 > i5 });
      return a8 !== l7 ? (this.device = { ...this.device, editor: l7 }, true) : false;
    });
    i$1(this, "onResize", Fe(() => {
      this.scene.getElementsIncludingDeleted().forEach((t5) => he.delete(t5)), this.refreshViewportBreakpoints(), this.updateDOMRect(), cE || this.refreshEditorBreakpoints(), this.setState({});
    }));
    i$1(this, "onFullscreenChange", () => {
      !document.fullscreenElement && this.state.activeEmbeddable?.state === "active" && this.setState({ activeEmbeddable: null });
    });
    i$1(this, "renderInteractiveSceneCallback", ({ atLeastOneVisibleElement: t5, scrollBars: r5, elementsMap: n8 }) => {
      r5 && (Pg = r5);
      let i5 = this.state.editingTextElement ? false : !t5 && n8.size > 0;
      this.state.scrolledOutside !== i5 && this.setState({ scrolledOutside: i5 }), this.scheduleImageRefresh();
    });
    i$1(this, "onScroll", $o(() => {
      let { offsetTop: t5, offsetLeft: r5 } = this.getCanvasOffsets();
      this.setState((n8) => n8.offsetLeft === r5 && n8.offsetTop === t5 ? null : { offsetTop: t5, offsetLeft: r5 });
    }, LE));
    i$1(this, "onCut", Fe((t5) => {
      !this.excalidrawContainerRef.current?.contains(document.activeElement) || ag(t5.target) || (this.actionManager.executeAction(yc, "keyboard", t5), t5.preventDefault(), t5.stopPropagation());
    }));
    i$1(this, "onCopy", Fe((t5) => {
      !this.excalidrawContainerRef.current?.contains(document.activeElement) || ag(t5.target) || (this.actionManager.executeAction(_i, "keyboard", t5), t5.preventDefault(), t5.stopPropagation());
    }));
    i$1(this, "onTouchStart", (t5) => {
      if (_s && t5.preventDefault(), !al) {
        al = true, clearTimeout(Mg), Mg = window.setTimeout(e11.resetTapTwice, TE);
        return;
      }
      if (al && t5.touches.length === 1) {
        let r5 = t5.touches[0];
        this.handleCanvasDoubleClick({ clientX: r5.clientX, clientY: r5.clientY }), al = false, clearTimeout(Mg);
      }
      t5.touches.length === 2 && this.setState({ selectedElementIds: Ha$1({}, this.state), activeEmbeddable: null });
    });
    i$1(this, "onTouchEnd", (t5) => {
      this.resetContextMenuTimer(), t5.touches.length > 0 ? this.setState({ previousSelectedElementIds: {}, selectedElementIds: Ha$1(this.state.previousSelectedElementIds, this.state) }) : fe.pointers.clear();
    });
    i$1(this, "pasteFromClipboard", Fe(async (t5) => {
      let r5 = !!Rd, n8 = document.activeElement, i5 = this.excalidrawContainerRef.current?.contains(n8);
      if (t5 && !i5) return;
      let a8 = document.elementFromPoint(this.lastViewportPosition.x, this.lastViewportPosition.y);
      if (t5 && (!(a8 instanceof HTMLCanvasElement) || ag(n8))) return;
      let { x: l7, y: s5 } = Dn({ clientX: this.lastViewportPosition.x, clientY: this.lastViewportPosition.y }, this.state), c8 = t5?.clipboardData?.files[0], m8 = await vK(t5, r5);
      if (!c8 && !r5) {
        if (m8.mixedContent) return this.addElementsFromMixedContentPaste(m8.mixedContent, { isPlainPaste: r5, sceneX: l7, sceneY: s5 });
        if (m8.text) {
          let d3 = m8.text.trim();
          d3.startsWith("<svg") && d3.endsWith("</svg>") && (c8 = OY(d3));
        }
      }
      if (Hi$1(c8) && !m8.spreadsheet) {
        if (!this.isToolSupported("image")) {
          this.setState({ errorMessage: g("errors.imageToolNotSupported") });
          return;
        }
        let d3 = this.createImageElement({ sceneX: l7, sceneY: s5 });
        this.insertImageElement(d3, c8), this.initializeImageDimensions(d3), this.setState({ selectedElementIds: Ha$1({ [d3.id]: true }, this.state) });
        return;
      }
      if (this.props.onPaste) try {
        if (await this.props.onPaste(m8, t5) === false) return;
      } catch (d3) {
        console.error(d3);
      }
      if (m8.errorMessage) this.setState({ errorMessage: m8.errorMessage });
      else if (m8.spreadsheet && !r5) this.setState({ pasteDialog: { data: m8.spreadsheet, shown: true } });
      else if (m8.elements) {
        let d3 = m8.programmaticAPI ? Yi(m8.elements) : m8.elements;
        this.addElementsFromPasteOrLibrary({ elements: d3, files: m8.files || null, position: "cursor", retainSeed: r5 });
      } else if (m8.text) {
        if (m8.text && lT(m8.text)) {
          let u3 = await __vitePreload(() => import("./index-TZwSmFf6.js").then((n10) => n10.b5), true ? [] : void 0, import.meta.url);
          try {
            let { elements: h3, files: f3 } = await u3.parseMermaidToExcalidraw(m8.text), b3 = Yi(h3, { regenerateIds: true });
            this.addElementsFromPasteOrLibrary({ elements: b3, files: f3, position: "cursor" });
            return;
          } catch (h3) {
            console.warn(`parsing pasted text as mermaid definition failed: ${h3.message}`);
          }
        }
        let d3 = gd$1(m8.text).split(/\n+/).map((u3) => u3.trim()).filter(Boolean), p3 = d3.map((u3) => J_$1(u3)).filter((u3) => Y_(u3, this.props.validateEmbeddable) && (/^(http|https):\/\/[^\s/$.?#].[^\s]*$/.test(u3) || V2(u3)?.type === "video"));
        if (!Rd && p3.length > 0 && p3.length === d3.length) {
          let u3 = [];
          for (let h3 of p3) {
            let f3 = u3[u3.length - 1], b3 = this.insertEmbeddableElement({ sceneX: f3 ? f3.x + f3.width + 20 : l7, sceneY: s5, link: dn(h3) });
            b3 && u3.push(b3);
          }
          u3.length && this.setState({ selectedElementIds: Object.fromEntries(u3.map((h3) => [h3.id, true])) });
          return;
        }
        this.addTextFromPaste(m8.text, r5);
      }
      this.setActiveTool({ type: "selection" }), t5?.preventDefault();
    }));
    i$1(this, "addElementsFromPasteOrLibrary", (t5) => {
      let r5 = Mp$1(t5.elements, null, void 0), [n8, i5, a8, l7] = $e$1(r5), s5 = dt(n8, a8) / 2, c8 = dt(i5, l7) / 2, m8 = typeof t5.position == "object" ? t5.position.clientX : t5.position === "cursor" ? this.lastViewportPosition.x : this.state.width / 2 + this.state.offsetLeft, d3 = typeof t5.position == "object" ? t5.position.clientY : t5.position === "cursor" ? this.lastViewportPosition.y : this.state.height / 2 + this.state.offsetTop, { x: p3, y: u3 } = Dn({ clientX: m8, clientY: d3 }, this.state), h3 = p3 - s5, f3 = u3 - c8, [b3, x3] = Vr(h3, f3, this.getEffectiveGridSize()), T3 = ZB(r5.map((k2) => vt$1(k2, { x: k2.x + b3 - n8, y: k2.y + x3 - i5 })), { randomizeSeed: !t5.retainSeed }), E3 = this.scene.getElementsIncludingDeleted(), w3 = [...E3, ...T3];
      w3 = this.props.onDuplicate?.(w3, E3) || w3, Zr(w3, te(T3));
      let I3 = this.getTopLayerFrameAtSceneCoords({ x: p3, y: u3 });
      if (I3) {
        let k2 = xH(T3, I3);
        l9(w3, k2, I3, this.state);
      }
      this.scene.replaceAllElements(w3), T3.forEach((k2) => {
        if (k$2(k2) && Ne(k2)) {
          let R3 = qe(k2, this.scene.getElementsMapIncludingDeleted());
          Xa$1(k2, R3, this.scene.getElementsMapIncludingDeleted());
        }
      }), sE && Nn.loadElementsFonts(T3).then((k2) => {
        this.fonts.onLoaded(k2);
      }), t5.files && this.addMissingFiles(t5.files), this.store.shouldCaptureIncrement();
      let _3 = f9(T3);
      this.setState({ ...this.state, openSidebar: this.state.openSidebar && this.device.editor.canFitSidebar && st.get(Ja) ? this.state.openSidebar : null, ...aF({ editingGroupId: null, selectedElementIds: _3.reduce((k2, R3) => (Ne(R3) || (k2[R3.id] = true), k2), {}) }, this.scene.getNonDeletedElements(), this.state, this) }, () => {
        t5.files && this.addNewImagesToImageCache();
      }), this.setActiveTool({ type: "selection" }), t5.fitToContent && this.scrollToContent(T3, { fitToContent: true, canvasOffsets: this.getEditorUIOffsets() });
    });
    i$1(this, "setAppState", (t5, r5) => {
      this.setState(t5, r5);
    });
    i$1(this, "removePointer", (t5) => {
      Ur && this.resetContextMenuTimer(), fe.pointers.delete(t5.pointerId);
    });
    i$1(this, "toggleLock", (t5 = "ui") => {
      this.state.activeTool.locked || le("toolbar", "toggleLock", `${t5} (${this.device.editor.isMobile ? "mobile" : "desktop"})`), this.setState((r5) => ({ activeTool: { ...r5.activeTool, ...$r(this.state, r5.activeTool.locked ? { type: "selection" } : r5.activeTool), locked: !r5.activeTool.locked } }));
    });
    i$1(this, "updateFrameRendering", (t5) => {
      this.setState((r5) => {
        let n8 = typeof t5 == "function" ? t5(r5.frameRendering) : t5;
        return { frameRendering: { enabled: n8?.enabled ?? r5.frameRendering.enabled, clip: n8?.clip ?? r5.frameRendering.clip, name: n8?.name ?? r5.frameRendering.name, outline: n8?.outline ?? r5.frameRendering.outline } };
      });
    });
    i$1(this, "togglePenMode", (t5) => {
      this.setState((r5) => ({ penMode: t5 ?? !r5.penMode, penDetected: true }));
    });
    i$1(this, "onHandToolToggle", () => {
      this.actionManager.executeAction(Zy);
    });
    i$1(this, "zoomCanvas", (t5) => {
      this.setState({ ...Qo({ viewportX: this.state.width / 2 + this.state.offsetLeft, viewportY: this.state.height / 2 + this.state.offsetTop, nextZoom: Oa(t5) }, this.state) });
    });
    i$1(this, "cancelInProgressAnimation", null);
    i$1(this, "scrollToContent", (t5 = this.scene.getNonDeletedElements(), r5) => {
      if (typeof t5 == "string") {
        let s5;
        if (op(t5) ? s5 = GO(t5) : s5 = t5, s5) {
          let c8 = this.scene.getElementsFromId(s5);
          c8?.length ? this.scrollToContent(c8, { fitToContent: r5?.fitToContent ?? true, animate: r5?.animate ?? true }) : op(t5) && this.setState({ toast: { message: g("elementLink.notFound"), duration: 3e3, closable: true } });
        }
        return;
      }
      this.cancelInProgressAnimation?.();
      let n8 = Array.isArray(t5) ? t5 : [t5], i5 = this.state.zoom, a8 = this.state.scrollX, l7 = this.state.scrollY;
      if (r5?.fitToContent || r5?.fitToViewport) {
        let { appState: s5 } = Fa({ canvasOffsets: r5.canvasOffsets, targetElements: n8, appState: this.state, fitToViewport: !!r5?.fitToViewport, viewportZoomFactor: r5?.viewportZoomFactor, minZoom: r5?.minZoom, maxZoom: r5?.maxZoom });
        i5 = s5.zoom, a8 = s5.scrollX, l7 = s5.scrollY;
      } else {
        let s5 = _a$1(n8, this.state);
        a8 = s5.scrollX, l7 = s5.scrollY;
      }
      if (r5?.animate) {
        let s5 = this.state.scrollX, c8 = this.state.scrollY, m8 = this.state.zoom.value, d3 = sg({ fromValues: { scrollX: s5, scrollY: c8, zoom: m8 }, toValues: { scrollX: a8, scrollY: l7, zoom: i5.value }, interpolateValue: (p3, u3, h3, f3) => {
          if (f3 === "zoom") return p3 * Math.pow(u3 / p3, ud$1(h3));
        }, onStep: ({ scrollX: p3, scrollY: u3, zoom: h3 }) => {
          this.setState({ scrollX: p3, scrollY: u3, zoom: { value: h3 } });
        }, onStart: () => {
          this.setState({ shouldCacheIgnoreZoom: true });
        }, onEnd: () => {
          this.setState({ shouldCacheIgnoreZoom: false });
        }, onCancel: () => {
          this.setState({ shouldCacheIgnoreZoom: false });
        }, duration: r5?.duration ?? 500 });
        this.cancelInProgressAnimation = () => {
          d3(), this.cancelInProgressAnimation = null;
        };
      } else this.setState({ scrollX: a8, scrollY: l7, zoom: i5 });
    });
    i$1(this, "maybeUnfollowRemoteUser", () => {
      this.state.userToFollow && this.setState({ userToFollow: null });
    });
    i$1(this, "translateCanvas", (t5) => {
      this.cancelInProgressAnimation?.(), this.maybeUnfollowRemoteUser(), this.setState(t5);
    });
    i$1(this, "setToast", (t5) => {
      this.setState({ toast: t5 });
    });
    i$1(this, "restoreFileFromShare", async () => {
      try {
        let t5 = await caches.open("web-share-target"), r5 = await t5.match("shared-file");
        if (r5) {
          let n8 = await r5.blob(), i5 = new File([n8], n8.name || "", { type: n8.type });
          this.loadFileToCanvas(i5, null), await t5.delete("shared-file"), window.history.replaceState(null, lE, window.location.pathname);
        }
      } catch (t5) {
        this.setState({ errorMessage: t5.message });
      }
    });
    i$1(this, "addFiles", Fe((t5) => {
      let { addedFiles: r5 } = this.addMissingFiles(t5);
      this.clearImageShapeCache(r5), this.scene.triggerUpdate(), this.addNewImagesToImageCache();
    }));
    i$1(this, "addMissingFiles", (t5, r5 = false) => {
      let n8 = r5 ? {} : { ...this.files }, i5 = {}, a8 = Array.isArray(t5) ? t5 : Object.values(t5);
      for (let l7 of a8) if (!n8[l7.id] && (i5[l7.id] = l7, n8[l7.id] = l7, l7.mimeType === H.svg)) try {
        let s5 = NY(LO(BY(l7.dataURL)), H.svg);
        l7.dataURL !== s5 && (l7.version = (l7.version ?? 1) + 1, l7.dataURL = s5);
      } catch (s5) {
        console.error(s5);
      }
      return this.files = n8, { addedFiles: i5 };
    });
    i$1(this, "updateScene", Fe((t5) => {
      let r5 = An$1(t5.elements ?? []);
      if (t5.captureUpdate && t5.captureUpdate !== dr.EVENTUALLY) {
        let n8 = this.store.snapshot.appState, i5 = this.store.snapshot.elements, a8 = t5.appState ? Object.assign({}, n8, t5.appState) : n8, l7 = t5.elements ? this.store.filterUncomittedElements(this.scene.getElementsMapIncludingDeleted(), te(r5)) : i5;
        t5.captureUpdate === dr.IMMEDIATELY ? this.store.captureIncrement(l7, a8) : t5.captureUpdate === dr.NEVER && this.store.updateSnapshot(l7, a8);
      }
      t5.appState && this.setState(t5.appState), t5.elements && this.scene.replaceAllElements(r5), t5.collaborators && this.setState({ collaborators: t5.collaborators });
    }));
    i$1(this, "triggerRender", (t5) => {
      t5 === true ? this.scene.triggerUpdate() : this.setState({});
    });
    i$1(this, "toggleSidebar", ({ name: t5, tab: r5, force: n8 }) => {
      let i5;
      n8 === void 0 ? i5 = this.state.openSidebar?.name === t5 && this.state.openSidebar?.tab === r5 ? null : t5 : i5 = n8 ? t5 : null;
      let a8 = i5 ? { name: i5 } : null;
      return a8 && r5 && (a8.tab = r5), this.setState({ openSidebar: a8 }), !!i5;
    });
    i$1(this, "updateCurrentCursorPosition", Fe((t5) => {
      this.lastViewportPosition.x = t5.clientX, this.lastViewportPosition.y = t5.clientY;
    }));
    i$1(this, "getEditorUIOffsets", () => {
      let t5 = this.excalidrawContainerRef?.current?.querySelector(".App-toolbar")?.getBoundingClientRect()?.bottom ?? 0, r5 = this.excalidrawContainerRef?.current?.querySelector(".sidebar")?.getBoundingClientRect(), n8 = this.excalidrawContainerRef?.current?.querySelector(".App-menu__left")?.getBoundingClientRect(), i5 = 16;
      return qo().rtl ? { top: t5 + i5, right: Math.max(this.state.width - (n8?.left ?? this.state.width), 0) + i5, bottom: i5, left: Math.max(r5?.right ?? 0, 0) + i5 } : { top: t5 + i5, right: Math.max(this.state.width - (r5?.left ?? this.state.width) + i5, 0), bottom: i5, left: Math.max(n8?.right ?? 0, 0) + i5 };
    });
    i$1(this, "onKeyDown", Fe((t5) => {
      if ("Proxy" in window && (!t5.shiftKey && /^[A-Z]$/.test(t5.key) || t5.shiftKey && /^[a-z]$/.test(t5.key)) && (t5 = new Proxy(t5, { get(a8, l7) {
        let s5 = a8[l7];
        return typeof s5 == "function" ? s5.bind(a8) : l7 === "key" ? t5.shiftKey ? a8.key.toUpperCase() : a8.key.toLowerCase() : s5;
      } })), !D6(t5.target)) {
        if ((t5.key === Q.ESCAPE || t5.key === Q.ENTER) && this.state.croppingElementId) {
          this.finishImageCropping();
          return;
        }
        let a8 = at$1(this.scene.getNonDeletedElementsMap(), this.state);
        if (a8.length === 1 && Ye$1(a8[0]) && t5.key === Q.ENTER) {
          this.startImageCropping(a8[0]);
          return;
        }
        if (t5.key === Q.ESCAPE && this.flowChartCreator.isCreatingChart) {
          this.flowChartCreator.clear(), this.triggerRender(true);
          return;
        }
        let l7 = C$(t5.key);
        if (t5[Q.CTRL_OR_CMD] && l7 && !t5.shiftKey) {
          t5.preventDefault();
          let s5 = at$1(this.scene.getNonDeletedElementsMap(), this.state);
          s5.length === 1 && Og$1(s5[0]) && this.flowChartCreator.createNodes(s5[0], this.scene.getNonDeletedElementsMap(), this.state, Hu(t5.key)), this.flowChartCreator.pendingNodes?.length && !iJ(this.flowChartCreator.pendingNodes, this.canvas.width / window.devicePixelRatio, this.canvas.height / window.devicePixelRatio, { offsetLeft: this.state.offsetLeft, offsetTop: this.state.offsetTop, scrollX: this.state.scrollX, scrollY: this.state.scrollY, zoom: this.state.zoom }, this.scene.getNonDeletedElementsMap(), this.getEditorUIOffsets()) && this.scrollToContent(this.flowChartCreator.pendingNodes, { animate: true, duration: 300, fitToContent: true, canvasOffsets: this.getEditorUIOffsets() });
          return;
        }
        if (t5.altKey) {
          let s5 = at$1(this.scene.getNonDeletedElementsMap(), this.state);
          if (s5.length === 1 && l7) {
            t5.preventDefault();
            let c8 = this.flowChartNavigator.exploreByDirection(s5[0], this.scene.getNonDeletedElementsMap(), Hu(t5.key));
            if (c8) {
              this.setState((d3) => ({ selectedElementIds: Ha$1({ [c8]: true }, d3) }));
              let m8 = this.scene.getNonDeletedElementsMap().get(c8);
              m8 && !iJ([m8], this.canvas.width / window.devicePixelRatio, this.canvas.height / window.devicePixelRatio, { offsetLeft: this.state.offsetLeft, offsetTop: this.state.offsetTop, scrollX: this.state.scrollX, scrollY: this.state.scrollY, zoom: this.state.zoom }, this.scene.getNonDeletedElementsMap(), this.getEditorUIOffsets()) && this.scrollToContent(m8, { animate: true, duration: 300, canvasOffsets: this.getEditorUIOffsets() });
            }
            return;
          }
        }
      }
      if (t5[Q.CTRL_OR_CMD] && t5.key === Q.P && !t5.shiftKey && !t5.altKey) {
        this.setToast({ message: g("commandPalette.shortcutHint", { shortcut: Ye("commandPalette") }) }), t5.preventDefault();
        return;
      }
      if (t5[Q.CTRL_OR_CMD] && t5.key.toLowerCase() === Q.V && (Rd = t5.shiftKey, clearTimeout(pT), pT = window.setTimeout(() => {
        Rd = false;
      }, 100)), t5[Q.CTRL_OR_CMD] && ag(t5.target) && (t5.code === D1.MINUS || t5.code === D1.EQUAL)) {
        t5.preventDefault();
        return;
      }
      if (ag(t5.target) && t5.key !== Q.ESCAPE || C$(t5.key) && D6(t5.target)) return;
      if (t5.key === Q.QUESTION_MARK) {
        this.setState({ openDialog: { name: "help" } });
        return;
      } else if (t5.key.toLowerCase() === Q.E && t5.shiftKey && t5[Q.CTRL_OR_CMD]) {
        t5.preventDefault(), this.setState({ openDialog: { name: "imageExport" } });
        return;
      }
      if (t5.key === Q.PAGE_UP || t5.key === Q.PAGE_DOWN) {
        let a8 = (t5.shiftKey ? this.state.width : this.state.height) / this.state.zoom.value;
        t5.key === Q.PAGE_DOWN && (a8 = -a8), t5.shiftKey ? this.translateCanvas((l7) => ({ scrollX: l7.scrollX + a8 })) : this.translateCanvas((l7) => ({ scrollY: l7.scrollY + a8 }));
      }
      if (this.state.openDialog?.name === "elementLinkSelector" || this.actionManager.handleKeyDown(t5) || this.state.viewModeEnabled) return;
      if (t5[Q.CTRL_OR_CMD] && this.state.isBindingEnabled && this.setState({ isBindingEnabled: false }), C$(t5.key)) {
        let a8 = this.scene.getSelectedElements({ selectedElementIds: this.state.selectedElementIds, includeBoundTextElement: true, includeElementsInFrames: true }), l7 = a8.find(X$1), s5 = /* @__PURE__ */ new Set();
        a8.filter(X$1).filter((p3) => {
          let u3 = p3.startBinding && !a8.some((f3) => f3.id === p3.startBinding?.elementId), h3 = p3.endBinding && !a8.some((f3) => f3.id === p3.endBinding?.elementId);
          return u3 || h3;
        }).forEach((p3) => s5.add(p3.id)), a8 = a8.filter((p3) => !s5.has(p3.id));
        let c8 = this.getEffectiveGridSize() && (t5.shiftKey ? fE : this.getEffectiveGridSize()) || (t5.shiftKey ? UE : fE), m8 = 0, d3 = 0;
        t5.key === Q.ARROW_LEFT ? m8 = -c8 : t5.key === Q.ARROW_RIGHT ? m8 = c8 : t5.key === Q.ARROW_UP ? d3 = -c8 : t5.key === Q.ARROW_DOWN && (d3 = c8), a8.forEach((p3) => {
          Y(p3, { x: p3.x + m8, y: p3.y + d3 }, false), Jt(p3, this.scene.getNonDeletedElementsMap(), { simultaneouslyUpdated: a8 });
        }), this.setState({ suggestedBindings: _N(a8.filter((p3) => p3.id !== l7?.id || c8 !== 0), this.scene.getNonDeletedElementsMap(), this.state.zoom) }), this.scene.triggerUpdate(), t5.preventDefault();
      } else if (t5.key === Q.ENTER) {
        let a8 = this.scene.getSelectedElements(this.state);
        if (a8.length === 1) {
          let l7 = a8[0];
          if (t5[Q.CTRL_OR_CMD]) ae(l7) && (!this.state.editingLinearElement || this.state.editingLinearElement.elementId !== a8[0].id) && (this.store.shouldCaptureIncrement(), X$1(l7) || this.setState({ editingLinearElement: new z$1(l7) }));
          else if (k$2(l7) || pB(l7)) {
            let s5;
            k$2(l7) || (s5 = l7);
            let c8 = cB(l7, this.state, this.scene.getNonDeletedElementsMap()), m8 = c8.x, d3 = c8.y;
            this.startTextEditing({ sceneX: m8, sceneY: d3, container: s5 }), t5.preventDefault();
            return;
          } else de(l7) && this.setState({ editingFrame: l7.id });
        }
      } else if (!t5.ctrlKey && !t5.altKey && !t5.metaKey && !this.state.newElement && !this.state.selectionElement && !this.state.selectedElementsAreBeingDragged) {
        let a8 = iP(t5.key);
        a8 ? (this.state.activeTool.type !== a8 && le("toolbar", a8, `keyboard (${this.device.editor.isMobile ? "mobile" : "desktop"})`), a8 === "arrow" && this.state.activeTool.type === "arrow" && this.setState((l7) => ({ currentItemArrowType: l7.currentItemArrowType === Ws$1.sharp ? Ws$1.round : l7.currentItemArrowType === Ws$1.round ? Ws$1.elbow : Ws$1.sharp })), this.setActiveTool({ type: a8 }), t5.stopPropagation()) : t5.key === Q.Q && (this.toggleLock("keyboard"), t5.stopPropagation());
      }
      if (t5.key === Q.SPACE && fe.pointers.size === 0 && (Mn = true, Jb(this.interactiveCanvas, mo.GRAB), t5.preventDefault()), (t5.key === Q.G || t5.key === Q.S) && !t5.altKey && !t5[Q.CTRL_OR_CMD]) {
        let a8 = this.scene.getSelectedElements(this.state);
        if (this.state.activeTool.type === "selection" && !a8.length) return;
        t5.key === Q.G && (Am(this.state.activeTool.type) || a8.some((l7) => Am(l7.type))) && (this.setState({ openPopup: "elementBackground" }), t5.stopPropagation()), t5.key === Q.S && (this.setState({ openPopup: "elementStroke" }), t5.stopPropagation());
      }
      if (!t5[Q.CTRL_OR_CMD] && t5.shiftKey && t5.key.toLowerCase() === Q.F) {
        let a8 = this.scene.getSelectedElements(this.state);
        if (this.state.activeTool.type === "selection" && !a8.length) return;
        (this.state.activeTool.type === "text" || a8.find((l7) => k$2(l7) || oe(l7, this.scene.getNonDeletedElementsMap()))) && (t5.preventDefault(), this.setState({ openPopup: "fontFamily" }));
      }
      if (t5.key === Q.K && !t5.altKey && !t5[Q.CTRL_OR_CMD]) {
        this.state.activeTool.type === "laser" ? this.setActiveTool({ type: "selection" }) : this.setActiveTool({ type: "laser" });
        return;
      }
      t5[Q.CTRL_OR_CMD] && (t5.key === Q.BACKSPACE || t5.key === Q.DELETE) && st.set(In, "clearCanvas");
      let r5 = t5.key.toLocaleLowerCase(), n8 = r5 === Q.S && t5.shiftKey, i5 = t5.key === Q.I || r5 === Q.G && t5.shiftKey;
      (n8 || i5) && this.openEyeDropper({ type: n8 ? "stroke" : "background" });
    }));
    i$1(this, "onKeyUp", Fe((t5) => {
      if (t5.key === Q.SPACE && (this.state.viewModeEnabled || this.state.openDialog?.name === "elementLinkSelector" ? Jb(this.interactiveCanvas, mo.GRAB) : this.state.activeTool.type === "selection" ? Hb(this.interactiveCanvas) : ($2(this.interactiveCanvas, this.state), this.setState({ selectedElementIds: Ha$1({}, this.state), selectedGroupIds: {}, editingGroupId: null, activeEmbeddable: null })), Mn = false), !t5[Q.CTRL_OR_CMD] && !this.state.isBindingEnabled && this.setState({ isBindingEnabled: true }), C$(t5.key) && (BN(this.scene.getSelectedElements(this.state).filter(ae), this.scene.getNonDeletedElementsMap(), this.scene.getNonDeletedElements(), this.scene, Fa$1(this.state), this.state.selectedLinearElement?.selectedPointsIndices ?? [], this.state.zoom), this.setState({ suggestedBindings: [] })), t5.altKey || this.flowChartNavigator.isExploring && (this.flowChartNavigator.clear(), this.syncActionResult({ captureUpdate: dr.IMMEDIATELY })), !t5[Q.CTRL_OR_CMD] && this.flowChartCreator.isCreatingChart) {
        this.flowChartCreator.pendingNodes?.length && this.scene.insertElements(this.flowChartCreator.pendingNodes);
        let r5 = this.flowChartCreator.pendingNodes?.[0];
        r5 && (this.setState((n8) => ({ selectedElementIds: Ha$1({ [r5.id]: true }, n8) })), iJ([r5], this.canvas.width / window.devicePixelRatio, this.canvas.height / window.devicePixelRatio, { offsetLeft: this.state.offsetLeft, offsetTop: this.state.offsetTop, scrollX: this.state.scrollX, scrollY: this.state.scrollY, zoom: this.state.zoom }, this.scene.getNonDeletedElementsMap(), this.getEditorUIOffsets()) || this.scrollToContent(r5, { animate: true, duration: 300, canvasOffsets: this.getEditorUIOffsets() })), this.flowChartCreator.clear(), this.syncActionResult({ captureUpdate: dr.IMMEDIATELY });
      }
    }));
    i$1(this, "isToolSupported", (t5) => this.props.UIOptions.tools?.[t5] !== false);
    i$1(this, "setActiveTool", (t5) => {
      if (!this.isToolSupported(t5.type)) {
        console.warn(`"${t5.type}" tool is disabled via "UIOptions.canvasActions.tools.${t5.type}"`);
        return;
      }
      let r5 = $r(this.state, t5);
      r5.type === "hand" ? Jb(this.interactiveCanvas, mo.GRAB) : Mn || $2(this.interactiveCanvas, { ...this.state, activeTool: r5 }), og(document.activeElement) && this.focusContainer(), na(r5.type) || this.setState({ suggestedBindings: [] }), r5.type === "image" && this.onImageAction({ insertOnCanvasDirectly: (t5.type === "image" && t5.insertOnCanvasDirectly) ?? false }), this.setState((n8) => {
        let i5 = { snapLines: n8.snapLines.length ? [] : n8.snapLines, originSnapOffset: null, activeEmbeddable: null };
        return r5.type === "freedraw" && this.store.shouldCaptureIncrement(), r5.type !== "selection" ? { ...n8, activeTool: r5, selectedElementIds: Ha$1({}, n8), selectedGroupIds: Ha$1({}, n8), editingGroupId: null, multiElement: null, ...i5 } : { ...n8, activeTool: r5, ...i5 };
      });
    });
    i$1(this, "setOpenDialog", (t5) => {
      this.setState({ openDialog: t5 });
    });
    i$1(this, "setCursor", (t5) => {
      Jb(this.interactiveCanvas, t5);
    });
    i$1(this, "resetCursor", () => {
      Hb(this.interactiveCanvas);
    });
    i$1(this, "isTouchScreenMultiTouchGesture", () => fe.pointers.size >= 2);
    i$1(this, "getName", () => this.state.name || this.props.name || `${g("labels.untitled")}-${ng()}`);
    i$1(this, "onGestureStart", Fe((t5) => {
      t5.preventDefault(), this.isTouchScreenMultiTouchGesture() && this.setState({ selectedElementIds: Ha$1({}, this.state), activeEmbeddable: null }), fe.initialScale = this.state.zoom.value;
    }));
    i$1(this, "onGestureChange", Fe((t5) => {
      if (t5.preventDefault(), this.isTouchScreenMultiTouchGesture()) return;
      let r5 = fe.initialScale;
      r5 && this.setState((n8) => ({ ...Qo({ viewportX: this.lastViewportPosition.x, viewportY: this.lastViewportPosition.y, nextZoom: Oa(r5 * t5.scale) }, n8) }));
    }));
    i$1(this, "onGestureEnd", Fe((t5) => {
      t5.preventDefault(), this.isTouchScreenMultiTouchGesture() && this.setState({ previousSelectedElementIds: {}, selectedElementIds: Ha$1(this.state.previousSelectedElementIds, this.state) }), fe.initialScale = null;
    }));
    i$1(this, "startTextEditing", ({ sceneX: t5, sceneY: r5, insertAtParentCenter: n8 = true, container: i5, autoEdit: a8 = true }) => {
      let l7 = false, s5 = n8 && this.getTextWysiwygSnappedToCenterPosition(t5, r5, this.state, i5);
      i5 && s5 && (oe(i5, this.scene.getNonDeletedElementsMap()) || (l7 = true));
      let c8 = null, m8 = this.scene.getSelectedElements(this.state);
      m8.length === 1 ? k$2(m8[0]) ? c8 = m8[0] : i5 ? c8 = oe(m8[0], this.scene.getNonDeletedElementsMap()) : c8 = this.getTextElementAtPosition(t5, r5) : c8 = this.getTextElementAtPosition(t5, r5);
      let d3 = c8?.fontFamily || this.state.currentItemFontFamily, p3 = c8?.lineHeight || ko(d3), u3 = this.state.currentItemFontSize;
      if (!c8 && l7 && i5 && !ee(i5)) {
        let x3 = Td(Ee({ fontSize: u3, fontFamily: d3 }), p3), T3 = Ld$1(u3, p3), E3 = Math.max(i5.height, T3), w3 = Math.max(i5.width, x3);
        Y(i5, { height: E3, width: w3 }), t5 = i5.x + w3 / 2, r5 = i5.y + E3 / 2, s5 && (s5 = this.getTextWysiwygSnappedToCenterPosition(t5, r5, this.state, i5));
      }
      let h3 = this.getTopLayerFrameAtSceneCoords({ x: t5, y: r5 }), f3 = c8 || qt({ x: s5 ? s5.elementCenterX : t5, y: s5 ? s5.elementCenterY : r5, strokeColor: this.state.currentItemStrokeColor, backgroundColor: this.state.currentItemBackgroundColor, fillStyle: this.state.currentItemFillStyle, strokeWidth: this.state.currentItemStrokeWidth, strokeStyle: this.state.currentItemStrokeStyle, roughness: this.state.currentItemRoughness, opacity: this.state.currentItemOpacity, text: "", fontSize: u3, fontFamily: d3, textAlign: s5 ? "center" : this.state.currentItemTextAlign, verticalAlign: s5 ? kt.MIDDLE : go, containerId: l7 ? i5?.id : void 0, groupIds: i5?.groupIds ?? [], lineHeight: p3, angle: i5?.angle ?? 0, frameId: h3 ? h3.id : null });
      if (!c8 && l7 && i5 && Y(i5, { boundElements: (i5.boundElements || []).concat({ type: "text", id: f3.id }) }), this.setState({ editingTextElement: f3 }), !c8) if (i5 && l7) {
        let b3 = this.scene.getElementIndex(i5.id);
        this.scene.insertElementAtIndex(f3, b3 + 1);
      } else this.scene.insertElement(f3);
      a8 || c8 || i5 ? this.handleTextWysiwyg(f3, { isExistingElement: !!c8 }) : this.setState({ newElement: f3, multiElement: null });
    });
    i$1(this, "startImageCropping", (t5) => {
      this.store.shouldCaptureIncrement(), this.setState({ croppingElementId: t5.id });
    });
    i$1(this, "finishImageCropping", () => {
      this.state.croppingElementId && (this.store.shouldCaptureIncrement(), this.setState({ croppingElementId: null }));
    });
    i$1(this, "handleCanvasDoubleClick", (t5) => {
      if (this.state.multiElement || this.state.activeTool.type !== "selection") return;
      let r5 = this.scene.getSelectedElements(this.state), { x: n8, y: i5 } = Dn(t5, this.state);
      if (r5.length === 1 && ae(r5[0])) {
        if (t5[Q.CTRL_OR_CMD] && (!this.state.editingLinearElement || this.state.editingLinearElement.elementId !== r5[0].id) && !X$1(r5[0])) {
          this.store.shouldCaptureIncrement(), this.setState({ editingLinearElement: new z$1(r5[0]) });
          return;
        } else if (this.state.selectedLinearElement && X$1(r5[0])) {
          let l7 = z$1.getSegmentMidpointHitCoords(this.state.selectedLinearElement, { x: n8, y: i5 }, this.state, this.scene.getNonDeletedElementsMap()), s5 = l7 ? z$1.getSegmentMidPointIndex(this.state.selectedLinearElement, this.state, l7, this.scene.getNonDeletedElementsMap()) : -1;
          if (s5 && s5 > -1) {
            this.store.shouldCaptureIncrement(), z$1.deleteFixedSegment(r5[0], s5);
            let c8 = z$1.getSegmentMidpointHitCoords({ ...this.state.selectedLinearElement, segmentMidPointHoveredCoords: null }, { x: n8, y: i5 }, this.state, this.scene.getNonDeletedElementsMap()), m8 = c8 ? z$1.getSegmentMidPointIndex(this.state.selectedLinearElement, this.state, c8, this.scene.getNonDeletedElementsMap()) : null;
            this.setState({ selectedLinearElement: { ...this.state.selectedLinearElement, pointerDownState: { ...this.state.selectedLinearElement.pointerDownState, segmentMidpoint: { index: m8, value: l7, added: false } }, segmentMidPointHoveredCoords: c8 } });
            return;
          }
        }
      }
      if (r5.length === 1 && Ye$1(r5[0])) {
        this.startImageCropping(r5[0]);
        return;
      }
      if (Hb(this.interactiveCanvas), dF(this.state).length > 0) {
        let l7 = this.getElementAtPosition(n8, i5), s5 = l7 && lF(l7, this.state.selectedGroupIds);
        if (s5) {
          this.store.shouldCaptureIncrement(), this.setState((c8) => ({ ...c8, ...aF({ editingGroupId: s5, selectedElementIds: { [l7.id]: true } }, this.scene.getNonDeletedElements(), c8, this) }));
          return;
        }
      }
      if (Hb(this.interactiveCanvas), !t5[Q.CTRL_OR_CMD] && !this.state.viewModeEnabled) {
        let l7 = this.getElementAtPosition(n8, i5);
        if (gt$1(l7)) {
          this.setState({ activeEmbeddable: { element: l7, state: "active" } });
          return;
        }
        let s5 = this.getTextBindableContainerAtPosition(n8, i5);
        if (s5 && (bn(s5) || !Wt(s5.backgroundColor) || xm({ x: n8, y: i5, element: s5, shape: ti(s5, this.scene.getNonDeletedElementsMap()), threshold: this.getElementHitThreshold() }))) {
          let c8 = cB(s5, this.state, this.scene.getNonDeletedElementsMap());
          n8 = c8.x, i5 = c8.y;
        }
        this.startTextEditing({ sceneX: n8, sceneY: i5, insertAtParentCenter: !t5.altKey, container: s5 });
      }
    });
    i$1(this, "getElementLinkAtPosition", (t5, r5) => {
      let n8 = this.scene.getNonDeletedElements(), i5 = -1;
      for (let a8 = n8.length - 1; a8 >= 0; a8--) {
        let l7 = n8[a8];
        if (r5 && l7.id === r5.id && (i5 = a8), l7.link && a8 >= i5 && BO(l7, this.scene.getNonDeletedElementsMap(), this.state, u$1(t5.x, t5.y), this.device.editor.isMobile)) return l7;
      }
    });
    i$1(this, "redirectToLink", (t5, r5) => {
      let n8 = ie(u$1(this.lastPointerDownEvent.clientX, this.lastPointerDownEvent.clientY), u$1(this.lastPointerUpEvent.clientX, this.lastPointerUpEvent.clientY));
      if (!this.hitLinkElement || n8 > As) return;
      let i5 = Dn(this.lastPointerDownEvent, this.state), a8 = this.scene.getNonDeletedElementsMap(), l7 = BO(this.hitLinkElement, a8, this.state, u$1(i5.x, i5.y), this.device.editor.isMobile), s5 = Dn(this.lastPointerUpEvent, this.state), c8 = BO(this.hitLinkElement, a8, this.state, u$1(s5.x, s5.y), this.device.editor.isMobile);
      if (l7 && c8) {
        lu();
        let m8 = this.hitLinkElement.link;
        if (m8) {
          m8 = dn(m8);
          let d3;
          if (this.props.onLinkOpen && (d3 = yg("excalidraw-link", t5.nativeEvent), this.props.onLinkOpen({ ...this.hitLinkElement, link: m8 }, d3)), !d3?.defaultPrevented) {
            let p3 = gB(m8) ? "_self" : "_blank", u3 = window.open(void 0, p3);
            u3 && (u3.opener = null, u3.location = m8);
          }
        }
      }
    });
    i$1(this, "getTopLayerFrameAtSceneCoords", (t5) => {
      let r5 = this.scene.getNonDeletedElementsMap(), n8 = this.scene.getNonDeletedFramesLikes().filter((i5) => mH(t5, i5, r5));
      return n8.length ? n8[n8.length - 1] : null;
    });
    i$1(this, "handleCanvasPointerMove", (t5) => {
      this.savePointer(t5.clientX, t5.clientY, this.state.cursorButton), this.lastPointerMoveEvent = t5.nativeEvent, fe.pointers.has(t5.pointerId) && fe.pointers.set(t5.pointerId, { x: t5.clientX, y: t5.clientY });
      let r5 = fe.initialScale;
      if (fe.pointers.size === 2 && fe.lastCenter && r5 && fe.initialDistance) {
        let u3 = Ou(fe.pointers), h3 = u3.x - fe.lastCenter.x, f3 = u3.y - fe.lastCenter.y;
        fe.lastCenter = u3;
        let b3 = Fu(Array.from(fe.pointers.values())), x3 = this.state.activeTool.type === "freedraw" && this.state.penMode ? 1 : b3 / fe.initialDistance, T3 = x3 ? Oa(r5 * x3) : this.state.zoom.value;
        this.setState((E3) => {
          let w3 = Qo({ viewportX: u3.x, viewportY: u3.y, nextZoom: T3 }, E3);
          this.translateCanvas({ zoom: w3.zoom, scrollX: w3.scrollX + 2 * (h3 / T3), scrollY: w3.scrollY + 2 * (f3 / T3), shouldCacheIgnoreZoom: true });
        }), this.resetShouldCacheIgnoreZoomDebounced();
      } else fe.lastCenter = fe.initialDistance = fe.initialScale = null;
      if (Mn || ll || Dg || nd(this.state)) return;
      let i5 = Gu(Pg, t5.clientX - this.state.offsetLeft, t5.clientY - this.state.offsetTop).isOverEither;
      !this.state.newElement && !this.state.selectionElement && !this.state.selectedElementsAreBeingDragged && !this.state.multiElement && (i5 ? Hb(this.interactiveCanvas) : $2(this.interactiveCanvas, this.state));
      let a8 = Dn(t5, this.state), { x: l7, y: s5 } = a8;
      if (!this.state.newElement && DF(this.state.activeTool.type)) {
        let { originOffset: u3, snapLines: h3 } = LF(this.scene.getNonDeletedElements(), this, { x: l7, y: s5 }, t5, this.scene.getNonDeletedElementsMap());
        this.setState((f3) => {
          let b3 = Dg$1(f3.snapLines, h3), x3 = f3.originSnapOffset ? Dg$1(f3.originSnapOffset, u3) : u3;
          return f3.snapLines === b3 && f3.originSnapOffset === x3 ? null : { snapLines: b3, originSnapOffset: x3 };
        });
      } else !this.state.newElement && !this.state.selectedElementsAreBeingDragged && !this.state.selectionElement && this.setState((u3) => u3.snapLines.length ? { snapLines: [] } : null);
      if (this.state.editingLinearElement && !this.state.editingLinearElement.isDragging) {
        let u3 = z$1.handlePointerMove(t5, l7, s5, this, this.scene.getNonDeletedElementsMap());
        u3 && u3 !== this.state.editingLinearElement && reactDomExports.flushSync(() => {
          this.setState({ editingLinearElement: u3 });
        }), u3?.lastUncommittedPoint != null ? this.maybeSuggestBindingAtCursor(a8, u3.elbowed) : reactDomExports.flushSync(() => {
          this.setState({ suggestedBindings: [] });
        });
      }
      if (N6(this.state.activeTool.type)) {
        let { newElement: u3 } = this.state;
        Pr(u3, false) ? this.maybeSuggestBindingsForLinearElementAtCoords(u3, [a8], this.state.startBoundElement) : this.maybeSuggestBindingAtCursor(a8, false);
      }
      if (this.state.multiElement) {
        let { multiElement: u3 } = this.state, { x: h3, y: f3 } = u3, { points: b3, lastCommittedPoint: x3 } = u3, T3 = b3[b3.length - 1];
        if ($2(this.interactiveCanvas, this.state), T3 === x3) ie(u$1(l7 - h3, s5 - f3), T3) >= Ks$1 ? Y(u3, { points: [...b3, u$1(l7 - h3, s5 - f3)] }, false) : Jb(this.interactiveCanvas, mo.POINTER);
        else if (b3.length > 2 && x3 && ie(u$1(l7 - h3, s5 - f3), x3) < Ks$1) Jb(this.interactiveCanvas, mo.POINTER), Y(u3, { points: b3.slice(0, -1) }, false);
        else {
          let [E3, w3] = Vr(l7, s5, t5[Q.CTRL_OR_CMD] || X$1(u3) ? null : this.getEffectiveGridSize()), [S3, I3] = u3?.lastCommittedPoint ?? [0, 0], _3 = E3 - h3 - S3, k2 = w3 - f3 - I3;
          ga(t5) && ({ width: _3, height: k2 } = Va(S3 + h3, I3 + f3, E3, w3)), Kt(b3, this.state.zoom.value) && Jb(this.interactiveCanvas, mo.POINTER), Y(u3, { points: [...b3.slice(0, -1), u$1(S3 + _3, I3 + k2)] }, false, { isDragging: true }), this.triggerRender(false);
        }
        return;
      }
      if (!!t5.buttons || this.state.activeTool.type !== "selection" && this.state.activeTool.type !== "text" && this.state.activeTool.type !== "eraser") return;
      let m8 = this.scene.getNonDeletedElements(), d3 = this.scene.getSelectedElements(this.state);
      if (d3.length === 1 && !i5 && !this.state.editingLinearElement) {
        if (this.state.selectedLinearElement && this.handleHoverSelectedLinearElement(this.state.selectedLinearElement, l7, s5), (!this.state.selectedLinearElement || this.state.selectedLinearElement.hoverPointIndex === -1) && this.state.openDialog?.name !== "elementLinkSelector" && !(d3.length === 1 && X$1(d3[0]))) {
          let u3 = E9(m8, this.state, l7, s5, this.state.zoom, t5.pointerType, this.scene.getNonDeletedElementsMap(), this.device);
          if (u3 && u3.transformHandleType) {
            Jb(this.interactiveCanvas, h9(u3));
            return;
          }
        }
      } else if (d3.length > 1 && !i5 && this.state.openDialog?.name !== "elementLinkSelector") {
        let u3 = g9($e$1(d3), l7, s5, this.state.zoom, t5.pointerType, this.device);
        if (u3) {
          Jb(this.interactiveCanvas, h9({ transformHandleType: u3 }));
          return;
        }
      }
      let p3 = this.getElementAtPosition(a8.x, a8.y);
      this.hitLinkElement = this.getElementLinkAtPosition(a8, p3), !td$1(this.state) && (this.hitLinkElement && !this.state.selectedElementIds[this.hitLinkElement.id] ? (Jb(this.interactiveCanvas, mo.POINTER), Tv(this.hitLinkElement, this.state, this.scene.getNonDeletedElementsMap())) : (lu(), p3 && (p3.link || Bo(p3)) && this.state.selectedElementIds[p3.id] && !this.state.contextMenu && !this.state.showHyperlinkPopup ? this.setState({ showHyperlinkPopup: "info" }) : this.state.activeTool.type === "text" ? Jb(this.interactiveCanvas, k$2(p3) ? mo.TEXT : mo.CROSSHAIR) : this.state.viewModeEnabled ? Jb(this.interactiveCanvas, mo.GRAB) : this.state.openDialog?.name === "elementLinkSelector" ? Jb(this.interactiveCanvas, mo.AUTO) : i5 ? Jb(this.interactiveCanvas, mo.AUTO) : this.state.selectedLinearElement ? this.handleHoverSelectedLinearElement(this.state.selectedLinearElement, l7, s5) : t5[Q.CTRL_OR_CMD] ? Jb(this.interactiveCanvas, mo.AUTO) : (p3 || this.isHittingCommonBoundingBoxOfSelectedElements(a8, d3)) && !p3?.locked && (p3 && gt$1(p3) && this.isIframeLikeElementCenter(p3, t5, l7, s5) ? (Jb(this.interactiveCanvas, mo.POINTER), this.setState({ activeEmbeddable: { element: p3, state: "hover" } })) : (!p3 || !X$1(p3)) && (Jb(this.interactiveCanvas, mo.MOVE), this.state.activeEmbeddable?.state === "hover" && this.setState({ activeEmbeddable: null })))), this.state.openDialog?.name === "elementLinkSelector" && p3 ? this.setState((u3) => ({ hoveredElementIds: Dg$1(u3.hoveredElementIds, aF({ editingGroupId: u3.editingGroupId, selectedElementIds: { [p3.id]: true } }, this.scene.getNonDeletedElements(), u3, this).selectedElementIds) })) : this.state.openDialog?.name === "elementLinkSelector" && !p3 && this.setState((u3) => ({ hoveredElementIds: Dg$1(u3.hoveredElementIds, {}) })));
    });
    i$1(this, "handleEraser", (t5, r5, n8) => {
      this.eraserTrail.addPointToPath(n8.x, n8.y);
      let i5 = false, a8 = /* @__PURE__ */ new Set(), l7 = this.scene.getNonDeletedElements(), s5 = (u3) => {
        for (let h3 of u3) {
          if (h3.locked) return;
          if (t5.altKey ? this.elementsPendingErasure.delete(h3.id) && (i5 = true) : this.elementsPendingErasure.has(h3.id) || (i5 = true, this.elementsPendingErasure.add(h3.id)), i5 && h3.groupIds?.length) {
            let f3 = h3.groupIds.at(-1);
            if (!a8.has(f3)) {
              a8.add(f3);
              let b3 = an(l7, f3);
              for (let x3 of b3) t5.altKey ? this.elementsPendingErasure.delete(x3.id) : this.elementsPendingErasure.add(x3.id);
            }
          }
        }
      }, c8 = ie(u$1(r5.lastCoords.x, r5.lastCoords.y), u$1(n8.x, n8.y)), m8 = this.getElementHitThreshold(), d3 = { ...r5.lastCoords }, p3 = 0;
      for (; p3 <= c8; ) {
        let u3 = this.getElementsAtPosition(d3.x, d3.y);
        if (s5(u3), p3 === c8) break;
        p3 = Math.min(p3 + m8, c8);
        let h3 = p3 / c8, f3 = (1 - h3) * d3.x + h3 * n8.x, b3 = (1 - h3) * d3.y + h3 * n8.y;
        d3.x = f3, d3.y = b3;
      }
      if (r5.lastCoords.x = n8.x, r5.lastCoords.y = n8.y, i5) {
        for (let u3 of this.scene.getNonDeletedElements()) Ne(u3) && (this.elementsPendingErasure.has(u3.id) || this.elementsPendingErasure.has(u3.containerId)) && (t5.altKey ? (this.elementsPendingErasure.delete(u3.id), this.elementsPendingErasure.delete(u3.containerId)) : (this.elementsPendingErasure.add(u3.id), this.elementsPendingErasure.add(u3.containerId)));
        this.elementsPendingErasure = new Set(this.elementsPendingErasure), this.triggerRender();
      }
    });
    i$1(this, "handleTouchMove", (t5) => {
      sl = true;
    });
    i$1(this, "handleCanvasPointerDown", (t5) => {
      let r5 = t5.target;
      if (r5.setPointerCapture && r5.setPointerCapture(t5.pointerId), this.maybeCleanupAfterMissingPointerUp(t5.nativeEvent), this.maybeUnfollowRemoteUser(), this.state.searchMatches && (this.setState((d3) => ({ searchMatches: d3.searchMatches.map((p3) => ({ ...p3, focus: false })) })), st.set(cg, null)), this.state.contextMenu && this.setState({ contextMenu: null }), this.state.snapLines && this.setAppState({ snapLines: [] }), this.updateGestureOnPointerDown(t5), t5.pointerType === "touch" && this.state.newElement && this.state.newElement.type === "freedraw") {
        let d3 = this.state.newElement;
        this.updateScene({ ...d3.points.length < 10 ? { elements: this.scene.getElementsIncludingDeleted().filter((p3) => p3.id !== d3.id) } : {}, appState: { newElement: null, editingTextElement: null, startBoundElement: null, suggestedBindings: [], selectedElementIds: Ha$1(Object.keys(this.state.selectedElementIds).filter((p3) => p3 !== d3.id).reduce((p3, u3) => (p3[u3] = this.state.selectedElementIds[u3], p3), {}), this.state) }, captureUpdate: this.state.openDialog?.name === "elementLinkSelector" ? dr.EVENTUALLY : dr.NEVER });
        return;
      }
      let n8 = document.getSelection();
      if (n8?.anchorNode && n8.removeAllRanges(), this.maybeOpenContextMenuAfterPointerDownOnTouchDevices(t5), !this.state.penDetected && t5.pointerType === "pen" && this.setState((d3) => ({ penMode: true, penDetected: true })), !this.device.isTouchScreen && ["pen", "touch"].includes(t5.pointerType) && (this.device = Ig$1(this.device, { isTouchScreen: true })), ll || (this.lastPointerDownEvent = t5, this.handleCanvasPanUsingWheelOrSpaceDrag(t5))) return;
      if (this.setState({ lastPointerDownWith: t5.pointerType, cursorButton: "down" }), this.savePointer(t5.clientX, t5.clientY, "down"), t5.button === mE.ERASER && this.state.activeTool.type !== fn.eraser) {
        this.setState({ activeTool: $r(this.state, { type: fn.eraser, lastActiveToolBeforeEraser: this.state.activeTool }) }, () => {
          this.handleCanvasPointerDown(t5);
          let d3 = () => {
            p3(), u3?.(), td$1(this.state) && this.setState({ activeTool: $r(this.state, { ...this.state.activeTool.lastActiveTool || { type: fn.selection }, lastActiveToolBeforeEraser: null }) });
          }, p3 = Sg$1(window, "pointerup", d3, { once: true }), u3;
          requestAnimationFrame(() => {
            u3 = this.missingPointerEventCleanupEmitter.once(d3);
          });
        });
        return;
      }
      if (t5.button !== mE.MAIN && t5.button !== mE.TOUCH && t5.button !== mE.ERASER || fe.pointers.size > 1) return;
      let i5 = this.initialPointerDownState(t5);
      if (this.setState({ selectedElementsAreBeingDragged: false }), this.handleDraggingScrollBar(t5, i5) || (this.clearSelectionIfNotUsingSelection(), this.updateBindingEnabledOnPointerMove(t5), this.handleSelectionOnPointerDown(t5, i5)) || !(!this.state.penMode || t5.pointerType !== "touch" || this.state.activeTool.type === "selection" || this.state.activeTool.type === "text" || this.state.activeTool.type === "image")) return;
      if (this.state.activeTool.type === "text") this.handleTextOnPointerDown(t5, i5);
      else if (this.state.activeTool.type === "arrow" || this.state.activeTool.type === "line") this.handleLinearElementOnPointerDown(t5, this.state.activeTool.type, i5);
      else if (this.state.activeTool.type === "image") {
        Jb(this.interactiveCanvas, mo.CROSSHAIR);
        let d3 = this.state.pendingImageElementId && this.scene.getElement(this.state.pendingImageElementId);
        if (!d3) return;
        this.setState({ newElement: d3, pendingImageElementId: null, multiElement: null });
        let { x: p3, y: u3 } = Dn(t5, this.state), h3 = this.getTopLayerFrameAtSceneCoords({ x: p3, y: u3 });
        Y(d3, { x: p3, y: u3, frameId: h3 ? h3.id : null });
      } else this.state.activeTool.type === "freedraw" ? this.handleFreeDrawElementOnPointerDown(t5, this.state.activeTool.type, i5) : this.state.activeTool.type === "custom" ? $2(this.interactiveCanvas, this.state) : this.state.activeTool.type === fn.frame || this.state.activeTool.type === fn.magicframe ? this.createFrameElementOnPointerDown(i5, this.state.activeTool.type) : this.state.activeTool.type === "laser" ? this.laserTrails.startPath(i5.lastCoords.x, i5.lastCoords.y) : this.state.activeTool.type !== "eraser" && this.state.activeTool.type !== "hand" && this.createGenericElementOnPointerDown(this.state.activeTool.type, i5);
      this.props?.onPointerDown?.(this.state.activeTool, i5), this.onPointerDownEmitter.trigger(this.state.activeTool, i5, t5), this.state.activeTool.type === "eraser" && this.eraserTrail.startPath(i5.lastCoords.x, i5.lastCoords.y);
      let l7 = this.onPointerMoveFromPointerDownHandler(i5), s5 = this.onPointerUpFromPointerDownHandler(i5), c8 = this.onKeyDownFromPointerDownHandler(i5), m8 = this.onKeyUpFromPointerDownHandler(i5);
      this.missingPointerEventCleanupEmitter.once((d3) => s5(d3 || t5.nativeEvent)), (!this.state.viewModeEnabled || this.state.activeTool.type === "laser") && (window.addEventListener("pointermove", l7), window.addEventListener("pointerup", s5), window.addEventListener("keydown", c8), window.addEventListener("keyup", m8), i5.eventListeners.onMove = l7, i5.eventListeners.onUp = s5, i5.eventListeners.onKeyUp = m8, i5.eventListeners.onKeyDown = c8);
    });
    i$1(this, "handleCanvasPointerUp", (t5) => {
      this.removePointer(t5), this.lastPointerUpEvent = t5;
      let r5 = Dn({ clientX: t5.clientX, clientY: t5.clientY }, this.state), n8 = t5.timeStamp - (this.lastPointerDownEvent?.timeStamp ?? 0);
      if (this.device.editor.isMobile && n8 < 300) {
        let i5 = this.getElementAtPosition(r5.x, r5.y);
        if (gt$1(i5) && this.isIframeLikeElementCenter(i5, t5, r5.x, r5.y)) {
          this.handleEmbeddableCenterClick(i5);
          return;
        }
      }
      if (this.device.isTouchScreen) {
        let i5 = this.getElementAtPosition(r5.x, r5.y);
        this.hitLinkElement = this.getElementLinkAtPosition(r5, i5);
      }
      this.hitLinkElement && !this.state.selectedElementIds[this.hitLinkElement.id] ? n8 < 300 && gt$1(this.hitLinkElement) && !b7(this.hitLinkElement, this.scene.getNonDeletedElementsMap(), this.state, u$1(r5.x, r5.y)) ? this.handleEmbeddableCenterClick(this.hitLinkElement) : this.redirectToLink(t5, this.device.isTouchScreen) : this.state.viewModeEnabled && this.setState({ activeEmbeddable: null, selectedElementIds: {} });
    });
    i$1(this, "maybeOpenContextMenuAfterPointerDownOnTouchDevices", (t5) => {
      t5.pointerType === "touch" && (sl = false, Ur ? sl = true : Ur = window.setTimeout(() => {
        Ur = 0, sl || this.handleCanvasContextMenu(t5);
      }, ME));
    });
    i$1(this, "resetContextMenuTimer", () => {
      clearTimeout(Ur), Ur = 0, sl = false;
    });
    i$1(this, "maybeCleanupAfterMissingPointerUp", (t5) => {
      cl?.(), this.missingPointerEventCleanupEmitter.trigger(t5).clear();
    });
    i$1(this, "handleCanvasPanUsingWheelOrSpaceDrag", (t5) => {
      if (!(fe.pointers.size <= 1 && (t5.button === mE.WHEEL || t5.button === mE.MAIN && Mn || nd(this.state) || this.state.viewModeEnabled))) return false;
      ll = true, this.focusContainer(), this.state.editingTextElement || t5.preventDefault();
      let r5 = false, n8 = typeof window === void 0 ? false : /Linux/.test(window.navigator.platform);
      Jb(this.interactiveCanvas, mo.GRABBING);
      let { clientX: i5, clientY: a8 } = t5, l7 = Ad((c8) => {
        let m8 = i5 - c8.clientX, d3 = a8 - c8.clientY;
        if (i5 = c8.clientX, a8 = c8.clientY, n8 && !r5 && (Math.abs(m8) > 1 || Math.abs(d3) > 1)) {
          r5 = true;
          let p3 = (h3) => {
            document.body.removeEventListener("paste", p3), h3.stopPropagation();
          }, u3 = () => {
            setTimeout(() => {
              document.body.removeEventListener("paste", p3), window.removeEventListener("pointerup", u3);
            }, 100);
          };
          document.body.addEventListener("paste", p3), window.addEventListener("pointerup", u3);
        }
        this.translateCanvas({ scrollX: this.state.scrollX - m8 / this.state.zoom.value, scrollY: this.state.scrollY - d3 / this.state.zoom.value });
      }), s5 = Fe(cl = () => {
        cl = null, ll = false, Mn || (this.state.viewModeEnabled ? Jb(this.interactiveCanvas, mo.GRAB) : $2(this.interactiveCanvas, this.state)), this.setState({ cursorButton: "up" }), this.savePointer(t5.clientX, t5.clientY, "up"), window.removeEventListener("pointermove", l7), window.removeEventListener("pointerup", s5), window.removeEventListener("blur", s5), l7.flush();
      });
      return window.addEventListener("blur", s5), window.addEventListener("pointermove", l7, { passive: true }), window.addEventListener("pointerup", s5), true;
    });
    i$1(this, "clearSelectionIfNotUsingSelection", () => {
      this.state.activeTool.type !== "selection" && this.setState({ selectedElementIds: Ha$1({}, this.state), selectedGroupIds: {}, editingGroupId: null, activeEmbeddable: null });
    });
    i$1(this, "handleSelectionOnPointerDown", (t5, r5) => {
      if (this.state.activeTool.type === "selection") {
        let n8 = this.scene.getNonDeletedElements(), i5 = this.scene.getNonDeletedElementsMap(), a8 = this.scene.getSelectedElements(this.state);
        if (a8.length === 1 && !this.state.editingLinearElement && !X$1(a8[0]) && !(this.state.selectedLinearElement && this.state.selectedLinearElement.hoverPointIndex !== -1)) {
          let l7 = E9(n8, this.state, r5.origin.x, r5.origin.y, this.state.zoom, t5.pointerType, this.scene.getNonDeletedElementsMap(), this.device);
          l7 != null && (l7.transformHandleType === "rotation" ? (this.setState({ resizingElement: l7.element }), r5.resize.handleType = l7.transformHandleType) : (this.state.croppingElementId || this.setState({ resizingElement: l7.element }), r5.resize.handleType = l7.transformHandleType));
        } else a8.length > 1 && (r5.resize.handleType = g9($e$1(a8), r5.origin.x, r5.origin.y, this.state.zoom, t5.pointerType, this.device));
        if (r5.resize.handleType) r5.resize.isResizing = true, r5.resize.offset = un(T9(r5.resize.handleType, a8, i5, r5.origin.x, r5.origin.y)), a8.length === 1 && ae(a8[0]) && a8[0].points.length === 2 && (r5.resize.arrowDirection = M9(r5.resize.handleType, a8[0]));
        else {
          if (this.state.selectedLinearElement) {
            let c8 = this.state.editingLinearElement || this.state.selectedLinearElement, m8 = z$1.handlePointerDown(t5, this, this.store, r5.origin, c8, this.scene);
            if (m8.hitElement && (r5.hit.element = m8.hitElement), m8.linearElementEditor && (this.setState({ selectedLinearElement: m8.linearElementEditor }), this.state.editingLinearElement && this.setState({ editingLinearElement: m8.linearElementEditor })), m8.didAddPoint) return true;
          }
          if (r5.hit.element = r5.hit.element ?? this.getElementAtPosition(r5.origin.x, r5.origin.y), this.hitLinkElement = this.getElementLinkAtPosition(r5.origin, r5.hit.element), this.hitLinkElement) return true;
          if (this.state.croppingElementId && r5.hit.element?.id !== this.state.croppingElementId && this.finishImageCropping(), r5.hit.element && this.getElementLinkAtPosition({ x: r5.origin.x, y: r5.origin.y }, r5.hit.element)) return false;
          r5.hit.allHitElements = this.getElementsAtPosition(r5.origin.x, r5.origin.y);
          let l7 = r5.hit.element, s5 = r5.hit.allHitElements.some((c8) => this.isASelectedElement(c8));
          if ((l7 === null || !s5) && !t5.shiftKey && !r5.hit.hasHitCommonBoundingBoxOfSelectedElements && this.clearSelection(l7), this.state.editingLinearElement) this.setState({ selectedElementIds: Ha$1({ [this.state.editingLinearElement.elementId]: true }, this.state) });
          else if (l7 != null) {
            if (t5[Q.CTRL_OR_CMD]) return this.state.selectedElementIds[l7.id] || (r5.hit.wasAddedToSelection = true), this.setState((c8) => ({ ...cF(c8, l7), previousSelectedElementIds: this.state.selectedElementIds })), false;
            this.state.selectedElementIds[l7.id] || (this.state.editingGroupId && !Lb(l7, this.state.editingGroupId) && this.setState({ selectedElementIds: Ha$1({}, this.state), selectedGroupIds: {}, editingGroupId: null, activeEmbeddable: null }), !s5 && !r5.hit.hasHitCommonBoundingBoxOfSelectedElements && (this.setState((c8) => {
              let m8 = { ...c8.selectedElementIds, [l7.id]: true }, d3 = [];
              if (Object.keys(c8.selectedElementIds).forEach((p3) => {
                let u3 = this.scene.getElement(p3);
                u3 && d3.push(u3);
              }), de(l7)) co(d3, l7.id).forEach((p3) => {
                delete m8[p3.id];
              });
              else if (l7.frameId) m8[l7.frameId] && delete m8[l7.id];
              else {
                let p3 = l7.groupIds, u3 = new Set(p3.flatMap((h3) => an(this.scene.getNonDeletedElements(), h3)).filter((h3) => de(h3)).map((h3) => h3.id));
                u3.size > 0 && d3.forEach((h3) => {
                  h3.frameId && u3.has(h3.frameId) && (delete m8[h3.id], h3.groupIds.flatMap((f3) => an(this.scene.getNonDeletedElements(), f3)).forEach((f3) => {
                    delete m8[f3.id];
                  }));
                });
              }
              return c8.openDialog?.name === "elementLinkSelector" && (l7.groupIds.some((p3) => c8.selectedGroupIds[p3]) || (m8 = { [l7.id]: true })), { ...aF({ editingGroupId: c8.editingGroupId, selectedElementIds: m8 }, this.scene.getNonDeletedElements(), c8, this), showHyperlinkPopup: l7.link || Bo(l7) ? "info" : false };
            }), r5.hit.wasAddedToSelection = true));
          }
          this.setState({ previousSelectedElementIds: this.state.selectedElementIds });
        }
      }
      return false;
    });
    i$1(this, "handleTextOnPointerDown", (t5, r5) => {
      if (this.state.editingTextElement) return;
      let n8 = r5.origin.x, i5 = r5.origin.y, a8 = this.getElementAtPosition(n8, i5, { includeBoundTextElement: true }), l7 = this.getTextBindableContainerAtPosition(n8, i5);
      bn(a8) && (l7 = a8, n8 = a8.x + a8.width / 2, i5 = a8.y + a8.height / 2), this.startTextEditing({ sceneX: n8, sceneY: i5, insertAtParentCenter: !t5.altKey, container: l7, autoEdit: false }), Hb(this.interactiveCanvas), this.state.activeTool.locked || this.setState({ activeTool: $r(this.state, { type: "selection" }) });
    });
    i$1(this, "handleFreeDrawElementOnPointerDown", (t5, r5, n8) => {
      let [i5, a8] = Vr(n8.origin.x, n8.origin.y, null), l7 = this.getTopLayerFrameAtSceneCoords({ x: i5, y: a8 }), s5 = t5.pressure === 0.5, c8 = kB({ type: r5, x: i5, y: a8, strokeColor: this.state.currentItemStrokeColor, backgroundColor: this.state.currentItemBackgroundColor, fillStyle: this.state.currentItemFillStyle, strokeWidth: this.state.currentItemStrokeWidth, strokeStyle: this.state.currentItemStrokeStyle, roughness: this.state.currentItemRoughness, opacity: this.state.currentItemOpacity, roundness: null, simulatePressure: s5, locked: false, frameId: l7 ? l7.id : null, points: [u$1(0, 0)], pressures: s5 ? [] : [t5.pressure] });
      this.scene.insertElement(c8), this.setState((d3) => {
        let p3 = { ...d3.selectedElementIds };
        return delete p3[c8.id], { selectedElementIds: Ha$1(p3, d3) };
      });
      let m8 = Bn(n8.origin, this.scene.getNonDeletedElements(), this.scene.getNonDeletedElementsMap(), this.state.zoom);
      this.setState({ newElement: c8, startBoundElement: m8, suggestedBindings: [] });
    });
    i$1(this, "insertIframeElement", ({ sceneX: t5, sceneY: r5, width: n8, height: i5 }) => {
      let [a8, l7] = Vr(t5, r5, this.lastPointerDownEvent?.[Q.CTRL_OR_CMD] ? null : this.getEffectiveGridSize()), s5 = qB({ type: "iframe", x: a8, y: l7, strokeColor: "transparent", backgroundColor: "transparent", fillStyle: this.state.currentItemFillStyle, strokeWidth: this.state.currentItemStrokeWidth, strokeStyle: this.state.currentItemStrokeStyle, roughness: this.state.currentItemRoughness, roundness: this.getCurrentItemRoundness("iframe"), opacity: this.state.currentItemOpacity, locked: false, width: n8, height: i5 });
      return this.scene.insertElement(s5), s5;
    });
    i$1(this, "insertEmbeddableElement", ({ sceneX: t5, sceneY: r5, link: n8 }) => {
      let [i5, a8] = Vr(t5, r5, this.lastPointerDownEvent?.[Q.CTRL_OR_CMD] ? null : this.getEffectiveGridSize()), l7 = V2(n8);
      if (!l7) return;
      l7.error instanceof URIError && this.setToast({ message: g("toast.unrecognizedLinkFormat"), closable: true });
      let s5 = VB({ type: "embeddable", x: i5, y: a8, strokeColor: "transparent", backgroundColor: "transparent", fillStyle: this.state.currentItemFillStyle, strokeWidth: this.state.currentItemStrokeWidth, strokeStyle: this.state.currentItemStrokeStyle, roughness: this.state.currentItemRoughness, roundness: this.getCurrentItemRoundness("embeddable"), opacity: this.state.currentItemOpacity, locked: false, width: l7.intrinsicSize.w, height: l7.intrinsicSize.h, link: n8 });
      return this.scene.insertElement(s5), s5;
    });
    i$1(this, "createImageElement", ({ sceneX: t5, sceneY: r5, addToFrameUnderCursor: n8 = true }) => {
      let [i5, a8] = Vr(t5, r5, this.lastPointerDownEvent?.[Q.CTRL_OR_CMD] ? null : this.getEffectiveGridSize()), l7 = n8 ? this.getTopLayerFrameAtSceneCoords({ x: i5, y: a8 }) : null;
      return Wb({ type: "image", x: i5, y: a8, strokeColor: this.state.currentItemStrokeColor, backgroundColor: this.state.currentItemBackgroundColor, fillStyle: this.state.currentItemFillStyle, strokeWidth: this.state.currentItemStrokeWidth, strokeStyle: this.state.currentItemStrokeStyle, roughness: this.state.currentItemRoughness, roundness: null, opacity: this.state.currentItemOpacity, locked: false, frameId: l7 ? l7.id : null });
    });
    i$1(this, "handleLinearElementOnPointerDown", (t5, r5, n8) => {
      if (this.state.multiElement) {
        let { multiElement: i5 } = this.state;
        if (i5.type === "line" && Kt(i5.points, this.state.zoom.value)) {
          Y(i5, { lastCommittedPoint: i5.points[i5.points.length - 1] }), this.actionManager.executeAction(Ht);
          return;
        }
        if (X$1(i5) && i5.points.length > 1) {
          Y(i5, { lastCommittedPoint: i5.points[i5.points.length - 1] }), this.actionManager.executeAction(Ht);
          return;
        }
        let { x: a8, y: l7, lastCommittedPoint: s5 } = i5;
        if (i5.points.length > 1 && s5 && ie(u$1(n8.origin.x - a8, n8.origin.y - l7), s5) < Ks$1) {
          this.actionManager.executeAction(Ht);
          return;
        }
        this.setState((c8) => ({ selectedElementIds: Ha$1({ ...c8.selectedElementIds, [i5.id]: true }, c8) })), Y(i5, { lastCommittedPoint: i5.points[i5.points.length - 1] }), Jb(this.interactiveCanvas, mo.POINTER);
      } else {
        let [i5, a8] = Vr(n8.origin.x, n8.origin.y, t5[Q.CTRL_OR_CMD] ? null : this.getEffectiveGridSize()), l7 = this.getTopLayerFrameAtSceneCoords({ x: i5, y: a8 }), { currentItemStartArrowhead: s5, currentItemEndArrowhead: c8 } = this.state, [m8, d3] = r5 === "arrow" ? [s5, c8] : [null, null], p3 = r5 === "arrow" ? Zb({ type: r5, x: i5, y: a8, strokeColor: this.state.currentItemStrokeColor, backgroundColor: this.state.currentItemBackgroundColor, fillStyle: this.state.currentItemFillStyle, strokeWidth: this.state.currentItemStrokeWidth, strokeStyle: this.state.currentItemStrokeStyle, roughness: this.state.currentItemRoughness, opacity: this.state.currentItemOpacity, roundness: this.state.currentItemArrowType === Ws$1.round ? { type: ot.PROPORTIONAL_RADIUS } : null, startArrowhead: m8, endArrowhead: d3, locked: false, frameId: l7 ? l7.id : null, elbowed: this.state.currentItemArrowType === Ws$1.elbow, fixedSegments: this.state.currentItemArrowType === Ws$1.elbow ? [] : null }) : On({ type: r5, x: i5, y: a8, strokeColor: this.state.currentItemStrokeColor, backgroundColor: this.state.currentItemBackgroundColor, fillStyle: this.state.currentItemFillStyle, strokeWidth: this.state.currentItemStrokeWidth, strokeStyle: this.state.currentItemStrokeStyle, roughness: this.state.currentItemRoughness, opacity: this.state.currentItemOpacity, roundness: this.state.currentItemRoundness === "round" ? { type: ot.PROPORTIONAL_RADIUS } : null, locked: false, frameId: l7 ? l7.id : null });
        this.setState((h3) => {
          let f3 = { ...h3.selectedElementIds };
          return delete f3[p3.id], { selectedElementIds: Ha$1(f3, h3) };
        }), Y(p3, { points: [...p3.points, u$1(0, 0)] });
        let u3 = Bn(n8.origin, this.scene.getNonDeletedElements(), this.scene.getNonDeletedElementsMap(), this.state.zoom, X$1(p3), X$1(p3));
        this.scene.insertElement(p3), this.setState({ newElement: p3, startBoundElement: u3, suggestedBindings: [] });
      }
    });
    i$1(this, "createGenericElementOnPointerDown", (t5, r5) => {
      let [n8, i5] = Vr(r5.origin.x, r5.origin.y, this.lastPointerDownEvent?.[Q.CTRL_OR_CMD] ? null : this.getEffectiveGridSize()), a8 = this.getTopLayerFrameAtSceneCoords({ x: n8, y: i5 }), l7 = { x: n8, y: i5, strokeColor: this.state.currentItemStrokeColor, backgroundColor: this.state.currentItemBackgroundColor, fillStyle: this.state.currentItemFillStyle, strokeWidth: this.state.currentItemStrokeWidth, strokeStyle: this.state.currentItemStrokeStyle, roughness: this.state.currentItemRoughness, opacity: this.state.currentItemOpacity, roundness: this.getCurrentItemRoundness(t5), locked: false, frameId: a8 ? a8.id : null }, s5;
      t5 === "embeddable" ? s5 = VB({ type: "embeddable", ...l7 }) : s5 = Xr({ type: t5, ...l7 }), s5.type === "selection" ? this.setState({ selectionElement: s5 }) : (this.scene.insertElement(s5), this.setState({ multiElement: null, newElement: s5 }));
    });
    i$1(this, "createFrameElementOnPointerDown", (t5, r5) => {
      let [n8, i5] = Vr(t5.origin.x, t5.origin.y, this.lastPointerDownEvent?.[Q.CTRL_OR_CMD] ? null : this.getEffectiveGridSize()), a8 = { x: n8, y: i5, opacity: this.state.currentItemOpacity, locked: false, ...Pe$1 }, l7 = r5 === fn.magicframe ? GB(a8) : XB(a8);
      this.scene.insertElement(l7), this.setState({ multiElement: null, newElement: l7 });
    });
    i$1(this, "restoreReadyToEraseElements", () => {
      this.elementsPendingErasure = /* @__PURE__ */ new Set(), this.triggerRender();
    });
    i$1(this, "eraseElements", () => {
      let t5 = false, r5 = this.scene.getElementsIncludingDeleted().map((n8) => this.elementsPendingErasure.has(n8.id) || n8.frameId && this.elementsPendingErasure.has(n8.frameId) || Ne(n8) && this.elementsPendingErasure.has(n8.containerId) ? (t5 = true, vt$1(n8, { isDeleted: true })) : n8);
      this.elementsPendingErasure = /* @__PURE__ */ new Set(), t5 && (this.store.shouldCaptureIncrement(), this.scene.replaceAllElements(r5));
    });
    i$1(this, "initializeImage", async ({ imageFile: t5, imageElement: r5, showCursorImagePreview: n8 = false }) => {
      if (!Hi$1(t5)) throw new Error(g("errors.unsupportedFileType"));
      let i5 = t5.type;
      if (Jb(this.interactiveCanvas, "wait"), i5 === H.svg) try {
        t5 = OY(LO(await t5.text()), t5.name);
      } catch (m8) {
        throw console.warn(m8), new Error(g("errors.svgImageInsertError"));
      }
      let a8 = await (this.props.generateIdForFile?.(t5) || $Y(t5));
      if (!a8) throw console.warn("Couldn't generate file id or the supplied `generateIdForFile` didn't resolve to one."), new Error(g("errors.imageInsertError"));
      if (!this.files[a8]?.dataURL) {
        try {
          t5 = await _Y(t5, { maxWidthOrHeight: OE });
        } catch (m8) {
          console.error("Error trying to resizing image file on insertion", m8);
        }
        if (t5.size > AE) throw new Error(g("errors.fileTooBig", { maxSize: `${Math.trunc(AE / 1024 / 1024)}MB` }));
      }
      if (n8) {
        let m8 = this.files[a8]?.dataURL, d3 = m8 && FY(m8);
        this.setImagePreviewCursor(d3 || t5);
      }
      let s5 = this.files[a8]?.dataURL || await PY(t5), c8 = Y(r5, { fileId: a8 }, false);
      return new Promise(async (m8, d3) => {
        try {
          this.addMissingFiles([{ mimeType: i5, id: a8, dataURL: s5, created: Date.now(), lastRetrieved: Date.now() }]);
          let p3 = this.imageCache.get(a8);
          p3 || (this.addNewImagesToImageCache(), await this.updateImageCache([c8])), p3?.image instanceof Promise && await p3.image, this.state.pendingImageElementId !== c8.id && this.state.newElement?.id !== c8.id && this.initializeImageDimensions(c8, true), m8(c8);
        } catch (p3) {
          console.error(p3), d3(new Error(g("errors.imageInsertError")));
        } finally {
          n8 || Hb(this.interactiveCanvas);
        }
      });
    });
    i$1(this, "insertImageElement", async (t5, r5, n8) => {
      if (!this.isToolSupported("image")) {
        this.setState({ errorMessage: g("errors.imageToolNotSupported") });
        return;
      }
      this.scene.insertElement(t5);
      try {
        return await this.initializeImage({ imageFile: r5, imageElement: t5, showCursorImagePreview: n8 });
      } catch (i5) {
        return Y(t5, { isDeleted: true }), this.actionManager.executeAction(Ht), this.setState({ errorMessage: i5.message || g("errors.imageInsertError") }), null;
      }
    });
    i$1(this, "setImagePreviewCursor", async (t5) => {
      let n8;
      try {
        n8 = await _Y(t5, { maxWidthOrHeight: 96 });
      } catch (a8) {
        throw a8.cause === "UNSUPPORTED" ? new Error(g("errors.unsupportedFileType")) : a8;
      }
      let i5 = await PY(n8);
      if (t5.type === H.svg) {
        let a8 = await u7(i5), l7 = Math.min(a8.height, 96), s5 = l7 * (a8.width / a8.height);
        s5 > 96 && (s5 = 96, l7 = s5 * (a8.height / a8.width));
        let c8 = document.createElement("canvas");
        c8.height = l7, c8.width = s5, c8.getContext("2d").drawImage(a8, 0, 0, s5, l7), i5 = c8.toDataURL(H.svg);
      }
      this.state.pendingImageElementId && Jb(this.interactiveCanvas, `url(${i5}) 4 4, auto`);
    });
    i$1(this, "onImageAction", async ({ insertOnCanvasDirectly: t5 }) => {
      try {
        let r5 = this.state.width / 2 + this.state.offsetLeft, n8 = this.state.height / 2 + this.state.offsetTop, { x: i5, y: a8 } = Dn({ clientX: r5, clientY: n8 }, this.state), l7 = await Z2({ description: "Image", extensions: Object.keys(yo) }), s5 = this.createImageElement({ sceneX: i5, sceneY: a8, addToFrameUnderCursor: false });
        t5 ? (this.insertImageElement(s5, l7), this.initializeImageDimensions(s5), this.setState({ selectedElementIds: Ha$1({ [s5.id]: true }, this.state) }, () => {
          this.actionManager.executeAction(Ht);
        })) : this.setState({ pendingImageElementId: s5.id }, () => {
          this.insertImageElement(s5, l7, true);
        });
      } catch (r5) {
        r5.name !== "AbortError" ? console.error(r5) : console.warn(r5), this.setState({ pendingImageElementId: null, newElement: null, activeTool: $r(this.state, { type: "selection" }) }, () => {
          this.actionManager.executeAction(Ht);
        });
      }
    });
    i$1(this, "initializeImageDimensions", (t5, r5 = false) => {
      let n8 = At(t5) && this.imageCache.get(t5.fileId)?.image;
      if (!n8 || n8 instanceof Promise) {
        if (t5.width < As / this.state.zoom.value && t5.height < As / this.state.zoom.value) {
          let i5 = 100 / this.state.zoom.value;
          Y(t5, { x: t5.x - i5 / 2, y: t5.y - i5 / 2, width: i5, height: i5 });
        }
        return;
      }
      if (r5 || t5.width < As / this.state.zoom.value && t5.height < As / this.state.zoom.value) {
        let i5 = Math.max(this.state.height - 120, 160), a8 = Math.min(i5, Math.floor(this.state.height * 0.5) / this.state.zoom.value), l7 = Math.min(n8.naturalHeight, a8), s5 = l7 * (n8.naturalWidth / n8.naturalHeight), c8 = t5.x + t5.width / 2 - s5 / 2, m8 = t5.y + t5.height / 2 - l7 / 2;
        Y(t5, { x: c8, y: m8, width: s5, height: l7, crop: null });
      }
    });
    i$1(this, "updateImageCache", async (t5, r5 = this.files) => {
      let { updatedFiles: n8, erroredFiles: i5 } = await ep({ imageCache: this.imageCache, fileIds: t5.map((a8) => a8.fileId), files: r5 });
      if (n8.size || i5.size) for (let a8 of t5) n8.has(a8.fileId) && he.delete(a8);
      return i5.size && this.scene.replaceAllElements(this.scene.getElementsIncludingDeleted().map((a8) => At(a8) && i5.has(a8.fileId) ? vt$1(a8, { status: "error" }) : a8)), { updatedFiles: n8, erroredFiles: i5 };
    });
    i$1(this, "addNewImagesToImageCache", async (t5 = tp(this.scene.getNonDeletedElements()), r5 = this.files) => {
      let n8 = t5.filter((i5) => !i5.isDeleted && !this.imageCache.has(i5.fileId));
      if (n8.length) {
        let { updatedFiles: i5 } = await this.updateImageCache(n8, r5);
        i5.size && this.scene.triggerUpdate();
      }
    });
    i$1(this, "scheduleImageRefresh", gM(() => {
      this.addNewImagesToImageCache();
    }, RE));
    i$1(this, "updateBindingEnabledOnPointerMove", (t5) => {
      let r5 = FN(t5);
      this.state.isBindingEnabled !== r5 && this.setState({ isBindingEnabled: r5 });
    });
    i$1(this, "maybeSuggestBindingAtCursor", (t5, r5) => {
      let n8 = Bn(t5, this.scene.getNonDeletedElements(), this.scene.getNonDeletedElementsMap(), this.state.zoom, false, r5);
      this.setState({ suggestedBindings: n8 != null ? [n8] : [] });
    });
    i$1(this, "maybeSuggestBindingsForLinearElementAtCoords", (t5, r5, n8) => {
      if (!r5.length) return;
      let i5 = r5.reduce((a8, l7) => {
        let s5 = Bn(l7, this.scene.getNonDeletedElements(), this.scene.getNonDeletedElementsMap(), this.state.zoom, X$1(t5), X$1(t5));
        return s5 != null && !ab(t5, n8?.id, s5) && a8.push(s5), a8;
      }, []);
      this.setState({ suggestedBindings: i5 });
    });
    i$1(this, "handleInteractiveCanvasRef", (t5) => {
      t5 !== null ? (this.interactiveCanvas = t5, this.interactiveCanvas.addEventListener("touchstart", this.onTouchStart, { passive: false }), this.interactiveCanvas.addEventListener("touchend", this.onTouchEnd)) : (this.interactiveCanvas?.removeEventListener("touchstart", this.onTouchStart), this.interactiveCanvas?.removeEventListener("touchend", this.onTouchEnd));
    });
    i$1(this, "handleAppOnDrop", async (t5) => {
      let { file: r5, fileHandle: n8 } = await KY(t5), { x: i5, y: a8 } = Dn(t5, this.state);
      try {
        if (Hi$1(r5) && this.isToolSupported("image")) {
          if (r5?.type === H.png || r5?.type === H.svg) try {
            let c8 = await z2$1(r5, this.state, this.scene.getElementsIncludingDeleted(), n8);
            this.syncActionResult({ ...c8, appState: { ...c8.appState || this.state, isLoading: false }, replaceFiles: true, captureUpdate: dr.IMMEDIATELY });
            return;
          } catch (c8) {
            if (c8.name !== "EncodingError") throw new Error(g("alerts.couldNotLoadInvalidFile"));
          }
          let s5 = this.createImageElement({ sceneX: i5, sceneY: a8 });
          this.insertImageElement(s5, r5), this.initializeImageDimensions(s5), this.setState({ selectedElementIds: Ha$1({ [s5.id]: true }, this.state) });
          return;
        }
      } catch (s5) {
        return this.setState({ isLoading: false, errorMessage: s5.message });
      }
      let l7 = t5.dataTransfer.getData(H.excalidrawlib);
      if (l7 && typeof l7 == "string") {
        try {
          let s5 = J9(l7);
          this.addElementsFromPasteOrLibrary({ elements: _c(s5), position: t5, files: null });
        } catch (s5) {
          this.setState({ errorMessage: s5.message });
        }
        return;
      }
      if (r5 && await this.loadFileToCanvas(r5, n8), t5.dataTransfer?.types?.includes("text/plain")) {
        let s5 = t5.dataTransfer?.getData("text");
        if (s5 && Y_(s5, this.props.validateEmbeddable) && (/^(http|https):\/\/[^\s/$.?#].[^\s]*$/.test(s5) || V2(s5)?.type === "video")) {
          let c8 = this.insertEmbeddableElement({ sceneX: i5, sceneY: a8, link: dn(s5) });
          c8 && this.setState({ selectedElementIds: { [c8.id]: true } });
        }
      }
    });
    i$1(this, "loadFileToCanvas", async (t5, r5) => {
      t5 = await ts(t5);
      try {
        let n8 = this.scene.getElementsIncludingDeleted(), i5;
        try {
          i5 = await H9(t5, this.state, n8, r5);
        } catch (a8) {
          let l7 = a8 instanceof nn;
          if (l7 && a8.code === "IMAGE_NOT_CONTAINS_SCENE_DATA" && !this.isToolSupported("image")) {
            this.setState({ isLoading: false, errorMessage: g("errors.imageToolNotSupported") });
            return;
          }
          let s5 = l7 ? g("alerts.cannotRestoreFromImage") : g("alerts.couldNotLoadInvalidFile");
          this.setState({ isLoading: false, errorMessage: s5 });
        }
        if (!i5) return;
        i5.type === H.excalidraw ? (An$1(n8.concat(i5.data.elements)), this.store.updateSnapshot(te(n8), this.state), this.setState({ isLoading: true }), this.syncActionResult({ ...i5.data, appState: { ...i5.data.appState || this.state, isLoading: false }, replaceFiles: true, captureUpdate: dr.IMMEDIATELY })) : i5.type === H.excalidrawlib && await this.library.updateLibrary({ libraryItems: t5, merge: true, openLibraryMenu: true }).catch((a8) => {
          console.error(a8), this.setState({ errorMessage: g("errors.importLibraryError") });
        });
      } catch (n8) {
        this.setState({ isLoading: false, errorMessage: n8.message });
      }
    });
    i$1(this, "handleCanvasContextMenu", (t5) => {
      if (t5.preventDefault(), ("pointerType" in t5.nativeEvent && t5.nativeEvent.pointerType === "touch" || "pointerType" in t5.nativeEvent && t5.nativeEvent.pointerType === "pen" && t5.button !== mE.SECONDARY) && this.state.activeTool.type !== "selection") return;
      let { x: r5, y: n8 } = Dn(t5, this.state), i5 = this.getElementAtPosition(r5, n8, { preferSelected: true, includeLockedElements: true }), a8 = this.scene.getSelectedElements(this.state), l7 = this.isHittingCommonBoundingBoxOfSelectedElements({ x: r5, y: n8 }, a8), s5 = i5 || l7 ? "element" : "canvas", c8 = this.excalidrawContainerRef.current, { top: m8, left: d3 } = c8.getBoundingClientRect(), p3 = t5.clientX - d3, u3 = t5.clientY - m8;
      le("contextMenu", "openContextMenu", s5), this.setState({ ...i5 && !this.state.selectedElementIds[i5.id] ? { ...this.state, ...aF({ editingGroupId: this.state.editingGroupId, selectedElementIds: { [i5.id]: true } }, this.scene.getNonDeletedElements(), this.state, this), selectedLinearElement: ae(i5) ? new z$1(i5) : null } : this.state, showHyperlinkPopup: false }, () => {
        this.setState({ contextMenu: { top: u3, left: p3, items: this.getContextMenuItems(s5) } });
      });
    });
    i$1(this, "maybeDragNewGenericElement", (t5, r5, n8 = true) => {
      let i5 = this.state.selectionElement, a8 = t5.lastCoords;
      if (i5 && this.state.activeTool.type !== "eraser") {
        _9({ newElement: i5, elementType: this.state.activeTool.type, originX: t5.origin.x, originY: t5.origin.y, x: a8.x, y: a8.y, width: dt(t5.origin.x, a8.x), height: dt(t5.origin.y, a8.y), shouldMaintainAspectRatio: q$(r5), shouldResizeFromCenter: V$(r5), zoom: this.state.zoom.value, informMutation: n8 });
        return;
      }
      let l7 = this.state.newElement;
      if (!l7) return;
      let [s5, c8] = Vr(a8.x, a8.y, r5[Q.CTRL_OR_CMD] ? null : this.getEffectiveGridSize()), m8 = At(l7) && this.imageCache.get(l7.fileId)?.image, d3 = m8 && !(m8 instanceof Promise) ? m8.width / m8.height : null;
      this.maybeCacheReferenceSnapPoints(r5, [l7]);
      let { snapOffset: p3, snapLines: u3 } = MF(l7, this, r5, { x: t5.originInGrid.x + (this.state.originSnapOffset?.x ?? 0), y: t5.originInGrid.y + (this.state.originSnapOffset?.y ?? 0) }, { x: s5 - t5.originInGrid.x, y: c8 - t5.originInGrid.y }, this.scene.getNonDeletedElementsMap());
      s5 += p3.x, c8 += p3.y, this.setState({ snapLines: u3 }), _9({ newElement: l7, elementType: this.state.activeTool.type, originX: t5.originInGrid.x, originY: t5.originInGrid.y, x: s5, y: c8, width: dt(t5.originInGrid.x, s5), height: dt(t5.originInGrid.y, c8), shouldMaintainAspectRatio: Ye$1(l7) ? !q$(r5) : q$(r5), shouldResizeFromCenter: V$(r5), zoom: this.state.zoom.value, widthAspectRatio: d3, originOffset: this.state.originSnapOffset, informMutation: n8 }), this.setState({ newElement: l7 }), (this.state.activeTool.type === fn.frame || this.state.activeTool.type === fn.magicframe) && this.setState({ elementsToHighlight: EH(this.scene.getNonDeletedElements(), l7, this.state, this.scene.getNonDeletedElementsMap()) });
    });
    i$1(this, "maybeHandleCrop", (t5, r5) => {
      if (!this.state.croppingElementId) return false;
      let n8 = t5.resize.handleType, i5 = t5.lastCoords, [a8, l7] = Vr(i5.x - t5.resize.offset.x, i5.y - t5.resize.offset.y, r5[Q.CTRL_OR_CMD] ? null : this.getEffectiveGridSize()), s5 = this.scene.getNonDeletedElementsMap().get(this.state.croppingElementId);
      if (n8 && s5 && Ye$1(s5)) {
        let c8 = t5.originalElements.get(s5.id), m8 = At(s5) && this.imageCache.get(s5.fileId)?.image;
        if (c8 && Ye$1(c8) && m8 && !(m8 instanceof Promise)) {
          let [d3, p3] = Vr(i5.x, i5.y, r5[Q.CTRL_OR_CMD] ? null : this.getEffectiveGridSize()), u3 = { x: d3 - t5.originInGrid.x, y: p3 - t5.originInGrid.y };
          this.maybeCacheReferenceSnapPoints(r5, [s5]);
          let { snapOffset: h3, snapLines: f3 } = TF([s5], [c8], this, r5, u3, n8);
          Y(s5, lP(s5, n8, m8.naturalWidth, m8.naturalHeight, a8 + h3.x, l7 + h3.y, r5.shiftKey ? c8.width / c8.height : void 0)), Jt(s5, this.scene.getNonDeletedElementsMap(), { newSize: { width: s5.width, height: s5.height } }), this.setState({ isCropping: n8 && n8 !== "rotation", snapLines: f3 });
        }
        return true;
      }
      return false;
    });
    i$1(this, "maybeHandleResize", (t5, r5) => {
      let n8 = this.scene.getSelectedElements(this.state), i5 = n8.filter((d3) => de(d3)), a8 = t5.resize.handleType;
      if (i5.length > 0 && a8 === "rotation" || n8.length === 1 && X$1(n8[0]) || this.state.croppingElementId) return false;
      this.setState({ isResizing: a8 && a8 !== "rotation", isRotating: a8 === "rotation", activeEmbeddable: null });
      let l7 = t5.lastCoords, [s5, c8] = Vr(l7.x - t5.resize.offset.x, l7.y - t5.resize.offset.y, r5[Q.CTRL_OR_CMD] ? null : this.getEffectiveGridSize()), m8 = /* @__PURE__ */ new Map();
      if (i5.forEach((d3) => {
        co(this.scene.getNonDeletedElements(), d3.id).forEach((u3) => {
          m8.set(d3.id + u3.id, { x: u3.x - d3.x, y: u3.y - d3.y });
        });
      }), !this.state.selectedElementsAreBeingDragged) {
        let [d3, p3] = Vr(l7.x, l7.y, r5[Q.CTRL_OR_CMD] ? null : this.getEffectiveGridSize()), u3 = { x: d3 - t5.originInGrid.x, y: p3 - t5.originInGrid.y }, h3 = [...t5.originalElements.values()];
        this.maybeCacheReferenceSnapPoints(r5, n8);
        let { snapOffset: f3, snapLines: b3 } = TF(n8, at$1(h3, this.state), this, r5, u3, a8);
        s5 += f3.x, c8 += f3.y, this.setState({ snapLines: b3 });
      }
      if (y9(t5.originalElements, a8, n8, this.scene.getElementsMapIncludingDeleted(), this.scene, ga(r5), V$(r5), n8.some((d3) => Ye$1(d3)) ? !q$(r5) : q$(r5), s5, c8, t5.resize.center.x, t5.resize.center.y)) {
        let d3 = _N(n8, this.scene.getNonDeletedElementsMap(), this.state.zoom), p3 = /* @__PURE__ */ new Set();
        return i5.forEach((u3) => {
          EH(this.scene.getNonDeletedElements(), u3, this.state, this.scene.getNonDeletedElementsMap()).forEach((h3) => p3.add(h3));
        }), this.setState({ elementsToHighlight: [...p3], suggestedBindings: d3 }), true;
      }
      return false;
    });
    i$1(this, "getContextMenuItems", (t5) => {
      let r5 = [];
      return r5.push(wc, vc), t5 === "canvas" ? this.state.viewModeEnabled ? [...r5, Cc, Mi, wg, Di] : [Qp, $e, wc, vc, Tc, $e, bp, Cv, $e, Cc, eu, Mi, wg, Di] : (r5.push(Tc), this.state.viewModeEnabled ? [_i, ...r5] : [$e, yc, _i, Qp, $e, N1, O1, F1, $e, Du, $e, ...r5, $e, Wp, Kp, $e, Xp, aT, tu, ou, fv, $p, $e, jp, $e, up, gp, hp, fp, $e, Jp, qp, $e, Mu, $e, Ga, Vc, $e, xp, cu, $e, _a]);
    });
    i$1(this, "handleWheel", Fe((t5) => {
      if (!(t5.target instanceof HTMLCanvasElement || t5.target instanceof HTMLTextAreaElement || t5.target instanceof HTMLIFrameElement)) {
        t5[Q.CTRL_OR_CMD] && t5.preventDefault();
        return;
      }
      if (t5.preventDefault(), ll) return;
      let { deltaX: r5, deltaY: n8 } = t5;
      if (t5.metaKey || t5.ctrlKey) {
        let i5 = Math.sign(n8), a8 = DE * 100, l7 = Math.abs(n8), s5 = n8;
        l7 > a8 && (s5 = a8 * i5);
        let c8 = this.state.zoom.value - s5 / 100;
        c8 += Math.log10(Math.max(1, this.state.zoom.value)) * -i5 * Math.min(1, l7 / 20), this.translateCanvas((m8) => ({ ...Qo({ viewportX: this.lastViewportPosition.x, viewportY: this.lastViewportPosition.y, nextZoom: Oa(c8) }, m8), shouldCacheIgnoreZoom: true })), this.resetShouldCacheIgnoreZoomDebounced();
        return;
      }
      if (t5.shiftKey) {
        this.translateCanvas(({ zoom: i5, scrollX: a8 }) => ({ scrollX: a8 - (n8 || r5) / i5.value }));
        return;
      }
      this.translateCanvas(({ zoom: i5, scrollX: a8, scrollY: l7 }) => ({ scrollX: a8 - r5 / i5.value, scrollY: l7 - n8 / i5.value }));
    }));
    i$1(this, "savePointer", (t5, r5, n8) => {
      if (!t5 || !r5) return;
      let { x: i5, y: a8 } = Dn({ clientX: t5, clientY: r5 }, this.state);
      let l7 = { x: i5, y: a8, tool: this.state.activeTool.type === "laser" ? "laser" : "pointer" };
      this.props.onPointerUpdate?.({ pointer: l7, button: n8, pointersMap: fe.pointers });
    });
    i$1(this, "resetShouldCacheIgnoreZoomDebounced", $o(() => {
      this.unmounted || this.setState({ shouldCacheIgnoreZoom: false });
    }, 300));
    i$1(this, "updateDOMRect", (t5) => {
      if (this.excalidrawContainerRef?.current) {
        let r5 = this.excalidrawContainerRef.current, { width: n8, height: i5, left: a8, top: l7 } = r5.getBoundingClientRect(), { width: s5, height: c8, offsetTop: m8, offsetLeft: d3 } = this.state;
        if (n8 === s5 && i5 === c8 && a8 === d3 && l7 === m8) {
          t5 && t5();
          return;
        }
        this.setState({ width: n8, height: i5, offsetLeft: a8, offsetTop: l7 }, () => {
          t5 && t5();
        });
      }
    });
    i$1(this, "refresh", () => {
      this.setState({ ...this.getCanvasOffsets() });
    });
    let r3 = mt(), { excalidrawAPI: n3, viewModeEnabled: i3 = false, zenModeEnabled: a3 = false, gridModeEnabled: l3 = false, objectsSnapModeEnabled: s3 = false, theme: c3 = r3.theme, name: m3 = `${g("labels.untitled")}-${ng()}` } = t3;
    if (this.state = { ...r3, theme: c3, isLoading: true, ...this.getCanvasOffsets(), viewModeEnabled: i3, zenModeEnabled: a3, objectsSnapModeEnabled: s3, gridModeEnabled: l3 ?? r3.gridModeEnabled, name: m3, width: window.innerWidth, height: window.innerHeight }, this.id = nanoid(), this.library = new Ov(this), this.actionManager = new $c(this.syncActionResult, () => this.state, () => this.scene.getElementsIncludingDeleted(), this), this.scene = new Ts(), this.canvas = document.createElement("canvas"), this.rc = q5.canvas(this.canvas), this.renderer = new il(this.scene), this.visibleElements = [], this.store = new O2(), this.history = new Xa(), n3) {
      let d3 = { updateScene: this.updateScene, updateLibrary: this.library.updateLibrary, addFiles: this.addFiles, resetScene: this.resetScene, getSceneElementsIncludingDeleted: this.getSceneElementsIncludingDeleted, history: { clear: this.resetHistory }, scrollToContent: this.scrollToContent, getSceneElements: this.getSceneElements, getAppState: () => this.state, getFiles: () => this.files, getName: this.getName, registerAction: (p3) => {
        this.actionManager.registerAction(p3);
      }, refresh: this.refresh, setToast: this.setToast, id: this.id, setActiveTool: this.setActiveTool, setCursor: this.setCursor, resetCursor: this.resetCursor, updateFrameRendering: this.updateFrameRendering, toggleSidebar: this.toggleSidebar, onChange: (p3) => this.onChangeEmitter.on(p3), onPointerDown: (p3) => this.onPointerDownEmitter.on(p3), onPointerUp: (p3) => this.onPointerUpEmitter.on(p3), onScrollChange: (p3) => this.onScrollChangeEmitter.on(p3), onUserFollow: (p3) => this.onUserFollowEmitter.on(p3) };
      typeof n3 == "function" ? n3(d3) : console.error("excalidrawAPI should be a function!");
    }
    this.excalidrawContainerValue = { container: this.excalidrawContainerRef.current, id: this.id }, this.fonts = new Nn(this.scene), this.history = new Xa(), this.actionManager.registerAll(M2), this.actionManager.registerAction(Aw(this.history, this.store)), this.actionManager.registerAction(_w(this.history, this.store));
  }
  onWindowMessage(t3) {
    if (t3.origin !== "https://player.vimeo.com" && t3.origin !== "https://www.youtube.com") return;
    let r3 = null;
    try {
      r3 = JSON.parse(t3.data);
    } catch {
    }
    if (r3) switch (t3.origin) {
      case "https://player.vimeo.com":
        if (r3.method === "paused") {
          let n3 = null, i3 = document.body.querySelectorAll("iframe.excalidraw__embeddable");
          if (!i3) break;
          for (let a3 of i3) a3.contentWindow === t3.source && (n3 = a3.contentWindow);
          n3?.postMessage(JSON.stringify({ method: r3.value ? "play" : "pause", value: true }), "*");
        }
        break;
      case "https://www.youtube.com":
        if (r3.event === "infoDelivery" && r3.info && r3.id && typeof r3.info.playerState == "number") {
          let n3 = r3.id, i3 = r3.info.playerState;
          Object.values(EE).includes(i3) && Rg.set(n3, i3);
        }
        break;
    }
  }
  cacheEmbeddableRef(t3, r3) {
    r3 && this.iFrameRefs.set(t3.id, r3);
  }
  getHTMLIFrameElement(t3) {
    return this.iFrameRefs.get(t3.id);
  }
  handleEmbeddableCenterClick(t3) {
    if (this.state.activeEmbeddable?.element === t3 && this.state.activeEmbeddable?.state === "active" || (setTimeout(() => {
      this.setState({ activeEmbeddable: { element: t3, state: "active" }, selectedElementIds: { [t3.id]: true }, newElement: null, selectionElement: null });
    }, 100), _o$1(t3))) return;
    let r3 = this.getHTMLIFrameElement(t3);
    if (r3?.contentWindow) {
      if (r3.src.includes("youtube")) {
        let n3 = Rg.get(t3.id);
        switch (n3 || (Rg.set(t3.id, EE.UNSTARTED), r3.contentWindow.postMessage(JSON.stringify({ event: "listening", id: t3.id }), "*")), n3) {
          case EE.PLAYING:
          case EE.BUFFERING:
            r3.contentWindow?.postMessage(JSON.stringify({ event: "command", func: "pauseVideo", args: "" }), "*");
            break;
          default:
            r3.contentWindow?.postMessage(JSON.stringify({ event: "command", func: "playVideo", args: "" }), "*");
        }
      }
      r3.src.includes("player.vimeo.com") && r3.contentWindow.postMessage(JSON.stringify({ method: "paused" }), "*");
    }
  }
  isIframeLikeElementCenter(t3, r3, n3, i3) {
    return t3 && !r3.altKey && !r3.shiftKey && !r3.metaKey && !r3.ctrlKey && (this.state.activeEmbeddable?.element !== t3 || this.state.activeEmbeddable?.state === "hover" || !this.state.activeEmbeddable) && n3 >= t3.x + t3.width / 3 && n3 <= t3.x + 2 * t3.width / 3 && i3 >= t3.y + t3.height / 3 && i3 <= t3.y + 2 * t3.height / 3;
  }
  renderEmbeddables() {
    let t3 = this.state.zoom.value, r3 = this.state.width, n3 = this.state.height, i3 = this.scene.getNonDeletedElements().filter((a3) => Bo(a3) && this.embedsValidationStatus.get(a3.id) === true || _o$1(a3));
    return jsxRuntimeExports.jsx(jsxRuntimeExports.Fragment, { children: i3.map((a3) => {
      let { x: l3, y: s3 } = ta({ sceneX: a3.x, sceneY: a3.y }, this.state), c3 = kp(a3, r3, n3, this.state, this.scene.getNonDeletedElementsMap()), m3 = this.initializedEmbeds.has(a3.id);
      if (c3 && !m3 && this.initializedEmbeds.add(a3.id), !(c3 || m3)) return null;
      let p3;
      if (_o$1(a3)) {
        p3 = null;
        let f3 = (a3.customData?.generationData ?? this.magicGenerations.get(a3.id)) || { status: "error", message: "No generation data", code: "ERR_NO_GENERATION_DATA" };
        if (f3.status === "done") {
          let b3 = f3.html;
          p3 = { intrinsicSize: { w: a3.width, h: a3.height }, type: "document", srcdoc: () => b3 };
        } else if (f3.status === "pending") p3 = { intrinsicSize: { w: a3.width, h: a3.height }, type: "document", srcdoc: () => za$1(`
                    <style>
                      html, body {
                        width: 100%;
                        height: 100%;
                        color: ${this.state.theme === ke.DARK ? "white" : "black"};
                      }
                      body {
                        display: flex;
                        align-items: center;
                        justify-content: center;
                        flex-direction: column;
                        gap: 1rem;
                      }

                      .Spinner {
                        display: flex;
                        align-items: center;
                        justify-content: center;
                        margin-left: auto;
                        margin-right: auto;
                      }

                      .Spinner svg {
                        animation: rotate 1.6s linear infinite;
                        transform-origin: center center;
                        width: 40px;
                        height: 40px;
                      }

                      .Spinner circle {
                        stroke: currentColor;
                        animation: dash 1.6s linear 0s infinite;
                        stroke-linecap: round;
                      }

                      @keyframes rotate {
                        100% {
                          transform: rotate(360deg);
                        }
                      }

                      @keyframes dash {
                        0% {
                          stroke-dasharray: 1, 300;
                          stroke-dashoffset: 0;
                        }
                        50% {
                          stroke-dasharray: 150, 300;
                          stroke-dashoffset: -200;
                        }
                        100% {
                          stroke-dasharray: 1, 300;
                          stroke-dashoffset: -280;
                        }
                      }
                    </style>
                    <div class="Spinner">
                      <svg
                        viewBox="0 0 100 100"
                      >
                        <circle
                          cx="50"
                          cy="50"
                          r="46"
                          stroke-width="8"
                          fill="none"
                          stroke-miter-limit="10"
                        />
                      </svg>
                    </div>
                    <div>Generating...</div>
                  `) };
        else {
          let b3;
          f3.code === "ERR_GENERATION_INTERRUPTED" ? b3 = "Generation was interrupted..." : b3 = f3.message || "Generation failed", p3 = { intrinsicSize: { w: a3.width, h: a3.height }, type: "document", srcdoc: () => za$1(`
                    <style>
                    html, body {
                      height: 100%;
                    }
                      body {
                        display: flex;
                        flex-direction: column;
                        align-items: center;
                        justify-content: center;
                        color: ${Z.red[3]};
                      }
                      h1, h3 {
                        margin-top: 0;
                        margin-bottom: 0.5rem;
                      }
                    </style>
                    <h1>Error!</h1>
                    <h3>${b3}</h3>
                  `) };
        }
      } else p3 = V2(T2(a3.link || ""));
      let u3 = this.state.activeEmbeddable?.element === a3 && this.state.activeEmbeddable?.state === "active", h3 = this.state.activeEmbeddable?.element === a3 && this.state.activeEmbeddable?.state === "hover";
      return jsxRuntimeExports.jsx("div", { className: dM("excalidraw__embeddable-container", { "is-hovered": h3 }), style: { transform: c3 ? `translate(${l3 - this.state.offsetLeft}px, ${s3 - this.state.offsetTop}px) scale(${t3})` : "none", display: c3 ? "block" : "none", opacity: Pm(a3, We(a3, this.scene.getNonDeletedElementsMap()), this.elementsPendingErasure, null, this.state.openDialog?.name === "elementLinkSelector" ? zs : 1), "--embeddable-radius": `${it$1(Math.min(a3.width, a3.height), a3)}px` }, children: jsxRuntimeExports.jsxs("div", { className: "excalidraw__embeddable-container__inner", style: { width: c3 ? `${a3.width}px` : 0, height: c3 ? `${a3.height}px` : 0, transform: c3 ? `rotate(${a3.angle}rad)` : "none", pointerEvents: u3 ? bE.enabled : bE.disabled }, children: [h3 && jsxRuntimeExports.jsx("div", { className: "excalidraw__embeddable-hint", children: g("buttons.embeddableInteractionButton") }), jsxRuntimeExports.jsx("div", { className: "excalidraw__embeddable__outer", style: { padding: `${a3.strokeWidth}px` }, children: (Bo(a3) ? this.props.renderEmbeddable?.(a3, this.state) : null) ?? jsxRuntimeExports.jsx("iframe", { ref: (f3) => this.cacheEmbeddableRef(a3, f3), className: "excalidraw__embeddable", srcDoc: p3?.type === "document" ? p3.srcdoc(this.state.theme) : void 0, src: p3?.type !== "document" ? p3?.link ?? "" : void 0, scrolling: "no", referrerPolicy: "no-referrer-when-downgrade", title: "Excalidraw Embedded Content", allow: "accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture", allowFullScreen: true, sandbox: `${p3?.sandbox?.allowSameOrigin ? "allow-same-origin" : ""} allow-scripts allow-forms allow-popups allow-popups-to-escape-sandbox allow-presentation allow-downloads` }) })] }) }, a3.id);
    }) });
  }
  toggleOverscrollBehavior(t3) {
    document.documentElement.style.overscrollBehaviorX = t3.type === "pointerenter" ? "none" : "auto";
  }
  render() {
    let t3 = this.scene.getSelectedElements(this.state), { renderTopRightUI: r3, renderCustomStats: n3 } = this.props, i3 = this.scene.getSceneNonce(), { elementsMap: a3, visibleElements: l3 } = this.renderer.getRenderableElements({ sceneNonce: i3, zoom: this.state.zoom, offsetLeft: this.state.offsetLeft, offsetTop: this.state.offsetTop, scrollX: this.state.scrollX, scrollY: this.state.scrollY, height: this.state.height, width: this.state.width, editingTextElement: this.state.editingTextElement, newElementId: this.state.newElement?.id, pendingImageElementId: this.state.pendingImageElementId });
    this.visibleElements = l3;
    let s3 = this.scene.getNonDeletedElementsMap(), c3 = "setPointerCapture" in HTMLElement.prototype ? false : this.state.selectionElement || this.state.newElement || this.state.selectedElementsAreBeingDragged || this.state.resizingElement || this.state.activeTool.type === "laser" && this.state.cursorButton === "down", m3 = t3[0];
    return jsxRuntimeExports.jsx("div", { className: dM("excalidraw excalidraw-container", { "excalidraw--view-mode": this.state.viewModeEnabled || this.state.openDialog?.name === "elementLinkSelector", "excalidraw--mobile": this.device.editor.isMobile }), style: { "--ui-pointerEvents": c3 ? bE.disabled : bE.enabled, "--right-sidebar-width": "302px" }, ref: this.excalidrawContainerRef, onDrop: this.handleAppOnDrop, tabIndex: 0, onKeyDown: this.props.handleKeyboardGlobally ? void 0 : this.onKeyDown, onPointerEnter: this.toggleOverscrollBehavior, onPointerLeave: this.toggleOverscrollBehavior, children: jsxRuntimeExports.jsx(gT.Provider, { value: this, children: jsxRuntimeExports.jsx(hT.Provider, { value: this.props, children: jsxRuntimeExports.jsx(Fg.Provider, { value: this.excalidrawContainerValue, children: jsxRuntimeExports.jsx(Og.Provider, { value: this.device, children: jsxRuntimeExports.jsx(Ug.Provider, { value: this.setAppState, children: jsxRuntimeExports.jsx(zg.Provider, { value: this.state, children: jsxRuntimeExports.jsxs(Bg.Provider, { value: this.scene.getNonDeletedElements(), children: [jsxRuntimeExports.jsxs(Hg.Provider, { value: this.actionManager, children: [jsxRuntimeExports.jsx(M1, { canvas: this.canvas, appState: this.state, files: this.files, setAppState: this.setAppState, actionManager: this.actionManager, elements: this.scene.getNonDeletedElements(), onLockToggle: this.toggleLock, onPenModeToggle: this.togglePenMode, onHandToolToggle: this.onHandToolToggle, langCode: qo().code, renderTopRightUI: r3, renderCustomStats: n3, showExitZenModeBtn: typeof this.props?.zenModeEnabled > "u" && this.state.zenModeEnabled, UIOptions: this.props.UIOptions, onExportImage: this.onExportImage, renderWelcomeScreen: !this.state.isLoading && this.state.showWelcomeScreen && this.state.activeTool.type === "selection" && !this.state.zenModeEnabled && !this.scene.getElementsIncludingDeleted().length, app: this, isCollaborating: this.props.isCollaborating, generateLinkForSelection: this.props.generateLinkForSelection, children: this.props.children }), jsxRuntimeExports.jsx("div", { className: "excalidraw-textEditorContainer" }), jsxRuntimeExports.jsx("div", { className: "excalidraw-contextMenuContainer" }), jsxRuntimeExports.jsx("div", { className: "excalidraw-eye-dropper-container" }), jsxRuntimeExports.jsx(tT, { trails: [this.laserTrails, this.eraserTrail] }), t3.length === 1 && this.state.openDialog?.name !== "elementLinkSelector" && this.state.showHyperlinkPopup && jsxRuntimeExports.jsx(vv, { element: m3, elementsMap: s3, setAppState: this.setAppState, onLinkOpen: this.props.onLinkOpen, setToast: this.setToast, updateEmbedValidationStatus: this.updateEmbedValidationStatus }, m3.id), this.props.aiEnabled !== false && t3.length === 1 && yd$1(m3) && jsxRuntimeExports.jsx(Ag, { element: m3, elementsMap: a3, children: jsxRuntimeExports.jsx(Md, { title: g("labels.convertToCode"), icon: v4, checked: false, onChange: () => this.onMagicFrameGenerate(m3, "button") }) }), t3.length === 1 && _o$1(m3) && m3.customData?.generationData?.status === "done" && jsxRuntimeExports.jsxs(Ag, { element: m3, elementsMap: a3, children: [jsxRuntimeExports.jsx(Md, { title: g("labels.copySource"), icon: E4, checked: false, onChange: () => this.onIframeSrcCopy(m3) }), jsxRuntimeExports.jsx(Md, { title: "Enter fullscreen", icon: N4, checked: false, onChange: () => {
      let d3 = this.getHTMLIFrameElement(m3);
      if (d3) try {
        d3.requestFullscreen(), this.setState({ activeEmbeddable: { element: m3, state: "active" }, selectedElementIds: { [m3.id]: true }, newElement: null, selectionElement: null });
      } catch (p3) {
        console.warn(p3), this.setState({ errorMessage: "Couldn't enter fullscreen" });
      }
    } })] }), this.state.toast !== null && jsxRuntimeExports.jsx(P1, { message: this.state.toast.message, onClose: () => this.setToast(null), duration: this.state.toast.duration, closable: this.state.toast.closable }), this.state.contextMenu && jsxRuntimeExports.jsx(Ow, { items: this.state.contextMenu.items, top: this.state.contextMenu.top, left: this.state.contextMenu.left, actionManager: this.actionManager, onClose: (d3) => {
      this.setState({ contextMenu: null }, () => {
        this.focusContainer(), d3?.();
      });
    } }), jsxRuntimeExports.jsx(Lg, { canvas: this.canvas, rc: this.rc, elementsMap: a3, allElementsMap: s3, visibleElements: l3, sceneNonce: i3, selectionNonce: this.state.selectionElement?.versionNonce, scale: window.devicePixelRatio, appState: this.state, renderConfig: { imageCache: this.imageCache, isExporting: false, renderGrid: Sb(this), canvasBackgroundColor: this.state.viewBackgroundColor, embedsValidationStatus: this.embedsValidationStatus, elementsPendingErasure: this.elementsPendingErasure, pendingFlowchartNodes: this.flowChartCreator.pendingNodes } }), this.state.newElement && jsxRuntimeExports.jsx(dT, { appState: this.state, scale: window.devicePixelRatio, rc: this.rc, elementsMap: a3, allElementsMap: s3, renderConfig: { imageCache: this.imageCache, isExporting: false, renderGrid: false, canvasBackgroundColor: this.state.viewBackgroundColor, embedsValidationStatus: this.embedsValidationStatus, elementsPendingErasure: this.elementsPendingErasure, pendingFlowchartNodes: null } }), jsxRuntimeExports.jsx(kg, { containerRef: this.excalidrawContainerRef, canvas: this.interactiveCanvas, elementsMap: a3, visibleElements: l3, allElementsMap: s3, selectedElements: t3, sceneNonce: i3, selectionNonce: this.state.selectionElement?.versionNonce, scale: window.devicePixelRatio, appState: this.state, device: this.device, renderInteractiveSceneCallback: this.renderInteractiveSceneCallback, handleCanvasRef: this.handleInteractiveCanvasRef, onContextMenu: this.handleCanvasContextMenu, onPointerMove: this.handleCanvasPointerMove, onPointerUp: this.handleCanvasPointerUp, onPointerCancel: this.removePointer, onTouchMove: this.handleTouchMove, onPointerDown: this.handleCanvasPointerDown, onDoubleClick: this.handleCanvasDoubleClick }), this.state.userToFollow && jsxRuntimeExports.jsx(nT, { width: this.state.width, height: this.state.height, userToFollow: this.state.userToFollow, onDisconnect: this.maybeUnfollowRemoteUser }), this.renderFrameNames()] }), this.renderEmbeddables()] }) }) }) }) }) }) }) });
  }
  setPlugins(t3) {
    Object.assign(this.plugins, t3);
  }
  async onMagicFrameGenerate(t3, r3) {
    let n3 = this.plugins.diagramToCode?.generate;
    if (!n3) {
      this.setState({ errorMessage: "No diagram to code plugin found" });
      return;
    }
    let i3 = Ep(this.scene.getNonDeletedElements(), t3).filter((l3) => !yd$1(l3));
    if (!i3.length) {
      r3 === "button" ? (this.setState({ errorMessage: "Cannot generate from an empty frame" }), le("ai", "generate (no-children)", "d2c")) : this.setActiveTool({ type: "magicframe" });
      return;
    }
    let a3 = this.insertIframeElement({ sceneX: t3.x + t3.width + 30, sceneY: t3.y, width: t3.width, height: t3.height });
    if (a3) {
      this.updateMagicGeneration({ frameElement: a3, data: { status: "pending" } }), this.setState({ selectedElementIds: { [a3.id]: true } }), le("ai", "generate (start)", "d2c");
      try {
        let { html: l3 } = await n3({ frame: t3, children: i3 });
        if (le("ai", "generate (success)", "d2c"), !l3.trim()) {
          this.updateMagicGeneration({ frameElement: a3, data: { status: "error", code: "ERR_OAI", message: "Nothing genereated :(" } });
          return;
        }
        let s3 = l3.includes("<!DOCTYPE html>") && l3.includes("</html>") ? l3.slice(l3.indexOf("<!DOCTYPE html>"), l3.indexOf("</html>") + 7) : l3;
        this.updateMagicGeneration({ frameElement: a3, data: { status: "done", html: s3 } });
      } catch (l3) {
        le("ai", "generate (failed)", "d2c"), this.updateMagicGeneration({ frameElement: a3, data: { status: "error", code: "ERR_OAI", message: l3.message || "Unknown error during generation" } });
      }
    }
  }
  onIframeSrcCopy(t3) {
    t3.customData?.generationData?.status === "done" && (hs(t3.customData.generationData.html), this.setToast({ message: "copied to clipboard", closable: false, duration: 1500 }));
  }
  clearImageShapeCache(t3) {
    let r3 = t3 ?? this.files;
    this.scene.getNonDeletedElements().forEach((n3) => {
      At(n3) && r3[n3.fileId] && (this.imageCache.delete(n3.fileId), he.delete(n3));
    });
  }
  async componentDidMount() {
    if (this.unmounted = false, this.excalidrawContainerValue.container = this.excalidrawContainerRef.current, c$1.MODE === je.TEST || c$1.DEV) {
      this.setState.bind(this);
      Object.defineProperties(window.h, { state: { configurable: true, get: () => this.state }, setState: { configurable: true, value: (...n3) => this.setState(...n3) }, app: { configurable: true, value: this }, history: { configurable: true, value: this.history }, store: { configurable: true, value: this.store }, fonts: { configurable: true, value: this.fonts } });
    }
    this.store.onStoreIncrementEmitter.on((r3) => {
      this.history.record(r3.elementsChange, r3.appStateChange);
    }), this.scene.onUpdate(this.triggerRender), this.addEventListeners(), this.props.autoFocus && this.excalidrawContainerRef.current && this.focusContainer(), Ot() || (this.refreshViewportBreakpoints(), this.refreshEditorBreakpoints()), cE && this.excalidrawContainerRef.current && (this.resizeObserver = new ResizeObserver(() => {
      this.refreshEditorBreakpoints(), this.updateDOMRect();
    }), this.resizeObserver?.observe(this.excalidrawContainerRef.current)), new URLSearchParams(window.location.search.slice(1)).has("web-share-target") ? this.restoreFileFromShare() : this.updateDOMRect(this.initializeScene), dE() && !Vg$1() && this.setState({ errorMessage: jsxRuntimeExports.jsx(z1, {}) });
  }
  componentWillUnmount() {
    window.launchQueue?.setConsumer(() => {
    }), this.renderer.destroy(), this.scene.destroy(), this.scene = new Ts(), this.fonts = new Nn(this.scene), this.renderer = new il(this.scene), this.files = {}, this.imageCache.clear(), this.resizeObserver?.disconnect(), this.unmounted = true, this.removeEventListeners(), this.library.destroy(), this.laserTrails.stop(), this.eraserTrail.stop(), this.onChangeEmitter.clear(), this.store.onStoreIncrementEmitter.clear(), he.destroy(), mi.destroy(), clearTimeout(Ur), Ib.clearCache(), aF.clearCache(), Ur = 0, document.documentElement.style.overscrollBehaviorX = "";
  }
  removeEventListeners() {
    this.onRemoveEventListenersEmitter.trigger();
  }
  addEventListeners() {
    this.removeEventListeners(), this.props.handleKeyboardGlobally && this.onRemoveEventListenersEmitter.once(Sg$1(document, "keydown", this.onKeyDown, false)), this.onRemoveEventListenersEmitter.once(Sg$1(this.excalidrawContainerRef.current, "wheel", this.handleWheel, { passive: false }), Sg$1(window, "message", this.onWindowMessage, false), Sg$1(document, "pointerup", this.removePointer, { passive: false }), Sg$1(document, "copy", this.onCopy, { passive: false }), Sg$1(document, "keyup", this.onKeyUp, { passive: true }), Sg$1(document, "pointermove", this.updateCurrentCursorPosition, { passive: false }), Sg$1(document.fonts, "loadingdone", (t3) => {
      let r3 = t3.fontfaces;
      this.fonts.onLoaded(r3);
    }, { passive: false }), Sg$1(document, "gesturestart", this.onGestureStart, false), Sg$1(document, "gesturechange", this.onGestureChange, false), Sg$1(document, "gestureend", this.onGestureEnd, false), Sg$1(window, "focus", () => {
      this.maybeCleanupAfterMissingPointerUp(null), this.triggerRender(true);
    }, { passive: false })), !this.state.viewModeEnabled && (this.onRemoveEventListenersEmitter.once(Sg$1(document, "fullscreenchange", this.onFullscreenChange, { passive: false }), Sg$1(document, "paste", this.pasteFromClipboard, { passive: false }), Sg$1(document, "cut", this.onCut, { passive: false }), Sg$1(window, "resize", this.onResize, false), Sg$1(window, "unload", this.onUnload, false), Sg$1(window, "blur", this.onBlur, false), Sg$1(this.excalidrawContainerRef.current, "wheel", this.handleWheel, { passive: false }), Sg$1(this.excalidrawContainerRef.current, "dragover", this.disableEvent, false), Sg$1(this.excalidrawContainerRef.current, "drop", this.disableEvent, false)), this.props.detectScroll && this.onRemoveEventListenersEmitter.once(Sg$1(mg$1(this.excalidrawContainerRef.current), "scroll", this.onScroll, { passive: false })));
  }
  componentDidUpdate(t3, r3) {
    this.updateEmbeddables();
    let n3 = this.scene.getElementsIncludingDeleted(), i3 = this.scene.getElementsMapIncludingDeleted(), a3 = this.scene.getNonDeletedElementsMap();
    !this.state.showWelcomeScreen && !n3.length && this.setState({ showWelcomeScreen: true }), t3.UIOptions.dockedSidebarBreakpoint !== this.props.UIOptions.dockedSidebarBreakpoint && this.refreshEditorBreakpoints(), r3.userToFollow && !this.state.collaborators.has(r3.userToFollow.socketId) && this.maybeUnfollowRemoteUser(), (r3.zoom.value !== this.state.zoom.value || r3.scrollX !== this.state.scrollX || r3.scrollY !== this.state.scrollY) && (this.props?.onScrollChange?.(this.state.scrollX, this.state.scrollY, this.state.zoom), this.onScrollChangeEmitter.trigger(this.state.scrollX, this.state.scrollY, this.state.zoom)), r3.userToFollow !== this.state.userToFollow && (r3.userToFollow && this.onUserFollowEmitter.trigger({ userToFollow: r3.userToFollow, action: "UNFOLLOW" }), this.state.userToFollow && this.onUserFollowEmitter.trigger({ userToFollow: this.state.userToFollow, action: "FOLLOW" })), Object.keys(this.state.selectedElementIds).length && td$1(this.state) && this.setState({ activeTool: $r(this.state, { type: "selection" }) }), this.state.activeTool.type === "eraser" && r3.theme !== this.state.theme && Yb(this.interactiveCanvas, this.state.theme), r3.activeTool.type === "selection" && this.state.activeTool.type !== "selection" && this.state.showHyperlinkPopup && this.setState({ showHyperlinkPopup: false }), t3.langCode !== this.props.langCode && this.updateLanguage(), td$1(r3) && !td$1(this.state) && this.eraserTrail.endPath(), t3.viewModeEnabled !== this.props.viewModeEnabled && this.setState({ viewModeEnabled: !!this.props.viewModeEnabled }), r3.viewModeEnabled !== this.state.viewModeEnabled && (this.addEventListeners(), this.deselectElements()), (r3.openDialog?.name === "elementLinkSelector" || this.state.openDialog?.name === "elementLinkSelector") && r3.openDialog?.name !== this.state.openDialog?.name && (this.deselectElements(), this.setState({ hoveredElementIds: {} })), t3.zenModeEnabled !== this.props.zenModeEnabled && this.setState({ zenModeEnabled: !!this.props.zenModeEnabled }), t3.theme !== this.props.theme && this.props.theme && this.setState({ theme: this.props.theme }), this.excalidrawContainerRef.current?.classList.toggle("theme--dark", this.state.theme === ke.DARK), this.state.editingLinearElement && !this.state.selectedElementIds[this.state.editingLinearElement.elementId] && setTimeout(() => {
      this.state.editingLinearElement && this.actionManager.executeAction(Ht);
    }), this.state.editingTextElement?.isDeleted && this.setState({ editingTextElement: null }), this.state.selectedLinearElement && !this.state.selectedElementIds[this.state.selectedLinearElement.elementId] && this.setState({ selectedLinearElement: null });
    let { multiElement: s3 } = r3;
    r3.activeTool !== this.state.activeTool && s3 != null && Fa$1(this.state) && Pr(s3, false) && ON(s3, this.state, un(z$1.getPointAtIndexGlobalCoordinates(s3, -1, a3)), this.scene.getNonDeletedElementsMap(), this.scene.getNonDeletedElements()), this.store.commit(i3, this.state), this.state.isLoading || (this.props.onChange?.(n3, this.state, this.files), this.onChangeEmitter.trigger(n3, this.state, this.files));
  }
  static resetTapTwice() {
    al = false;
  }
  async addElementsFromMixedContentPaste(t3, { isPlainPaste: r3, sceneX: n3, sceneY: i3 }) {
    if (!r3 && t3.some((a3) => a3.type === "imageUrl") && this.isToolSupported("image")) {
      let a3 = t3.filter((p3) => p3.type === "imageUrl").map((p3) => p3.value), l3 = await Promise.all(a3.map(async (p3) => {
        try {
          return { file: await AY(p3) };
        } catch (u3) {
          let h3 = u3.message;
          return u3.cause === "FETCH_ERROR" ? h3 = g("errors.failedToFetchImage") : u3.cause === "UNSUPPORTED" && (h3 = g("errors.unsupportedFileType")), { errorMessage: h3 };
        }
      })), s3 = i3, c3 = false, m3 = {};
      for (let p3 of l3) if (p3.file) {
        let u3 = this.createImageElement({ sceneX: n3, sceneY: s3 }), h3 = await this.insertImageElement(u3, p3.file);
        h3 && (c3 || (c3 = true, s3 -= h3.height / 2), Y(h3, { y: s3 }, false), s3 = u3.y + u3.height + 25, m3[u3.id] = true);
      }
      this.setState({ selectedElementIds: Ha$1(m3, this.state) });
      let d3 = l3.find((p3) => !!p3.errorMessage);
      d3 && d3.errorMessage && this.setState({ errorMessage: d3.errorMessage });
    } else {
      let a3 = t3.filter((l3) => l3.type === "text");
      a3.length && this.addTextFromPaste(a3.map((l3) => l3.value).join(`

`), r3);
    }
  }
  addTextFromPaste(t3, r3 = false) {
    let { x: n3, y: i3 } = Dn({ clientX: this.lastViewportPosition.x, clientY: this.lastViewportPosition.y }, this.state), a3 = { x: n3, y: i3, strokeColor: this.state.currentItemStrokeColor, backgroundColor: this.state.currentItemBackgroundColor, fillStyle: this.state.currentItemFillStyle, strokeWidth: this.state.currentItemStrokeWidth, strokeStyle: this.state.currentItemStrokeStyle, roundness: null, roughness: this.state.currentItemRoughness, opacity: this.state.currentItemOpacity, text: t3, fontSize: this.state.currentItemFontSize, fontFamily: this.state.currentItemFontFamily, textAlign: Vn, verticalAlign: go, locked: false }, l3 = Ee({ fontSize: a3.fontSize, fontFamily: a3.fontFamily }), s3 = ko(a3.fontFamily), [c3, , m3] = fN(this.state), d3 = Math.max(Math.min((m3 - c3) * 0.5, 800), 200), p3 = 10, u3 = i3, h3 = r3 ? [t3] : t3.split(`
`), f3 = h3.reduce((b3, x3, T3) => {
      let E3 = ia(x3).trim();
      if (E3.length) {
        let w3 = this.getTopLayerFrameAtSceneCoords({ x: n3, y: u3 }), S3 = ht(E3, l3, s3), I3 = S3.width > d3, _3 = I3 ? en(E3, l3, d3) : E3;
        S3 = I3 ? ht(_3, l3, s3) : S3;
        let k2 = n3 - S3.width / 2, R3 = u3 - S3.height / 2, M = qt({ ...a3, x: k2, y: R3, text: _3, originalText: E3, lineHeight: s3, autoResize: !I3, frameId: w3 ? w3.id : null });
        b3.push(M), u3 += M.height + p3;
      } else h3[T3 - 1]?.trim() && (u3 += Zn(a3.fontSize, s3) + p3);
      return b3;
    }, []);
    f3.length !== 0 && (this.scene.insertElements(f3), this.setState({ selectedElementIds: Ha$1(Object.fromEntries(f3.map((b3) => [b3.id, true])), this.state) }), !r3 && f3.length > 1 && uT === false && !this.device.editor.isMobile && (this.setToast({ message: g("toast.pasteAsSingleElement", { shortcut: cg$1("CtrlOrCmd+Shift+V") }), duration: 5e3 }), uT = true), this.store.shouldCaptureIncrement());
  }
  handleTextWysiwyg(t3, { isExistingElement: r3 = false }) {
    let n3 = this.scene.getElementsMapIncludingDeleted(), i3 = (a3, l3) => {
      this.scene.replaceAllElements([...this.scene.getElementsIncludingDeleted().map((s3) => s3.id === t3.id && k$2(s3) ? vt$1(s3, { originalText: a3, isDeleted: l3 ?? s3.isDeleted, ...Ga$1(s3, qe(s3, n3), n3, a3) }) : s3)]);
    };
    iT({ id: t3.id, canvas: this.canvas, getViewportCoords: (a3, l3) => {
      let { x: s3, y: c3 } = ta({ sceneX: a3, sceneY: l3 }, this.state);
      return [s3 - this.state.offsetLeft, c3 - this.state.offsetTop];
    }, onChange: Fe((a3) => {
      i3(a3, false), zp$1(t3) && Jt(t3, this.scene.getNonDeletedElementsMap());
    }), onSubmit: Fe(({ viaKeyboard: a3, nextOriginalText: l3 }) => {
      let s3 = !l3.trim();
      if (i3(l3, s3), !s3 && a3) {
        let c3 = t3.containerId ? t3.containerId : t3.id;
        reactDomExports.flushSync(() => {
          this.setState((m3) => ({ selectedElementIds: Ha$1({ ...m3.selectedElementIds, [c3]: true }, m3) }));
        });
      }
      s3 && KN(this.scene.getNonDeletedElements(), [t3]), (!s3 || r3) && this.store.shouldCaptureIncrement(), reactDomExports.flushSync(() => {
        this.setState({ newElement: null, editingTextElement: null });
      }), this.state.activeTool.locked && $2(this.interactiveCanvas, this.state), this.focusContainer();
    }), element: t3, excalidrawContainer: this.excalidrawContainerRef.current, app: this, autoSelect: !this.device.isTouchScreen }), this.deselectElements(), i3(t3.originalText, false);
  }
  deselectElements() {
    this.setState({ selectedElementIds: Ha$1({}, this.state), selectedGroupIds: {}, editingGroupId: null, activeEmbeddable: null });
  }
  getTextElementAtPosition(t3, r3) {
    let n3 = this.getElementAtPosition(t3, r3, { includeBoundTextElement: true });
    return n3 && k$2(n3) && !n3.isDeleted ? n3 : null;
  }
  getElementAtPosition(t3, r3, n3) {
    let i3 = this.getElementsAtPosition(t3, r3, n3?.includeBoundTextElement, n3?.includeLockedElements);
    if (i3.length > 1) {
      if (n3?.preferSelected) {
        for (let l3 = i3.length - 1; l3 > -1; l3--) if (this.state.selectedElementIds[i3[l3].id]) return i3[l3];
      }
      let a3 = i3[i3.length - 1];
      return xm({ x: t3, y: r3, element: a3, shape: ti(a3, this.scene.getNonDeletedElementsMap()), threshold: this.getElementHitThreshold() / 2, frameNameBound: de(a3) ? this.frameNameBoundsCache.get(a3) : null }) ? a3 : i3[i3.length - 2];
    }
    return i3.length === 1 ? i3[0] : null;
  }
  getElementsAtPosition(t3, r3, n3 = false, i3 = false) {
    let a3 = [], l3 = this.scene.getNonDeletedElementsMap();
    return (n3 && i3 ? this.scene.getNonDeletedElements() : this.scene.getNonDeletedElements().filter((c3) => (i3 || !c3.locked) && (n3 || !(k$2(c3) && c3.containerId)))).filter((c3) => this.hitElement(t3, r3, c3)).filter((c3) => {
      let m3 = We(c3, l3);
      return m3 && this.state.frameRendering.enabled && this.state.frameRendering.clip ? mH({ x: t3, y: r3 }, m3, l3) : true;
    }).filter((c3) => _o$1(c3) ? (a3.push(c3), false) : true).concat(a3);
  }
  getElementHitThreshold() {
    return xE / this.state.zoom.value;
  }
  hitElement(t3, r3, n3, i3 = true) {
    if (i3 && this.state.selectedElementIds[n3.id] && fJ([n3], this.state)) {
      let l3 = f$(n3, this.scene.getNonDeletedElementsMap(), Ye$1(n3) ? 0 : this.getElementHitThreshold());
      if (Wo(u$1(t3, r3), l3)) return true;
    }
    return hm(t3, r3, L1$1(n3, this.scene.getNonDeletedElementsMap())) ? true : xm({ x: t3, y: r3, element: n3, shape: ti(n3, this.scene.getNonDeletedElementsMap()), threshold: this.getElementHitThreshold(), frameNameBound: de(n3) ? this.frameNameBoundsCache.get(n3) : null });
  }
  getTextBindableContainerAtPosition(t3, r3) {
    let n3 = this.scene.getNonDeletedElements(), i3 = this.scene.getSelectedElements(this.state);
    if (i3.length === 1) return F6(i3[0], false) ? i3[0] : null;
    let a3 = null;
    for (let l3 = n3.length - 1; l3 >= 0; --l3) {
      if (n3[l3].isDeleted) continue;
      let [s3, c3, m3, d3] = C$1(n3[l3], this.scene.getNonDeletedElementsMap());
      if (ee(n3[l3]) && xm({ x: t3, y: r3, element: n3[l3], shape: ti(n3[l3], this.scene.getNonDeletedElementsMap()), threshold: this.getElementHitThreshold() })) {
        a3 = n3[l3];
        break;
      } else if (s3 < t3 && t3 < m3 && c3 < r3 && r3 < d3) {
        a3 = n3[l3];
        break;
      }
    }
    return F6(a3, false) ? a3 : null;
  }
  handleHoverSelectedLinearElement(t3, r3, n3) {
    let i3 = this.scene.getNonDeletedElementsMap(), a3 = z$1.getElement(t3.elementId, i3);
    if (a3) if (this.state.selectedLinearElement) {
      let l3 = -1, s3 = null;
      xm({ x: r3, y: n3, element: a3, shape: ti(a3, this.scene.getNonDeletedElementsMap()) }) ? (l3 = z$1.getPointIndexUnderCursor(a3, i3, this.state.zoom, r3, n3), s3 = z$1.getSegmentMidpointHitCoords(t3, { x: r3, y: n3 }, this.state, this.scene.getNonDeletedElementsMap()), (X$1(a3) ? l3 === 0 || l3 === a3.points.length - 1 : l3 >= 0) || s3 ? Jb(this.interactiveCanvas, mo.POINTER) : this.hitElement(r3, n3, a3) && Jb(this.interactiveCanvas, mo.MOVE)) : this.hitElement(r3, n3, a3) && (!X$1(a3) || !(a3.startBinding || a3.endBinding)) && Jb(this.interactiveCanvas, mo.MOVE), this.state.selectedLinearElement.hoverPointIndex !== l3 && this.setState({ selectedLinearElement: { ...this.state.selectedLinearElement, hoverPointIndex: l3 } }), z$1.arePointsEqual(this.state.selectedLinearElement.segmentMidPointHoveredCoords, s3) || this.setState({ selectedLinearElement: { ...this.state.selectedLinearElement, segmentMidPointHoveredCoords: s3 } });
    } else Jb(this.interactiveCanvas, mo.AUTO);
  }
  updateGestureOnPointerDown(t3) {
    fe.pointers.set(t3.pointerId, { x: t3.clientX, y: t3.clientY }), fe.pointers.size === 2 && (fe.lastCenter = Ou(fe.pointers), fe.initialScale = this.state.zoom.value, fe.initialDistance = Fu(Array.from(fe.pointers.values())));
  }
  initialPointerDownState(t3) {
    let r3 = Dn(t3, this.state), n3 = this.scene.getSelectedElements(this.state), [i3, a3, l3, s3] = $e$1(n3), c3 = n3.findIndex(X$1) === 0;
    return { origin: r3, withCmdOrCtrl: t3[Q.CTRL_OR_CMD], originInGrid: un(Vr(r3.x, r3.y, t3[Q.CTRL_OR_CMD] || c3 ? null : this.getEffectiveGridSize())), scrollbars: Gu(Pg, t3.clientX - this.state.offsetLeft, t3.clientY - this.state.offsetTop), lastCoords: { ...r3 }, originalElements: this.scene.getNonDeletedElements().reduce((m3, d3) => (m3.set(d3.id, Gr(d3)), m3), /* @__PURE__ */ new Map()), resize: { handleType: false, isResizing: false, offset: { x: 0, y: 0 }, arrowDirection: "origin", center: { x: (l3 + i3) / 2, y: (s3 + a3) / 2 } }, hit: { element: null, allHitElements: [], wasAddedToSelection: false, hasBeenDuplicated: false, hasHitCommonBoundingBoxOfSelectedElements: this.isHittingCommonBoundingBoxOfSelectedElements(r3, n3) }, drag: { hasOccurred: false, offset: null }, eventListeners: { onMove: null, onUp: null, onKeyUp: null, onKeyDown: null }, boxSelection: { hasOccurred: false } };
  }
  handleDraggingScrollBar(t3, r3) {
    if (!(r3.scrollbars.isOverEither && !this.state.multiElement)) return false;
    Dg = true, r3.lastCoords.x = t3.clientX, r3.lastCoords.y = t3.clientY;
    let n3 = Ad((a3) => {
      a3.target instanceof HTMLElement && this.handlePointerMoveOverScrollbars(a3, r3);
    }), i3 = Fe(() => {
      cl = null, Dg = false, $2(this.interactiveCanvas, this.state), this.setState({ cursorButton: "up" }), this.savePointer(t3.clientX, t3.clientY, "up"), window.removeEventListener("pointermove", n3), window.removeEventListener("pointerup", i3), n3.flush();
    });
    return cl = i3, window.addEventListener("pointermove", n3), window.addEventListener("pointerup", i3), true;
  }
  isASelectedElement(t3) {
    return t3 != null && this.state.selectedElementIds[t3.id];
  }
  isHittingCommonBoundingBoxOfSelectedElements(t3, r3) {
    if (r3.length < 2) return false;
    let n3 = this.getElementHitThreshold(), [i3, a3, l3, s3] = $e$1(r3);
    return t3.x > i3 - n3 && t3.x < l3 + n3 && t3.y > a3 - n3 && t3.y < s3 + n3;
  }
  getCurrentItemRoundness(t3) {
    return this.state.currentItemRoundness === "round" ? { type: Oo$1(t3) ? ot.ADAPTIVE_RADIUS : ot.PROPORTIONAL_RADIUS } : null;
  }
  maybeCacheReferenceSnapPoints(t3, r3, n3 = false) {
    sr({ event: t3, app: this, selectedElements: r3 }) && (n3 || !mi.getReferenceSnapPoints()) && mi.setReferenceSnapPoints(wF(this.scene.getNonDeletedElements(), r3, this.state, this.scene.getNonDeletedElementsMap()));
  }
  maybeCacheVisibleGaps(t3, r3, n3 = false) {
    sr({ event: t3, app: this, selectedElements: r3 }) && (n3 || !mi.getVisibleGaps()) && mi.setVisibleGaps(IF(this.scene.getNonDeletedElements(), r3, this.state, this.scene.getNonDeletedElementsMap()));
  }
  onKeyDownFromPointerDownHandler(t3) {
    return Fe((r3) => {
      this.maybeHandleResize(t3, r3) || this.maybeDragNewGenericElement(t3, r3);
    });
  }
  onKeyUpFromPointerDownHandler(t3) {
    return Fe((r3) => {
      r3.key === Q.ALT && r3.preventDefault(), !this.maybeHandleResize(t3, r3) && this.maybeDragNewGenericElement(t3, r3);
    });
  }
  onPointerMoveFromPointerDownHandler(t3) {
    return Ad((r3) => {
      if (this.state.openDialog?.name === "elementLinkSelector") return;
      let n3 = Dn(r3, this.state);
      if (this.state.selectedLinearElement && this.state.selectedLinearElement.elbowed && this.state.selectedLinearElement.pointerDownState.segmentMidpoint.index) {
        let [p3, u3] = Vr(n3.x, n3.y, r3[Q.CTRL_OR_CMD] ? null : this.getEffectiveGridSize()), h3 = this.state.selectedLinearElement.pointerDownState.segmentMidpoint.index;
        if (h3 < 0) {
          let b3 = z$1.getSegmentMidpointHitCoords({ ...this.state.selectedLinearElement, segmentMidPointHoveredCoords: null }, { x: p3, y: u3 }, this.state, this.scene.getNonDeletedElementsMap());
          h3 = b3 ? z$1.getSegmentMidPointIndex(this.state.selectedLinearElement, this.state, b3, this.scene.getNonDeletedElementsMap()) : -1;
        }
        let f3 = z$1.moveFixedSegment(this.state.selectedLinearElement, h3, p3, u3, this.scene.getNonDeletedElementsMap());
        reactDomExports.flushSync(() => {
          this.state.selectedLinearElement && this.setState({ selectedLinearElement: { ...this.state.selectedLinearElement, segmentMidPointHoveredCoords: f3.segmentMidPointHoveredCoords, pointerDownState: f3.pointerDownState } });
        });
        return;
      }
      let i3 = this.lastPointerMoveCoords ?? t3.origin;
      if (this.lastPointerMoveCoords = n3, t3.drag.offset === null && (t3.drag.offset = un(B9(this.scene.getSelectedElements(this.state), t3.origin.x, t3.origin.y))), !(r3.target instanceof HTMLElement) || this.handlePointerMoveOverScrollbars(r3, t3)) return;
      if (td$1(this.state)) {
        this.handleEraser(r3, t3, n3);
        return;
      }
      this.state.activeTool.type === "laser" && this.laserTrails.addPointToPath(n3.x, n3.y);
      let [l3, s3] = Vr(n3.x, n3.y, r3[Q.CTRL_OR_CMD] ? null : this.getEffectiveGridSize());
      if (!t3.drag.hasOccurred && (this.state.activeTool.type === "arrow" || this.state.activeTool.type === "line") && ie(u$1(n3.x, n3.y), u$1(t3.origin.x, t3.origin.y)) < As) return;
      if (t3.resize.isResizing && (t3.lastCoords.x = n3.x, t3.lastCoords.y = n3.y, this.maybeHandleCrop(t3, r3) || this.maybeHandleResize(t3, r3))) return true;
      let c3 = this.scene.getNonDeletedElementsMap();
      if (this.state.selectedLinearElement) {
        let p3 = this.state.editingLinearElement || this.state.selectedLinearElement;
        if (z$1.shouldAddMidpoint(this.state.selectedLinearElement, n3, this.state, c3)) {
          let h3 = z$1.addMidpoint(this.state.selectedLinearElement, n3, this, !r3[Q.CTRL_OR_CMD], c3);
          if (!h3) return;
          reactDomExports.flushSync(() => {
            this.state.selectedLinearElement && this.setState({ selectedLinearElement: { ...this.state.selectedLinearElement, pointerDownState: h3.pointerDownState, selectedPointsIndices: h3.selectedPointsIndices } }), this.state.editingLinearElement && this.setState({ editingLinearElement: { ...this.state.editingLinearElement, pointerDownState: h3.pointerDownState, selectedPointsIndices: h3.selectedPointsIndices } });
          });
          return;
        } else if (p3.pointerDownState.segmentMidpoint.value !== null && !p3.pointerDownState.segmentMidpoint.added) return;
        if (z$1.handlePointDragging(r3, this, n3.x, n3.y, (h3, f3) => {
          this.maybeSuggestBindingsForLinearElementAtCoords(h3, f3);
        }, p3, this.scene)) {
          t3.lastCoords.x = n3.x, t3.lastCoords.y = n3.y, t3.drag.hasOccurred = true, this.state.editingLinearElement && !this.state.editingLinearElement.isDragging && this.setState({ editingLinearElement: { ...this.state.editingLinearElement, isDragging: true } }), this.state.selectedLinearElement.isDragging || this.setState({ selectedLinearElement: { ...this.state.selectedLinearElement, isDragging: true } });
          return;
        }
      }
      let m3 = t3.hit.allHitElements.some((p3) => this.isASelectedElement(p3)), d3 = this.state.editingLinearElement && r3.shiftKey && this.state.editingLinearElement.elementId === t3.hit.element?.id;
      if ((m3 || t3.hit.hasHitCommonBoundingBoxOfSelectedElements) && !d3) {
        let p3 = this.scene.getSelectedElements(this.state);
        if (p3.every((b3) => b3.locked)) return;
        let u3 = p3.find((b3) => de(b3)), h3 = this.getTopLayerFrameAtSceneCoords(n3), f3 = h3 && !u3 ? h3 : null;
        if (this.state.frameToHighlight !== f3 && reactDomExports.flushSync(() => {
          this.setState({ frameToHighlight: f3 });
        }), t3.drag.hasOccurred = true, p3.length > 0 && !t3.withCmdOrCtrl && !this.state.editingTextElement && this.state.activeEmbeddable?.state !== "active") {
          let b3 = { x: n3.x - t3.origin.x, y: n3.y - t3.origin.y }, x3 = [...t3.originalElements.values()], T3 = r3.shiftKey;
          if (T3) {
            let S3 = Math.abs(b3.x), I3 = Math.abs(b3.y), _3 = T3 && S3 < I3, k2 = T3 && S3 > I3;
            _3 && (b3.x = 0), k2 && (b3.y = 0);
          }
          if (this.state.croppingElementId) {
            let S3 = this.scene.getNonDeletedElementsMap().get(this.state.croppingElementId);
            if (S3 && Ye$1(S3) && S3.crop !== null && t3.hit.element === S3) {
              let I3 = S3.crop, _3 = At(S3) && this.imageCache.get(S3.fileId)?.image;
              if (_3 && !(_3 instanceof Promise)) {
                let k2 = ue(Be(n3.x - i3.x, n3.y - i3.y), Math.max(this.state.zoom.value, 2)), [R3, M, N3, G3, H3, V3] = C$1(S3, c3), F3 = O(T$1(u$1(R3, M), u$1(H3, V3), S3.angle)), O$1 = O(T$1(u$1(N3, M), u$1(H3, V3), S3.angle)), j = O(T$1(u$1(R3, G3), u$1(H3, V3), S3.angle)), oe2 = Je(Lo(O$1, F3)), W = Je(Lo(j, F3)), ne3 = Be(h6(k2, oe2), h6(k2, W)), ge2 = { ...I3, x: se(I3.x - ne3[0] * Math.sign(S3.scale[0]), 0, _3.naturalWidth - I3.width), y: se(I3.y - ne3[1] * Math.sign(S3.scale[1]), 0, _3.naturalHeight - I3.height) };
                Y(S3, { crop: ge2 });
                return;
              }
            }
          }
          this.maybeCacheVisibleGaps(r3, p3), this.maybeCacheReferenceSnapPoints(r3, p3);
          let { snapOffset: E3, snapLines: w3 } = RF(x3, b3, this, r3, this.scene.getNonDeletedElementsMap());
          if (this.setState({ snapLines: w3 }), this.state.editingFrame || N9(t3, p3, b3, this.scene, E3, r3[Q.CTRL_OR_CMD] ? null : this.getEffectiveGridSize()), this.setState({ selectedElementsAreBeingDragged: true, selectionElement: null }), (p3.length !== 1 || !X$1(p3[0])) && this.setState({ suggestedBindings: _N(p3, this.scene.getNonDeletedElementsMap(), this.state.zoom) }), r3.altKey && !t3.hit.hasBeenDuplicated) {
            t3.hit.hasBeenDuplicated = true;
            let S3 = [], I3 = [], _3 = /* @__PURE__ */ new Map(), k2 = /* @__PURE__ */ new Map(), R3 = t3.hit.element, M = new Set(this.scene.getSelectedElements({ selectedElementIds: this.state.selectedElementIds, includeBoundTextElement: true, includeElementsInFrames: true }).map((V3) => V3.id)), N3 = this.scene.getElementsIncludingDeleted();
            for (let V3 of N3) {
              let F3 = M.has(V3.id) || V3.id === R3?.id && t3.hit.wasAddedToSelection;
              if (Math.abs(V3.x) > 1e7 || Math.abs(V3.x) > 1e7 || Math.abs(V3.width) > 1e7 || Math.abs(V3.height) > 1e7) {
                console.error("Alt+dragging element in scene with invalid dimensions", V3.x, V3.y, V3.width, V3.height, F3);
                return;
              }
              if (F3) {
                let O3 = zb(this.state.editingGroupId, _3, V3);
                if (Math.abs(O3.x) > 1e7 || Math.abs(O3.x) > 1e7 || Math.abs(O3.width) > 1e7 || Math.abs(O3.height) > 1e7) {
                  console.error("Alt+dragging duplicated element with invalid dimensions", O3.x, O3.y, O3.width, O3.height);
                  return;
                }
                let j = t3.originalElements.get(V3.id);
                if (Math.abs(j.x) > 1e7 || Math.abs(j.x) > 1e7 || Math.abs(j.width) > 1e7 || Math.abs(j.height) > 1e7) {
                  console.error("Alt+dragging duplicated element with invalid dimensions", j.x, j.y, j.width, j.height);
                  return;
                }
                Y(O3, { x: j.x, y: j.y }), t3.originalElements.set(O3.id, O3), S3.push(O3), I3.push(V3), k2.set(V3.id, O3.id);
              } else S3.push(V3);
            }
            let G3 = [...S3, ...I3];
            G3 = this.props.onDuplicate?.(G3, N3) || G3, Zr(G3, te(I3)), dB(S3, I3, k2), AN(G3, I3, k2, "duplicatesServeAsOld"), uH(G3, I3, k2), this.scene.replaceAllElements(G3), this.maybeCacheVisibleGaps(r3, p3, true), this.maybeCacheReferenceSnapPoints(r3, p3, true);
          }
          return;
        }
      }
      if (this.state.selectionElement) t3.lastCoords.x = n3.x, t3.lastCoords.y = n3.y, this.maybeDragNewGenericElement(t3, r3);
      else {
        let p3 = this.state.newElement;
        if (!p3) return;
        if (p3.type === "freedraw") {
          let u3 = p3.points, h3 = n3.x - p3.x, f3 = n3.y - p3.y, b3 = u3.length > 0 && u3[u3.length - 1];
          if (!(b3 && b3[0] === h3 && b3[1] === f3)) {
            let T3 = p3.simulatePressure ? p3.pressures : [...p3.pressures, r3.pressure];
            Y(p3, { points: [...u3, u$1(h3, f3)], pressures: T3 }, false), this.setState({ newElement: p3 });
          }
        } else if (ae(p3)) {
          t3.drag.hasOccurred = true;
          let u3 = p3.points, h3 = l3 - p3.x, f3 = s3 - p3.y;
          ga(r3) && u3.length === 2 && ({ width: h3, height: f3 } = Va(p3.x, p3.y, n3.x, n3.y)), u3.length === 1 ? Y(p3, { points: [...u3, u$1(h3, f3)] }, false) : (u3.length === 2 || u3.length > 1 && X$1(p3)) && Y(p3, { points: [...u3.slice(0, -1), u$1(h3, f3)] }, false, { isDragging: true }), this.setState({ newElement: p3 }), Pr(p3, false) && this.maybeSuggestBindingsForLinearElementAtCoords(p3, [n3], this.state.startBoundElement);
        } else t3.lastCoords.x = n3.x, t3.lastCoords.y = n3.y, this.maybeDragNewGenericElement(t3, r3, false);
      }
      if (this.state.activeTool.type === "selection") {
        t3.boxSelection.hasOccurred = true;
        let p3 = this.scene.getNonDeletedElements();
        if (this.state.editingLinearElement) z$1.handleBoxSelection(r3, this.state, this.setState.bind(this), this.scene.getNonDeletedElementsMap());
        else {
          let u3 = true;
          !r3.shiftKey && Ib(p3, this.state) && (t3.withCmdOrCtrl && t3.hit.element ? this.setState((f3) => aF({ ...f3, selectedElementIds: { [t3.hit.element.id]: true } }, this.scene.getNonDeletedElements(), f3, this)) : u3 = false);
          let h3 = this.state.selectionElement ? ui(p3, this.state.selectionElement, this.scene.getNonDeletedElementsMap(), false) : [];
          this.setState((f3) => {
            let b3 = { ...u3 && f3.selectedElementIds, ...h3.reduce((x3, T3) => (x3[T3.id] = true, x3), {}) };
            return t3.hit.element && (h3.length ? delete b3[t3.hit.element.id] : b3[t3.hit.element.id] = true), f3 = u3 ? f3 : { ...f3, selectedGroupIds: {}, editingGroupId: null }, { ...aF({ editingGroupId: f3.editingGroupId, selectedElementIds: b3 }, this.scene.getNonDeletedElements(), f3, this), selectedLinearElement: h3.length === 1 && ae(h3[0]) ? new z$1(h3[0]) : null, showHyperlinkPopup: h3.length === 1 && (h3[0].link || Bo(h3[0])) ? "info" : false };
          });
        }
      }
    });
  }
  handlePointerMoveOverScrollbars(t3, r3) {
    if (r3.scrollbars.isOverHorizontal) {
      let n3 = t3.clientX, i3 = n3 - r3.lastCoords.x;
      return this.translateCanvas({ scrollX: this.state.scrollX - i3 / this.state.zoom.value }), r3.lastCoords.x = n3, true;
    }
    if (r3.scrollbars.isOverVertical) {
      let n3 = t3.clientY, i3 = n3 - r3.lastCoords.y;
      return this.translateCanvas({ scrollY: this.state.scrollY - i3 / this.state.zoom.value }), r3.lastCoords.y = n3, true;
    }
    return false;
  }
  onPointerUpFromPointerDownHandler(t3) {
    return Fe((r3) => {
      this.removePointer(r3), t3.eventListeners.onMove && t3.eventListeners.onMove.flush();
      let { newElement: n3, resizingElement: i3, croppingElementId: a3, multiElement: l3, activeTool: s3, isResizing: c3, isRotating: m3, isCropping: d3 } = this.state;
      this.setState((b3) => ({ isResizing: false, isRotating: false, isCropping: false, resizingElement: null, selectionElement: null, frameToHighlight: null, elementsToHighlight: null, cursorButton: "up", snapLines: Dg$1(b3.snapLines, []), originSnapOffset: null })), this.lastPointerMoveCoords = null, mi.setReferenceSnapPoints(null), mi.setVisibleGaps(null), this.savePointer(r3.clientX, r3.clientY, "up"), this.setState({ selectedElementsAreBeingDragged: false });
      let p3 = this.scene.getNonDeletedElementsMap();
      if (t3.drag.hasOccurred && t3.hit?.element?.id) {
        let b3 = p3.get(t3.hit.element.id);
        xt(b3) && b3.boundElements?.filter((x3) => x3.type === "arrow").map((x3) => p3.get(x3.id)).filter((x3) => X$1(x3)).forEach((x3) => {
          x3 && Y(x3, {}, true);
        });
      }
      if (this.state.editingLinearElement) if (!t3.boxSelection.hasOccurred && t3.hit?.element?.id !== this.state.editingLinearElement.elementId) this.actionManager.executeAction(Ht);
      else {
        let b3 = z$1.handlePointerUp(r3, this.state.editingLinearElement, this.state, this.scene);
        b3 !== this.state.editingLinearElement && this.setState({ editingLinearElement: b3, suggestedBindings: [] });
      }
      else if (this.state.selectedLinearElement) {
        if (this.state.selectedLinearElement.elbowed) {
          let b3 = z$1.getElement(this.state.selectedLinearElement.elementId, this.scene.getNonDeletedElementsMap());
          b3 && Y(b3, {}, true);
        }
        if (t3.hit?.element?.id !== this.state.selectedLinearElement.elementId) this.scene.getSelectedElements(this.state).length > 1 && this.setState({ selectedLinearElement: null });
        else {
          let b3 = z$1.handlePointerUp(r3, this.state.selectedLinearElement, this.state, this.scene), { startBindingElement: x3, endBindingElement: T3 } = b3, E3 = this.scene.getElement(b3.elementId);
          Pr(E3) && Ba(E3, x3, T3, p3, this.scene), b3 !== this.state.selectedLinearElement && this.setState({ selectedLinearElement: { ...b3, selectedPointsIndices: null }, suggestedBindings: [] });
        }
      }
      if (this.missingPointerEventCleanupEmitter.clear(), window.removeEventListener("pointermove", t3.eventListeners.onMove), window.removeEventListener("pointerup", t3.eventListeners.onUp), window.removeEventListener("keydown", t3.eventListeners.onKeyDown), window.removeEventListener("keyup", t3.eventListeners.onKeyUp), this.state.pendingImageElementId && this.setState({ pendingImageElementId: null }), this.props?.onPointerUp?.(s3, t3), this.onPointerUpEmitter.trigger(this.state.activeTool, t3, r3), n3?.type === "freedraw") {
        let b3 = Dn(r3, this.state), x3 = n3.points, T3 = b3.x - n3.x, E3 = b3.y - n3.y;
        T3 === x3[0][0] && E3 === x3[0][1] && (E3 += 1e-4, T3 += 1e-4);
        let w3 = n3.simulatePressure ? [] : [...n3.pressures, r3.pressure];
        Y(n3, { points: [...x3, u$1(T3, E3)], pressures: w3, lastCommittedPoint: u$1(T3, E3) }), this.actionManager.executeAction(Ht);
        return;
      }
      if (Ye$1(n3)) {
        let b3 = n3;
        try {
          this.initializeImageDimensions(b3), this.setState({ selectedElementIds: Ha$1({ [b3.id]: true }, this.state) }, () => {
            this.actionManager.executeAction(Ht);
          });
        } catch (x3) {
          console.error(x3), this.scene.replaceAllElements(this.scene.getElementsIncludingDeleted().filter((T3) => T3.id !== b3.id)), this.actionManager.executeAction(Ht);
        }
        return;
      }
      if (ae(n3)) {
        n3.points.length > 1 && this.store.shouldCaptureIncrement();
        let b3 = Dn(r3, this.state);
        !t3.drag.hasOccurred && n3 && !l3 ? (Y(n3, { points: [...n3.points, u$1(b3.x - n3.x, b3.y - n3.y)] }), this.setState({ multiElement: n3, newElement: n3 })) : t3.drag.hasOccurred && !l3 && (Fa$1(this.state) && Pr(n3, false) && ON(n3, this.state, b3, this.scene.getNonDeletedElementsMap(), this.scene.getNonDeletedElements()), this.setState({ suggestedBindings: [], startBoundElement: null }), s3.locked ? this.setState((x3) => ({ newElement: null })) : (Hb(this.interactiveCanvas), this.setState((x3) => ({ newElement: null, activeTool: $r(this.state, { type: "selection" }), selectedElementIds: Ha$1({ ...x3.selectedElementIds, [n3.id]: true }, x3), selectedLinearElement: new z$1(n3) }))), this.scene.triggerUpdate());
        return;
      }
      if (k$2(n3)) {
        let b3 = Ko(Ee({ fontSize: n3.fontSize, fontFamily: n3.fontFamily }), n3.lineHeight);
        n3.width < b3 && Y(n3, { autoResize: true }), this.resetCursor(), this.handleTextWysiwyg(n3, { isExistingElement: true });
      }
      if (s3.type !== "selection" && n3 && ao$1(n3)) {
        this.updateScene({ elements: this.scene.getElementsIncludingDeleted().filter((b3) => b3.id !== n3.id), appState: { newElement: null }, captureUpdate: dr.NEVER });
        return;
      }
      if (de(n3)) {
        let b3 = gH(this.scene.getElementsIncludingDeleted(), n3, this.scene.getNonDeletedElementsMap());
        this.scene.replaceAllElements(l9(this.scene.getElementsMapIncludingDeleted(), b3, n3, this.state));
      }
      if (n3 && (Y(n3, bs(n3)), this.scene.triggerUpdate()), t3.drag.hasOccurred) {
        let b3 = Dn(r3, this.state);
        if (this.state.selectedLinearElement && this.state.selectedLinearElement.isDragging) {
          let x3 = this.scene.getElement(this.state.selectedLinearElement.elementId);
          if (x3?.frameId) {
            let T3 = We(x3, p3);
            T3 && x3 && (hn(x3, T3, this.scene.getNonDeletedElementsMap()) || (Y(x3, { groupIds: [] }), Xp$1([x3], this.scene.getNonDeletedElementsMap()), this.scene.triggerUpdate()));
          }
        } else {
          let x3 = this.getTopLayerFrameAtSceneCoords(b3), T3 = this.scene.getSelectedElements(this.state), E3 = this.scene.getElementsMapIncludingDeleted(), w3 = (S3) => {
            if (S3.length > 0) {
              for (let I3 of S3) {
                let _3 = I3.groupIds.indexOf(this.state.editingGroupId);
                Y(I3, { groupIds: I3.groupIds.slice(0, _3) }, false);
              }
              E3.forEach((I3) => {
                I3.groupIds.length && an(E3, I3.groupIds[I3.groupIds.length - 1]).length < 2 && Y(I3, { groupIds: [] }, false);
              }), this.setState({ editingGroupId: null });
            }
          };
          if (x3 && !this.state.selectedElementIds[x3.id]) {
            let S3 = T3.filter((I3) => I3.frameId !== x3.id && Gp$1(I3, E3, this.state));
            this.state.editingGroupId && w3(S3), E3 = l9(E3, S3, x3, this.state);
          } else if (!x3 && this.state.editingGroupId) {
            let S3 = T3.filter((I3) => I3.frameId && !Gp$1(I3, E3, this.state));
            w3(S3);
          }
          E3 = yH(E3, this.state, this), this.scene.replaceAllElements(E3);
        }
      }
      if (i3 && this.store.shouldCaptureIncrement(), i3 && ao$1(i3) && this.updateScene({ elements: this.scene.getElementsIncludingDeleted().filter((b3) => b3.id !== i3.id), captureUpdate: dr.NEVER }), t3.resize.isResizing) {
        let b3 = yH(this.scene.getElementsIncludingDeleted(), this.state, this), x3 = this.scene.getSelectedElements(this.state).filter((T3) => de(T3));
        for (let T3 of x3) b3 = hH(b3, EH(this.scene.getElementsIncludingDeleted(), T3, this.state, p3), T3, this);
        this.scene.replaceAllElements(b3);
      }
      let u3 = t3.hit.element;
      this.state.selectedLinearElement?.elementId !== u3?.id && ae(u3) && this.scene.getSelectedElements(this.state).length === 1 && this.setState({ selectedLinearElement: new z$1(u3) }), (!a3 || a3 && (!u3 && !d3 || u3 && u3.id !== a3)) && this.finishImageCropping();
      let h3 = this.lastPointerDownEvent, f3 = this.lastPointerUpEvent || this.lastPointerMoveEvent;
      if (td$1(this.state) && h3 && f3) {
        if (this.eraserTrail.endPath(), ie(u$1(h3.clientX, h3.clientY), u$1(f3.clientX, f3.clientY)) === 0) {
          let x3 = Dn({ clientX: f3.clientX, clientY: f3.clientY }, this.state);
          this.getElementsAtPosition(x3.x, x3.y).forEach((E3) => this.elementsPendingErasure.add(E3.id));
        }
        this.eraseElements();
        return;
      } else this.elementsPendingErasure.size && this.restoreReadyToEraseElements();
      if (u3 && !t3.drag.hasOccurred && !t3.hit.wasAddedToSelection && (!this.state.editingLinearElement || !t3.boxSelection.hasOccurred) && (r3.shiftKey && !this.state.editingLinearElement ? this.state.selectedElementIds[u3.id] ? sF(this.state, u3) ? this.setState((b3) => {
        let x3 = { ...b3.selectedElementIds };
        for (let T3 of u3.groupIds.flatMap((E3) => an(this.scene.getNonDeletedElements(), E3))) delete x3[T3.id];
        return { selectedGroupIds: { ...b3.selectedElementIds, ...u3.groupIds.map((T3) => ({ [T3]: false })).reduce((T3, E3) => ({ ...T3, ...E3 }), {}) }, selectedElementIds: Ha$1(x3, b3) };
      }) : this.state.selectedLinearElement?.isDragging || this.setState((b3) => {
        let x3 = { ...b3.selectedElementIds };
        delete x3[u3.id];
        let T3 = at$1(this.scene.getNonDeletedElements(), { selectedElementIds: x3 });
        return { ...aF({ editingGroupId: b3.editingGroupId, selectedElementIds: x3 }, this.scene.getNonDeletedElements(), b3, this), selectedLinearElement: T3.length === 1 && ae(T3[0]) ? new z$1(T3[0]) : b3.selectedLinearElement };
      }) : u3.frameId && this.state.selectedElementIds[u3.frameId] ? this.setState((b3) => {
        let x3 = { ...b3.selectedElementIds, [u3.id]: true };
        return delete x3[u3.frameId], (this.scene.getElement(u3.frameId)?.groupIds ?? []).flatMap((T3) => an(this.scene.getNonDeletedElements(), T3)).forEach((T3) => {
          delete x3[T3.id];
        }), { ...aF({ editingGroupId: b3.editingGroupId, selectedElementIds: x3 }, this.scene.getNonDeletedElements(), b3, this), showHyperlinkPopup: u3.link || Bo(u3) ? "info" : false };
      }) : this.setState((b3) => ({ selectedElementIds: Ha$1({ ...b3.selectedElementIds, [u3.id]: true }, b3) })) : this.setState((b3) => ({ ...aF({ editingGroupId: b3.editingGroupId, selectedElementIds: { [u3.id]: true } }, this.scene.getNonDeletedElements(), b3, this), selectedLinearElement: ae(u3) && b3.selectedLinearElement?.elementId !== u3.id ? new z$1(u3) : b3.selectedLinearElement }))), !(u3 && X$1(u3)) && !t3.drag.hasOccurred && !this.state.isResizing && (u3 && A$({ x: t3.origin.x, y: t3.origin.y, element: u3, shape: ti(u3, this.scene.getNonDeletedElementsMap()), threshold: this.getElementHitThreshold(), frameNameBound: de(u3) ? this.frameNameBoundsCache.get(u3) : null }, p3) || !u3 && t3.hit.hasHitCommonBoundingBoxOfSelectedElements)) {
        this.state.editingLinearElement ? this.setState({ editingLinearElement: null }) : this.setState({ selectedElementIds: Ha$1({}, this.state), selectedGroupIds: {}, editingGroupId: null, activeEmbeddable: null }), Jb(this.interactiveCanvas, mo.AUTO);
        return;
      }
      if (!s3.locked && s3.type !== "freedraw" && n3 && this.setState((b3) => ({ selectedElementIds: Ha$1({ ...b3.selectedElementIds, [n3.id]: true }, b3), showHyperlinkPopup: Bo(n3) && !n3.link ? "editor" : b3.showHyperlinkPopup })), (s3.type !== "selection" || Ib(this.scene.getNonDeletedElements(), this.state) || !Qt(this.state.previousSelectedElementIds, this.state.selectedElementIds)) && this.store.shouldCaptureIncrement(), t3.drag.hasOccurred || c3 || m3 || d3) {
        let b3 = this.scene.getSelectedElements(this.state).filter(ae);
        BN(b3, this.scene.getNonDeletedElementsMap(), this.scene.getNonDeletedElements(), this.scene, Fa$1(this.state), this.state.selectedLinearElement?.selectedPointsIndices ?? [], this.state.zoom);
      }
      if (s3.type === "laser") {
        this.laserTrails.endPath();
        return;
      }
      !s3.locked && s3.type !== "freedraw" ? (Hb(this.interactiveCanvas), this.setState({ newElement: null, suggestedBindings: [], activeTool: $r(this.state, { type: "selection" }) })) : this.setState({ newElement: null, suggestedBindings: [] }), u3 && this.lastPointerUpEvent && this.lastPointerDownEvent && this.lastPointerUpEvent.timeStamp - this.lastPointerDownEvent.timeStamp < 300 && fe.pointers.size <= 1 && gt$1(u3) && this.isIframeLikeElementCenter(u3, this.lastPointerUpEvent, t3.origin.x, t3.origin.y) && this.handleEmbeddableCenterClick(u3);
    });
  }
  clearSelection(t3) {
    this.setState((r3) => ({ selectedElementIds: Ha$1({}, r3), activeEmbeddable: null, selectedGroupIds: {}, editingGroupId: r3.editingGroupId && t3 != null && Lb(t3, r3.editingGroupId) ? r3.editingGroupId : null })), this.setState({ selectedElementIds: Ha$1({}, this.state), activeEmbeddable: null, previousSelectedElementIds: this.state.selectedElementIds });
  }
  getTextWysiwygSnappedToCenterPosition(t3, r3, n3, i3) {
    if (i3) {
      let a3 = i3.x + i3.width / 2, l3 = i3.y + i3.height / 2, s3 = cB(i3, n3, this.scene.getNonDeletedElementsMap());
      if (s3 && (a3 = s3.x, l3 = s3.y), Math.hypot(t3 - a3, r3 - l3) < pE) {
        let { x: d3, y: p3 } = ta({ sceneX: a3, sceneY: l3 }, n3);
        return { viewportX: d3, viewportY: p3, elementCenterX: a3, elementCenterY: l3 };
      }
    }
  }
  getCanvasOffsets() {
    if (this.excalidrawContainerRef?.current) {
      let t3 = this.excalidrawContainerRef.current, { left: r3, top: n3 } = t3.getBoundingClientRect();
      return { offsetLeft: r3, offsetTop: n3 };
    }
    return { offsetLeft: 0, offsetTop: 0 };
  }
  async updateLanguage() {
    let t3 = xi.find((r3) => r3.code === this.props.langCode) || _o;
    await $s(t3), this.setAppState({});
  }
}, tM = () => {
  (c$1.MODE === je.TEST || c$1.DEV) && (window.h = window.h || {}, Object.defineProperties(window.h, { elements: { configurable: true, get() {
    return this.app?.scene.getElementsIncludingDeleted();
  }, set(e12) {
    return this.app?.scene.replaceAllElements(An$1(e12));
  } }, scene: { configurable: true, get() {
    return this.app?.scene;
  } } }));
};
tM();
var bT = Ng;
var rM = () => {
  Array.prototype.at || Object.defineProperty(Array.prototype, "at", { value: function(e12) {
    if (e12 = Math.trunc(e12) || 0, e12 < 0 && (e12 += this.length), !(e12 < 0 || e12 >= this.length)) return this[e12];
  }, writable: true, enumerable: false, configurable: true }), Element.prototype.replaceChildren || (Element.prototype.replaceChildren = function(...e12) {
    this.innerHTML = "", this.append(...e12);
  });
}, xT = rM;
var aM = () => jsxRuntimeExports.jsx("svg", { viewBox: "0 0 40 40", fill: "none", xmlns: "http://www.w3.org/2000/svg", className: "ExcalidrawLogo-icon", children: jsxRuntimeExports.jsx("path", { d: "M39.9 32.889a.326.326 0 0 0-.279-.056c-2.094-3.083-4.774-6-7.343-8.833l-.419-.472a.212.212 0 0 0-.056-.139.586.586 0 0 0-.167-.111l-.084-.083-.056-.056c-.084-.167-.28-.278-.475-.167-.782.39-1.507.973-2.206 1.528-.92.722-1.842 1.445-2.708 2.25a8.405 8.405 0 0 0-.977 1.028c-.14.194-.028.361.14.444-.615.611-1.23 1.223-1.843 1.861a.315.315 0 0 0-.084.223c0 .083.056.166.111.194l1.09.833v.028c1.535 1.528 4.244 3.611 7.12 5.861.418.334.865.667 1.284 1 .195.223.39.473.558.695.084.11.28.139.391.055.056.056.14.111.196.167a.398.398 0 0 0 .167.056.255.255 0 0 0 .224-.111.394.394 0 0 0 .055-.167c.029 0 .028.028.056.028a.318.318 0 0 0 .224-.084l5.082-5.528a.309.309 0 0 0 0-.444Zm-14.63-1.917a.485.485 0 0 0 .111.14c.586.5 1.2 1 1.843 1.555l-2.569-1.945-.251-.166c-.056-.028-.112-.084-.168-.111l-.195-.167.056-.056.055-.055.112-.111c.866-.861 2.346-2.306 3.1-3.028-.81.805-2.43 3.167-2.095 3.944Zm8.767 6.89-2.122-1.612a44.713 44.713 0 0 0-2.625-2.5c1.145.861 2.122 1.611 2.262 1.75 1.117.972 1.06.806 1.815 1.445l.921.666a1.06 1.06 0 0 1-.251.25Zm.558.416-.056-.028c.084-.055.168-.111.252-.194l-.196.222ZM1.089 5.75c.055.361.14.722.195 1.056.335 1.833.67 3.5 1.284 4.75l.252.944c.084.361.223.806.363.917 1.424 1.25 3.602 3.11 5.947 4.889a.295.295 0 0 0 .363 0s0 .027.028.027a.254.254 0 0 0 .196.084.318.318 0 0 0 .223-.084c2.988-3.305 5.221-6.027 6.813-8.305.112-.111.14-.278.14-.417.111-.111.195-.25.307-.333.111-.111.111-.306 0-.39l-.028-.027c0-.055-.028-.139-.084-.167-.698-.666-1.2-1.138-1.731-1.638-.922-.862-1.871-1.75-3.881-3.75l-.028-.028c-.028-.028-.056-.056-.112-.056-.558-.194-1.703-.389-3.127-.639C6.087 2.223 3.21 1.723.614.944c0 0-.168 0-.196.028l-.083.084c-.028.027-.056.055-.224.11h.056-.056c.028.167.028.278.084.473 0 .055.112.5.112.555l.782 3.556Zm15.496 3.278-.335-.334c.084.112.196.195.335.334Zm-3.546 4.666-.056.056c0-.028.028-.056.056-.056Zm-2.038-10c.168.167.866.834 1.033.973-.726-.334-2.54-1.167-3.379-1.445.838.167 1.983.334 2.346.472ZM1.424 2.306c.419.722.754 3.222 1.089 5.666-.196-.778-.335-1.555-.503-2.278-.251-1.277-.503-2.416-.838-3.416.056 0 .14 0 .252.028Zm-.168-.584c-.112 0-.223-.028-.307-.028 0-.027 0-.055-.028-.055.14 0 .223.028.335.083Zm-1.089.222c0-.027 0-.027 0 0ZM39.453 1.333c.028-.11-.558-.61-.363-.639.42-.027.42-.666 0-.666-.558.028-1.144.166-1.675.25-.977.194-1.982.389-2.96.61-2.205.473-4.383.973-6.561 1.557-.67.194-1.424.333-2.066.666-.224.111-.196.333-.084.472-.056.028-.084.028-.14.056-.195.028-.363.056-.558.083-.168.028-.252.167-.224.334 0 .027.028.083.028.11-1.173 1.556-2.485 3.195-3.909 4.945-1.396 1.611-2.876 3.306-4.356 5.056-4.719 5.5-10.052 11.75-15.943 17.25a.268.268 0 0 0 0 .389c.028.027.056.055.084.055-.084.084-.168.14-.252.222-.056.056-.084.111-.084.167a.605.605 0 0 0-.111.139c-.112.111-.112.305.028.389.111.11.307.11.39-.028.029-.028.029-.056.056-.056a.44.44 0 0 1 .615 0c.335.362.67.723.977 1.028l-.698-.583c-.112-.111-.307-.083-.39.028-.113.11-.085.305.027.389l7.427 6.194c.056.056.112.056.196.056s.14-.028.195-.084l.168-.166c.028.027.083.027.111.027.084 0 .14-.027.196-.083 10.052-10.055 18.15-17.639 27.42-24.417.083-.055.111-.166.111-.25.112 0 .196-.083.251-.194 1.704-5.194 2.039-9.806 2.15-12.083v-.028c0-.028.028-.056.028-.083.028-.056.028-.084.028-.084a1.626 1.626 0 0 0-.111-1.028ZM21.472 9.5c.446-.5.893-1.028 1.34-1.5-2.876 3.778-7.65 9.583-14.408 16.5 4.607-5.083 9.242-10.333 13.068-15ZM5.193 35.778h.084-.084Zm3.462 3.194c-.027-.028-.027-.028 0-.028v.028Zm4.16-3.583c.224-.25.448-.472.699-.722 0 0 0 .027.028.027-.252.223-.475.445-.726.695Zm1.146-1.111c.14-.14.279-.334.446-.5l.028-.028c1.648-1.694 3.351-3.389 5.082-5.111l.028-.028c.419-.333.921-.694 1.368-1.028a379.003 379.003 0 0 0-6.952 6.695ZM24.794 6.472c-.921 1.195-1.954 2.778-2.82 4.028-2.736 3.944-11.532 13.583-11.727 13.75a1976.983 1976.983 0 0 1-8.042 7.639l-.167.167c-.14-.167-.14-.417.028-.556C14.49 19.861 22.03 10.167 25.074 5.917c-.084.194-.14.36-.28.555Zm4.83 5.695c-1.116-.64-1.646-1.64-1.34-2.611l.084-.334c.028-.083.084-.194.14-.277.307-.5.754-.917 1.257-1.167.027 0 .055 0 .083-.028-.028-.056-.028-.139-.028-.222.028-.167.14-.278.335-.278.335 0 1.369.306 1.76.639.111.083.223.194.335.305.14.167.363.445.474.667.056.028.112.306.196.445.056.222.111.472.084.694-.028.028 0 .194-.028.194a2.668 2.668 0 0 1-.363 1.028c-.028.028-.028.056-.056.084l-.028.027c-.14.223-.335.417-.53.556-.643.444-1.369.583-2.095.389 0 0-.195-.084-.28-.111Zm8.154-.834a39.098 39.098 0 0 1-.893 3.167c0 .028-.028.083 0 .111-.056 0-.084.028-.14.056-2.206 1.61-4.356 3.305-6.506 5.028 1.843-1.64 3.686-3.306 5.613-4.945.558-.5.949-1.139 1.06-1.861l.28-1.667v-.055c.14-.334.67-.195.586.166Z", fill: "currentColor" }) }), lM = () => jsxRuntimeExports.jsxs("svg", { viewBox: "0 0 450 55", xmlns: "http://www.w3.org/2000/svg", fill: "none", className: "ExcalidrawLogo-text", children: [jsxRuntimeExports.jsx("path", { d: "M429.27 96.74c2.47-1.39 4.78-3.02 6.83-4.95 1.43-1.35 2.73-2.86 3.81-4.51-.66.9-1.4 1.77-2.23 2.59-2.91 2.84-5.72 5.09-8.42 6.87h.01ZM343.6 69.36c.33 3.13.58 6.27.79 9.4.09 1.37.18 2.75.25 4.12-.12-4.46-.27-8.93-.5-13.39-.11-2.08-.24-4.16-.4-6.24-.06 1.79-.11 3.85-.13 6.11h-.01ZM378.47 98.34c.01-.37.07-1.13.01-6.51-.11 1.9-.22 3.81-.31 5.71-.07 1.42-.22 2.91-.16 4.35.39.03.78.07 1.17.1-.92-.85-.76-2.01-.72-3.66l.01.01ZM344.09 86.12c-.09-2.41-.22-4.83-.39-7.24v12.21c.15-.05.32-.09.47-.14.05-1.61-.03-3.23-.09-4.83h.01ZM440.69 66.79c-.22-.34-.45-.67-.69-.99-3.71-4.87-9.91-7.14-15.65-8.55-1.05-.26-2.12-.49-3.18-.71 2.29.59 4.48 1.26 6.64 2.02 7.19 2.54 10.57 5.41 12.88 8.23ZM305.09 72.46l1.2 3.6c.84 2.53 1.67 5.06 2.46 7.61.24.78.5 1.57.73 2.36.22-.04.44-.08.67-.12a776.9 776.9 0 0 1-5.01-13.57c-.02.04-.03.09-.05.13v-.01ZM345.49 90.25v.31c1.48-.42 3.05-.83 4.66-1.2-1.56.25-3.12.52-4.66.89ZM371.02 90.22c0-.57-.04-1.14-.11-1.71-.06-.02-.12-.04-.19-.05-.21-.05-.43-.08-.65-.11.42.16.74.88.95 1.87ZM398.93 54.23c-.13 0-.27-.01-.4-.02l.03.4c.11-.15.23-.27.37-.38ZM401.57 62.28v-.15c-1.22-.24-2.86-.61-3.23-1.25-.09-.15-.18-.51-.27-.98-.09.37-.2.73-.33 1.09 1.24.56 2.52.98 3.83 1.29ZM421.73 88.68c-2.97 1.65-6.28 3.12-9.69 3.68v.18c4.72-.14 11.63-3.85 16.33-8.38-2.04 1.75-4.33 3.24-6.63 4.53l-.01-.01ZM411.28 80.92c-.05-1.2-.09-2.4-.15-3.6-.21 5.66-.46 11.38-.47 14.51.24-.02.48-.04.71-.07.15-3.61.05-7.23-.09-10.83v-.01Z", transform: "translate(-144.023 -51.76)" }), jsxRuntimeExports.jsx("path", { d: "M425.38 67.41c-3.5-1.45-7.19-2.57-14.06-3.62.09 1.97.06 4.88-.03 8.12.03.04.06.09.06.15.19 1.36.28 2.73.37 4.1.25 3.77.39 7.55.41 11.33 0 1.38-.01 2.76-.07 4.13 1.4-.25 2.78-.65 4.12-1.15 4.07-1.5 7.94-3.78 11.28-6.54 2.33-1.92 5.13-4.49 5.88-7.58.63-3.53-2.45-6.68-7.97-8.96l.01.02ZM411.35 92.53v-.06l-.34.03c.11.01.22.03.34.03ZM314.26 64.06c-.23-.59-.47-1.17-.7-1.75.57 1.62 1.11 3.25 1.6 4.9l.15.54 2.35 6.05c.32.82.66 1.64.98 2.46-1.38-4.1-2.83-8.17-4.39-12.2h.01ZM156.82 103.07c-.18.13-.38.23-.58.33 1.32-.03 2.66-.2 3.93-.34.86-.09 1.72-.22 2.58-.33-2.12.1-4.12.17-5.94.34h.01ZM210.14 68.88s.03.04.05.07c.18-.31.39-.64.58-.96-.21.3-.42.6-.64.89h.01ZM201.65 82.8c-.5.77-1.02 1.56-1.49 2.37 1.11-1.55 2.21-3.1 3.2-4.59-.23.23-.49.51-.75.79-.32.47-.65.95-.96 1.43ZM194.03 98.66c-.33-.4-.65-.84-1.05-1.17-.24-.2-.07-.49.17-.56-.23-.26-.42-.5-.63-.75 1.51-2.55 3.93-5.87 6.4-9.28-.17-.08-.29-.28-.2-.49.04-.09.09-.17.13-.26-1.21 1.78-2.42 3.55-3.61 5.33-.87 1.31-1.74 2.64-2.54 4-.29.5-.63 1.04-.87 1.61.81.65 1.63 1.27 2.47 1.88-.09-.11-.18-.21-.27-.32v.01ZM307.79 82.93c-1-3.17-2.05-6.32-3.1-9.48-1.62 4.08-3.69 9.17-6.16 15.19 3.32-1.04 6.77-1.87 10.27-2.5-.32-1.08-.67-2.15-1.01-3.21ZM149.5 80.7c.05-1.71.04-3.43 0-5.14-.1 2.26-.16 4.51-.22 6.77-.02.73-.03 1.46-.04 2.19.14-1.27.2-2.55.24-3.82h.02ZM228.98 98.3c.39 1.25.91 3.03.94 3.91.06-.03.12-.07.17-.1.08-1.29-.55-2.65-1.11-3.81ZM307.72 53.36c.81.5 1.53 1.04 2.07 1.49-.38-.8-.78-1.58-1.21-2.35-.17.03-.34.06-.51.11-.43.12-.86.26-1.29.41.35-.01.53.1.94.34ZM283.69 96.14c3.91-7.25 6.89-13.35 8.88-18.15l1.1-2.66c-1.27 2.64-2.56 5.27-3.83 7.9-1.53 3.15-3.06 6.31-4.58 9.47-.87 1.81-1.76 3.62-2.54 5.47.04.02.07.04.11.07.05.05.1.09.15.14.05-.73.27-1.48.71-2.24ZM289.92 103.23s-.04.01-.05.03c0-.02.04-.03.05-.04.05-.05.11-.1.16-.15l.21-.21c-.55 0-1.5-.27-2.55-.72.4.26.8.51 1.22.74.24.13.48.26.73.37.05.02.1.03.14.05a.27.27 0 0 1 .08-.07h.01ZM269.23 68.49c-.39-.19-.82-.48-1.33-.87-3.06-1.56-6.31-2.78-9.36-2.35-3.5.49-5.7 1.11-7.74 2.44 5.71-2.6 12.82-2.07 18.44.79l-.01-.01ZM177.87 53.69l1.06.03c-.96-.22-2-.25-2.89-.3-4.95-.26-9.99.33-14.86 1.19-2.44.43-4.88.95-7.28 1.59 9.09-1.76 15.69-2.77 23.97-2.51ZM219.85 55.51c-.18.12-.36.27-.56.45-.45.53-.86 1.11-1.26 1.66-1.91 2.61-3.71 5.31-5.57 7.95l-.12.18 8.05-10.11c-.18-.05-.36-.1-.55-.13h.01ZM510.71 54.1c.12-.15.29-.3.53-.45.69-.4 3.72-.63 5.87-.74-.36-.02-.73-.04-1.09-.05-1.84-.03-3.67.09-5.49.35.05.3.12.59.18.88v.01ZM510.76 86.02c1.37-3.07 2.49-6.27 3.57-9.46.55-1.64 1.12-3.3 1.6-4.97-1.59 4.01-3.67 9.14-6.2 15.3.24-.08.5-.14.74-.22.1-.22.19-.44.29-.65ZM566.95 75.76c.11-.02.23.03.31.11-.05-.13-.09-.26-.14-.39-.05.09-.11.18-.17.28ZM511.33 86.41c3.08-.89 6.24-1.62 9.46-2.14-1.51-3.98-2.98-7.96-4.39-11.87-.05.15-.09.31-.14.46-1.02 3.32-2.15 6.61-3.39 9.85-.48 1.25-.98 2.49-1.53 3.7h-.01ZM578.24 74.45c.11-.44.23-.87.35-1.31-.31.7-.64 1.39-.97 2.08.09.21.19.4.28.61.12-.46.23-.92.35-1.38h-.01ZM520.62 53.11c-.09 0-.18-.01-.28-.02.38.34.29 1.08.93 2.53l6.65 17.15c2.2 5.68 4.69 11.36 7.41 16.87l1.06 2.17c-2.95-7.05-5.92-14.08-8.87-21.13-1.58-3.79-3.16-7.59-4.7-11.4-.78-1.92-1.73-3.89-2.25-5.91-.03-.1 0-.19.04-.26h.01ZM578.78 77.87c1.45-5.77 3.07-10.43 3.58-13.36.05-.34.16-.88.31-1.55-.67 1.79-1.37 3.56-2.08 5.33-.12.43-.23.86-.35 1.29-.65 2.43-1.29 4.86-1.9 7.3.14.33.29.65.43 1l.01-.01ZM545.3 94.66c.02-.44.03-.83.05-1.12.02-1.01.05-2.02.11-3.02.03-6.66-.46-14.33-1.46-22.8-.13-.42-.27-1.24-.56-2.89 0-.02 0-.04-.01-.06.62 6.61.95 13.25 1.32 19.87.17 3.08.33 6.16.52 9.23.02.25.03.52.04.78l-.01.01ZM580.77 102.81c.13.2.27.38.37.49.27-.11.53-.22.8-.32-.43.09-.82.05-1.17-.16v-.01ZM530.48 104.07h.33c-.36-.13-.71-.32-1.04-.56.14.24.3.47.45.7.06-.08.14-.13.26-.13v-.01ZM542.63 58.82c.06.23.11.47.15.71.14-.33.36-.62.7-.86-.28.05-.57.11-.85.15ZM583.81 57.87c.15-.7.29-1.41.42-2.11-.14.45-.28.9-.42 1.34-.46 1.44-.89 2.89-1.31 4.34.44-1.19.88-2.37 1.31-3.57ZM523.62 91.48c-4.66 1.17-9.05 2.89-14.02 5.27 4.65-1.84 9.48-3.29 14.28-4.63-.09-.22-.17-.41-.26-.64ZM460.64 78.3c-.04-2.9-.11-5.81-.28-8.71-.1-1.68-.17-3.43-.5-5.09-.07.02-.14.03-.2.05.3 6.54.45 12.17.51 17.12.17-.07.34-.14.51-.2 0-1.06-.01-2.11-.03-3.17h-.01ZM470.63 63.24c-3.38-.26-6.81.32-10.1 1.1.41 2.01.47 4.14.57 6.18.18 3.55.25 7.11.27 10.67 3.31-1.38 6.5-3.12 9.3-5.35 1.96-1.56 3.86-3.41 5.02-5.66.73-1.41 1.19-3.22.26-4.65-1.09-1.7-3.46-2.14-5.32-2.29ZM460.29 63.68c1-.24 2.01-.46 3.04-.65-1.15.16-2.37.38-3.71.69v.13c.07-.02.15-.04.22-.05.11-.13.3-.18.45-.11v-.01ZM457.24 100.96c.43-.03.86-.07 1.29-.11.14-.49.27-.99.38-1.49-.44.7-1 1.23-1.67 1.6ZM482.88 104.98c-.18.23-.36.38-.55.47.14.09.27.19.4.28a70.76 70.76 0 0 0 4.37-4.63c.76-.89 1.52-1.81 2.19-2.77-.3-.27-.61-.53-.92-.79-.07 1.94-4.62 6.32-5.49 7.45v-.01Z", transform: "translate(-144.023 -51.76)" }), jsxRuntimeExports.jsx("path", { d: "M474.36 63.31c-.4-.16-.84-.27-1.29-.37 1.56.42 3.08 1.22 3.76 2.74.62 1.4.32 2.95-.28 4.32.7-1.22.94-2.34.74-3.47-.24-1.33-1.19-2.54-2.93-3.21v-.01ZM477.34 89.18c-1.2-.81-2.4-1.62-3.6-2.42-.14.1-.26.19-.4.29 1.4.67 2.73 1.39 4 2.13ZM465.88 93.85c.37.25.74.5 1.1.75.46.32.92.65 1.38.97-1.57-1.2-2.01-1.61-2.49-1.72h.01ZM574.92 90.06c-2.28-5.21-4.93-11.13-5.67-12.26-.1-.15-1.57-3.01-1.63-3.08 0 0-.01.02-.02.02.4 1.37 1.09 2.69 1.65 3.99 2.14 4.95 4.36 9.86 6.67 14.73.6 1.26 1.21 2.52 1.83 3.78-.75-2.01-1.64-4.45-2.83-7.18ZM448.73 65.29c.1.2.22.38.34.57.22-.02.43-.06.65-.08v-.08c-.14-.05-.25 0-.99-.41ZM460.16 94.81c-.02.31-.06.59-.1.89-.03 1.71-.33 3.43-.79 5.07.15-.02.3-.03.45-.05.01-.04.02-.08.03-.11.09-.34.15-.69.2-1.03.17-1.07.25-2.16.33-3.24.05-.69.08-1.39.12-2.08-.27.1-.27.26-.24.57v-.02Z", transform: "translate(-144.023 -51.76)" }), jsxRuntimeExports.jsx("path", { d: "m328.67 98.12-3.22-6.58c-1.29-2.63-2.53-5.29-3.72-7.97-.25-.85-.52-1.69-.79-2.53-.81-2.57-1.67-5.12-2.55-7.67-1.92-5.53-3.9-11.08-6.32-16.41-.72-1.58-1.46-3.44-2.63-4.79-.03-.17-.16-.29-.34-.36a.282.282 0 0 0-.23-.04c-.06-.01-.12 0-.18.01-.74.06-1.5.38-2.19.61-2.22.77-4.4 1.64-6.63 2.38-.03-.08-.06-.16-.09-.25-.15-.42-.82-.24-.67.19.03.09.07.19.1.28l-.18.06c-.36.11-.28.6 0 .68.18 1.18.63 2.36.98 3.49.03.09.06.17.08.26-.08.23-.17.46-.24.64-.37.98-.79 1.94-1.21 2.9-1.27 2.89-2.62 5.75-3.98 8.6-3.18 6.67-6.44 13.31-9.64 19.97-1.08 2.25-2.2 4.5-3.15 6.81-.13.32.24.5.5.37 1.34 1.33 2.84 2.5 4.4 3.57.65.44 1.31.87 2.01 1.24.4.22.86.48 1.33.5.24.01.35-.19.33-.37.11-.1.21-.21.28-.28.41-.41.81-.84 1.2-1.26.85-.92 1.69-1.87 2.5-2.84 6.31-2.34 12.6-4.31 18.71-5.84 2.14 5.3 3.43 8.43 3.97 9.58.55 1.05 1.15 1.88 1.82 2.52 1.32.56 6.96-.03 9.23-1.96.87-1.28 1.19-2.67.93-4.15-.09-.5-.22-.95-.4-1.33l-.01-.03Zm-20.09-45.61c.43.77.83 1.56 1.21 2.35-.54-.45-1.27-.99-2.07-1.49-.42-.24-.6-.35-.94-.34.43-.15.85-.29 1.29-.41.17-.05.34-.08.51-.11Zm-25.86 45.66c.78-1.85 1.67-3.66 2.54-5.47 1.51-3.16 3.05-6.31 4.58-9.47 1.28-2.63 2.56-5.26 3.83-7.9l-1.1 2.66c-1.99 4.79-4.97 10.9-8.88 18.15-.43.76-.66 1.51-.71 2.24-.05-.05-.1-.09-.15-.14a.259.259 0 0 0-.11-.07Zm6.24 4.71c-.42-.23-.82-.48-1.22-.74 1.05.45 2 .72 2.55.72l-.21.21c-.05.05-.11.1-.16.15-.01.01-.04.03-.05.04 0-.02.03-.02.05-.03a.27.27 0 0 0-.08.07c-.05-.02-.1-.03-.14-.05-.25-.1-.49-.24-.73-.37h-.01Zm15.73-29.43c1.05 3.15 2.1 6.31 3.1 9.48.34 1.06.69 2.13 1.01 3.21-3.5.63-6.95 1.46-10.27 2.5 2.48-6.03 4.54-11.11 6.16-15.19Zm4.79 12.57c-.23-.79-.49-1.58-.73-2.36-.79-2.54-1.63-5.08-2.46-7.61l-1.2-3.6c.02-.04.04-.09.05-.13 1.6 4.45 3.28 9 5.01 13.57l-.67.12v.01Zm5.83-18.27-.15-.54c-.49-1.64-1.03-3.28-1.6-4.9.23.58.47 1.17.7 1.75 1.56 4.03 3.01 8.1 4.39 12.2-.33-.82-.67-1.64-.98-2.46l-2.35-6.05h-.01ZM390.43 79.37c-.13-10.43-.22-17.5-.24-19.97-.24-1.6.21-2.88-.65-3.65-.14-.13-.32-.23-.52-.32h.03c.45 0 .45-.69 0-.7-1.75-.03-3.5-.04-5.25-.14-1.38-.08-2.76-.21-4.15-.31-.07 0-.12.01-.17.04-.21-.07-.47.03-.45.31l.03.45c-.11.14-.19.3-.22.5-.21 1.26-.32 13.67-.36 23.59-.32 5.79-.67 11.57-.97 17.36-.09 1.73-.29 3.54-.21 5.3-.39.02-.38.64.04.69v.12c.05.44.74.45.7 0v-.06c1.1.09 2.2.21 3.3.3 1.14.19 2.44.2 3.29.17 1.73-.05 2.92-.05 3.8-.37.45-.05.9-.11 1.35-.17.44-.06.25-.73-.19-.67h-.01c.24-.32.45-.72.62-1.25.66-1.84.41-6.36.34-11.33l-.13-9.9.02.01Zm-12.26 18.17c.09-1.91.2-3.81.31-5.71.06 5.38 0 6.14-.01 6.51-.05 1.65-.21 2.81.72 3.66-.39-.04-.78-.07-1.17-.1-.06-1.44.09-2.93.16-4.35l-.01-.01ZM588.97 53.85c-2.06-.25-3.17-.51-3.76-.6a.3.3 0 0 1 .04-.08c.22-.39-.39-.75-.6-.35-.56 1.02-.9 2.19-1.26 3.29-.61 1.88-1.17 3.78-1.72 5.68-.63 2.19-1.24 4.39-1.83 6.59-.81 2.03-1.67 4.05-2.61 6.03-1.7-3.64-3.11-6.04-4.03-7.57-2.26-3.74-2.85-5.48-3.57-6.08l.31-.09c.43-.12.25-.8-.19-.67-1.06.3-2.12.6-3.17.95-.93.32-1.85.69-2.76 1.07-.13.05-.19.16-.22.27-.04.02-.08.05-.11.07-.04-.06-.07-.12-.11-.18a.354.354 0 0 0-.48-.12c-.16.09-.22.32-.13.48l.33.54c0 .09.02.18.06.28.51 1.16.78 1.38.72 1.47-2.42 3.44-5.41 7.86-6.2 9.1-1.27 1.97-2.01 3.14-2.45 3.84l-.91-6.56-.43-4.1c-.19-1.85-.37-3.23-.53-4.13-.19-1.1-.3-2.15-.45-3.16-.2-1.36-.29-2.06-.47-2.42h.04c.45.02.45-.68 0-.7-3.43-.16-6.81.94-10.17 1.48-.24-.22-.73-.04-.58.32.24.59.33 1.25.43 1.87.17 1.06.29 2.13.4 3.2.32 3.09.53 6.2.74 9.3.44 6.75.77 13.51 1.17 20.26.11 1.95.13 3.96.46 5.89.05.3.37.31.55.14.74 1.71 2.87 1.27 6.13 1.27 1.34 0 2.39.04 2.99-.11.02.32.48.53.63.18 3.61-8.26 7.41-16.46 12.05-24.2.03-.05.04-.1.05-.15.3.73.64 1.45.94 2.16.97 2.26 1.97 4.52 2.98 6.76 2.26 5.03 4.54 10.07 7.09 14.96.47.9.94 1.79 1.47 2.65.2.32.4.67.66.96-.18.25 0 .68.34.54.91-.38 1.82-.75 2.76-1.07 1.04-.35 2.11-.65 3.17-.95.39-.11.28-.66-.07-.68.62-.4.95-.96.87-1.91-.3-3.34.72-7.47.86-8.52l2.14-11.43c1.75-10.74 3.13-17.51 3.23-20.86.02-.49.08-2.84.13-3.24.17-1.25.48-1-4.96-1.65l.03-.02Zm-46.19 5.67c-.04-.24-.09-.48-.15-.71l.85-.15c-.34.24-.56.53-.7.86Zm1.95 25.12c-.36-6.63-.7-13.26-1.32-19.87 0 .02 0 .04.01.06.29 1.65.44 2.47.56 2.89 1 8.46 1.5 16.14 1.46 22.8-.06.99-.1 2-.11 3.02-.01.29-.03.68-.05 1.12-.01-.26-.03-.53-.04-.78-.19-3.08-.35-6.16-.52-9.23l.01-.01Zm36.4 18.66c-.11-.11-.24-.29-.37-.49.35.21.74.26 1.17.16-.27.11-.53.22-.8.32v.01Zm-.89-33.72c.12-.43.23-.86.35-1.29.71-1.77 1.41-3.55 2.08-5.33-.15.68-.26 1.22-.31 1.55-.5 2.94-2.13 7.59-3.58 13.36-.15-.35-.29-.66-.43-1 .61-2.44 1.25-4.87 1.9-7.3l-.01.01Zm3.56-12.48c.14-.44.28-.89.42-1.34-.13.7-.27 1.41-.42 2.11-.43 1.19-.86 2.38-1.31 3.57.42-1.45.85-2.9 1.31-4.34Zm-5.22 16.05c-.11.44-.23.87-.35 1.31-.12.46-.23.92-.35 1.38-.1-.22-.19-.4-.28-.61.34-.69.66-1.38.97-2.08h.01Zm-11.64 2.62c.06-.1.12-.19.17-.28.05.13.09.26.14.39a.398.398 0 0 0-.31-.11Zm2.3 2.98c-.56-1.3-1.25-2.63-1.65-3.99 0 0 .01-.02.02-.02.06.08 1.52 2.93 1.63 3.08.73 1.13 3.38 7.04 5.67 12.26 1.2 2.73 2.08 5.17 2.83 7.18-.62-1.25-1.23-2.51-1.83-3.78-2.31-4.87-4.53-9.78-6.67-14.73ZM275.92 87.03c-1.06-2.18-1.13-3.45-2.44-2.93-1.52.57-2.94 1.3-4.5 2.1-1.4.72-2.68 1.44-3.92 2.12.01-.25-.24-.5-.51-.34-4.8 2.93-12.41 4.7-17.28 1.31-1.98-1.77-3.32-4.15-3.97-5.78-.29-.95-.49-1.94-.63-2.93-.14-3.34 1.58-6.53 3.9-9.12.8-.79 1.68-1.51 2.66-2.12 3.7-2.3 8.22-3.07 12.51-2.51 2.71.35 5.32 1.24 7.71 2.55.39.22.75-.39.35-.6-.18-.1-.37-.18-.55-.27.56.27 1.03.33 1.51.19l-.48.39c-.15.11-.23.3-.13.48.09.15.33.24.48.13 1.3-.97 2.46-2.09 3.45-3.37.37-.29.64-.6.65-.97v-.02c.08-.33-.03-.7-.21-1.08-.31-.87-.98-2.01-2.19-3.26-2.43-2.52-3.79-3.45-5.68-4.26-1.14-.49-3.12-1.06-4.42-1.23-3.28-.42-10.64-1.21-18.18 4.11-7.74 5.46-11.94 12.3-12.23 20.61-.08 2.06.04 3.98.34 5.71.74 4.18 2.57 8 5.44 11.34 4.26 4.99 9.76 7.52 16.34 7.52 4.85 0 9.69-1.77 14.89-4.62.23-.12.45-.23.68-.35 2.19-1.1 4.37-2.23 6.46-3.5.49-.3 1.03-.61 1.5-.98 1.47-.87 1.11-1.12.49-2.95-.39-1.14-.76-2.7-2.06-5.36l.02-.01Zm-17.38-21.76c3.05-.42 6.31.79 9.36 2.35.51.39.94.68 1.33.87-5.61-2.86-12.72-3.39-18.44-.79 2.05-1.33 4.24-1.95 7.74-2.44l.01.01ZM443.67 72.67c-.4-2.2-1.15-4.33-2.37-6.22-1.49-2.32-3.58-4.19-5.91-5.64-6.17-3.81-13.75-5.11-20.83-6.01-3.23-.41-6.47-.69-9.72-.92l-1.39-.12c-.85-.07-1.52-.1-2.05-.1-1.08-.06-2.17-.12-3.25-.17-.08 0-.14.02-.19.05-.1.05-.18.14-.16.3.27 2.55-.01 5.12-.92 7.52-.15.38.4.56.62.28 1.32.59 2.68 1.05 4.08 1.37 0 2.78-.14 7.58-.33 12.91 0 0 0 .02-.01.03-.61 3.66-.79 7.42-1 11.12-.23 4.01-.43 8.03-.44 12.05 0 .64 0 1.28.03 1.93.02.31 0 .68.15.96.06.11.14.16.24.17-.2.17-.21.54.11.59 3.83.67 7.78.71 11.68.25 2.3-.19 4.87-.65 7.65-1.56 1.85-.54 3.67-1.18 5.43-1.91 7.2-3.02 14.31-8.07 17.35-15.53.76-1.86 1.17-3.8 1.31-5.75.3-1.93.28-3.82-.09-5.58l.01-.02Zm-19.32-15.42c5.74 1.41 11.94 3.68 15.65 8.55.25.32.47.65.69.99-2.3-2.82-5.68-5.69-12.88-8.23-2.16-.76-4.35-1.43-6.64-2.02 1.06.21 2.13.45 3.18.71Zm-25.82-3.04c.13 0 .27.01.4.02-.14.1-.26.23-.37.38 0-.13-.02-.26-.03-.4Zm34.82 22.17c-.75 3.09-3.55 5.66-5.88 7.58-3.35 2.76-7.21 5.03-11.28 6.54-1.33.49-2.71.9-4.12 1.15.06-1.38.08-2.76.07-4.13-.02-3.78-.16-7.56-.41-11.33-.09-1.37-.18-2.74-.37-4.1 0-.06-.03-.11-.06-.15.09-3.25.12-6.16.03-8.12 6.86 1.05 10.56 2.17 14.06 3.62 5.52 2.28 8.59 5.44 7.97 8.96l-.01-.02Zm-22 16.15c-.12 0-.23-.02-.34-.03l.34-.03v.06Zm-.69-.7c0-3.13.26-8.84.47-14.51.06 1.2.11 2.41.15 3.6.15 3.6.25 7.23.09 10.83-.24.03-.48.05-.71.07v.01Zm-12.33-30.94c.37.63 2.01 1.01 3.23 1.25v.15c-1.31-.31-2.59-.73-3.83-1.29.12-.36.23-.72.33-1.09.08.48.18.84.27.98Zm13.7 31.65v-.18c3.41-.56 6.71-2.02 9.69-3.68 2.31-1.28 4.59-2.78 6.63-4.53-4.69 4.53-11.61 8.24-16.33 8.38l.01.01Zm24.07-.75c-2.05 1.93-4.37 3.56-6.83 4.95 2.7-1.78 5.52-4.03 8.42-6.87.82-.82 1.56-1.69 2.23-2.59-1.08 1.65-2.38 3.16-3.81 4.51h-.01ZM187.16 92.14c-.79-2.47-2.1-7.12-3.1-6.87-.19-.01-2.09.77-4.08 1.54-3.06 1.18-5.91 2.13-10.09 2.82-2.74.42-5.87 1.01-10.61 1.06.04-3.34.05-6.01.05-7.99 7.97-.65 12.33-2.11 16.37-3.55 1.11-.39 2.69-1.01 2.63-1.8-.08-.35-.55-1.39-1.17-2.61-.47-1.16-.98-2.31-1.61-3.38-.42-.71-1.04-1.69-1.86-2.06-.11-.08-.22-.13-.29-.12-.02 0-.04 0-.07.01-.19-.04-.39-.05-.6-.01-.17.03-.24.15-.25.28-.04.02-.09.04-.14.05-4.33 1.48-8.85 2.33-13.24 3.61a499.1 499.1 0 0 0-.31-8.19c4.51-.99 8.88-1.38 13.11-1.82 3.68-.38 6.28.12 7.47.34.59.11.9.16 1.16.18h.1c-.1.37.44.66.62.28.02-.04.03-.08.05-.13.15.2.53.22.62-.1.17-.58.19-1.21.21-1.81v-.36c.03-.15.05-.3.07-.45.52-2.47.33-5.09-.64-7.44-.11-.27-.44-.28-.6-.14-.08-.21-.15-.42-.24-.62-.19-.41-.79-.05-.6.35.03.07.05.15.09.22-.98-.42-2.15-.54-3.17-.63-2.17-.19-4.37-.14-6.54 0-5.7.35-11.4 1.3-16.91 2.79-2.08.56-4.13 1.22-6.14 2-4.54 1.05-3.79 1.51-2.17 6.07.18.51.46 1.68.54 1.94.82 2.47 1.08 2.13 3.1 2.13s0 .05 0 .08h.52c-.48 2.66-.51 5.45-.62 8.13-.15 3.48-.22 6.96-.28 10.45 0 .41-.01.82-.02 1.23-.16.29-.33.57-.51.85-.05.38-.09.77-.14 1.18-.42 3.52-.59 6.48-.52 8.8v.34c.02.47.05.76.06.87.16 1.57-.26 3.47 1.35 3.79 1.61.32 3.5.55 4.85.55.11 0 .22-.02.33-.02 1.79.24 3.67.05 5.45-.12 2.85-.28 5.69-.7 8.51-1.19 3.03-.53 6.05-1.14 9.04-1.86 2.4-.58 4.82-1.19 7.13-2.06.51-.19 1.73-.57 2.46-1.14 1.81-.68 2.18-1 1.57-2.67-.23-.62-.48-1.49-.91-2.78l-.03-.02Zm-11.12-38.71c.89.05 1.93.08 2.89.3-.33 0-.68-.02-1.06-.03-8.28-.26-14.88.75-23.97 2.51 2.41-.64 4.85-1.16 7.28-1.59 4.87-.86 9.91-1.45 14.86-1.19Zm-26.53 22.13c.03 1.71.04 3.43 0 5.14-.04 1.27-.11 2.55-.24 3.82 0-.73.02-1.46.04-2.19.05-2.26.12-4.51.22-6.77h-.02Zm6.73 27.85c.2-.1.4-.21.58-.33 1.82-.17 3.82-.24 5.94-.34-.86.11-1.72.24-2.58.33-1.27.14-2.61.31-3.93.34h-.01ZM534.48 85.44c-3.52-8.38-7.07-16.75-10.5-25.17-.63-1.54-1.25-3.09-1.86-4.65-.31-.8-.65-1.6-.87-2.43-.04-.17-.17-.24-.31-.25.1-.2 0-.51-.29-.53-1.59-.08-3.18-.22-4.78-.25-1.96-.03-3.91.13-5.84.42-.31.05-.31.38-.13.56-.03.06-.05.14-.04.22.23 1.54.63 3.06 1.16 4.53.13.35.27.7.41 1.06l-2.68 6.18c-.11.03-.2.09-.25.22-.67 1.9-1.52 3.73-2.34 5.56a536.85 536.85 0 0 1-3.9 8.45c-2.64 5.64-5.34 11.25-7.91 16.93-.44.97-.88 1.94-1.29 2.93-.2.48-.47 1-.55 1.52v.05c-.02.12.02.26.16.34 1.19.73 2.41 1.41 3.66 2.05 1.2.62 2.45 1.25 3.76 1.61.43.12.62-.55.19-.67-1.13-.31-2.2-.83-3.24-1.36 1.09.36 2.1.69 2.75.93 2.82 1.01 2.38 1.1 4.3-3.75 2.1-1.09 4.34-1.96 6.53-2.79 4.35-1.64 8.8-3.03 13.27-4.29.82 2.01 1.77 3.97 2.72 5.92.35.83.62 1.45.79 1.82.22.42.45.8.69 1.15.17.33.33.67.5 1 .42.8.84 1.63 1.4 2.35.23.29.6 0 .55-.31 1.53-.02 3.06-.07 4.58-.27.92-.12 1.82-.32 2.71-.54 1.39-.27 3.85-1.11 3.74-1.42-.67-1.96-1.55-3.87-2.34-5.78-1.57-3.78-3.16-7.56-4.75-11.33v-.01Zm-11.65-26.16c1.54 3.81 3.12 7.6 4.7 11.4 2.94 7.05 5.91 14.09 8.87 21.13l-1.06-2.17c-2.71-5.51-5.2-11.19-7.41-16.87l-6.65-17.15c-.65-1.45-.55-2.19-.93-2.53.09 0 .18.01.28.02a.29.29 0 0 0-.04.26c.52 2.02 1.47 3.98 2.25 5.91h-.01Zm-6.58 13.58c.05-.15.09-.31.14-.46 1.41 3.92 2.88 7.9 4.39 11.87-3.22.52-6.38 1.25-9.46 2.14.55-1.22 1.05-2.46 1.53-3.7 1.24-3.24 2.37-6.53 3.39-9.85h.01Zm-.23-20c.36 0 .73.03 1.09.05-2.15.1-5.18.33-5.87.74-.24.15-.41.3-.53.45-.06-.29-.13-.58-.18-.88 1.82-.26 3.65-.39 5.49-.35v-.01Zm-.09 18.72c-.49 1.67-1.05 3.33-1.6 4.97-1.07 3.19-2.19 6.38-3.57 9.46-.09.21-.19.43-.29.65-.25.07-.5.14-.74.22 2.53-6.16 4.61-11.29 6.2-15.3Zm-6.34 25.16c4.97-2.38 9.37-4.1 14.02-5.27l.26.64c-4.8 1.35-9.63 2.8-14.28 4.63Zm20.17 6.76c.33.23.68.42 1.04.56h-.33c-.12 0-.21.06-.26.13-.15-.23-.31-.45-.45-.7v.01ZM226.57 91.75c-3.55-4.74-6.68-9.11-9.31-12.99 9.2-15.25 10.05-17.81 10.35-18.38.17-.34 1.09-2.27.64-2.53-1.13-.65-1.03-.65-2.97-1.71-1.19-.65-3.04-1.61-4.53-2.12-1.71-.59-1.24-.36-3 2.77-.06.1-.11.2-.17.3-.75 1.02-1.48 2.05-2.2 3.09-1.88 2.71-3.73 5.45-5.69 8.1-3.68-4.91-6.88-8.76-9.51-11.43-.15-.15-.3-.29-.46-.42-1.27-1.28-7.24 3.53-7.93 5.58-.09.09-.19.16-.28.25-.27.26.03.64.33.58.19.65.5 1.29.94 1.91 3.85 5.06 7.19 9.76 9.94 14-1.23 2.61-3.06 5-4.67 7.38l-2.28 3.33c-.5.66-.93 1.23-1.29 1.69-.67.93-2.09 2.61-2.3 3.87-.51.85-1.16 1.84-1.29 2.83-.06.44.61.63.67.19.01-.08.04-.15.06-.22 1.36 1.08 2.76 2.11 4.19 3.11 1.3.91 2.62 1.85 4.04 2.56.21.1.4 0 .48-.17.24.07.48.14.72.2.44.1.62-.57.19-.67-2.02-.48-3.77-1.57-5.23-3.02-.47-.46-.9-.96-1.32-1.46 1.74 1.35 4.2 2.89 5.89 4.14 1.39 1.03 2.85-2.27 4.22-4.2 1.86-2.64 3.96-5.86 5.52-8.29l10.39 14.51c.67.81 1.14 1.21 1.57 1.36-.05.24.12.51.41.4 1.53-.58 3.05-1.19 4.54-1.87 1.52-.69 3.06-1.45 4.36-2.5a.28.28 0 0 0 .12-.23c1.66-1.1.81-1.74-1.41-4.91-1.13-1.58-1.71-2.36-3.7-5.01l-.03-.02Zm2.41 6.54c.56 1.15 1.19 2.52 1.11 3.81-.06.04-.12.07-.17.1-.03-.88-.55-2.66-.94-3.91Zm-16.51-32.73c1.86-2.65 3.65-5.35 5.57-7.95.4-.55.81-1.13 1.26-1.66.19-.18.38-.33.56-.45.18.03.36.08.55.13l-8.05 10.11.12-.18h-.01ZM192.7 95.48c.79-1.37 1.66-2.69 2.54-4 1.19-1.79 2.4-3.56 3.61-5.33-.04.09-.09.17-.13.26-.1.22.03.41.2.49-2.47 3.42-4.89 6.73-6.4 9.28.21.24.4.48.63.75-.24.07-.4.36-.17.56.4.33.72.77 1.05 1.17.09.11.18.21.27.32-.84-.61-1.66-1.24-2.47-1.88.24-.57.58-1.11.87-1.61v-.01Zm7.46-10.32c.47-.81.98-1.59 1.49-2.37.31-.48.64-.95.96-1.43.26-.29.52-.56.75-.79-.99 1.48-2.09 3.03-3.2 4.59Zm10.03-16.22s-.03-.05-.05-.07c.22-.29.43-.59.64-.89-.2.32-.4.65-.58.96h-.01ZM371.54 87.96c-.01-.08-.01-.16-.03-.23-.06-.38-.58-.29-.66.03-.3-.05-.6-.08-.81-.11-1.14-.15-2.29-.19-3.44-.2 1.04-.09 2.09-.18 3.14-.23.45-.02.45-.72 0-.7-6.57.35-13.14 1.23-19.65 2.11-1.53.21-3.05.42-4.57.68-.01 0-.02.01-.04.01-.04-3.33-.13-6.66-.24-9.99-.19-5.7-.4-11.41-.88-17.1-.13-1.51-.23-3.07-.49-4.58 0-.25 0-.48-.02-.68-.06-1.19-.04-2.61-.68-2.78-.16-.07-.72-.16-1.5-.24.22-.17.16-.62-.2-.63-1.19-.04-2.39.09-3.57.23-1.2.14-2.41.32-3.59.6-.16-.1-.41-.06-.5.12-.06.02-.13.03-.19.05-.35.1-.29.55-.03.66-.26.6-.19 2.27-.21 3-.02.66-.66 33.73-.9 40.3-.03.65.06 1.12.04 1.45-.16 3.05.87 4.96 6.34 3.93 1.09-.08 2.75-.77 5.36-1.43 4.13-1.04 5.78-1.52 6.2-1.65 6.43-1.69 6.78-1.97 11.72-2.43.55-.05 4.8-.38 6.03-.3.64.04 1.19.07 1.65.1.09 0 .16-.03.24-.05.1.27.56.33.66-.02.39-1.32.61-2.71.78-4.08.2-1.61.29-3.24.15-4.86.24.03.52-.23.38-.53-.09-.2-.27-.33-.49-.43v-.02Zm-.63.56c.07.57.11 1.14.11 1.71-.21-.99-.53-1.71-.95-1.87.22.03.44.06.65.11.06.01.12.04.19.05Zm-25.41 1.73c1.54-.36 3.1-.64 4.66-.89-1.61.37-3.18.77-4.66 1.2v-.31Zm-.86-7.37c-.07-1.37-.16-2.75-.25-4.12-.21-3.13-.45-6.27-.79-9.4.02-2.25.08-4.31.13-6.11.16 2.08.29 4.16.4 6.24.23 4.46.38 8.93.5 13.39h.01Zm-.94-4c.16 2.41.29 4.83.39 7.24.06 1.6.14 3.22.09 4.83-.15.05-.32.09-.47.14V78.88h-.01ZM483.72 92.83c-3.05-2.28-6.22-4.4-9.38-6.51 8.86-6.49 13.49-12.95 13.73-19.23.04-.76 0-1.5-.13-2.2-.67-3.82-3.5-6.68-8.39-8.48.13.04.27.08.4.13 3.92 1.39 7.74 4.23 8.5 8.56.34 1.95-.05 3.96-.98 5.69-.21.4.39.75.6.35 1.86-3.46 1.46-7.55-.97-10.63-3.53-4.47-9.76-5.88-15.16-6.16-2.32-.12-4.64-.04-6.95.19-6 .32-12.71 1.68-17.63 3.21-.37.11-.67.23-.92.35-.2-.17-.62.02-.57.37v.03c-.64.68-.18 1.64.48 3.21.38.91.67 1.89 1.15 2.58.32.76.68 1.51 1.13 2.19.14.21.38.19.53.07.19-.02.38-.05.57-.08v1.57c-.06.06-.1.13-.11.23-.27 4.18-.34 8.38-.48 12.57l-.3 9.03c-.24 3.91-.44 6.77-.46 7.26-.05.88-.11 1.95.07 2.81-.01.22-.02.43-.04.65 0 .11-.02.23-.03.35 0 .05-.03.27-.01.16-.05.4.5.59.64.28.05.04.12.08.2.08 1.75.13 3.5.28 5.25.3 1.69.02 3.38-.12 5.06-.32.08.23.36.39.55.15.06-.08.11-.17.16-.26.18-.09.24-.32.18-.48.05-.2.1-.4.13-.6.16-.86.25-1.74.33-2.62.11-1.17.17-2.34.23-3.51.15-.01.32-.03.52-.04.36-.03 1.73-.15 2.06-.15.39 0 .7-.02.95-.04 1.76 1.11 3.45 2.35 5.14 3.55 2.83 2.01 5.64 4.04 8.47 6.04 1.42 1 2.85 2 4.29 2.97.1.06.19.07.27.04.08 0 .17-.02.25-.1 1.61-1.56 3.15-3.18 4.6-4.88.75-.88 1.49-1.78 2.15-2.73.01.01.03.02.04.03.34.3.83-.2.49-.49-2.16-1.9-4.34-3.76-6.64-5.48l.03-.01Zm-6.38-3.65a55.72 55.72 0 0 0-4-2.13c.14-.1.26-.19.4-.29 1.2.81 2.4 1.61 3.6 2.42Zm-20.1 11.78c.67-.37 1.23-.91 1.67-1.6-.11.5-.24 1-.38 1.49-.43.04-.86.08-1.29.11Zm2.38-37.24c1.34-.31 2.56-.52 3.71-.69-1.03.19-2.04.41-3.04.65-.14-.07-.34-.02-.45.11-.07.02-.15.04-.22.05v-.13.01Zm.04.84c.07-.02.14-.03.2-.05.34 1.66.41 3.41.5 5.09.17 2.9.24 5.81.28 8.71l.03 3.17c-.17.07-.34.14-.51.2-.06-4.96-.21-10.58-.51-17.12h.01Zm16.04 5.62c-1.16 2.25-3.06 4.1-5.02 5.66-2.8 2.23-5.99 3.97-9.3 5.35-.01-3.56-.09-7.12-.27-10.67-.1-2.04-.16-4.16-.57-6.18 3.3-.78 6.72-1.36 10.1-1.1 1.85.14 4.23.59 5.32 2.29.92 1.43.46 3.24-.26 4.65Zm.85-.18c.6-1.37.9-2.92.28-4.32-.67-1.52-2.2-2.32-3.76-2.74.46.1.89.21 1.29.37 1.74.67 2.69 1.88 2.93 3.21.2 1.13-.05 2.25-.74 3.47V70Zm-27.47-4.14c-.12-.19-.23-.38-.34-.57.74.42.85.36.99.41v.08c-.22.03-.43.06-.65.08Zm11.21 30.46c-.08 1.08-.16 2.17-.33 3.24-.05.35-.11.69-.2 1.03 0 .04-.02.07-.03.11-.15.02-.3.04-.45.05.45-1.64.76-3.36.79-5.07.03-.29.08-.57.1-.89-.03-.31-.03-.47.24-.57-.04.69-.07 1.39-.12 2.08v.02Zm5.6-2.47c.48.11.92.52 2.49 1.72-.46-.32-.92-.65-1.38-.97-.37-.25-.73-.5-1.1-.75h-.01Zm21.23 7.24a70.76 70.76 0 0 1-4.37 4.63c-.14-.09-.27-.19-.4-.28.19-.09.37-.24.55-.47.87-1.14 5.43-5.51 5.49-7.45.31.26.62.53.92.79-.67.97-1.42 1.88-2.19 2.77v.01Z", fill: "currentColor", transform: "translate(-144.023 -51.76)" })] }), vT = ({ style: e12, size: o3 = "small", withText: t3 }) => jsxRuntimeExports.jsxs("div", { className: `ExcalidrawLogo is-${o3}`, style: e12, children: [jsxRuntimeExports.jsx(aM, {}), t3 && jsxRuntimeExports.jsx(lM, {})] });
var Yg = ({ icon: e12, shortcut: o3, children: t3 }) => {
  let r3 = me();
  return jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [jsxRuntimeExports.jsx("div", { className: "welcome-screen-menu-item__icon", children: e12 }), jsxRuntimeExports.jsx("div", { className: "welcome-screen-menu-item__text", children: t3 }), o3 && !r3.editor.isMobile && jsxRuntimeExports.jsx("div", { className: "welcome-screen-menu-item__shortcut", children: o3 })] });
};
Yg.displayName = "WelcomeScreenMenuItemContent";
var dl = ({ onSelect: e12, children: o3, icon: t3, shortcut: r3, className: n3 = "", ...i3 }) => jsxRuntimeExports.jsx("button", { ...i3, type: "button", className: `welcome-screen-menu-item ${n3}`, onClick: e12, children: jsxRuntimeExports.jsx(Yg, { icon: t3, shortcut: r3, children: o3 }) });
dl.displayName = "WelcomeScreenMenuItem";
var TT = ({ children: e12, href: o3, icon: t3, shortcut: r3, className: n3 = "", ...i3 }) => jsxRuntimeExports.jsx("a", { ...i3, className: `welcome-screen-menu-item ${n3}`, href: o3, target: "_blank", rel: "noreferrer", children: jsxRuntimeExports.jsx(Yg, { icon: t3, shortcut: r3, children: e12 }) });
TT.displayName = "WelcomeScreenMenuItemLink";
var lo = ({ children: e12 }) => {
  let { WelcomeScreenCenterTunnel: o3 } = _e();
  return jsxRuntimeExports.jsx(o3.In, { children: jsxRuntimeExports.jsx("div", { className: "welcome-screen-center", children: e12 || jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [jsxRuntimeExports.jsx(Vg, {}), jsxRuntimeExports.jsx(Wg, { children: g("welcomeScreen.defaults.center_heading") }), jsxRuntimeExports.jsxs(Kg, { children: [jsxRuntimeExports.jsx($g, {}), jsxRuntimeExports.jsx(Xg, {})] })] }) }) });
};
lo.displayName = "Center";
var Vg = ({ children: e12 }) => jsxRuntimeExports.jsx("div", { className: "welcome-screen-center__logo excalifont welcome-screen-decor", children: e12 || jsxRuntimeExports.jsx(vT, { withText: true }) });
Vg.displayName = "Logo";
var Wg = ({ children: e12 }) => jsxRuntimeExports.jsx("div", { className: "welcome-screen-center__heading welcome-screen-decor excalifont", children: e12 });
Wg.displayName = "Heading";
var Kg = ({ children: e12 }) => jsxRuntimeExports.jsx("div", { className: "welcome-screen-menu", children: e12 });
Kg.displayName = "Menu";
var Xg = () => {
  let e12 = Xe2();
  return jsxRuntimeExports.jsx(dl, { onSelect: () => e12.executeAction(wn), shortcut: "?", icon: Px, children: g("helpDialog.title") });
};
Xg.displayName = "MenuItemHelp";
var $g = () => {
  let e12 = ve(), o3 = Xe2();
  return e12.viewModeEnabled ? null : jsxRuntimeExports.jsx(dl, { onSelect: () => o3.executeAction(Si), shortcut: Ye("loadScene"), icon: Yx, children: g("buttons.load") });
};
$g.displayName = "MenuItemLoadScene";
var CT = ({ onSelect: e12 }) => {
  let { t: o3 } = Ve();
  return jsxRuntimeExports.jsx(dl, { shortcut: null, onSelect: e12, icon: xh, children: o3("labels.liveCollaboration") });
};
CT.displayName = "MenuItemLiveCollaborationTrigger";
lo.Logo = Vg;
lo.Heading = Wg;
lo.Menu = Kg;
lo.MenuItem = dl;
lo.MenuItemLink = TT;
lo.MenuItemHelp = Xg;
lo.MenuItemLoadScene = $g;
lo.MenuItemLiveCollaborationTrigger = CT;
var Od = ({ children: e12 }) => {
  let { WelcomeScreenMenuHintTunnel: o3 } = _e();
  return jsxRuntimeExports.jsx(o3.In, { children: jsxRuntimeExports.jsxs("div", { className: "excalifont welcome-screen-decor welcome-screen-decor-hint welcome-screen-decor-hint--menu", children: [Ex, jsxRuntimeExports.jsx("div", { className: "welcome-screen-decor-hint__label", children: e12 || g("welcomeScreen.defaults.menuHint") })] }) });
};
Od.displayName = "MenuHint";
var Fd = ({ children: e12 }) => {
  let { WelcomeScreenToolbarHintTunnel: o3 } = _e();
  return jsxRuntimeExports.jsx(o3.In, { children: jsxRuntimeExports.jsxs("div", { className: "excalifont welcome-screen-decor welcome-screen-decor-hint welcome-screen-decor-hint--toolbar", children: [jsxRuntimeExports.jsx("div", { className: "welcome-screen-decor-hint__label", children: e12 || g("welcomeScreen.defaults.toolbarHint") }), xx] }) });
};
Fd.displayName = "ToolbarHint";
var Bd = ({ children: e12 }) => {
  let { WelcomeScreenHelpHintTunnel: o3 } = _e();
  return jsxRuntimeExports.jsx(o3.In, { children: jsxRuntimeExports.jsxs("div", { className: "excalifont welcome-screen-decor welcome-screen-decor-hint welcome-screen-decor-hint--help", children: [jsxRuntimeExports.jsx("div", { children: e12 || g("welcomeScreen.defaults.helpHint") }), gx] }) });
};
Bd.displayName = "HelpHint";
gM((e12, o3, t3) => {
  if (c$1.DEV || c$1.MODE === je.TEST || window?.DEBUG_FRACTIONAL_INDICES) {
    let r3 = An$1(e12.map((n3) => ({ ...n3 })));
    Za$1(r3, { shouldThrow: c$1.DEV || c$1.MODE === je.TEST, includeBoundTextValidation: true, reconciliationContext: { localElements: o3, remoteElements: t3 } });
  }
}, 1e3 * 60, { leading: true, trailing: false });
xT();
var TM = (e12) => {
  let { onChange: o3, initialData: t3, excalidrawAPI: r3, isCollaborating: n3 = false, onPointerUpdate: i3, renderTopRightUI: a3, langCode: l3 = _o.code, viewModeEnabled: s3, zenModeEnabled: c3, gridModeEnabled: m3, libraryReturnUrl: d3, theme: p3, name: u3, renderCustomStats: h3, onPaste: f3, detectScroll: b3 = true, handleKeyboardGlobally: x3 = false, onLibraryChange: T3, autoFocus: E3 = false, generateIdForFile: w3, onLinkOpen: S3, generateLinkForSelection: I3, onPointerDown: _3, onPointerUp: k2, onScrollChange: R3, onDuplicate: M, children: N3, validateEmbeddable: G3, renderEmbeddable: H3, aiEnabled: V3, showDeprecatedFonts: F3 } = e12, O3 = e12.UIOptions?.canvasActions, j = { ...e12.UIOptions, canvasActions: { ...PE.canvasActions, ...O3 }, tools: { image: e12.UIOptions?.tools?.image ?? true } };
  return O3?.export && (j.canvasActions.export.saveFileToDisk = O3.export?.saveFileToDisk ?? PE.canvasActions.export.saveFileToDisk), j.canvasActions.toggleTheme === null && typeof p3 > "u" && (j.canvasActions.toggleTheme = true), reactExports.useEffect(() => {
    (async () => {
      await __vitePreload(() => import("./roundRect-CjfubgrN.js"), true ? [] : void 0, import.meta.url);
    })();
    let W = (ne3) => {
      typeof ne3.scale == "number" && ne3.scale !== 1 && ne3.preventDefault();
    };
    return document.addEventListener("touchmove", W, { passive: false }), () => {
      document.removeEventListener("touchmove", W);
    };
  }, []), jsxRuntimeExports.jsx(VE, { store: st, children: jsxRuntimeExports.jsx(XE, { langCode: l3, theme: p3, children: jsxRuntimeExports.jsx(bT, { onChange: o3, initialData: t3, excalidrawAPI: r3, isCollaborating: n3, onPointerUpdate: i3, renderTopRightUI: a3, langCode: l3, viewModeEnabled: s3, zenModeEnabled: c3, gridModeEnabled: m3, libraryReturnUrl: d3, theme: p3, name: u3, renderCustomStats: h3, UIOptions: j, onPaste: f3, detectScroll: b3, handleKeyboardGlobally: x3, onLibraryChange: T3, autoFocus: E3, generateIdForFile: w3, onLinkOpen: S3, generateLinkForSelection: I3, onPointerDown: _3, onPointerUp: k2, onScrollChange: R3, onDuplicate: M, validateEmbeddable: G3, renderEmbeddable: H3, aiEnabled: V3 !== false, showDeprecatedFonts: F3, children: N3 }) }) });
}, CM = (e12, o3) => {
  if (e12.children !== o3.children) return false;
  let { initialData: t3, UIOptions: r3 = {}, ...n3 } = e12, { initialData: i3, UIOptions: a3 = {}, ...l3 } = o3, s3 = Object.keys(r3), c3 = Object.keys(a3);
  return s3.length !== c3.length ? false : s3.every((d3) => d3 === "canvasActions" ? Object.keys(r3.canvasActions).every((u3) => u3 === "export" && r3?.canvasActions?.export && a3?.canvasActions?.export ? r3.canvasActions.export.saveFileToDisk === a3.canvasActions.export.saveFileToDisk : r3?.canvasActions?.[u3] === a3?.canvasActions?.[u3]) : r3[d3] === a3[d3]) && Qt(n3, l3);
}, IM = React.memo(TM, CM);
IM.displayName = "Excalidraw";
const ipcApi = {
  saveFile: async (filename, data) => {
    const response = await window.electron?.ipcRenderer.invoke("file:save", { filename, data });
    return response;
  },
  loadFile: async (filePath) => {
    const response = await window.electron?.ipcRenderer.invoke("file:load", filePath);
    return response;
  },
  saveThumbnail: async (filePath, imageData) => {
    const response = await window.electron?.ipcRenderer.invoke("file:saveThumbnail", { filePath, imageData });
    return response;
  },
  browseFiles: async (directory) => {
    const response = await window.electron?.ipcRenderer.invoke("file:browse", directory);
    return response;
  }
};
function useSaveFile() {
  return useMutation({
    mutationFn: ({ filename, data }) => ipcApi.saveFile(filename, data)
  });
}
function useLoadFile() {
  return useMutation({
    mutationFn: (filePath) => ipcApi.loadFile(filePath)
  });
}
function useSaveThumbnail() {
  return useMutation({
    mutationFn: ({ filePath, imageData }) => ipcApi.saveThumbnail(filePath, imageData)
  });
}
function useBrowseFiles(directory) {
  return useQuery({
    queryKey: ["files", directory],
    queryFn: () => ipcApi.browseFiles(directory),
    enabled: true
  });
}
const createStoreImpl = (createState) => {
  let state;
  const listeners = /* @__PURE__ */ new Set();
  const setState = (partial, replace) => {
    const nextState = typeof partial === "function" ? partial(state) : partial;
    if (!Object.is(nextState, state)) {
      const previousState = state;
      state = (replace != null ? replace : typeof nextState !== "object" || nextState === null) ? nextState : Object.assign({}, state, nextState);
      listeners.forEach((listener) => listener(state, previousState));
    }
  };
  const getState2 = () => state;
  const getInitialState = () => initialState;
  const subscribe = (listener) => {
    listeners.add(listener);
    return () => listeners.delete(listener);
  };
  const api = { setState, getState: getState2, getInitialState, subscribe };
  const initialState = state = createState(setState, getState2, api);
  return api;
};
const createStore = ((createState) => createState ? createStoreImpl(createState) : createStoreImpl);
const identity = (arg) => arg;
function useStore(api, selector = identity) {
  const slice = React.useSyncExternalStore(
    api.subscribe,
    React.useCallback(() => selector(api.getState()), [api, selector]),
    React.useCallback(() => selector(api.getInitialState()), [api, selector])
  );
  React.useDebugValue(slice);
  return slice;
}
const createImpl = (createState) => {
  const api = createStore(createState);
  const useBoundStore = (selector) => useStore(api, selector);
  Object.assign(useBoundStore, api);
  return useBoundStore;
};
const create = ((createState) => createState ? createImpl(createState) : createImpl);
const useDrawingStore = create((set) => ({
  currentFile: null,
  drawingData: null,
  setCurrentFile: (file) => set({ currentFile: file }),
  setDrawingData: (data) => set({ drawingData: data }),
  clearDrawing: () => set({ currentFile: null, drawingData: null })
}));
const ExcalidrawCanvas = ({ initialData, onSave }) => {
  const apiRef = reactExports.useRef(null);
  const { currentFile, setDrawingData } = useDrawingStore();
  const saveFileMutation = useSaveFile();
  const saveThumbnailMutation = useSaveThumbnail();
  const handleSave = async () => {
    if (!apiRef.current) return;
    const elements = apiRef.current.getSceneElements();
    const appState = apiRef.current.getAppState();
    const data = { elements, appState };
    setDrawingData(data);
    onSave?.(data);
    const filename = currentFile || `drawing_${Date.now()}`;
    try {
      const result = await saveFileMutation.mutateAsync({ filename, data });
      if (result?.success) {
        const blob = await n9({
          elements,
          appState,
          exportPadding: 10
        });
        const imageData = await blobToBase64(blob);
        await saveThumbnailMutation.mutateAsync({ filePath: result.filePath, imageData });
      }
    } catch (error) {
      console.error("Failed to save file:", error);
    }
  };
  const blobToBase64 = (blob) => {
    return new Promise((resolve, reject) => {
      const reader = new FileReader();
      reader.onloadend = () => resolve(reader.result);
      reader.onerror = reject;
      reader.readAsDataURL(blob);
    });
  };
  return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "w-full h-full flex flex-col", children: [
    /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex justify-between items-center p-4 bg-gray-100 border-b", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx("h1", { className: "text-lg font-bold", children: "Excalidraw" }),
      /* @__PURE__ */ jsxRuntimeExports.jsx(
        "button",
        {
          onClick: handleSave,
          className: "px-4 py-2 bg-blue-500 text-white rounded hover:bg-blue-600",
          disabled: saveFileMutation.isPending,
          children: saveFileMutation.isPending ? "Saving..." : "Save"
        }
      )
    ] }),
    /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "flex-1", children: /* @__PURE__ */ jsxRuntimeExports.jsx(
      IM,
      {
        ref: apiRef,
        initialData,
        onChange: (elements, appState) => {
        },
        UIOptions: {
          canvasMenu: {
            defaultItems: ["clearReset", "export"]
          }
        }
      }
    ) })
  ] });
};
const FileBrowser = ({ onFileSelect }) => {
  const [currentDirectory, setCurrentDirectory] = reactExports.useState();
  const { data, isLoading } = useBrowseFiles(currentDirectory);
  const loadFileMutation = useLoadFile();
  const { setCurrentFile, setDrawingData } = useDrawingStore();
  const files = data?.files || [];
  const currentPath = data?.currentPath || "";
  const handleSelectFile = async (file) => {
    if (file.isDirectory) {
      setCurrentDirectory(file.path);
      return;
    }
    try {
      const result = await loadFileMutation.mutateAsync(file.path);
      if (result?.success) {
        setCurrentFile(file.path);
        setDrawingData(result.data);
        onFileSelect?.(file.path);
      }
    } catch (error) {
      console.error("Failed to load file:", error);
    }
  };
  const handleNavigateUp = () => {
    const parent = currentPath.split("/").slice(0, -1).join("/");
    setCurrentDirectory(parent || "/");
  };
  return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "w-full h-full flex flex-col bg-white", children: [
    /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "p-4 border-b", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx("h2", { className: "text-lg font-bold mb-2", children: "File Browser" }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "text-sm text-gray-600 break-all", children: currentPath })
    ] }),
    /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "p-4", children: currentPath !== "/" && /* @__PURE__ */ jsxRuntimeExports.jsx(
      "button",
      {
        onClick: handleNavigateUp,
        className: "w-full text-left px-4 py-2 rounded hover:bg-gray-100 font-semibold",
        children: ".. (Parent Directory)"
      }
    ) }),
    /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "flex-1 overflow-y-auto", children: isLoading ? /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "p-4 text-center text-gray-500", children: "Loading..." }) : files.length === 0 ? /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "p-4 text-center text-gray-500", children: "No files found" }) : /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { children: [
      files.filter((f3) => f3.isDirectory).map((file) => /* @__PURE__ */ jsxRuntimeExports.jsxs(
        "div",
        {
          onClick: () => handleSelectFile(file),
          className: "px-4 py-3 hover:bg-blue-50 cursor-pointer border-b flex items-center",
          children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "text-xl mr-3", children: "" }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "font-medium", children: file.name })
          ]
        },
        file.path
      )),
      files.filter((f3) => !f3.isDirectory).map((file) => /* @__PURE__ */ jsxRuntimeExports.jsx(
        "div",
        {
          onClick: () => handleSelectFile(file),
          className: "px-4 py-3 hover:bg-blue-50 cursor-pointer border-b",
          children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex items-start", children: [
            file.hasThumbnail ? /* @__PURE__ */ jsxRuntimeExports.jsx(
              "img",
              {
                src: `file://${file.path.replace(/\.excalidraw$/, ".png")}`,
                alt: file.name,
                className: "w-12 h-12 object-cover rounded mr-3",
                onError: (e12) => {
                  e12.target.style.display = "none";
                }
              }
            ) : /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "w-12 h-12 bg-gray-200 rounded mr-3 flex items-center justify-center", children: /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "text-xl", children: "" }) }),
            /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "font-medium", children: file.name }),
              /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "text-xs text-gray-500", children: file.path })
            ] })
          ] })
        },
        file.path
      ))
    ] }) })
  ] });
};
const queryClient = new QueryClient();
function App() {
  const [layout, setLayout] = reactExports.useState("browser");
  const { drawingData } = useDrawingStore();
  return /* @__PURE__ */ jsxRuntimeExports.jsx(QueryClientProvider, { client: queryClient, children: /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "w-screen h-screen flex bg-gray-50", children: layout === "browser" ? /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "w-full flex flex-col", children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "p-4 bg-white border-b flex gap-2", children: /* @__PURE__ */ jsxRuntimeExports.jsx(
      "button",
      {
        onClick: () => setLayout("editor"),
        disabled: !drawingData,
        className: "px-4 py-2 bg-blue-500 text-white rounded disabled:bg-gray-300 disabled:cursor-not-allowed hover:bg-blue-600",
        children: "Open Editor"
      }
    ) }),
    /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "flex-1", children: /* @__PURE__ */ jsxRuntimeExports.jsx(
      FileBrowser,
      {
        onFileSelect: () => {
          setLayout("editor");
        }
      }
    ) })
  ] }) : /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "w-full flex flex-col", children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "p-4 bg-white border-b flex gap-2", children: /* @__PURE__ */ jsxRuntimeExports.jsx(
      "button",
      {
        onClick: () => setLayout("browser"),
        className: "px-4 py-2 bg-gray-500 text-white rounded hover:bg-gray-600",
        children: "Back to Browser"
      }
    ) }),
    /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "flex-1", children: /* @__PURE__ */ jsxRuntimeExports.jsx(ExcalidrawCanvas, { initialData: drawingData || void 0 }) })
  ] }) }) });
}
ReactDOM$1.createRoot(document.getElementById("root")).render(
  /* @__PURE__ */ jsxRuntimeExports.jsx(React.StrictMode, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(App, {}) })
);
const image7KUKJ7J4 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  decodePngMetadata: iC$1,
  encodePngMetadata: _p$1,
  getTEXtChunk: X9
}, Symbol.toStringTag, { value: "Module" }));
const enB4ZKOASM = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  alerts: l,
  buttons: n,
  canvasError: u,
  clearCanvasDialog: v,
  colorPicker: A,
  colors: F,
  commandPalette: R$1,
  confirmDialog: C,
  default: B,
  element: c,
  elementLink: r,
  encrypted: E,
  errorDialog: y,
  errorSplash: h,
  errors: s,
  exportDialog: w,
  fontList: N$1,
  headings: p,
  helpDialog: k$1,
  hints: m,
  imageExportDialog: x,
  labels: t,
  library: a,
  mermaid: D,
  overwriteConfirm: _,
  publishDialog: f,
  publishSuccessDialog: S,
  quickSearch: I,
  roomDialog: g$1,
  search: i,
  shareDialog: b,
  stats: T,
  toast: L,
  toolBar: d,
  userList: z,
  welcomeScreen: P
}, Symbol.toStringTag, { value: "Module" }));
const percentagesBXMCSKIN = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  default: N,
  en: R,
  kaa: k
}, Symbol.toStringTag, { value: "Module" }));
export {
  __vitePreload as _,
  commonjsGlobal as c,
  distExports as d,
  f$1 as f,
  getDefaultExportFromCjs as g
};
